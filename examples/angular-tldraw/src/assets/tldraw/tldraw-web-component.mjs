var rte = Object.defineProperty;
var ite = (n, e, t) => e in n ? rte(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t;
var U = (n, e, t) => ite(n, typeof e != "symbol" ? e + "" : e, t);
function ote(n, e) {
  for (var t = 0; t < e.length; t++) {
    const r = e[t];
    if (typeof r != "string" && !Array.isArray(r)) {
      for (const i in r)
        if (i !== "default" && !(i in n)) {
          const s = Object.getOwnPropertyDescriptor(r, i);
          s && Object.defineProperty(n, i, s.get ? s : {
            enumerable: !0,
            get: () => r[i]
          });
        }
    }
  }
  return Object.freeze(Object.defineProperty(n, Symbol.toStringTag, { value: "Module" }));
}
var ba = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function wh(n) {
  return n && n.__esModule && Object.prototype.hasOwnProperty.call(n, "default") ? n.default : n;
}
var P1 = { exports: {} }, Pn = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var rF;
function ste() {
  if (rF) return Pn;
  rF = 1;
  var n = Symbol.for("react.element"), e = Symbol.for("react.portal"), t = Symbol.for("react.fragment"), r = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), l = Symbol.for("react.context"), c = Symbol.for("react.forward_ref"), d = Symbol.for("react.suspense"), h = Symbol.for("react.memo"), g = Symbol.for("react.lazy"), y = Symbol.iterator;
  function v(te) {
    return te === null || typeof te != "object" ? null : (te = y && te[y] || te["@@iterator"], typeof te == "function" ? te : null);
  }
  var w = { isMounted: function() {
    return !1;
  }, enqueueForceUpdate: function() {
  }, enqueueReplaceState: function() {
  }, enqueueSetState: function() {
  } }, C = Object.assign, E = {};
  function P(te, me, Oe) {
    this.props = te, this.context = me, this.refs = E, this.updater = Oe || w;
  }
  P.prototype.isReactComponent = {}, P.prototype.setState = function(te, me) {
    if (typeof te != "object" && typeof te != "function" && te != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, te, me, "setState");
  }, P.prototype.forceUpdate = function(te) {
    this.updater.enqueueForceUpdate(this, te, "forceUpdate");
  };
  function I() {
  }
  I.prototype = P.prototype;
  function k(te, me, Oe) {
    this.props = te, this.context = me, this.refs = E, this.updater = Oe || w;
  }
  var L = k.prototype = new I();
  L.constructor = k, C(L, P.prototype), L.isPureReactComponent = !0;
  var O = Array.isArray, z = Object.prototype.hasOwnProperty, F = { current: null }, H = { key: !0, ref: !0, __self: !0, __source: !0 };
  function V(te, me, Oe) {
    var Ze, De = {}, yt = null, it = null;
    if (me != null) for (Ze in me.ref !== void 0 && (it = me.ref), me.key !== void 0 && (yt = "" + me.key), me) z.call(me, Ze) && !H.hasOwnProperty(Ze) && (De[Ze] = me[Ze]);
    var We = arguments.length - 2;
    if (We === 1) De.children = Oe;
    else if (1 < We) {
      for (var Qe = Array(We), gt = 0; gt < We; gt++) Qe[gt] = arguments[gt + 2];
      De.children = Qe;
    }
    if (te && te.defaultProps) for (Ze in We = te.defaultProps, We) De[Ze] === void 0 && (De[Ze] = We[Ze]);
    return { $$typeof: n, type: te, key: yt, ref: it, props: De, _owner: F.current };
  }
  function re(te, me) {
    return { $$typeof: n, type: te.type, key: me, ref: te.ref, props: te.props, _owner: te._owner };
  }
  function q(te) {
    return typeof te == "object" && te !== null && te.$$typeof === n;
  }
  function J(te) {
    var me = { "=": "=0", ":": "=2" };
    return "$" + te.replace(/[=:]/g, function(Oe) {
      return me[Oe];
    });
  }
  var ie = /\/+/g;
  function W(te, me) {
    return typeof te == "object" && te !== null && te.key != null ? J("" + te.key) : me.toString(36);
  }
  function Y(te, me, Oe, Ze, De) {
    var yt = typeof te;
    (yt === "undefined" || yt === "boolean") && (te = null);
    var it = !1;
    if (te === null) it = !0;
    else switch (yt) {
      case "string":
      case "number":
        it = !0;
        break;
      case "object":
        switch (te.$$typeof) {
          case n:
          case e:
            it = !0;
        }
    }
    if (it) return it = te, De = De(it), te = Ze === "" ? "." + W(it, 0) : Ze, O(De) ? (Oe = "", te != null && (Oe = te.replace(ie, "$&/") + "/"), Y(De, me, Oe, "", function(gt) {
      return gt;
    })) : De != null && (q(De) && (De = re(De, Oe + (!De.key || it && it.key === De.key ? "" : ("" + De.key).replace(ie, "$&/") + "/") + te)), me.push(De)), 1;
    if (it = 0, Ze = Ze === "" ? "." : Ze + ":", O(te)) for (var We = 0; We < te.length; We++) {
      yt = te[We];
      var Qe = Ze + W(yt, We);
      it += Y(yt, me, Oe, Qe, De);
    }
    else if (Qe = v(te), typeof Qe == "function") for (te = Qe.call(te), We = 0; !(yt = te.next()).done; ) yt = yt.value, Qe = Ze + W(yt, We++), it += Y(yt, me, Oe, Qe, De);
    else if (yt === "object") throw me = String(te), Error("Objects are not valid as a React child (found: " + (me === "[object Object]" ? "object with keys {" + Object.keys(te).join(", ") + "}" : me) + "). If you meant to render a collection of children, use an array instead.");
    return it;
  }
  function oe(te, me, Oe) {
    if (te == null) return te;
    var Ze = [], De = 0;
    return Y(te, Ze, "", "", function(yt) {
      return me.call(Oe, yt, De++);
    }), Ze;
  }
  function le(te) {
    if (te._status === -1) {
      var me = te._result;
      me = me(), me.then(function(Oe) {
        (te._status === 0 || te._status === -1) && (te._status = 1, te._result = Oe);
      }, function(Oe) {
        (te._status === 0 || te._status === -1) && (te._status = 2, te._result = Oe);
      }), te._status === -1 && (te._status = 0, te._result = me);
    }
    if (te._status === 1) return te._result.default;
    throw te._result;
  }
  var ce = { current: null }, Q = { transition: null }, he = { ReactCurrentDispatcher: ce, ReactCurrentBatchConfig: Q, ReactCurrentOwner: F };
  function ke() {
    throw Error("act(...) is not supported in production builds of React.");
  }
  return Pn.Children = { map: oe, forEach: function(te, me, Oe) {
    oe(te, function() {
      me.apply(this, arguments);
    }, Oe);
  }, count: function(te) {
    var me = 0;
    return oe(te, function() {
      me++;
    }), me;
  }, toArray: function(te) {
    return oe(te, function(me) {
      return me;
    }) || [];
  }, only: function(te) {
    if (!q(te)) throw Error("React.Children.only expected to receive a single React element child.");
    return te;
  } }, Pn.Component = P, Pn.Fragment = t, Pn.Profiler = i, Pn.PureComponent = k, Pn.StrictMode = r, Pn.Suspense = d, Pn.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = he, Pn.act = ke, Pn.cloneElement = function(te, me, Oe) {
    if (te == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + te + ".");
    var Ze = C({}, te.props), De = te.key, yt = te.ref, it = te._owner;
    if (me != null) {
      if (me.ref !== void 0 && (yt = me.ref, it = F.current), me.key !== void 0 && (De = "" + me.key), te.type && te.type.defaultProps) var We = te.type.defaultProps;
      for (Qe in me) z.call(me, Qe) && !H.hasOwnProperty(Qe) && (Ze[Qe] = me[Qe] === void 0 && We !== void 0 ? We[Qe] : me[Qe]);
    }
    var Qe = arguments.length - 2;
    if (Qe === 1) Ze.children = Oe;
    else if (1 < Qe) {
      We = Array(Qe);
      for (var gt = 0; gt < Qe; gt++) We[gt] = arguments[gt + 2];
      Ze.children = We;
    }
    return { $$typeof: n, type: te.type, key: De, ref: yt, props: Ze, _owner: it };
  }, Pn.createContext = function(te) {
    return te = { $$typeof: l, _currentValue: te, _currentValue2: te, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, te.Provider = { $$typeof: s, _context: te }, te.Consumer = te;
  }, Pn.createElement = V, Pn.createFactory = function(te) {
    var me = V.bind(null, te);
    return me.type = te, me;
  }, Pn.createRef = function() {
    return { current: null };
  }, Pn.forwardRef = function(te) {
    return { $$typeof: c, render: te };
  }, Pn.isValidElement = q, Pn.lazy = function(te) {
    return { $$typeof: g, _payload: { _status: -1, _result: te }, _init: le };
  }, Pn.memo = function(te, me) {
    return { $$typeof: h, type: te, compare: me === void 0 ? null : me };
  }, Pn.startTransition = function(te) {
    var me = Q.transition;
    Q.transition = {};
    try {
      te();
    } finally {
      Q.transition = me;
    }
  }, Pn.unstable_act = ke, Pn.useCallback = function(te, me) {
    return ce.current.useCallback(te, me);
  }, Pn.useContext = function(te) {
    return ce.current.useContext(te);
  }, Pn.useDebugValue = function() {
  }, Pn.useDeferredValue = function(te) {
    return ce.current.useDeferredValue(te);
  }, Pn.useEffect = function(te, me) {
    return ce.current.useEffect(te, me);
  }, Pn.useId = function() {
    return ce.current.useId();
  }, Pn.useImperativeHandle = function(te, me, Oe) {
    return ce.current.useImperativeHandle(te, me, Oe);
  }, Pn.useInsertionEffect = function(te, me) {
    return ce.current.useInsertionEffect(te, me);
  }, Pn.useLayoutEffect = function(te, me) {
    return ce.current.useLayoutEffect(te, me);
  }, Pn.useMemo = function(te, me) {
    return ce.current.useMemo(te, me);
  }, Pn.useReducer = function(te, me, Oe) {
    return ce.current.useReducer(te, me, Oe);
  }, Pn.useRef = function(te) {
    return ce.current.useRef(te);
  }, Pn.useState = function(te) {
    return ce.current.useState(te);
  }, Pn.useSyncExternalStore = function(te, me, Oe) {
    return ce.current.useSyncExternalStore(te, me, Oe);
  }, Pn.useTransition = function() {
    return ce.current.useTransition();
  }, Pn.version = "18.3.1", Pn;
}
var yx = { exports: {} };
yx.exports;
var iF;
function ate() {
  return iF || (iF = 1, function(n, e) {
    var t = {};
    /**
     * @license React
     * react.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    t.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var r = "18.3.1", i = Symbol.for("react.element"), s = Symbol.for("react.portal"), l = Symbol.for("react.fragment"), c = Symbol.for("react.strict_mode"), d = Symbol.for("react.profiler"), h = Symbol.for("react.provider"), g = Symbol.for("react.context"), y = Symbol.for("react.forward_ref"), v = Symbol.for("react.suspense"), w = Symbol.for("react.suspense_list"), C = Symbol.for("react.memo"), E = Symbol.for("react.lazy"), P = Symbol.for("react.offscreen"), I = Symbol.iterator, k = "@@iterator";
      function L(B) {
        if (B === null || typeof B != "object")
          return null;
        var ne = I && B[I] || B[k];
        return typeof ne == "function" ? ne : null;
      }
      var O = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, z = {
        transition: null
      }, F = {
        current: null,
        // Used to reproduce behavior of `batchedUpdates` in legacy mode.
        isBatchingLegacy: !1,
        didScheduleLegacyUpdate: !1
      }, H = {
        /**
         * @internal
         * @type {ReactComponent}
         */
        current: null
      }, V = {}, re = null;
      function q(B) {
        re = B;
      }
      V.setExtraStackFrame = function(B) {
        re = B;
      }, V.getCurrentStack = null, V.getStackAddendum = function() {
        var B = "";
        re && (B += re);
        var ne = V.getCurrentStack;
        return ne && (B += ne() || ""), B;
      };
      var J = !1, ie = !1, W = !1, Y = !1, oe = !1, le = {
        ReactCurrentDispatcher: O,
        ReactCurrentBatchConfig: z,
        ReactCurrentOwner: H
      };
      le.ReactDebugCurrentFrame = V, le.ReactCurrentActQueue = F;
      function ce(B) {
        {
          for (var ne = arguments.length, ge = new Array(ne > 1 ? ne - 1 : 0), Re = 1; Re < ne; Re++)
            ge[Re - 1] = arguments[Re];
          he("warn", B, ge);
        }
      }
      function Q(B) {
        {
          for (var ne = arguments.length, ge = new Array(ne > 1 ? ne - 1 : 0), Re = 1; Re < ne; Re++)
            ge[Re - 1] = arguments[Re];
          he("error", B, ge);
        }
      }
      function he(B, ne, ge) {
        {
          var Re = le.ReactDebugCurrentFrame, Ve = Re.getStackAddendum();
          Ve !== "" && (ne += "%s", ge = ge.concat([Ve]));
          var ot = ge.map(function(Je) {
            return String(Je);
          });
          ot.unshift("Warning: " + ne), Function.prototype.apply.call(console[B], console, ot);
        }
      }
      var ke = {};
      function te(B, ne) {
        {
          var ge = B.constructor, Re = ge && (ge.displayName || ge.name) || "ReactClass", Ve = Re + "." + ne;
          if (ke[Ve])
            return;
          Q("Can't call %s on a component that is not yet mounted. This is a no-op, but it might indicate a bug in your application. Instead, assign to `this.state` directly or define a `state = {};` class property with the desired state in the %s component.", ne, Re), ke[Ve] = !0;
        }
      }
      var me = {
        /**
         * Checks whether or not this composite component is mounted.
         * @param {ReactClass} publicInstance The instance we want to test.
         * @return {boolean} True if mounted, false otherwise.
         * @protected
         * @final
         */
        isMounted: function(B) {
          return !1;
        },
        /**
         * Forces an update. This should only be invoked when it is known with
         * certainty that we are **not** in a DOM transaction.
         *
         * You may want to call this when you know that some deeper aspect of the
         * component's state has changed but `setState` was not called.
         *
         * This will not invoke `shouldComponentUpdate`, but it will invoke
         * `componentWillUpdate` and `componentDidUpdate`.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueForceUpdate: function(B, ne, ge) {
          te(B, "forceUpdate");
        },
        /**
         * Replaces all of the state. Always use this or `setState` to mutate state.
         * You should treat `this.state` as immutable.
         *
         * There is no guarantee that `this.state` will be immediately updated, so
         * accessing `this.state` after calling this method may return the old value.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} completeState Next state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} callerName name of the calling function in the public API.
         * @internal
         */
        enqueueReplaceState: function(B, ne, ge, Re) {
          te(B, "replaceState");
        },
        /**
         * Sets a subset of the state. This only exists because _pendingState is
         * internal. This provides a merging strategy that is not available to deep
         * properties which is confusing. TODO: Expose pendingState or don't use it
         * during the merge.
         *
         * @param {ReactClass} publicInstance The instance that should rerender.
         * @param {object} partialState Next partial state to be merged with state.
         * @param {?function} callback Called after component is updated.
         * @param {?string} Name of the calling function in the public API.
         * @internal
         */
        enqueueSetState: function(B, ne, ge, Re) {
          te(B, "setState");
        }
      }, Oe = Object.assign, Ze = {};
      Object.freeze(Ze);
      function De(B, ne, ge) {
        this.props = B, this.context = ne, this.refs = Ze, this.updater = ge || me;
      }
      De.prototype.isReactComponent = {}, De.prototype.setState = function(B, ne) {
        if (typeof B != "object" && typeof B != "function" && B != null)
          throw new Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
        this.updater.enqueueSetState(this, B, ne, "setState");
      }, De.prototype.forceUpdate = function(B) {
        this.updater.enqueueForceUpdate(this, B, "forceUpdate");
      };
      {
        var yt = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see https://github.com/facebook/react/issues/3236)."]
        }, it = function(B, ne) {
          Object.defineProperty(De.prototype, B, {
            get: function() {
              ce("%s(...) is deprecated in plain JavaScript React classes. %s", ne[0], ne[1]);
            }
          });
        };
        for (var We in yt)
          yt.hasOwnProperty(We) && it(We, yt[We]);
      }
      function Qe() {
      }
      Qe.prototype = De.prototype;
      function gt(B, ne, ge) {
        this.props = B, this.context = ne, this.refs = Ze, this.updater = ge || me;
      }
      var Pt = gt.prototype = new Qe();
      Pt.constructor = gt, Oe(Pt, De.prototype), Pt.isPureReactComponent = !0;
      function mn() {
        var B = {
          current: null
        };
        return Object.seal(B), B;
      }
      var Zt = Array.isArray;
      function an(B) {
        return Zt(B);
      }
      function ln(B) {
        {
          var ne = typeof Symbol == "function" && Symbol.toStringTag, ge = ne && B[Symbol.toStringTag] || B.constructor.name || "Object";
          return ge;
        }
      }
      function Yt(B) {
        try {
          return Gn(B), !1;
        } catch {
          return !0;
        }
      }
      function Gn(B) {
        return "" + B;
      }
      function xr(B) {
        if (Yt(B))
          return Q("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ln(B)), Gn(B);
      }
      function Hr(B, ne, ge) {
        var Re = B.displayName;
        if (Re)
          return Re;
        var Ve = ne.displayName || ne.name || "";
        return Ve !== "" ? ge + "(" + Ve + ")" : ge;
      }
      function Pr(B) {
        return B.displayName || "Context";
      }
      function wr(B) {
        if (B == null)
          return null;
        if (typeof B.tag == "number" && Q("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof B == "function")
          return B.displayName || B.name || null;
        if (typeof B == "string")
          return B;
        switch (B) {
          case l:
            return "Fragment";
          case s:
            return "Portal";
          case d:
            return "Profiler";
          case c:
            return "StrictMode";
          case v:
            return "Suspense";
          case w:
            return "SuspenseList";
        }
        if (typeof B == "object")
          switch (B.$$typeof) {
            case g:
              var ne = B;
              return Pr(ne) + ".Consumer";
            case h:
              var ge = B;
              return Pr(ge._context) + ".Provider";
            case y:
              return Hr(B, B.render, "ForwardRef");
            case C:
              var Re = B.displayName || null;
              return Re !== null ? Re : wr(B.type) || "Memo";
            case E: {
              var Ve = B, ot = Ve._payload, Je = Ve._init;
              try {
                return wr(Je(ot));
              } catch {
                return null;
              }
            }
          }
        return null;
      }
      var Vr = Object.prototype.hasOwnProperty, Kr = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
      }, si, mo, Tr;
      Tr = {};
      function Ir(B) {
        if (Vr.call(B, "ref")) {
          var ne = Object.getOwnPropertyDescriptor(B, "ref").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return B.ref !== void 0;
      }
      function Zr(B) {
        if (Vr.call(B, "key")) {
          var ne = Object.getOwnPropertyDescriptor(B, "key").get;
          if (ne && ne.isReactWarning)
            return !1;
        }
        return B.key !== void 0;
      }
      function Ko(B, ne) {
        var ge = function() {
          si || (si = !0, Q("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
        };
        ge.isReactWarning = !0, Object.defineProperty(B, "key", {
          get: ge,
          configurable: !0
        });
      }
      function Ee(B, ne) {
        var ge = function() {
          mo || (mo = !0, Q("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", ne));
        };
        ge.isReactWarning = !0, Object.defineProperty(B, "ref", {
          get: ge,
          configurable: !0
        });
      }
      function ve(B) {
        if (typeof B.ref == "string" && H.current && B.__self && H.current.stateNode !== B.__self) {
          var ne = wr(H.current.type);
          Tr[ne] || (Q('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', ne, B.ref), Tr[ne] = !0);
        }
      }
      var $e = function(B, ne, ge, Re, Ve, ot, Je) {
        var kt = {
          // This tag allows us to uniquely identify this as a React Element
          $$typeof: i,
          // Built-in properties that belong on the element
          type: B,
          key: ne,
          ref: ge,
          props: Je,
          // Record the component responsible for creating this element.
          _owner: ot
        };
        return kt._store = {}, Object.defineProperty(kt._store, "validated", {
          configurable: !1,
          enumerable: !1,
          writable: !0,
          value: !1
        }), Object.defineProperty(kt, "_self", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Re
        }), Object.defineProperty(kt, "_source", {
          configurable: !1,
          enumerable: !1,
          writable: !1,
          value: Ve
        }), Object.freeze && (Object.freeze(kt.props), Object.freeze(kt)), kt;
      };
      function mt(B, ne, ge) {
        var Re, Ve = {}, ot = null, Je = null, kt = null, Qt = null;
        if (ne != null) {
          Ir(ne) && (Je = ne.ref, ve(ne)), Zr(ne) && (xr(ne.key), ot = "" + ne.key), kt = ne.__self === void 0 ? null : ne.__self, Qt = ne.__source === void 0 ? null : ne.__source;
          for (Re in ne)
            Vr.call(ne, Re) && !Kr.hasOwnProperty(Re) && (Ve[Re] = ne[Re]);
        }
        var Mn = arguments.length - 2;
        if (Mn === 1)
          Ve.children = ge;
        else if (Mn > 1) {
          for (var Bn = Array(Mn), lr = 0; lr < Mn; lr++)
            Bn[lr] = arguments[lr + 2];
          Object.freeze && Object.freeze(Bn), Ve.children = Bn;
        }
        if (B && B.defaultProps) {
          var tn = B.defaultProps;
          for (Re in tn)
            Ve[Re] === void 0 && (Ve[Re] = tn[Re]);
        }
        if (ot || Je) {
          var pr = typeof B == "function" ? B.displayName || B.name || "Unknown" : B;
          ot && Ko(Ve, pr), Je && Ee(Ve, pr);
        }
        return $e(B, ot, Je, kt, Qt, H.current, Ve);
      }
      function cn(B, ne) {
        var ge = $e(B.type, ne, B.ref, B._self, B._source, B._owner, B.props);
        return ge;
      }
      function yn(B, ne, ge) {
        if (B == null)
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + B + ".");
        var Re, Ve = Oe({}, B.props), ot = B.key, Je = B.ref, kt = B._self, Qt = B._source, Mn = B._owner;
        if (ne != null) {
          Ir(ne) && (Je = ne.ref, Mn = H.current), Zr(ne) && (xr(ne.key), ot = "" + ne.key);
          var Bn;
          B.type && B.type.defaultProps && (Bn = B.type.defaultProps);
          for (Re in ne)
            Vr.call(ne, Re) && !Kr.hasOwnProperty(Re) && (ne[Re] === void 0 && Bn !== void 0 ? Ve[Re] = Bn[Re] : Ve[Re] = ne[Re]);
        }
        var lr = arguments.length - 2;
        if (lr === 1)
          Ve.children = ge;
        else if (lr > 1) {
          for (var tn = Array(lr), pr = 0; pr < lr; pr++)
            tn[pr] = arguments[pr + 2];
          Ve.children = tn;
        }
        return $e(B.type, ot, Je, kt, Qt, Mn, Ve);
      }
      function qn(B) {
        return typeof B == "object" && B !== null && B.$$typeof === i;
      }
      var Rn = ".", sr = ":";
      function bn(B) {
        var ne = /[=:]/g, ge = {
          "=": "=0",
          ":": "=2"
        }, Re = B.replace(ne, function(Ve) {
          return ge[Ve];
        });
        return "$" + Re;
      }
      var vn = !1, fn = /\/+/g;
      function Ii(B) {
        return B.replace(fn, "$&/");
      }
      function oo(B, ne) {
        return typeof B == "object" && B !== null && B.key != null ? (xr(B.key), bn("" + B.key)) : ne.toString(36);
      }
      function ki(B, ne, ge, Re, Ve) {
        var ot = typeof B;
        (ot === "undefined" || ot === "boolean") && (B = null);
        var Je = !1;
        if (B === null)
          Je = !0;
        else
          switch (ot) {
            case "string":
            case "number":
              Je = !0;
              break;
            case "object":
              switch (B.$$typeof) {
                case i:
                case s:
                  Je = !0;
              }
          }
        if (Je) {
          var kt = B, Qt = Ve(kt), Mn = Re === "" ? Rn + oo(kt, 0) : Re;
          if (an(Qt)) {
            var Bn = "";
            Mn != null && (Bn = Ii(Mn) + "/"), ki(Qt, ne, Bn, "", function(tv) {
              return tv;
            });
          } else Qt != null && (qn(Qt) && (Qt.key && (!kt || kt.key !== Qt.key) && xr(Qt.key), Qt = cn(
            Qt,
            // Keep both the (mapped) and old keys if they differ, just as
            // traverseAllChildren used to do for objects as children
            ge + // $FlowFixMe Flow incorrectly thinks React.Portal doesn't have a key
            (Qt.key && (!kt || kt.key !== Qt.key) ? (
              // $FlowFixMe Flow incorrectly thinks existing element's key can be a number
              // eslint-disable-next-line react-internal/safe-string-coercion
              Ii("" + Qt.key) + "/"
            ) : "") + Mn
          )), ne.push(Qt));
          return 1;
        }
        var lr, tn, pr = 0, Qr = Re === "" ? Rn : Re + sr;
        if (an(B))
          for (var $u = 0; $u < B.length; $u++)
            lr = B[$u], tn = Qr + oo(lr, $u), pr += ki(lr, ne, ge, tn, Ve);
        else {
          var Ah = L(B);
          if (typeof Ah == "function") {
            var Gl = B;
            Ah === Gl.entries && (vn || ce("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), vn = !0);
            for (var Bu = Ah.call(Gl), Dh, ev = 0; !(Dh = Bu.next()).done; )
              lr = Dh.value, tn = Qr + oo(lr, ev++), pr += ki(lr, ne, ge, tn, Ve);
          } else if (ot === "object") {
            var mg = String(B);
            throw new Error("Objects are not valid as a React child (found: " + (mg === "[object Object]" ? "object with keys {" + Object.keys(B).join(", ") + "}" : mg) + "). If you meant to render a collection of children, use an array instead.");
          }
        }
        return pr;
      }
      function Cs(B, ne, ge) {
        if (B == null)
          return B;
        var Re = [], Ve = 0;
        return ki(B, Re, "", "", function(ot) {
          return ne.call(ge, ot, Ve++);
        }), Re;
      }
      function ka(B) {
        var ne = 0;
        return Cs(B, function() {
          ne++;
        }), ne;
      }
      function Ra(B, ne, ge) {
        Cs(B, function() {
          ne.apply(this, arguments);
        }, ge);
      }
      function yo(B) {
        return Cs(B, function(ne) {
          return ne;
        }) || [];
      }
      function Ul(B) {
        if (!qn(B))
          throw new Error("React.Children.only expected to receive a single React element child.");
        return B;
      }
      function Xs(B) {
        var ne = {
          $$typeof: g,
          // As a workaround to support multiple concurrent renderers, we categorize
          // some renderers as primary and others as secondary. We only expect
          // there to be two concurrent renderers at most: React Native (primary) and
          // Fabric (secondary); React DOM (primary) and React ART (secondary).
          // Secondary renderers store their context values on separate fields.
          _currentValue: B,
          _currentValue2: B,
          // Used to track how many concurrent renderers this context currently
          // supports within in a single renderer. Such as parallel server rendering.
          _threadCount: 0,
          // These are circular
          Provider: null,
          Consumer: null,
          // Add these to use same hidden class in VM as ServerContext
          _defaultValue: null,
          _globalName: null
        };
        ne.Provider = {
          $$typeof: h,
          _context: ne
        };
        var ge = !1, Re = !1, Ve = !1;
        {
          var ot = {
            $$typeof: g,
            _context: ne
          };
          Object.defineProperties(ot, {
            Provider: {
              get: function() {
                return Re || (Re = !0, Q("Rendering <Context.Consumer.Provider> is not supported and will be removed in a future major release. Did you mean to render <Context.Provider> instead?")), ne.Provider;
              },
              set: function(Je) {
                ne.Provider = Je;
              }
            },
            _currentValue: {
              get: function() {
                return ne._currentValue;
              },
              set: function(Je) {
                ne._currentValue = Je;
              }
            },
            _currentValue2: {
              get: function() {
                return ne._currentValue2;
              },
              set: function(Je) {
                ne._currentValue2 = Je;
              }
            },
            _threadCount: {
              get: function() {
                return ne._threadCount;
              },
              set: function(Je) {
                ne._threadCount = Je;
              }
            },
            Consumer: {
              get: function() {
                return ge || (ge = !0, Q("Rendering <Context.Consumer.Consumer> is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?")), ne.Consumer;
              }
            },
            displayName: {
              get: function() {
                return ne.displayName;
              },
              set: function(Je) {
                Ve || (ce("Setting `displayName` on Context.Consumer has no effect. You should set it directly on the context with Context.displayName = '%s'.", Je), Ve = !0);
              }
            }
          }), ne.Consumer = ot;
        }
        return ne._currentRenderer = null, ne._currentRenderer2 = null, ne;
      }
      var vo = -1, vi = 0, So = 1, $i = 2;
      function Wo(B) {
        if (B._status === vo) {
          var ne = B._result, ge = ne();
          if (ge.then(function(ot) {
            if (B._status === vi || B._status === vo) {
              var Je = B;
              Je._status = So, Je._result = ot;
            }
          }, function(ot) {
            if (B._status === vi || B._status === vo) {
              var Je = B;
              Je._status = $i, Je._result = ot;
            }
          }), B._status === vo) {
            var Re = B;
            Re._status = vi, Re._result = ge;
          }
        }
        if (B._status === So) {
          var Ve = B._result;
          return Ve === void 0 && Q(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))

Did you accidentally put curly braces around the import?`, Ve), "default" in Ve || Q(`lazy: Expected the result of a dynamic import() call. Instead received: %s

Your code should look like: 
  const MyComponent = lazy(() => import('./MyComponent'))`, Ve), Ve.default;
        } else
          throw B._result;
      }
      function Ri(B) {
        var ne = {
          // We use these fields to store the result.
          _status: vo,
          _result: B
        }, ge = {
          $$typeof: E,
          _payload: ne,
          _init: Wo
        };
        {
          var Re, Ve;
          Object.defineProperties(ge, {
            defaultProps: {
              configurable: !0,
              get: function() {
                return Re;
              },
              set: function(ot) {
                Q("React.lazy(...): It is not supported to assign `defaultProps` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Re = ot, Object.defineProperty(ge, "defaultProps", {
                  enumerable: !0
                });
              }
            },
            propTypes: {
              configurable: !0,
              get: function() {
                return Ve;
              },
              set: function(ot) {
                Q("React.lazy(...): It is not supported to assign `propTypes` to a lazy component import. Either specify them where the component is defined, or create a wrapping component around it."), Ve = ot, Object.defineProperty(ge, "propTypes", {
                  enumerable: !0
                });
              }
            }
          });
        }
        return ge;
      }
      function Ma(B) {
        B != null && B.$$typeof === C ? Q("forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...)).") : typeof B != "function" ? Q("forwardRef requires a render function but was given %s.", B === null ? "null" : typeof B) : B.length !== 0 && B.length !== 2 && Q("forwardRef render functions accept exactly two parameters: props and ref. %s", B.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined."), B != null && (B.defaultProps != null || B.propTypes != null) && Q("forwardRef render functions do not support propTypes or defaultProps. Did you accidentally pass a React component?");
        var ne = {
          $$typeof: y,
          render: B
        };
        {
          var ge;
          Object.defineProperty(ne, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return ge;
            },
            set: function(Re) {
              ge = Re, !B.name && !B.displayName && (B.displayName = Re);
            }
          });
        }
        return ne;
      }
      var se;
      se = Symbol.for("react.module.reference");
      function Ue(B) {
        return !!(typeof B == "string" || typeof B == "function" || B === l || B === d || oe || B === c || B === v || B === w || Y || B === P || J || ie || W || typeof B == "object" && B !== null && (B.$$typeof === E || B.$$typeof === C || B.$$typeof === h || B.$$typeof === g || B.$$typeof === y || // This needs to include all possible module reference object
        // types supported by any Flight configuration anywhere since
        // we don't know which Flight build this will end up being used
        // with.
        B.$$typeof === se || B.getModuleId !== void 0));
      }
      function tt(B, ne) {
        Ue(B) || Q("memo: The first argument must be a component. Instead received: %s", B === null ? "null" : typeof B);
        var ge = {
          $$typeof: C,
          type: B,
          compare: ne === void 0 ? null : ne
        };
        {
          var Re;
          Object.defineProperty(ge, "displayName", {
            enumerable: !1,
            configurable: !0,
            get: function() {
              return Re;
            },
            set: function(Ve) {
              Re = Ve, !B.name && !B.displayName && (B.displayName = Ve);
            }
          });
        }
        return ge;
      }
      function rt() {
        var B = O.current;
        return B === null && Q(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`), B;
      }
      function zt(B) {
        var ne = rt();
        if (B._context !== void 0) {
          var ge = B._context;
          ge.Consumer === B ? Q("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be removed in a future major release. Did you mean to call useContext(Context) instead?") : ge.Provider === B && Q("Calling useContext(Context.Provider) is not supported. Did you mean to call useContext(Context) instead?");
        }
        return ne.useContext(B);
      }
      function Vt(B) {
        var ne = rt();
        return ne.useState(B);
      }
      function un(B, ne, ge) {
        var Re = rt();
        return Re.useReducer(B, ne, ge);
      }
      function en(B) {
        var ne = rt();
        return ne.useRef(B);
      }
      function Lr(B, ne) {
        var ge = rt();
        return ge.useEffect(B, ne);
      }
      function ar(B, ne) {
        var ge = rt();
        return ge.useInsertionEffect(B, ne);
      }
      function zn(B, ne) {
        var ge = rt();
        return ge.useLayoutEffect(B, ne);
      }
      function Mi(B, ne) {
        var ge = rt();
        return ge.useCallback(B, ne);
      }
      function Es(B, ne) {
        var ge = rt();
        return ge.useMemo(B, ne);
      }
      function Un(B, ne, ge) {
        var Re = rt();
        return Re.useImperativeHandle(B, ne, ge);
      }
      function yr(B, ne) {
        {
          var ge = rt();
          return ge.useDebugValue(B, ne);
        }
      }
      function Gt() {
        var B = rt();
        return B.useTransition();
      }
      function xo(B) {
        var ne = rt();
        return ne.useDeferredValue(B);
      }
      function Aa() {
        var B = rt();
        return B.useId();
      }
      function Qd(B, ne, ge) {
        var Re = rt();
        return Re.useSyncExternalStore(B, ne, ge);
      }
      var Ai = 0, al, so, Fu, Bi, zu, Jd, $l;
      function Da() {
      }
      Da.__reactDisabledLog = !0;
      function Go() {
        {
          if (Ai === 0) {
            al = console.log, so = console.info, Fu = console.warn, Bi = console.error, zu = console.group, Jd = console.groupCollapsed, $l = console.groupEnd;
            var B = {
              configurable: !0,
              enumerable: !0,
              value: Da,
              writable: !0
            };
            Object.defineProperties(console, {
              info: B,
              log: B,
              warn: B,
              error: B,
              group: B,
              groupCollapsed: B,
              groupEnd: B
            });
          }
          Ai++;
        }
      }
      function Hi() {
        {
          if (Ai--, Ai === 0) {
            var B = {
              configurable: !0,
              enumerable: !0,
              writable: !0
            };
            Object.defineProperties(console, {
              log: Oe({}, B, {
                value: al
              }),
              info: Oe({}, B, {
                value: so
              }),
              warn: Oe({}, B, {
                value: Fu
              }),
              error: Oe({}, B, {
                value: Bi
              }),
              group: Oe({}, B, {
                value: zu
              }),
              groupCollapsed: Oe({}, B, {
                value: Jd
              }),
              groupEnd: Oe({}, B, {
                value: $l
              })
            });
          }
          Ai < 0 && Q("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
        }
      }
      var _s = le.ReactCurrentDispatcher, ll;
      function Ac(B, ne, ge) {
        {
          if (ll === void 0)
            try {
              throw Error();
            } catch (Ve) {
              var Re = Ve.stack.trim().match(/\n( *(at )?)/);
              ll = Re && Re[1] || "";
            }
          return `
` + ll + B;
        }
      }
      var Oa = !1, Bl;
      {
        var cl = typeof WeakMap == "function" ? WeakMap : Map;
        Bl = new cl();
      }
      function ul(B, ne) {
        if (!B || Oa)
          return "";
        {
          var ge = Bl.get(B);
          if (ge !== void 0)
            return ge;
        }
        var Re;
        Oa = !0;
        var Ve = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        var ot;
        ot = _s.current, _s.current = null, Go();
        try {
          if (ne) {
            var Je = function() {
              throw Error();
            };
            if (Object.defineProperty(Je.prototype, "props", {
              set: function() {
                throw Error();
              }
            }), typeof Reflect == "object" && Reflect.construct) {
              try {
                Reflect.construct(Je, []);
              } catch (Qr) {
                Re = Qr;
              }
              Reflect.construct(B, [], Je);
            } else {
              try {
                Je.call();
              } catch (Qr) {
                Re = Qr;
              }
              B.call(Je.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (Qr) {
              Re = Qr;
            }
            B();
          }
        } catch (Qr) {
          if (Qr && Re && typeof Qr.stack == "string") {
            for (var kt = Qr.stack.split(`
`), Qt = Re.stack.split(`
`), Mn = kt.length - 1, Bn = Qt.length - 1; Mn >= 1 && Bn >= 0 && kt[Mn] !== Qt[Bn]; )
              Bn--;
            for (; Mn >= 1 && Bn >= 0; Mn--, Bn--)
              if (kt[Mn] !== Qt[Bn]) {
                if (Mn !== 1 || Bn !== 1)
                  do
                    if (Mn--, Bn--, Bn < 0 || kt[Mn] !== Qt[Bn]) {
                      var lr = `
` + kt[Mn].replace(" at new ", " at ");
                      return B.displayName && lr.includes("<anonymous>") && (lr = lr.replace("<anonymous>", B.displayName)), typeof B == "function" && Bl.set(B, lr), lr;
                    }
                  while (Mn >= 1 && Bn >= 0);
                break;
              }
          }
        } finally {
          Oa = !1, _s.current = ot, Hi(), Error.prepareStackTrace = Ve;
        }
        var tn = B ? B.displayName || B.name : "", pr = tn ? Ac(tn) : "";
        return typeof B == "function" && Bl.set(B, pr), pr;
      }
      function Uu(B, ne, ge) {
        return ul(B, !1);
      }
      function Dc(B) {
        var ne = B.prototype;
        return !!(ne && ne.isReactComponent);
      }
      function dn(B, ne, ge) {
        if (B == null)
          return "";
        if (typeof B == "function")
          return ul(B, Dc(B));
        if (typeof B == "string")
          return Ac(B);
        switch (B) {
          case v:
            return Ac("Suspense");
          case w:
            return Ac("SuspenseList");
        }
        if (typeof B == "object")
          switch (B.$$typeof) {
            case y:
              return Uu(B.render);
            case C:
              return dn(B.type, ne, ge);
            case E: {
              var Re = B, Ve = Re._payload, ot = Re._init;
              try {
                return dn(ot(Ve), ne, ge);
              } catch {
              }
            }
          }
        return "";
      }
      var Zs = {}, Oc = le.ReactDebugCurrentFrame;
      function Cn(B) {
        if (B) {
          var ne = B._owner, ge = dn(B.type, B._source, ne ? ne.type : null);
          Oc.setExtraStackFrame(ge);
        } else
          Oc.setExtraStackFrame(null);
      }
      function Ps(B, ne, ge, Re, Ve) {
        {
          var ot = Function.call.bind(Vr);
          for (var Je in B)
            if (ot(B, Je)) {
              var kt = void 0;
              try {
                if (typeof B[Je] != "function") {
                  var Qt = Error((Re || "React class") + ": " + ge + " type `" + Je + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof B[Je] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  throw Qt.name = "Invariant Violation", Qt;
                }
                kt = B[Je](ne, Je, Re, ge, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (Mn) {
                kt = Mn;
              }
              kt && !(kt instanceof Error) && (Cn(Ve), Q("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", Re || "React class", ge, Je, typeof kt), Cn(null)), kt instanceof Error && !(kt.message in Zs) && (Zs[kt.message] = !0, Cn(Ve), Q("Failed %s type: %s", ge, kt.message), Cn(null));
            }
        }
      }
      function Qs(B) {
        if (B) {
          var ne = B._owner, ge = dn(B.type, B._source, ne ? ne.type : null);
          q(ge);
        } else
          q(null);
      }
      var Ut;
      Ut = !1;
      function Hl() {
        if (H.current) {
          var B = wr(H.current.type);
          if (B)
            return `

Check the render method of \`` + B + "`.";
        }
        return "";
      }
      function ai(B) {
        if (B !== void 0) {
          var ne = B.fileName.replace(/^.*[\\\/]/, ""), ge = B.lineNumber;
          return `

Check your code at ` + ne + ":" + ge + ".";
        }
        return "";
      }
      function ao(B) {
        return B != null ? ai(B.__source) : "";
      }
      var Nr = {};
      function Ts(B) {
        var ne = Hl();
        if (!ne) {
          var ge = typeof B == "string" ? B : B.displayName || B.name;
          ge && (ne = `

Check the top-level render call using <` + ge + ">.");
        }
        return ne;
      }
      function kr(B, ne) {
        if (!(!B._store || B._store.validated || B.key != null)) {
          B._store.validated = !0;
          var ge = Ts(ne);
          if (!Nr[ge]) {
            Nr[ge] = !0;
            var Re = "";
            B && B._owner && B._owner !== H.current && (Re = " It was passed a child from " + wr(B._owner.type) + "."), Qs(B), Q('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ge, Re), Qs(null);
          }
        }
      }
      function $n(B, ne) {
        if (typeof B == "object") {
          if (an(B))
            for (var ge = 0; ge < B.length; ge++) {
              var Re = B[ge];
              qn(Re) && kr(Re, ne);
            }
          else if (qn(B))
            B._store && (B._store.validated = !0);
          else if (B) {
            var Ve = L(B);
            if (typeof Ve == "function" && Ve !== B.entries)
              for (var ot = Ve.call(B), Je; !(Je = ot.next()).done; )
                qn(Je.value) && kr(Je.value, ne);
          }
        }
      }
      function Is(B) {
        {
          var ne = B.type;
          if (ne == null || typeof ne == "string")
            return;
          var ge;
          if (typeof ne == "function")
            ge = ne.propTypes;
          else if (typeof ne == "object" && (ne.$$typeof === y || // Note: Memo only checks outer props here.
          // Inner props are checked in the reconciler.
          ne.$$typeof === C))
            ge = ne.propTypes;
          else
            return;
          if (ge) {
            var Re = wr(ne);
            Ps(ge, B.props, "prop", Re, B);
          } else if (ne.PropTypes !== void 0 && !Ut) {
            Ut = !0;
            var Ve = wr(ne);
            Q("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ve || "Unknown");
          }
          typeof ne.getDefaultProps == "function" && !ne.getDefaultProps.isReactClassApproved && Q("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
        }
      }
      function lo(B) {
        {
          for (var ne = Object.keys(B.props), ge = 0; ge < ne.length; ge++) {
            var Re = ne[ge];
            if (Re !== "children" && Re !== "key") {
              Qs(B), Q("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", Re), Qs(null);
              break;
            }
          }
          B.ref !== null && (Qs(B), Q("Invalid attribute `ref` supplied to `React.Fragment`."), Qs(null));
        }
      }
      function Di(B, ne, ge) {
        var Re = Ue(B);
        if (!Re) {
          var Ve = "";
          (B === void 0 || typeof B == "object" && B !== null && Object.keys(B).length === 0) && (Ve += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var ot = ao(ne);
          ot ? Ve += ot : Ve += Hl();
          var Je;
          B === null ? Je = "null" : an(B) ? Je = "array" : B !== void 0 && B.$$typeof === i ? (Je = "<" + (wr(B.type) || "Unknown") + " />", Ve = " Did you accidentally export a JSX literal instead of a component?") : Je = typeof B, Q("React.createElement: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Je, Ve);
        }
        var kt = mt.apply(this, arguments);
        if (kt == null)
          return kt;
        if (Re)
          for (var Qt = 2; Qt < arguments.length; Qt++)
            $n(arguments[Qt], B);
        return B === l ? lo(kt) : Is(kt), kt;
      }
      var Oi = !1;
      function ef(B) {
        var ne = Di.bind(null, B);
        return ne.type = B, Oi || (Oi = !0, ce("React.createFactory() is deprecated and will be removed in a future major release. Consider using JSX or use React.createElement() directly instead.")), Object.defineProperty(ne, "type", {
          enumerable: !1,
          get: function() {
            return ce("Factory.type is deprecated. Access the class directly before passing it to createFactory."), Object.defineProperty(this, "type", {
              value: B
            }), B;
          }
        }), ne;
      }
      function Vl(B, ne, ge) {
        for (var Re = yn.apply(this, arguments), Ve = 2; Ve < arguments.length; Ve++)
          $n(arguments[Ve], Re.type);
        return Is(Re), Re;
      }
      function ks(B, ne) {
        var ge = z.transition;
        z.transition = {};
        var Re = z.transition;
        z.transition._updatedFibers = /* @__PURE__ */ new Set();
        try {
          B();
        } finally {
          if (z.transition = ge, ge === null && Re._updatedFibers) {
            var Ve = Re._updatedFibers.size;
            Ve > 10 && ce("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), Re._updatedFibers.clear();
          }
        }
      }
      var Kl = !1, jc = null;
      function Wl(B) {
        if (jc === null)
          try {
            var ne = ("require" + Math.random()).slice(0, 7), ge = n && n[ne];
            jc = ge.call(n, "timers").setImmediate;
          } catch {
            jc = function(Ve) {
              Kl === !1 && (Kl = !0, typeof MessageChannel > "u" && Q("This browser does not have a MessageChannel implementation, so enqueuing tasks via await act(async () => ...) will fail. Please file an issue at https://github.com/facebook/react/issues if you encounter this warning."));
              var ot = new MessageChannel();
              ot.port1.onmessage = Ve, ot.port2.postMessage(void 0);
            };
          }
        return jc(B);
      }
      var qo = 0, Z = !1;
      function pe(B) {
        {
          var ne = qo;
          qo++, F.current === null && (F.current = []);
          var ge = F.isBatchingLegacy, Re;
          try {
            if (F.isBatchingLegacy = !0, Re = B(), !ge && F.didScheduleLegacyUpdate) {
              var Ve = F.current;
              Ve !== null && (F.didScheduleLegacyUpdate = !1, Lt(Ve));
            }
          } catch (tn) {
            throw ze(ne), tn;
          } finally {
            F.isBatchingLegacy = ge;
          }
          if (Re !== null && typeof Re == "object" && typeof Re.then == "function") {
            var ot = Re, Je = !1, kt = {
              then: function(tn, pr) {
                Je = !0, ot.then(function(Qr) {
                  ze(ne), qo === 0 ? lt(Qr, tn, pr) : tn(Qr);
                }, function(Qr) {
                  ze(ne), pr(Qr);
                });
              }
            };
            return !Z && typeof Promise < "u" && Promise.resolve().then(function() {
            }).then(function() {
              Je || (Z = !0, Q("You called act(async () => ...) without await. This could lead to unexpected testing behaviour, interleaving multiple act calls and mixing their scopes. You should - await act(async () => ...);"));
            }), kt;
          } else {
            var Qt = Re;
            if (ze(ne), qo === 0) {
              var Mn = F.current;
              Mn !== null && (Lt(Mn), F.current = null);
              var Bn = {
                then: function(tn, pr) {
                  F.current === null ? (F.current = [], lt(Qt, tn, pr)) : tn(Qt);
                }
              };
              return Bn;
            } else {
              var lr = {
                then: function(tn, pr) {
                  tn(Qt);
                }
              };
              return lr;
            }
          }
        }
      }
      function ze(B) {
        B !== qo - 1 && Q("You seem to have overlapping act() calls, this is not supported. Be sure to await previous act() calls before making a new one. "), qo = B;
      }
      function lt(B, ne, ge) {
        {
          var Re = F.current;
          if (Re !== null)
            try {
              Lt(Re), Wl(function() {
                Re.length === 0 ? (F.current = null, ne(B)) : lt(B, ne, ge);
              });
            } catch (Ve) {
              ge(Ve);
            }
          else
            ne(B);
        }
      }
      var Nn = !1;
      function Lt(B) {
        if (!Nn) {
          Nn = !0;
          var ne = 0;
          try {
            for (; ne < B.length; ne++) {
              var ge = B[ne];
              do
                ge = ge(!0);
              while (ge !== null);
            }
            B.length = 0;
          } catch (Re) {
            throw B = B.slice(ne + 1), Re;
          } finally {
            Nn = !1;
          }
        }
      }
      var nr = Di, Rr = Vl, Zn = ef, Qn = {
        map: Cs,
        forEach: Ra,
        count: ka,
        toArray: yo,
        only: Ul
      };
      e.Children = Qn, e.Component = De, e.Fragment = l, e.Profiler = d, e.PureComponent = gt, e.StrictMode = c, e.Suspense = v, e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = le, e.act = pe, e.cloneElement = Rr, e.createContext = Xs, e.createElement = nr, e.createFactory = Zn, e.createRef = mn, e.forwardRef = Ma, e.isValidElement = qn, e.lazy = Ri, e.memo = tt, e.startTransition = ks, e.unstable_act = pe, e.useCallback = Mi, e.useContext = zt, e.useDebugValue = yr, e.useDeferredValue = xo, e.useEffect = Lr, e.useId = Aa, e.useImperativeHandle = Un, e.useInsertionEffect = ar, e.useLayoutEffect = zn, e.useMemo = Es, e.useReducer = un, e.useRef = en, e.useState = Vt, e.useSyncExternalStore = Qd, e.useTransition = Gt, e.version = r, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(yx, yx.exports)), yx.exports;
}
var oF;
function aw() {
  if (oF) return P1.exports;
  oF = 1;
  var n = {};
  return n.NODE_ENV === "production" ? P1.exports = ste() : P1.exports = ate(), P1.exports;
}
var M = aw();
const Bt = /* @__PURE__ */ wh(M), lte = /* @__PURE__ */ ote({
  __proto__: null,
  default: Bt
}, [M]);
var ny = {}, T1 = { exports: {} }, fa = {}, I1 = { exports: {} }, dk = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var sF;
function cte() {
  return sF || (sF = 1, function(n) {
    function e(Q, he) {
      var ke = Q.length;
      Q.push(he);
      e: for (; 0 < ke; ) {
        var te = ke - 1 >>> 1, me = Q[te];
        if (0 < i(me, he)) Q[te] = he, Q[ke] = me, ke = te;
        else break e;
      }
    }
    function t(Q) {
      return Q.length === 0 ? null : Q[0];
    }
    function r(Q) {
      if (Q.length === 0) return null;
      var he = Q[0], ke = Q.pop();
      if (ke !== he) {
        Q[0] = ke;
        e: for (var te = 0, me = Q.length, Oe = me >>> 1; te < Oe; ) {
          var Ze = 2 * (te + 1) - 1, De = Q[Ze], yt = Ze + 1, it = Q[yt];
          if (0 > i(De, ke)) yt < me && 0 > i(it, De) ? (Q[te] = it, Q[yt] = ke, te = yt) : (Q[te] = De, Q[Ze] = ke, te = Ze);
          else if (yt < me && 0 > i(it, ke)) Q[te] = it, Q[yt] = ke, te = yt;
          else break e;
        }
      }
      return he;
    }
    function i(Q, he) {
      var ke = Q.sortIndex - he.sortIndex;
      return ke !== 0 ? ke : Q.id - he.id;
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
      var s = performance;
      n.unstable_now = function() {
        return s.now();
      };
    } else {
      var l = Date, c = l.now();
      n.unstable_now = function() {
        return l.now() - c;
      };
    }
    var d = [], h = [], g = 1, y = null, v = 3, w = !1, C = !1, E = !1, P = typeof setTimeout == "function" ? setTimeout : null, I = typeof clearTimeout == "function" ? clearTimeout : null, k = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function L(Q) {
      for (var he = t(h); he !== null; ) {
        if (he.callback === null) r(h);
        else if (he.startTime <= Q) r(h), he.sortIndex = he.expirationTime, e(d, he);
        else break;
        he = t(h);
      }
    }
    function O(Q) {
      if (E = !1, L(Q), !C) if (t(d) !== null) C = !0, le(z);
      else {
        var he = t(h);
        he !== null && ce(O, he.startTime - Q);
      }
    }
    function z(Q, he) {
      C = !1, E && (E = !1, I(V), V = -1), w = !0;
      var ke = v;
      try {
        for (L(he), y = t(d); y !== null && (!(y.expirationTime > he) || Q && !J()); ) {
          var te = y.callback;
          if (typeof te == "function") {
            y.callback = null, v = y.priorityLevel;
            var me = te(y.expirationTime <= he);
            he = n.unstable_now(), typeof me == "function" ? y.callback = me : y === t(d) && r(d), L(he);
          } else r(d);
          y = t(d);
        }
        if (y !== null) var Oe = !0;
        else {
          var Ze = t(h);
          Ze !== null && ce(O, Ze.startTime - he), Oe = !1;
        }
        return Oe;
      } finally {
        y = null, v = ke, w = !1;
      }
    }
    var F = !1, H = null, V = -1, re = 5, q = -1;
    function J() {
      return !(n.unstable_now() - q < re);
    }
    function ie() {
      if (H !== null) {
        var Q = n.unstable_now();
        q = Q;
        var he = !0;
        try {
          he = H(!0, Q);
        } finally {
          he ? W() : (F = !1, H = null);
        }
      } else F = !1;
    }
    var W;
    if (typeof k == "function") W = function() {
      k(ie);
    };
    else if (typeof MessageChannel < "u") {
      var Y = new MessageChannel(), oe = Y.port2;
      Y.port1.onmessage = ie, W = function() {
        oe.postMessage(null);
      };
    } else W = function() {
      P(ie, 0);
    };
    function le(Q) {
      H = Q, F || (F = !0, W());
    }
    function ce(Q, he) {
      V = P(function() {
        Q(n.unstable_now());
      }, he);
    }
    n.unstable_IdlePriority = 5, n.unstable_ImmediatePriority = 1, n.unstable_LowPriority = 4, n.unstable_NormalPriority = 3, n.unstable_Profiling = null, n.unstable_UserBlockingPriority = 2, n.unstable_cancelCallback = function(Q) {
      Q.callback = null;
    }, n.unstable_continueExecution = function() {
      C || w || (C = !0, le(z));
    }, n.unstable_forceFrameRate = function(Q) {
      0 > Q || 125 < Q ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : re = 0 < Q ? Math.floor(1e3 / Q) : 5;
    }, n.unstable_getCurrentPriorityLevel = function() {
      return v;
    }, n.unstable_getFirstCallbackNode = function() {
      return t(d);
    }, n.unstable_next = function(Q) {
      switch (v) {
        case 1:
        case 2:
        case 3:
          var he = 3;
          break;
        default:
          he = v;
      }
      var ke = v;
      v = he;
      try {
        return Q();
      } finally {
        v = ke;
      }
    }, n.unstable_pauseExecution = function() {
    }, n.unstable_requestPaint = function() {
    }, n.unstable_runWithPriority = function(Q, he) {
      switch (Q) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
          break;
        default:
          Q = 3;
      }
      var ke = v;
      v = Q;
      try {
        return he();
      } finally {
        v = ke;
      }
    }, n.unstable_scheduleCallback = function(Q, he, ke) {
      var te = n.unstable_now();
      switch (typeof ke == "object" && ke !== null ? (ke = ke.delay, ke = typeof ke == "number" && 0 < ke ? te + ke : te) : ke = te, Q) {
        case 1:
          var me = -1;
          break;
        case 2:
          me = 250;
          break;
        case 5:
          me = 1073741823;
          break;
        case 4:
          me = 1e4;
          break;
        default:
          me = 5e3;
      }
      return me = ke + me, Q = { id: g++, callback: he, priorityLevel: Q, startTime: ke, expirationTime: me, sortIndex: -1 }, ke > te ? (Q.sortIndex = ke, e(h, Q), t(d) === null && Q === t(h) && (E ? (I(V), V = -1) : E = !0, ce(O, ke - te))) : (Q.sortIndex = me, e(d, Q), C || w || (C = !0, le(z))), Q;
    }, n.unstable_shouldYield = J, n.unstable_wrapCallback = function(Q) {
      var he = v;
      return function() {
        var ke = v;
        v = he;
        try {
          return Q.apply(this, arguments);
        } finally {
          v = ke;
        }
      };
    };
  }(dk)), dk;
}
var fk = {}, aF;
function ute() {
  return aF || (aF = 1, function(n) {
    var e = {};
    /**
     * @license React
     * scheduler.development.js
     *
     * Copyright (c) Facebook, Inc. and its affiliates.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */
    e.NODE_ENV !== "production" && function() {
      typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
      var t = !1, r = 5;
      function i(ve, $e) {
        var mt = ve.length;
        ve.push($e), c(ve, $e, mt);
      }
      function s(ve) {
        return ve.length === 0 ? null : ve[0];
      }
      function l(ve) {
        if (ve.length === 0)
          return null;
        var $e = ve[0], mt = ve.pop();
        return mt !== $e && (ve[0] = mt, d(ve, mt, 0)), $e;
      }
      function c(ve, $e, mt) {
        for (var cn = mt; cn > 0; ) {
          var yn = cn - 1 >>> 1, qn = ve[yn];
          if (h(qn, $e) > 0)
            ve[yn] = $e, ve[cn] = qn, cn = yn;
          else
            return;
        }
      }
      function d(ve, $e, mt) {
        for (var cn = mt, yn = ve.length, qn = yn >>> 1; cn < qn; ) {
          var Rn = (cn + 1) * 2 - 1, sr = ve[Rn], bn = Rn + 1, vn = ve[bn];
          if (h(sr, $e) < 0)
            bn < yn && h(vn, sr) < 0 ? (ve[cn] = vn, ve[bn] = $e, cn = bn) : (ve[cn] = sr, ve[Rn] = $e, cn = Rn);
          else if (bn < yn && h(vn, $e) < 0)
            ve[cn] = vn, ve[bn] = $e, cn = bn;
          else
            return;
        }
      }
      function h(ve, $e) {
        var mt = ve.sortIndex - $e.sortIndex;
        return mt !== 0 ? mt : ve.id - $e.id;
      }
      var g = 1, y = 2, v = 3, w = 4, C = 5;
      function E(ve, $e) {
      }
      var P = typeof performance == "object" && typeof performance.now == "function";
      if (P) {
        var I = performance;
        n.unstable_now = function() {
          return I.now();
        };
      } else {
        var k = Date, L = k.now();
        n.unstable_now = function() {
          return k.now() - L;
        };
      }
      var O = 1073741823, z = -1, F = 250, H = 5e3, V = 1e4, re = O, q = [], J = [], ie = 1, W = null, Y = v, oe = !1, le = !1, ce = !1, Q = typeof setTimeout == "function" ? setTimeout : null, he = typeof clearTimeout == "function" ? clearTimeout : null, ke = typeof setImmediate < "u" ? setImmediate : null;
      typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
      function te(ve) {
        for (var $e = s(J); $e !== null; ) {
          if ($e.callback === null)
            l(J);
          else if ($e.startTime <= ve)
            l(J), $e.sortIndex = $e.expirationTime, i(q, $e);
          else
            return;
          $e = s(J);
        }
      }
      function me(ve) {
        if (ce = !1, te(ve), !le)
          if (s(q) !== null)
            le = !0, Tr(Oe);
          else {
            var $e = s(J);
            $e !== null && Ir(me, $e.startTime - ve);
          }
      }
      function Oe(ve, $e) {
        le = !1, ce && (ce = !1, Zr()), oe = !0;
        var mt = Y;
        try {
          var cn;
          if (!t) return Ze(ve, $e);
        } finally {
          W = null, Y = mt, oe = !1;
        }
      }
      function Ze(ve, $e) {
        var mt = $e;
        for (te(mt), W = s(q); W !== null && !(W.expirationTime > mt && (!ve || Hr())); ) {
          var cn = W.callback;
          if (typeof cn == "function") {
            W.callback = null, Y = W.priorityLevel;
            var yn = W.expirationTime <= mt, qn = cn(yn);
            mt = n.unstable_now(), typeof qn == "function" ? W.callback = qn : W === s(q) && l(q), te(mt);
          } else
            l(q);
          W = s(q);
        }
        if (W !== null)
          return !0;
        var Rn = s(J);
        return Rn !== null && Ir(me, Rn.startTime - mt), !1;
      }
      function De(ve, $e) {
        switch (ve) {
          case g:
          case y:
          case v:
          case w:
          case C:
            break;
          default:
            ve = v;
        }
        var mt = Y;
        Y = ve;
        try {
          return $e();
        } finally {
          Y = mt;
        }
      }
      function yt(ve) {
        var $e;
        switch (Y) {
          case g:
          case y:
          case v:
            $e = v;
            break;
          default:
            $e = Y;
            break;
        }
        var mt = Y;
        Y = $e;
        try {
          return ve();
        } finally {
          Y = mt;
        }
      }
      function it(ve) {
        var $e = Y;
        return function() {
          var mt = Y;
          Y = $e;
          try {
            return ve.apply(this, arguments);
          } finally {
            Y = mt;
          }
        };
      }
      function We(ve, $e, mt) {
        var cn = n.unstable_now(), yn;
        if (typeof mt == "object" && mt !== null) {
          var qn = mt.delay;
          typeof qn == "number" && qn > 0 ? yn = cn + qn : yn = cn;
        } else
          yn = cn;
        var Rn;
        switch (ve) {
          case g:
            Rn = z;
            break;
          case y:
            Rn = F;
            break;
          case C:
            Rn = re;
            break;
          case w:
            Rn = V;
            break;
          case v:
          default:
            Rn = H;
            break;
        }
        var sr = yn + Rn, bn = {
          id: ie++,
          callback: $e,
          priorityLevel: ve,
          startTime: yn,
          expirationTime: sr,
          sortIndex: -1
        };
        return yn > cn ? (bn.sortIndex = yn, i(J, bn), s(q) === null && bn === s(J) && (ce ? Zr() : ce = !0, Ir(me, yn - cn))) : (bn.sortIndex = sr, i(q, bn), !le && !oe && (le = !0, Tr(Oe))), bn;
      }
      function Qe() {
      }
      function gt() {
        !le && !oe && (le = !0, Tr(Oe));
      }
      function Pt() {
        return s(q);
      }
      function mn(ve) {
        ve.callback = null;
      }
      function Zt() {
        return Y;
      }
      var an = !1, ln = null, Yt = -1, Gn = r, xr = -1;
      function Hr() {
        var ve = n.unstable_now() - xr;
        return !(ve < Gn);
      }
      function Pr() {
      }
      function wr(ve) {
        if (ve < 0 || ve > 125) {
          console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported");
          return;
        }
        ve > 0 ? Gn = Math.floor(1e3 / ve) : Gn = r;
      }
      var Vr = function() {
        if (ln !== null) {
          var ve = n.unstable_now();
          xr = ve;
          var $e = !0, mt = !0;
          try {
            mt = ln($e, ve);
          } finally {
            mt ? Kr() : (an = !1, ln = null);
          }
        } else
          an = !1;
      }, Kr;
      if (typeof ke == "function")
        Kr = function() {
          ke(Vr);
        };
      else if (typeof MessageChannel < "u") {
        var si = new MessageChannel(), mo = si.port2;
        si.port1.onmessage = Vr, Kr = function() {
          mo.postMessage(null);
        };
      } else
        Kr = function() {
          Q(Vr, 0);
        };
      function Tr(ve) {
        ln = ve, an || (an = !0, Kr());
      }
      function Ir(ve, $e) {
        Yt = Q(function() {
          ve(n.unstable_now());
        }, $e);
      }
      function Zr() {
        he(Yt), Yt = -1;
      }
      var Ko = Pr, Ee = null;
      n.unstable_IdlePriority = C, n.unstable_ImmediatePriority = g, n.unstable_LowPriority = w, n.unstable_NormalPriority = v, n.unstable_Profiling = Ee, n.unstable_UserBlockingPriority = y, n.unstable_cancelCallback = mn, n.unstable_continueExecution = gt, n.unstable_forceFrameRate = wr, n.unstable_getCurrentPriorityLevel = Zt, n.unstable_getFirstCallbackNode = Pt, n.unstable_next = yt, n.unstable_pauseExecution = Qe, n.unstable_requestPaint = Ko, n.unstable_runWithPriority = De, n.unstable_scheduleCallback = We, n.unstable_shouldYield = Hr, n.unstable_wrapCallback = it, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
    }();
  }(fk)), fk;
}
var lF;
function O$() {
  if (lF) return I1.exports;
  lF = 1;
  var n = {};
  return n.NODE_ENV === "production" ? I1.exports = cte() : I1.exports = ute(), I1.exports;
}
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cF;
function dte() {
  if (cF) return fa;
  cF = 1;
  var n = aw(), e = O$();
  function t(u) {
    for (var f = "https://reactjs.org/docs/error-decoder.html?invariant=" + u, x = 1; x < arguments.length; x++) f += "&args[]=" + encodeURIComponent(arguments[x]);
    return "Minified React error #" + u + "; visit " + f + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
  }
  var r = /* @__PURE__ */ new Set(), i = {};
  function s(u, f) {
    l(u, f), l(u + "Capture", f);
  }
  function l(u, f) {
    for (i[u] = f, u = 0; u < f.length; u++) r.add(f[u]);
  }
  var c = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), d = Object.prototype.hasOwnProperty, h = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, g = {}, y = {};
  function v(u) {
    return d.call(y, u) ? !0 : d.call(g, u) ? !1 : h.test(u) ? y[u] = !0 : (g[u] = !0, !1);
  }
  function w(u, f, x, _) {
    if (x !== null && x.type === 0) return !1;
    switch (typeof f) {
      case "function":
      case "symbol":
        return !0;
      case "boolean":
        return _ ? !1 : x !== null ? !x.acceptsBooleans : (u = u.toLowerCase().slice(0, 5), u !== "data-" && u !== "aria-");
      default:
        return !1;
    }
  }
  function C(u, f, x, _) {
    if (f === null || typeof f > "u" || w(u, f, x, _)) return !0;
    if (_) return !1;
    if (x !== null) switch (x.type) {
      case 3:
        return !f;
      case 4:
        return f === !1;
      case 5:
        return isNaN(f);
      case 6:
        return isNaN(f) || 1 > f;
    }
    return !1;
  }
  function E(u, f, x, _, A, j, K) {
    this.acceptsBooleans = f === 2 || f === 3 || f === 4, this.attributeName = _, this.attributeNamespace = A, this.mustUseProperty = x, this.propertyName = u, this.type = f, this.sanitizeURL = j, this.removeEmptyString = K;
  }
  var P = {};
  "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(u) {
    P[u] = new E(u, 0, !1, u, null, !1, !1);
  }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(u) {
    var f = u[0];
    P[f] = new E(f, 1, !1, u[1], null, !1, !1);
  }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(u) {
    P[u] = new E(u, 2, !1, u.toLowerCase(), null, !1, !1);
  }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(u) {
    P[u] = new E(u, 2, !1, u, null, !1, !1);
  }), "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(u) {
    P[u] = new E(u, 3, !1, u.toLowerCase(), null, !1, !1);
  }), ["checked", "multiple", "muted", "selected"].forEach(function(u) {
    P[u] = new E(u, 3, !0, u, null, !1, !1);
  }), ["capture", "download"].forEach(function(u) {
    P[u] = new E(u, 4, !1, u, null, !1, !1);
  }), ["cols", "rows", "size", "span"].forEach(function(u) {
    P[u] = new E(u, 6, !1, u, null, !1, !1);
  }), ["rowSpan", "start"].forEach(function(u) {
    P[u] = new E(u, 5, !1, u.toLowerCase(), null, !1, !1);
  });
  var I = /[\-:]([a-z])/g;
  function k(u) {
    return u[1].toUpperCase();
  }
  "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(u) {
    var f = u.replace(
      I,
      k
    );
    P[f] = new E(f, 1, !1, u, null, !1, !1);
  }), "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(u) {
    var f = u.replace(I, k);
    P[f] = new E(f, 1, !1, u, "http://www.w3.org/1999/xlink", !1, !1);
  }), ["xml:base", "xml:lang", "xml:space"].forEach(function(u) {
    var f = u.replace(I, k);
    P[f] = new E(f, 1, !1, u, "http://www.w3.org/XML/1998/namespace", !1, !1);
  }), ["tabIndex", "crossOrigin"].forEach(function(u) {
    P[u] = new E(u, 1, !1, u.toLowerCase(), null, !1, !1);
  }), P.xlinkHref = new E("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1), ["src", "href", "action", "formAction"].forEach(function(u) {
    P[u] = new E(u, 1, !1, u.toLowerCase(), null, !0, !0);
  });
  function L(u, f, x, _) {
    var A = P.hasOwnProperty(f) ? P[f] : null;
    (A !== null ? A.type !== 0 : _ || !(2 < f.length) || f[0] !== "o" && f[0] !== "O" || f[1] !== "n" && f[1] !== "N") && (C(f, x, A, _) && (x = null), _ || A === null ? v(f) && (x === null ? u.removeAttribute(f) : u.setAttribute(f, "" + x)) : A.mustUseProperty ? u[A.propertyName] = x === null ? A.type === 3 ? !1 : "" : x : (f = A.attributeName, _ = A.attributeNamespace, x === null ? u.removeAttribute(f) : (A = A.type, x = A === 3 || A === 4 && x === !0 ? "" : "" + x, _ ? u.setAttributeNS(_, f, x) : u.setAttribute(f, x))));
  }
  var O = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, z = Symbol.for("react.element"), F = Symbol.for("react.portal"), H = Symbol.for("react.fragment"), V = Symbol.for("react.strict_mode"), re = Symbol.for("react.profiler"), q = Symbol.for("react.provider"), J = Symbol.for("react.context"), ie = Symbol.for("react.forward_ref"), W = Symbol.for("react.suspense"), Y = Symbol.for("react.suspense_list"), oe = Symbol.for("react.memo"), le = Symbol.for("react.lazy"), ce = Symbol.for("react.offscreen"), Q = Symbol.iterator;
  function he(u) {
    return u === null || typeof u != "object" ? null : (u = Q && u[Q] || u["@@iterator"], typeof u == "function" ? u : null);
  }
  var ke = Object.assign, te;
  function me(u) {
    if (te === void 0) try {
      throw Error();
    } catch (x) {
      var f = x.stack.trim().match(/\n( *(at )?)/);
      te = f && f[1] || "";
    }
    return `
` + te + u;
  }
  var Oe = !1;
  function Ze(u, f) {
    if (!u || Oe) return "";
    Oe = !0;
    var x = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
      if (f) if (f = function() {
        throw Error();
      }, Object.defineProperty(f.prototype, "props", { set: function() {
        throw Error();
      } }), typeof Reflect == "object" && Reflect.construct) {
        try {
          Reflect.construct(f, []);
        } catch (Te) {
          var _ = Te;
        }
        Reflect.construct(u, [], f);
      } else {
        try {
          f.call();
        } catch (Te) {
          _ = Te;
        }
        u.call(f.prototype);
      }
      else {
        try {
          throw Error();
        } catch (Te) {
          _ = Te;
        }
        u();
      }
    } catch (Te) {
      if (Te && _ && typeof Te.stack == "string") {
        for (var A = Te.stack.split(`
`), j = _.stack.split(`
`), K = A.length - 1, ee = j.length - 1; 1 <= K && 0 <= ee && A[K] !== j[ee]; ) ee--;
        for (; 1 <= K && 0 <= ee; K--, ee--) if (A[K] !== j[ee]) {
          if (K !== 1 || ee !== 1)
            do
              if (K--, ee--, 0 > ee || A[K] !== j[ee]) {
                var ae = `
` + A[K].replace(" at new ", " at ");
                return u.displayName && ae.includes("<anonymous>") && (ae = ae.replace("<anonymous>", u.displayName)), ae;
              }
            while (1 <= K && 0 <= ee);
          break;
        }
      }
    } finally {
      Oe = !1, Error.prepareStackTrace = x;
    }
    return (u = u ? u.displayName || u.name : "") ? me(u) : "";
  }
  function De(u) {
    switch (u.tag) {
      case 5:
        return me(u.type);
      case 16:
        return me("Lazy");
      case 13:
        return me("Suspense");
      case 19:
        return me("SuspenseList");
      case 0:
      case 2:
      case 15:
        return u = Ze(u.type, !1), u;
      case 11:
        return u = Ze(u.type.render, !1), u;
      case 1:
        return u = Ze(u.type, !0), u;
      default:
        return "";
    }
  }
  function yt(u) {
    if (u == null) return null;
    if (typeof u == "function") return u.displayName || u.name || null;
    if (typeof u == "string") return u;
    switch (u) {
      case H:
        return "Fragment";
      case F:
        return "Portal";
      case re:
        return "Profiler";
      case V:
        return "StrictMode";
      case W:
        return "Suspense";
      case Y:
        return "SuspenseList";
    }
    if (typeof u == "object") switch (u.$$typeof) {
      case J:
        return (u.displayName || "Context") + ".Consumer";
      case q:
        return (u._context.displayName || "Context") + ".Provider";
      case ie:
        var f = u.render;
        return u = u.displayName, u || (u = f.displayName || f.name || "", u = u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef"), u;
      case oe:
        return f = u.displayName || null, f !== null ? f : yt(u.type) || "Memo";
      case le:
        f = u._payload, u = u._init;
        try {
          return yt(u(f));
        } catch {
        }
    }
    return null;
  }
  function it(u) {
    var f = u.type;
    switch (u.tag) {
      case 24:
        return "Cache";
      case 9:
        return (f.displayName || "Context") + ".Consumer";
      case 10:
        return (f._context.displayName || "Context") + ".Provider";
      case 18:
        return "DehydratedFragment";
      case 11:
        return u = f.render, u = u.displayName || u.name || "", f.displayName || (u !== "" ? "ForwardRef(" + u + ")" : "ForwardRef");
      case 7:
        return "Fragment";
      case 5:
        return f;
      case 4:
        return "Portal";
      case 3:
        return "Root";
      case 6:
        return "Text";
      case 16:
        return yt(f);
      case 8:
        return f === V ? "StrictMode" : "Mode";
      case 22:
        return "Offscreen";
      case 12:
        return "Profiler";
      case 21:
        return "Scope";
      case 13:
        return "Suspense";
      case 19:
        return "SuspenseList";
      case 25:
        return "TracingMarker";
      case 1:
      case 0:
      case 17:
      case 2:
      case 14:
      case 15:
        if (typeof f == "function") return f.displayName || f.name || null;
        if (typeof f == "string") return f;
    }
    return null;
  }
  function We(u) {
    switch (typeof u) {
      case "boolean":
      case "number":
      case "string":
      case "undefined":
        return u;
      case "object":
        return u;
      default:
        return "";
    }
  }
  function Qe(u) {
    var f = u.type;
    return (u = u.nodeName) && u.toLowerCase() === "input" && (f === "checkbox" || f === "radio");
  }
  function gt(u) {
    var f = Qe(u) ? "checked" : "value", x = Object.getOwnPropertyDescriptor(u.constructor.prototype, f), _ = "" + u[f];
    if (!u.hasOwnProperty(f) && typeof x < "u" && typeof x.get == "function" && typeof x.set == "function") {
      var A = x.get, j = x.set;
      return Object.defineProperty(u, f, { configurable: !0, get: function() {
        return A.call(this);
      }, set: function(K) {
        _ = "" + K, j.call(this, K);
      } }), Object.defineProperty(u, f, { enumerable: x.enumerable }), { getValue: function() {
        return _;
      }, setValue: function(K) {
        _ = "" + K;
      }, stopTracking: function() {
        u._valueTracker = null, delete u[f];
      } };
    }
  }
  function Pt(u) {
    u._valueTracker || (u._valueTracker = gt(u));
  }
  function mn(u) {
    if (!u) return !1;
    var f = u._valueTracker;
    if (!f) return !0;
    var x = f.getValue(), _ = "";
    return u && (_ = Qe(u) ? u.checked ? "true" : "false" : u.value), u = _, u !== x ? (f.setValue(u), !0) : !1;
  }
  function Zt(u) {
    if (u = u || (typeof document < "u" ? document : void 0), typeof u > "u") return null;
    try {
      return u.activeElement || u.body;
    } catch {
      return u.body;
    }
  }
  function an(u, f) {
    var x = f.checked;
    return ke({}, f, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: x ?? u._wrapperState.initialChecked });
  }
  function ln(u, f) {
    var x = f.defaultValue == null ? "" : f.defaultValue, _ = f.checked != null ? f.checked : f.defaultChecked;
    x = We(f.value != null ? f.value : x), u._wrapperState = { initialChecked: _, initialValue: x, controlled: f.type === "checkbox" || f.type === "radio" ? f.checked != null : f.value != null };
  }
  function Yt(u, f) {
    f = f.checked, f != null && L(u, "checked", f, !1);
  }
  function Gn(u, f) {
    Yt(u, f);
    var x = We(f.value), _ = f.type;
    if (x != null) _ === "number" ? (x === 0 && u.value === "" || u.value != x) && (u.value = "" + x) : u.value !== "" + x && (u.value = "" + x);
    else if (_ === "submit" || _ === "reset") {
      u.removeAttribute("value");
      return;
    }
    f.hasOwnProperty("value") ? Hr(u, f.type, x) : f.hasOwnProperty("defaultValue") && Hr(u, f.type, We(f.defaultValue)), f.checked == null && f.defaultChecked != null && (u.defaultChecked = !!f.defaultChecked);
  }
  function xr(u, f, x) {
    if (f.hasOwnProperty("value") || f.hasOwnProperty("defaultValue")) {
      var _ = f.type;
      if (!(_ !== "submit" && _ !== "reset" || f.value !== void 0 && f.value !== null)) return;
      f = "" + u._wrapperState.initialValue, x || f === u.value || (u.value = f), u.defaultValue = f;
    }
    x = u.name, x !== "" && (u.name = ""), u.defaultChecked = !!u._wrapperState.initialChecked, x !== "" && (u.name = x);
  }
  function Hr(u, f, x) {
    (f !== "number" || Zt(u.ownerDocument) !== u) && (x == null ? u.defaultValue = "" + u._wrapperState.initialValue : u.defaultValue !== "" + x && (u.defaultValue = "" + x));
  }
  var Pr = Array.isArray;
  function wr(u, f, x, _) {
    if (u = u.options, f) {
      f = {};
      for (var A = 0; A < x.length; A++) f["$" + x[A]] = !0;
      for (x = 0; x < u.length; x++) A = f.hasOwnProperty("$" + u[x].value), u[x].selected !== A && (u[x].selected = A), A && _ && (u[x].defaultSelected = !0);
    } else {
      for (x = "" + We(x), f = null, A = 0; A < u.length; A++) {
        if (u[A].value === x) {
          u[A].selected = !0, _ && (u[A].defaultSelected = !0);
          return;
        }
        f !== null || u[A].disabled || (f = u[A]);
      }
      f !== null && (f.selected = !0);
    }
  }
  function Vr(u, f) {
    if (f.dangerouslySetInnerHTML != null) throw Error(t(91));
    return ke({}, f, { value: void 0, defaultValue: void 0, children: "" + u._wrapperState.initialValue });
  }
  function Kr(u, f) {
    var x = f.value;
    if (x == null) {
      if (x = f.children, f = f.defaultValue, x != null) {
        if (f != null) throw Error(t(92));
        if (Pr(x)) {
          if (1 < x.length) throw Error(t(93));
          x = x[0];
        }
        f = x;
      }
      f == null && (f = ""), x = f;
    }
    u._wrapperState = { initialValue: We(x) };
  }
  function si(u, f) {
    var x = We(f.value), _ = We(f.defaultValue);
    x != null && (x = "" + x, x !== u.value && (u.value = x), f.defaultValue == null && u.defaultValue !== x && (u.defaultValue = x)), _ != null && (u.defaultValue = "" + _);
  }
  function mo(u) {
    var f = u.textContent;
    f === u._wrapperState.initialValue && f !== "" && f !== null && (u.value = f);
  }
  function Tr(u) {
    switch (u) {
      case "svg":
        return "http://www.w3.org/2000/svg";
      case "math":
        return "http://www.w3.org/1998/Math/MathML";
      default:
        return "http://www.w3.org/1999/xhtml";
    }
  }
  function Ir(u, f) {
    return u == null || u === "http://www.w3.org/1999/xhtml" ? Tr(f) : u === "http://www.w3.org/2000/svg" && f === "foreignObject" ? "http://www.w3.org/1999/xhtml" : u;
  }
  var Zr, Ko = function(u) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(f, x, _, A) {
      MSApp.execUnsafeLocalFunction(function() {
        return u(f, x, _, A);
      });
    } : u;
  }(function(u, f) {
    if (u.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in u) u.innerHTML = f;
    else {
      for (Zr = Zr || document.createElement("div"), Zr.innerHTML = "<svg>" + f.valueOf().toString() + "</svg>", f = Zr.firstChild; u.firstChild; ) u.removeChild(u.firstChild);
      for (; f.firstChild; ) u.appendChild(f.firstChild);
    }
  });
  function Ee(u, f) {
    if (f) {
      var x = u.firstChild;
      if (x && x === u.lastChild && x.nodeType === 3) {
        x.nodeValue = f;
        return;
      }
    }
    u.textContent = f;
  }
  var ve = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
  }, $e = ["Webkit", "ms", "Moz", "O"];
  Object.keys(ve).forEach(function(u) {
    $e.forEach(function(f) {
      f = f + u.charAt(0).toUpperCase() + u.substring(1), ve[f] = ve[u];
    });
  });
  function mt(u, f, x) {
    return f == null || typeof f == "boolean" || f === "" ? "" : x || typeof f != "number" || f === 0 || ve.hasOwnProperty(u) && ve[u] ? ("" + f).trim() : f + "px";
  }
  function cn(u, f) {
    u = u.style;
    for (var x in f) if (f.hasOwnProperty(x)) {
      var _ = x.indexOf("--") === 0, A = mt(x, f[x], _);
      x === "float" && (x = "cssFloat"), _ ? u.setProperty(x, A) : u[x] = A;
    }
  }
  var yn = ke({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 });
  function qn(u, f) {
    if (f) {
      if (yn[u] && (f.children != null || f.dangerouslySetInnerHTML != null)) throw Error(t(137, u));
      if (f.dangerouslySetInnerHTML != null) {
        if (f.children != null) throw Error(t(60));
        if (typeof f.dangerouslySetInnerHTML != "object" || !("__html" in f.dangerouslySetInnerHTML)) throw Error(t(61));
      }
      if (f.style != null && typeof f.style != "object") throw Error(t(62));
    }
  }
  function Rn(u, f) {
    if (u.indexOf("-") === -1) return typeof f.is == "string";
    switch (u) {
      case "annotation-xml":
      case "color-profile":
      case "font-face":
      case "font-face-src":
      case "font-face-uri":
      case "font-face-format":
      case "font-face-name":
      case "missing-glyph":
        return !1;
      default:
        return !0;
    }
  }
  var sr = null;
  function bn(u) {
    return u = u.target || u.srcElement || window, u.correspondingUseElement && (u = u.correspondingUseElement), u.nodeType === 3 ? u.parentNode : u;
  }
  var vn = null, fn = null, Ii = null;
  function oo(u) {
    if (u = Gh(u)) {
      if (typeof vn != "function") throw Error(t(280));
      var f = u.stateNode;
      f && (f = Zl(f), vn(u.stateNode, u.type, f));
    }
  }
  function ki(u) {
    fn ? Ii ? Ii.push(u) : Ii = [u] : fn = u;
  }
  function Cs() {
    if (fn) {
      var u = fn, f = Ii;
      if (Ii = fn = null, oo(u), f) for (u = 0; u < f.length; u++) oo(f[u]);
    }
  }
  function ka(u, f) {
    return u(f);
  }
  function Ra() {
  }
  var yo = !1;
  function Ul(u, f, x) {
    if (yo) return u(f, x);
    yo = !0;
    try {
      return ka(u, f, x);
    } finally {
      yo = !1, (fn !== null || Ii !== null) && (Ra(), Cs());
    }
  }
  function Xs(u, f) {
    var x = u.stateNode;
    if (x === null) return null;
    var _ = Zl(x);
    if (_ === null) return null;
    x = _[f];
    e: switch (f) {
      case "onClick":
      case "onClickCapture":
      case "onDoubleClick":
      case "onDoubleClickCapture":
      case "onMouseDown":
      case "onMouseDownCapture":
      case "onMouseMove":
      case "onMouseMoveCapture":
      case "onMouseUp":
      case "onMouseUpCapture":
      case "onMouseEnter":
        (_ = !_.disabled) || (u = u.type, _ = !(u === "button" || u === "input" || u === "select" || u === "textarea")), u = !_;
        break e;
      default:
        u = !1;
    }
    if (u) return null;
    if (x && typeof x != "function") throw Error(t(231, f, typeof x));
    return x;
  }
  var vo = !1;
  if (c) try {
    var vi = {};
    Object.defineProperty(vi, "passive", { get: function() {
      vo = !0;
    } }), window.addEventListener("test", vi, vi), window.removeEventListener("test", vi, vi);
  } catch {
    vo = !1;
  }
  function So(u, f, x, _, A, j, K, ee, ae) {
    var Te = Array.prototype.slice.call(arguments, 3);
    try {
      f.apply(x, Te);
    } catch (He) {
      this.onError(He);
    }
  }
  var $i = !1, Wo = null, Ri = !1, Ma = null, se = { onError: function(u) {
    $i = !0, Wo = u;
  } };
  function Ue(u, f, x, _, A, j, K, ee, ae) {
    $i = !1, Wo = null, So.apply(se, arguments);
  }
  function tt(u, f, x, _, A, j, K, ee, ae) {
    if (Ue.apply(this, arguments), $i) {
      if ($i) {
        var Te = Wo;
        $i = !1, Wo = null;
      } else throw Error(t(198));
      Ri || (Ri = !0, Ma = Te);
    }
  }
  function rt(u) {
    var f = u, x = u;
    if (u.alternate) for (; f.return; ) f = f.return;
    else {
      u = f;
      do
        f = u, f.flags & 4098 && (x = f.return), u = f.return;
      while (u);
    }
    return f.tag === 3 ? x : null;
  }
  function zt(u) {
    if (u.tag === 13) {
      var f = u.memoizedState;
      if (f === null && (u = u.alternate, u !== null && (f = u.memoizedState)), f !== null) return f.dehydrated;
    }
    return null;
  }
  function Vt(u) {
    if (rt(u) !== u) throw Error(t(188));
  }
  function un(u) {
    var f = u.alternate;
    if (!f) {
      if (f = rt(u), f === null) throw Error(t(188));
      return f !== u ? null : u;
    }
    for (var x = u, _ = f; ; ) {
      var A = x.return;
      if (A === null) break;
      var j = A.alternate;
      if (j === null) {
        if (_ = A.return, _ !== null) {
          x = _;
          continue;
        }
        break;
      }
      if (A.child === j.child) {
        for (j = A.child; j; ) {
          if (j === x) return Vt(A), u;
          if (j === _) return Vt(A), f;
          j = j.sibling;
        }
        throw Error(t(188));
      }
      if (x.return !== _.return) x = A, _ = j;
      else {
        for (var K = !1, ee = A.child; ee; ) {
          if (ee === x) {
            K = !0, x = A, _ = j;
            break;
          }
          if (ee === _) {
            K = !0, _ = A, x = j;
            break;
          }
          ee = ee.sibling;
        }
        if (!K) {
          for (ee = j.child; ee; ) {
            if (ee === x) {
              K = !0, x = j, _ = A;
              break;
            }
            if (ee === _) {
              K = !0, _ = j, x = A;
              break;
            }
            ee = ee.sibling;
          }
          if (!K) throw Error(t(189));
        }
      }
      if (x.alternate !== _) throw Error(t(190));
    }
    if (x.tag !== 3) throw Error(t(188));
    return x.stateNode.current === x ? u : f;
  }
  function en(u) {
    return u = un(u), u !== null ? Lr(u) : null;
  }
  function Lr(u) {
    if (u.tag === 5 || u.tag === 6) return u;
    for (u = u.child; u !== null; ) {
      var f = Lr(u);
      if (f !== null) return f;
      u = u.sibling;
    }
    return null;
  }
  var ar = e.unstable_scheduleCallback, zn = e.unstable_cancelCallback, Mi = e.unstable_shouldYield, Es = e.unstable_requestPaint, Un = e.unstable_now, yr = e.unstable_getCurrentPriorityLevel, Gt = e.unstable_ImmediatePriority, xo = e.unstable_UserBlockingPriority, Aa = e.unstable_NormalPriority, Qd = e.unstable_LowPriority, Ai = e.unstable_IdlePriority, al = null, so = null;
  function Fu(u) {
    if (so && typeof so.onCommitFiberRoot == "function") try {
      so.onCommitFiberRoot(al, u, void 0, (u.current.flags & 128) === 128);
    } catch {
    }
  }
  var Bi = Math.clz32 ? Math.clz32 : $l, zu = Math.log, Jd = Math.LN2;
  function $l(u) {
    return u >>>= 0, u === 0 ? 32 : 31 - (zu(u) / Jd | 0) | 0;
  }
  var Da = 64, Go = 4194304;
  function Hi(u) {
    switch (u & -u) {
      case 1:
        return 1;
      case 2:
        return 2;
      case 4:
        return 4;
      case 8:
        return 8;
      case 16:
        return 16;
      case 32:
        return 32;
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return u & 4194240;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return u & 130023424;
      case 134217728:
        return 134217728;
      case 268435456:
        return 268435456;
      case 536870912:
        return 536870912;
      case 1073741824:
        return 1073741824;
      default:
        return u;
    }
  }
  function _s(u, f) {
    var x = u.pendingLanes;
    if (x === 0) return 0;
    var _ = 0, A = u.suspendedLanes, j = u.pingedLanes, K = x & 268435455;
    if (K !== 0) {
      var ee = K & ~A;
      ee !== 0 ? _ = Hi(ee) : (j &= K, j !== 0 && (_ = Hi(j)));
    } else K = x & ~A, K !== 0 ? _ = Hi(K) : j !== 0 && (_ = Hi(j));
    if (_ === 0) return 0;
    if (f !== 0 && f !== _ && !(f & A) && (A = _ & -_, j = f & -f, A >= j || A === 16 && (j & 4194240) !== 0)) return f;
    if (_ & 4 && (_ |= x & 16), f = u.entangledLanes, f !== 0) for (u = u.entanglements, f &= _; 0 < f; ) x = 31 - Bi(f), A = 1 << x, _ |= u[x], f &= ~A;
    return _;
  }
  function ll(u, f) {
    switch (u) {
      case 1:
      case 2:
      case 4:
        return f + 250;
      case 8:
      case 16:
      case 32:
      case 64:
      case 128:
      case 256:
      case 512:
      case 1024:
      case 2048:
      case 4096:
      case 8192:
      case 16384:
      case 32768:
      case 65536:
      case 131072:
      case 262144:
      case 524288:
      case 1048576:
      case 2097152:
        return f + 5e3;
      case 4194304:
      case 8388608:
      case 16777216:
      case 33554432:
      case 67108864:
        return -1;
      case 134217728:
      case 268435456:
      case 536870912:
      case 1073741824:
        return -1;
      default:
        return -1;
    }
  }
  function Ac(u, f) {
    for (var x = u.suspendedLanes, _ = u.pingedLanes, A = u.expirationTimes, j = u.pendingLanes; 0 < j; ) {
      var K = 31 - Bi(j), ee = 1 << K, ae = A[K];
      ae === -1 ? (!(ee & x) || ee & _) && (A[K] = ll(ee, f)) : ae <= f && (u.expiredLanes |= ee), j &= ~ee;
    }
  }
  function Oa(u) {
    return u = u.pendingLanes & -1073741825, u !== 0 ? u : u & 1073741824 ? 1073741824 : 0;
  }
  function Bl() {
    var u = Da;
    return Da <<= 1, !(Da & 4194240) && (Da = 64), u;
  }
  function cl(u) {
    for (var f = [], x = 0; 31 > x; x++) f.push(u);
    return f;
  }
  function ul(u, f, x) {
    u.pendingLanes |= f, f !== 536870912 && (u.suspendedLanes = 0, u.pingedLanes = 0), u = u.eventTimes, f = 31 - Bi(f), u[f] = x;
  }
  function Uu(u, f) {
    var x = u.pendingLanes & ~f;
    u.pendingLanes = f, u.suspendedLanes = 0, u.pingedLanes = 0, u.expiredLanes &= f, u.mutableReadLanes &= f, u.entangledLanes &= f, f = u.entanglements;
    var _ = u.eventTimes;
    for (u = u.expirationTimes; 0 < x; ) {
      var A = 31 - Bi(x), j = 1 << A;
      f[A] = 0, _[A] = -1, u[A] = -1, x &= ~j;
    }
  }
  function Dc(u, f) {
    var x = u.entangledLanes |= f;
    for (u = u.entanglements; x; ) {
      var _ = 31 - Bi(x), A = 1 << _;
      A & f | u[_] & f && (u[_] |= f), x &= ~A;
    }
  }
  var dn = 0;
  function Zs(u) {
    return u &= -u, 1 < u ? 4 < u ? u & 268435455 ? 16 : 536870912 : 4 : 1;
  }
  var Oc, Cn, Ps, Qs, Ut, Hl = !1, ai = [], ao = null, Nr = null, Ts = null, kr = /* @__PURE__ */ new Map(), $n = /* @__PURE__ */ new Map(), Is = [], lo = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
  function Di(u, f) {
    switch (u) {
      case "focusin":
      case "focusout":
        ao = null;
        break;
      case "dragenter":
      case "dragleave":
        Nr = null;
        break;
      case "mouseover":
      case "mouseout":
        Ts = null;
        break;
      case "pointerover":
      case "pointerout":
        kr.delete(f.pointerId);
        break;
      case "gotpointercapture":
      case "lostpointercapture":
        $n.delete(f.pointerId);
    }
  }
  function Oi(u, f, x, _, A, j) {
    return u === null || u.nativeEvent !== j ? (u = { blockedOn: f, domEventName: x, eventSystemFlags: _, nativeEvent: j, targetContainers: [A] }, f !== null && (f = Gh(f), f !== null && Cn(f)), u) : (u.eventSystemFlags |= _, f = u.targetContainers, A !== null && f.indexOf(A) === -1 && f.push(A), u);
  }
  function ef(u, f, x, _, A) {
    switch (f) {
      case "focusin":
        return ao = Oi(ao, u, f, x, _, A), !0;
      case "dragenter":
        return Nr = Oi(Nr, u, f, x, _, A), !0;
      case "mouseover":
        return Ts = Oi(Ts, u, f, x, _, A), !0;
      case "pointerover":
        var j = A.pointerId;
        return kr.set(j, Oi(kr.get(j) || null, u, f, x, _, A)), !0;
      case "gotpointercapture":
        return j = A.pointerId, $n.set(j, Oi($n.get(j) || null, u, f, x, _, A)), !0;
    }
    return !1;
  }
  function Vl(u) {
    var f = Gu(u.target);
    if (f !== null) {
      var x = rt(f);
      if (x !== null) {
        if (f = x.tag, f === 13) {
          if (f = zt(x), f !== null) {
            u.blockedOn = f, Ut(u.priority, function() {
              Ps(x);
            });
            return;
          }
        } else if (f === 3 && x.stateNode.current.memoizedState.isDehydrated) {
          u.blockedOn = x.tag === 3 ? x.stateNode.containerInfo : null;
          return;
        }
      }
    }
    u.blockedOn = null;
  }
  function ks(u) {
    if (u.blockedOn !== null) return !1;
    for (var f = u.targetContainers; 0 < f.length; ) {
      var x = nr(u.domEventName, u.eventSystemFlags, f[0], u.nativeEvent);
      if (x === null) {
        x = u.nativeEvent;
        var _ = new x.constructor(x.type, x);
        sr = _, x.target.dispatchEvent(_), sr = null;
      } else return f = Gh(x), f !== null && Cn(f), u.blockedOn = x, !1;
      f.shift();
    }
    return !0;
  }
  function Kl(u, f, x) {
    ks(u) && x.delete(f);
  }
  function jc() {
    Hl = !1, ao !== null && ks(ao) && (ao = null), Nr !== null && ks(Nr) && (Nr = null), Ts !== null && ks(Ts) && (Ts = null), kr.forEach(Kl), $n.forEach(Kl);
  }
  function Wl(u, f) {
    u.blockedOn === f && (u.blockedOn = null, Hl || (Hl = !0, e.unstable_scheduleCallback(e.unstable_NormalPriority, jc)));
  }
  function qo(u) {
    function f(A) {
      return Wl(A, u);
    }
    if (0 < ai.length) {
      Wl(ai[0], u);
      for (var x = 1; x < ai.length; x++) {
        var _ = ai[x];
        _.blockedOn === u && (_.blockedOn = null);
      }
    }
    for (ao !== null && Wl(ao, u), Nr !== null && Wl(Nr, u), Ts !== null && Wl(Ts, u), kr.forEach(f), $n.forEach(f), x = 0; x < Is.length; x++) _ = Is[x], _.blockedOn === u && (_.blockedOn = null);
    for (; 0 < Is.length && (x = Is[0], x.blockedOn === null); ) Vl(x), x.blockedOn === null && Is.shift();
  }
  var Z = O.ReactCurrentBatchConfig, pe = !0;
  function ze(u, f, x, _) {
    var A = dn, j = Z.transition;
    Z.transition = null;
    try {
      dn = 1, Nn(u, f, x, _);
    } finally {
      dn = A, Z.transition = j;
    }
  }
  function lt(u, f, x, _) {
    var A = dn, j = Z.transition;
    Z.transition = null;
    try {
      dn = 4, Nn(u, f, x, _);
    } finally {
      dn = A, Z.transition = j;
    }
  }
  function Nn(u, f, x, _) {
    if (pe) {
      var A = nr(u, f, x, _);
      if (A === null) fv(u, f, _, Lt, x), Di(u, _);
      else if (ef(A, u, f, x, _)) _.stopPropagation();
      else if (Di(u, _), f & 4 && -1 < lo.indexOf(u)) {
        for (; A !== null; ) {
          var j = Gh(A);
          if (j !== null && Oc(j), j = nr(u, f, x, _), j === null && fv(u, f, _, Lt, x), j === A) break;
          A = j;
        }
        A !== null && _.stopPropagation();
      } else fv(u, f, _, null, x);
    }
  }
  var Lt = null;
  function nr(u, f, x, _) {
    if (Lt = null, u = bn(_), u = Gu(u), u !== null) if (f = rt(u), f === null) u = null;
    else if (x = f.tag, x === 13) {
      if (u = zt(f), u !== null) return u;
      u = null;
    } else if (x === 3) {
      if (f.stateNode.current.memoizedState.isDehydrated) return f.tag === 3 ? f.stateNode.containerInfo : null;
      u = null;
    } else f !== u && (u = null);
    return Lt = u, null;
  }
  function Rr(u) {
    switch (u) {
      case "cancel":
      case "click":
      case "close":
      case "contextmenu":
      case "copy":
      case "cut":
      case "auxclick":
      case "dblclick":
      case "dragend":
      case "dragstart":
      case "drop":
      case "focusin":
      case "focusout":
      case "input":
      case "invalid":
      case "keydown":
      case "keypress":
      case "keyup":
      case "mousedown":
      case "mouseup":
      case "paste":
      case "pause":
      case "play":
      case "pointercancel":
      case "pointerdown":
      case "pointerup":
      case "ratechange":
      case "reset":
      case "resize":
      case "seeked":
      case "submit":
      case "touchcancel":
      case "touchend":
      case "touchstart":
      case "volumechange":
      case "change":
      case "selectionchange":
      case "textInput":
      case "compositionstart":
      case "compositionend":
      case "compositionupdate":
      case "beforeblur":
      case "afterblur":
      case "beforeinput":
      case "blur":
      case "fullscreenchange":
      case "focus":
      case "hashchange":
      case "popstate":
      case "select":
      case "selectstart":
        return 1;
      case "drag":
      case "dragenter":
      case "dragexit":
      case "dragleave":
      case "dragover":
      case "mousemove":
      case "mouseout":
      case "mouseover":
      case "pointermove":
      case "pointerout":
      case "pointerover":
      case "scroll":
      case "toggle":
      case "touchmove":
      case "wheel":
      case "mouseenter":
      case "mouseleave":
      case "pointerenter":
      case "pointerleave":
        return 4;
      case "message":
        switch (yr()) {
          case Gt:
            return 1;
          case xo:
            return 4;
          case Aa:
          case Qd:
            return 16;
          case Ai:
            return 536870912;
          default:
            return 16;
        }
      default:
        return 16;
    }
  }
  var Zn = null, Qn = null, B = null;
  function ne() {
    if (B) return B;
    var u, f = Qn, x = f.length, _, A = "value" in Zn ? Zn.value : Zn.textContent, j = A.length;
    for (u = 0; u < x && f[u] === A[u]; u++) ;
    var K = x - u;
    for (_ = 1; _ <= K && f[x - _] === A[j - _]; _++) ;
    return B = A.slice(u, 1 < _ ? 1 - _ : void 0);
  }
  function ge(u) {
    var f = u.keyCode;
    return "charCode" in u ? (u = u.charCode, u === 0 && f === 13 && (u = 13)) : u = f, u === 10 && (u = 13), 32 <= u || u === 13 ? u : 0;
  }
  function Re() {
    return !0;
  }
  function Ve() {
    return !1;
  }
  function ot(u) {
    function f(x, _, A, j, K) {
      this._reactName = x, this._targetInst = A, this.type = _, this.nativeEvent = j, this.target = K, this.currentTarget = null;
      for (var ee in u) u.hasOwnProperty(ee) && (x = u[ee], this[ee] = x ? x(j) : j[ee]);
      return this.isDefaultPrevented = (j.defaultPrevented != null ? j.defaultPrevented : j.returnValue === !1) ? Re : Ve, this.isPropagationStopped = Ve, this;
    }
    return ke(f.prototype, { preventDefault: function() {
      this.defaultPrevented = !0;
      var x = this.nativeEvent;
      x && (x.preventDefault ? x.preventDefault() : typeof x.returnValue != "unknown" && (x.returnValue = !1), this.isDefaultPrevented = Re);
    }, stopPropagation: function() {
      var x = this.nativeEvent;
      x && (x.stopPropagation ? x.stopPropagation() : typeof x.cancelBubble != "unknown" && (x.cancelBubble = !0), this.isPropagationStopped = Re);
    }, persist: function() {
    }, isPersistent: Re }), f;
  }
  var Je = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(u) {
    return u.timeStamp || Date.now();
  }, defaultPrevented: 0, isTrusted: 0 }, kt = ot(Je), Qt = ke({}, Je, { view: 0, detail: 0 }), Mn = ot(Qt), Bn, lr, tn, pr = ke({}, Qt, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: ja, button: 0, buttons: 0, relatedTarget: function(u) {
    return u.relatedTarget === void 0 ? u.fromElement === u.srcElement ? u.toElement : u.fromElement : u.relatedTarget;
  }, movementX: function(u) {
    return "movementX" in u ? u.movementX : (u !== tn && (tn && u.type === "mousemove" ? (Bn = u.screenX - tn.screenX, lr = u.screenY - tn.screenY) : lr = Bn = 0, tn = u), Bn);
  }, movementY: function(u) {
    return "movementY" in u ? u.movementY : lr;
  } }), Qr = ot(pr), $u = ke({}, pr, { dataTransfer: 0 }), Ah = ot($u), Gl = ke({}, Qt, { relatedTarget: 0 }), Bu = ot(Gl), Dh = ke({}, Je, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), ev = ot(Dh), mg = ke({}, Je, { clipboardData: function(u) {
    return "clipboardData" in u ? u.clipboardData : window.clipboardData;
  } }), tv = ot(mg), Nw = ke({}, Je, { data: 0 }), yg = ot(Nw), Fw = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
  }, zw = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
  }, Uw = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
  function G_(u) {
    var f = this.nativeEvent;
    return f.getModifierState ? f.getModifierState(u) : (u = Uw[u]) ? !!f[u] : !1;
  }
  function ja() {
    return G_;
  }
  var q_ = ke({}, Qt, { key: function(u) {
    if (u.key) {
      var f = Fw[u.key] || u.key;
      if (f !== "Unidentified") return f;
    }
    return u.type === "keypress" ? (u = ge(u), u === 13 ? "Enter" : String.fromCharCode(u)) : u.type === "keydown" || u.type === "keyup" ? zw[u.keyCode] || "Unidentified" : "";
  }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: ja, charCode: function(u) {
    return u.type === "keypress" ? ge(u) : 0;
  }, keyCode: function(u) {
    return u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
  }, which: function(u) {
    return u.type === "keypress" ? ge(u) : u.type === "keydown" || u.type === "keyup" ? u.keyCode : 0;
  } }), nv = ot(q_), rv = ke({}, pr, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), vg = ot(rv), Y_ = ke({}, Qt, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: ja }), Sg = ot(Y_), $w = ke({}, Je, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Yo = ot($w), ql = ke({}, pr, {
    deltaX: function(u) {
      return "deltaX" in u ? u.deltaX : "wheelDeltaX" in u ? -u.wheelDeltaX : 0;
    },
    deltaY: function(u) {
      return "deltaY" in u ? u.deltaY : "wheelDeltaY" in u ? -u.wheelDeltaY : "wheelDelta" in u ? -u.wheelDelta : 0;
    },
    deltaZ: 0,
    deltaMode: 0
  }), li = ot(ql), Yl = [9, 13, 27, 32], Oh = c && "CompositionEvent" in window, Lc = null;
  c && "documentMode" in document && (Lc = document.documentMode);
  var X_ = c && "TextEvent" in window && !Lc, tf = c && (!Oh || Lc && 8 < Lc && 11 >= Lc), Bw = " ", Hw = !1;
  function xg(u, f) {
    switch (u) {
      case "keyup":
        return Yl.indexOf(f.keyCode) !== -1;
      case "keydown":
        return f.keyCode !== 229;
      case "keypress":
      case "mousedown":
      case "focusout":
        return !0;
      default:
        return !1;
    }
  }
  function Vw(u) {
    return u = u.detail, typeof u == "object" && "data" in u ? u.data : null;
  }
  var nf = !1;
  function Z_(u, f) {
    switch (u) {
      case "compositionend":
        return Vw(f);
      case "keypress":
        return f.which !== 32 ? null : (Hw = !0, Bw);
      case "textInput":
        return u = f.data, u === Bw && Hw ? null : u;
      default:
        return null;
    }
  }
  function Kw(u, f) {
    if (nf) return u === "compositionend" || !Oh && xg(u, f) ? (u = ne(), B = Qn = Zn = null, nf = !1, u) : null;
    switch (u) {
      case "paste":
        return null;
      case "keypress":
        if (!(f.ctrlKey || f.altKey || f.metaKey) || f.ctrlKey && f.altKey) {
          if (f.char && 1 < f.char.length) return f.char;
          if (f.which) return String.fromCharCode(f.which);
        }
        return null;
      case "compositionend":
        return tf && f.locale !== "ko" ? null : f.data;
      default:
        return null;
    }
  }
  var Q_ = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 };
  function Ww(u) {
    var f = u && u.nodeName && u.nodeName.toLowerCase();
    return f === "input" ? !!Q_[u.type] : f === "textarea";
  }
  function Gw(u, f, x, _) {
    ki(_), f = Vh(f, "onChange"), 0 < f.length && (x = new kt("onChange", "change", null, x, _), u.push({ event: x, listeners: f }));
  }
  var rf = null, dl = null;
  function iv(u) {
    Eg(u, 0);
  }
  function jh(u) {
    var f = Rt(u);
    if (mn(f)) return u;
  }
  function qw(u, f) {
    if (u === "change") return f;
  }
  var Yw = !1;
  if (c) {
    var ov;
    if (c) {
      var sv = "oninput" in document;
      if (!sv) {
        var Xw = document.createElement("div");
        Xw.setAttribute("oninput", "return;"), sv = typeof Xw.oninput == "function";
      }
      ov = sv;
    } else ov = !1;
    Yw = ov && (!document.documentMode || 9 < document.documentMode);
  }
  function Zw() {
    rf && (rf.detachEvent("onpropertychange", Qw), dl = rf = null);
  }
  function Qw(u) {
    if (u.propertyName === "value" && jh(dl)) {
      var f = [];
      Gw(f, dl, u, bn(u)), Ul(iv, f);
    }
  }
  function J_(u, f, x) {
    u === "focusin" ? (Zw(), rf = f, dl = x, rf.attachEvent("onpropertychange", Qw)) : u === "focusout" && Zw();
  }
  function eP(u) {
    if (u === "selectionchange" || u === "keyup" || u === "keydown") return jh(dl);
  }
  function Jw(u, f) {
    if (u === "click") return jh(f);
  }
  function tP(u, f) {
    if (u === "input" || u === "change") return jh(f);
  }
  function eb(u, f) {
    return u === f && (u !== 0 || 1 / u === 1 / f) || u !== u && f !== f;
  }
  var La = typeof Object.is == "function" ? Object.is : eb;
  function Lh(u, f) {
    if (La(u, f)) return !0;
    if (typeof u != "object" || u === null || typeof f != "object" || f === null) return !1;
    var x = Object.keys(u), _ = Object.keys(f);
    if (x.length !== _.length) return !1;
    for (_ = 0; _ < x.length; _++) {
      var A = x[_];
      if (!d.call(f, A) || !La(u[A], f[A])) return !1;
    }
    return !0;
  }
  function tb(u) {
    for (; u && u.firstChild; ) u = u.firstChild;
    return u;
  }
  function nb(u, f) {
    var x = tb(u);
    u = 0;
    for (var _; x; ) {
      if (x.nodeType === 3) {
        if (_ = u + x.textContent.length, u <= f && _ >= f) return { node: x, offset: f - u };
        u = _;
      }
      e: {
        for (; x; ) {
          if (x.nextSibling) {
            x = x.nextSibling;
            break e;
          }
          x = x.parentNode;
        }
        x = void 0;
      }
      x = tb(x);
    }
  }
  function wg(u, f) {
    return u && f ? u === f ? !0 : u && u.nodeType === 3 ? !1 : f && f.nodeType === 3 ? wg(u, f.parentNode) : "contains" in u ? u.contains(f) : u.compareDocumentPosition ? !!(u.compareDocumentPosition(f) & 16) : !1 : !1;
  }
  function Nc() {
    for (var u = window, f = Zt(); f instanceof u.HTMLIFrameElement; ) {
      try {
        var x = typeof f.contentWindow.location.href == "string";
      } catch {
        x = !1;
      }
      if (x) u = f.contentWindow;
      else break;
      f = Zt(u.document);
    }
    return f;
  }
  function of(u) {
    var f = u && u.nodeName && u.nodeName.toLowerCase();
    return f && (f === "input" && (u.type === "text" || u.type === "search" || u.type === "tel" || u.type === "url" || u.type === "password") || f === "textarea" || u.contentEditable === "true");
  }
  function rb(u) {
    var f = Nc(), x = u.focusedElem, _ = u.selectionRange;
    if (f !== x && x && x.ownerDocument && wg(x.ownerDocument.documentElement, x)) {
      if (_ !== null && of(x)) {
        if (f = _.start, u = _.end, u === void 0 && (u = f), "selectionStart" in x) x.selectionStart = f, x.selectionEnd = Math.min(u, x.value.length);
        else if (u = (f = x.ownerDocument || document) && f.defaultView || window, u.getSelection) {
          u = u.getSelection();
          var A = x.textContent.length, j = Math.min(_.start, A);
          _ = _.end === void 0 ? j : Math.min(_.end, A), !u.extend && j > _ && (A = _, _ = j, j = A), A = nb(x, j);
          var K = nb(
            x,
            _
          );
          A && K && (u.rangeCount !== 1 || u.anchorNode !== A.node || u.anchorOffset !== A.offset || u.focusNode !== K.node || u.focusOffset !== K.offset) && (f = f.createRange(), f.setStart(A.node, A.offset), u.removeAllRanges(), j > _ ? (u.addRange(f), u.extend(K.node, K.offset)) : (f.setEnd(K.node, K.offset), u.addRange(f)));
        }
      }
      for (f = [], u = x; u = u.parentNode; ) u.nodeType === 1 && f.push({ element: u, left: u.scrollLeft, top: u.scrollTop });
      for (typeof x.focus == "function" && x.focus(), x = 0; x < f.length; x++) u = f[x], u.element.scrollLeft = u.left, u.element.scrollTop = u.top;
    }
  }
  var sf = c && "documentMode" in document && 11 >= document.documentMode, af = null, av = null, Nh = null, lv = !1;
  function ib(u, f, x) {
    var _ = x.window === x ? x.document : x.nodeType === 9 ? x : x.ownerDocument;
    lv || af == null || af !== Zt(_) || (_ = af, "selectionStart" in _ && of(_) ? _ = { start: _.selectionStart, end: _.selectionEnd } : (_ = (_.ownerDocument && _.ownerDocument.defaultView || window).getSelection(), _ = { anchorNode: _.anchorNode, anchorOffset: _.anchorOffset, focusNode: _.focusNode, focusOffset: _.focusOffset }), Nh && Lh(Nh, _) || (Nh = _, _ = Vh(av, "onSelect"), 0 < _.length && (f = new kt("onSelect", "select", null, f, x), u.push({ event: f, listeners: _ }), f.target = af)));
  }
  function Fh(u, f) {
    var x = {};
    return x[u.toLowerCase()] = f.toLowerCase(), x["Webkit" + u] = "webkit" + f, x["Moz" + u] = "moz" + f, x;
  }
  var lf = { animationend: Fh("Animation", "AnimationEnd"), animationiteration: Fh("Animation", "AnimationIteration"), animationstart: Fh("Animation", "AnimationStart"), transitionend: Fh("Transition", "TransitionEnd") }, bg = {}, co = {};
  c && (co = document.createElement("div").style, "AnimationEvent" in window || (delete lf.animationend.animation, delete lf.animationiteration.animation, delete lf.animationstart.animation), "TransitionEvent" in window || delete lf.transitionend.transition);
  function zh(u) {
    if (bg[u]) return bg[u];
    if (!lf[u]) return u;
    var f = lf[u], x;
    for (x in f) if (f.hasOwnProperty(x) && x in co) return bg[u] = f[x];
    return u;
  }
  var ob = zh("animationend"), sb = zh("animationiteration"), ab = zh("animationstart"), lb = zh("transitionend"), cb = /* @__PURE__ */ new Map(), cv = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
  function fl(u, f) {
    cb.set(u, f), s(f, [u]);
  }
  for (var Hu = 0; Hu < cv.length; Hu++) {
    var uv = cv[Hu], Uh = uv.toLowerCase(), nP = uv[0].toUpperCase() + uv.slice(1);
    fl(Uh, "on" + nP);
  }
  fl(ob, "onAnimationEnd"), fl(sb, "onAnimationIteration"), fl(ab, "onAnimationStart"), fl("dblclick", "onDoubleClick"), fl("focusin", "onFocus"), fl("focusout", "onBlur"), fl(lb, "onTransitionEnd"), l("onMouseEnter", ["mouseout", "mouseover"]), l("onMouseLeave", ["mouseout", "mouseover"]), l("onPointerEnter", ["pointerout", "pointerover"]), l("onPointerLeave", ["pointerout", "pointerover"]), s("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")), s("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")), s("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), s("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")), s("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
  var $h = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), rP = new Set("cancel close invalid load scroll toggle".split(" ").concat($h));
  function Cg(u, f, x) {
    var _ = u.type || "unknown-event";
    u.currentTarget = x, tt(_, f, void 0, u), u.currentTarget = null;
  }
  function Eg(u, f) {
    f = (f & 4) !== 0;
    for (var x = 0; x < u.length; x++) {
      var _ = u[x], A = _.event;
      _ = _.listeners;
      e: {
        var j = void 0;
        if (f) for (var K = _.length - 1; 0 <= K; K--) {
          var ee = _[K], ae = ee.instance, Te = ee.currentTarget;
          if (ee = ee.listener, ae !== j && A.isPropagationStopped()) break e;
          Cg(A, ee, Te), j = ae;
        }
        else for (K = 0; K < _.length; K++) {
          if (ee = _[K], ae = ee.instance, Te = ee.currentTarget, ee = ee.listener, ae !== j && A.isPropagationStopped()) break e;
          Cg(A, ee, Te), j = ae;
        }
      }
    }
    if (Ri) throw u = Ma, Ri = !1, Ma = null, u;
  }
  function Jn(u, f) {
    var x = f[hv];
    x === void 0 && (x = f[hv] = /* @__PURE__ */ new Set());
    var _ = u + "__bubble";
    x.has(_) || (dv(f, u, 2, !1), x.add(_));
  }
  function Fc(u, f, x) {
    var _ = 0;
    f && (_ |= 4), dv(x, u, _, f);
  }
  var Bh = "_reactListening" + Math.random().toString(36).slice(2);
  function Hh(u) {
    if (!u[Bh]) {
      u[Bh] = !0, r.forEach(function(x) {
        x !== "selectionchange" && (rP.has(x) || Fc(x, !1, u), Fc(x, !0, u));
      });
      var f = u.nodeType === 9 ? u : u.ownerDocument;
      f === null || f[Bh] || (f[Bh] = !0, Fc("selectionchange", !1, f));
    }
  }
  function dv(u, f, x, _) {
    switch (Rr(f)) {
      case 1:
        var A = ze;
        break;
      case 4:
        A = lt;
        break;
      default:
        A = Nn;
    }
    x = A.bind(null, f, x, u), A = void 0, !vo || f !== "touchstart" && f !== "touchmove" && f !== "wheel" || (A = !0), _ ? A !== void 0 ? u.addEventListener(f, x, { capture: !0, passive: A }) : u.addEventListener(f, x, !0) : A !== void 0 ? u.addEventListener(f, x, { passive: A }) : u.addEventListener(f, x, !1);
  }
  function fv(u, f, x, _, A) {
    var j = _;
    if (!(f & 1) && !(f & 2) && _ !== null) e: for (; ; ) {
      if (_ === null) return;
      var K = _.tag;
      if (K === 3 || K === 4) {
        var ee = _.stateNode.containerInfo;
        if (ee === A || ee.nodeType === 8 && ee.parentNode === A) break;
        if (K === 4) for (K = _.return; K !== null; ) {
          var ae = K.tag;
          if ((ae === 3 || ae === 4) && (ae = K.stateNode.containerInfo, ae === A || ae.nodeType === 8 && ae.parentNode === A)) return;
          K = K.return;
        }
        for (; ee !== null; ) {
          if (K = Gu(ee), K === null) return;
          if (ae = K.tag, ae === 5 || ae === 6) {
            _ = j = K;
            continue e;
          }
          ee = ee.parentNode;
        }
      }
      _ = _.return;
    }
    Ul(function() {
      var Te = j, He = bn(x), Ke = [];
      e: {
        var Be = cb.get(u);
        if (Be !== void 0) {
          var dt = kt, St = u;
          switch (u) {
            case "keypress":
              if (ge(x) === 0) break e;
            case "keydown":
            case "keyup":
              dt = nv;
              break;
            case "focusin":
              St = "focus", dt = Bu;
              break;
            case "focusout":
              St = "blur", dt = Bu;
              break;
            case "beforeblur":
            case "afterblur":
              dt = Bu;
              break;
            case "click":
              if (x.button === 2) break e;
            case "auxclick":
            case "dblclick":
            case "mousedown":
            case "mousemove":
            case "mouseup":
            case "mouseout":
            case "mouseover":
            case "contextmenu":
              dt = Qr;
              break;
            case "drag":
            case "dragend":
            case "dragenter":
            case "dragexit":
            case "dragleave":
            case "dragover":
            case "dragstart":
            case "drop":
              dt = Ah;
              break;
            case "touchcancel":
            case "touchend":
            case "touchmove":
            case "touchstart":
              dt = Sg;
              break;
            case ob:
            case sb:
            case ab:
              dt = ev;
              break;
            case lb:
              dt = Yo;
              break;
            case "scroll":
              dt = Mn;
              break;
            case "wheel":
              dt = li;
              break;
            case "copy":
            case "cut":
            case "paste":
              dt = tv;
              break;
            case "gotpointercapture":
            case "lostpointercapture":
            case "pointercancel":
            case "pointerdown":
            case "pointermove":
            case "pointerout":
            case "pointerover":
            case "pointerup":
              dt = vg;
          }
          var Ct = (f & 4) !== 0, ni = !Ct && u === "scroll", ye = Ct ? Be !== null ? Be + "Capture" : null : Be;
          Ct = [];
          for (var de = Te, Ce; de !== null; ) {
            Ce = de;
            var Ye = Ce.stateNode;
            if (Ce.tag === 5 && Ye !== null && (Ce = Ye, ye !== null && (Ye = Xs(de, ye), Ye != null && Ct.push(cf(de, Ye, Ce)))), ni) break;
            de = de.return;
          }
          0 < Ct.length && (Be = new dt(Be, St, null, x, He), Ke.push({ event: Be, listeners: Ct }));
        }
      }
      if (!(f & 7)) {
        e: {
          if (Be = u === "mouseover" || u === "pointerover", dt = u === "mouseout" || u === "pointerout", Be && x !== sr && (St = x.relatedTarget || x.fromElement) && (Gu(St) || St[Xl])) break e;
          if ((dt || Be) && (Be = He.window === He ? He : (Be = He.ownerDocument) ? Be.defaultView || Be.parentWindow : window, dt ? (St = x.relatedTarget || x.toElement, dt = Te, St = St ? Gu(St) : null, St !== null && (ni = rt(St), St !== ni || St.tag !== 5 && St.tag !== 6) && (St = null)) : (dt = null, St = Te), dt !== St)) {
            if (Ct = Qr, Ye = "onMouseLeave", ye = "onMouseEnter", de = "mouse", (u === "pointerout" || u === "pointerover") && (Ct = vg, Ye = "onPointerLeave", ye = "onPointerEnter", de = "pointer"), ni = dt == null ? Be : Rt(dt), Ce = St == null ? Be : Rt(St), Be = new Ct(Ye, de + "leave", dt, x, He), Be.target = ni, Be.relatedTarget = Ce, Ye = null, Gu(He) === Te && (Ct = new Ct(ye, de + "enter", St, x, He), Ct.target = Ce, Ct.relatedTarget = ni, Ye = Ct), ni = Ye, dt && St) t: {
              for (Ct = dt, ye = St, de = 0, Ce = Ct; Ce; Ce = Vu(Ce)) de++;
              for (Ce = 0, Ye = ye; Ye; Ye = Vu(Ye)) Ce++;
              for (; 0 < de - Ce; ) Ct = Vu(Ct), de--;
              for (; 0 < Ce - de; ) ye = Vu(ye), Ce--;
              for (; de--; ) {
                if (Ct === ye || ye !== null && Ct === ye.alternate) break t;
                Ct = Vu(Ct), ye = Vu(ye);
              }
              Ct = null;
            }
            else Ct = null;
            dt !== null && _g(Ke, Be, dt, Ct, !1), St !== null && ni !== null && _g(Ke, ni, St, Ct, !0);
          }
        }
        e: {
          if (Be = Te ? Rt(Te) : window, dt = Be.nodeName && Be.nodeName.toLowerCase(), dt === "select" || dt === "input" && Be.type === "file") var _t = qw;
          else if (Ww(Be)) if (Yw) _t = tP;
          else {
            _t = eP;
            var xt = J_;
          }
          else (dt = Be.nodeName) && dt.toLowerCase() === "input" && (Be.type === "checkbox" || Be.type === "radio") && (_t = Jw);
          if (_t && (_t = _t(u, Te))) {
            Gw(Ke, _t, x, He);
            break e;
          }
          xt && xt(u, Be, Te), u === "focusout" && (xt = Be._wrapperState) && xt.controlled && Be.type === "number" && Hr(Be, "number", Be.value);
        }
        switch (xt = Te ? Rt(Te) : window, u) {
          case "focusin":
            (Ww(xt) || xt.contentEditable === "true") && (af = xt, av = Te, Nh = null);
            break;
          case "focusout":
            Nh = av = af = null;
            break;
          case "mousedown":
            lv = !0;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            lv = !1, ib(Ke, x, He);
            break;
          case "selectionchange":
            if (sf) break;
          case "keydown":
          case "keyup":
            ib(Ke, x, He);
        }
        var At;
        if (Oh) e: {
          switch (u) {
            case "compositionstart":
              var Kt = "onCompositionStart";
              break e;
            case "compositionend":
              Kt = "onCompositionEnd";
              break e;
            case "compositionupdate":
              Kt = "onCompositionUpdate";
              break e;
          }
          Kt = void 0;
        }
        else nf ? xg(u, x) && (Kt = "onCompositionEnd") : u === "keydown" && x.keyCode === 229 && (Kt = "onCompositionStart");
        Kt && (tf && x.locale !== "ko" && (nf || Kt !== "onCompositionStart" ? Kt === "onCompositionEnd" && nf && (At = ne()) : (Zn = He, Qn = "value" in Zn ? Zn.value : Zn.textContent, nf = !0)), xt = Vh(Te, Kt), 0 < xt.length && (Kt = new yg(Kt, u, null, x, He), Ke.push({ event: Kt, listeners: xt }), At ? Kt.data = At : (At = Vw(x), At !== null && (Kt.data = At)))), (At = X_ ? Z_(u, x) : Kw(u, x)) && (Te = Vh(Te, "onBeforeInput"), 0 < Te.length && (He = new yg("onBeforeInput", "beforeinput", null, x, He), Ke.push({ event: He, listeners: Te }), He.data = At));
      }
      Eg(Ke, f);
    });
  }
  function cf(u, f, x) {
    return { instance: u, listener: f, currentTarget: x };
  }
  function Vh(u, f) {
    for (var x = f + "Capture", _ = []; u !== null; ) {
      var A = u, j = A.stateNode;
      A.tag === 5 && j !== null && (A = j, j = Xs(u, x), j != null && _.unshift(cf(u, j, A)), j = Xs(u, f), j != null && _.push(cf(u, j, A))), u = u.return;
    }
    return _;
  }
  function Vu(u) {
    if (u === null) return null;
    do
      u = u.return;
    while (u && u.tag !== 5);
    return u || null;
  }
  function _g(u, f, x, _, A) {
    for (var j = f._reactName, K = []; x !== null && x !== _; ) {
      var ee = x, ae = ee.alternate, Te = ee.stateNode;
      if (ae !== null && ae === _) break;
      ee.tag === 5 && Te !== null && (ee = Te, A ? (ae = Xs(x, j), ae != null && K.unshift(cf(x, ae, ee))) : A || (ae = Xs(x, j), ae != null && K.push(cf(x, ae, ee)))), x = x.return;
    }
    K.length !== 0 && u.push({ event: f, listeners: K });
  }
  var iP = /\r\n?/g, ub = /\u0000|\uFFFD/g;
  function db(u) {
    return (typeof u == "string" ? u : "" + u).replace(iP, `
`).replace(ub, "");
  }
  function Pg(u, f, x) {
    if (f = db(f), db(u) !== f && x) throw Error(t(425));
  }
  function Tg() {
  }
  var Ku = null, Kh = null;
  function Wu(u, f) {
    return u === "textarea" || u === "noscript" || typeof f.children == "string" || typeof f.children == "number" || typeof f.dangerouslySetInnerHTML == "object" && f.dangerouslySetInnerHTML !== null && f.dangerouslySetInnerHTML.__html != null;
  }
  var Ig = typeof setTimeout == "function" ? setTimeout : void 0, fb = typeof clearTimeout == "function" ? clearTimeout : void 0, kg = typeof Promise == "function" ? Promise : void 0, oP = typeof queueMicrotask == "function" ? queueMicrotask : typeof kg < "u" ? function(u) {
    return kg.resolve(null).then(u).catch(uf);
  } : Ig;
  function uf(u) {
    setTimeout(function() {
      throw u;
    });
  }
  function df(u, f) {
    var x = f, _ = 0;
    do {
      var A = x.nextSibling;
      if (u.removeChild(x), A && A.nodeType === 8) if (x = A.data, x === "/$") {
        if (_ === 0) {
          u.removeChild(A), qo(f);
          return;
        }
        _--;
      } else x !== "$" && x !== "$?" && x !== "$!" || _++;
      x = A;
    } while (x);
    qo(f);
  }
  function Na(u) {
    for (; u != null; u = u.nextSibling) {
      var f = u.nodeType;
      if (f === 1 || f === 3) break;
      if (f === 8) {
        if (f = u.data, f === "$" || f === "$!" || f === "$?") break;
        if (f === "/$") return null;
      }
    }
    return u;
  }
  function Rg(u) {
    u = u.previousSibling;
    for (var f = 0; u; ) {
      if (u.nodeType === 8) {
        var x = u.data;
        if (x === "$" || x === "$!" || x === "$?") {
          if (f === 0) return u;
          f--;
        } else x === "/$" && f++;
      }
      u = u.previousSibling;
    }
    return null;
  }
  var ff = Math.random().toString(36).slice(2), Js = "__reactFiber$" + ff, Wh = "__reactProps$" + ff, Xl = "__reactContainer$" + ff, hv = "__reactEvents$" + ff, pv = "__reactListeners$" + ff, hf = "__reactHandles$" + ff;
  function Gu(u) {
    var f = u[Js];
    if (f) return f;
    for (var x = u.parentNode; x; ) {
      if (f = x[Xl] || x[Js]) {
        if (x = f.alternate, f.child !== null || x !== null && x.child !== null) for (u = Rg(u); u !== null; ) {
          if (x = u[Js]) return x;
          u = Rg(u);
        }
        return f;
      }
      u = x, x = u.parentNode;
    }
    return null;
  }
  function Gh(u) {
    return u = u[Js] || u[Xl], !u || u.tag !== 5 && u.tag !== 6 && u.tag !== 13 && u.tag !== 3 ? null : u;
  }
  function Rt(u) {
    if (u.tag === 5 || u.tag === 6) return u.stateNode;
    throw Error(t(33));
  }
  function Zl(u) {
    return u[Wh] || null;
  }
  var ci = [], Sn = -1;
  function Xo(u) {
    return { current: u };
  }
  function cr(u) {
    0 > Sn || (u.current = ci[Sn], ci[Sn] = null, Sn--);
  }
  function gr(u, f) {
    Sn++, ci[Sn] = u.current, u.current = f;
  }
  var hn = {}, Wr = Xo(hn), ui = Xo(!1), ea = hn;
  function Rs(u, f) {
    var x = u.type.contextTypes;
    if (!x) return hn;
    var _ = u.stateNode;
    if (_ && _.__reactInternalMemoizedUnmaskedChildContext === f) return _.__reactInternalMemoizedMaskedChildContext;
    var A = {}, j;
    for (j in x) A[j] = f[j];
    return _ && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = f, u.__reactInternalMemoizedMaskedChildContext = A), A;
  }
  function di(u) {
    return u = u.childContextTypes, u != null;
  }
  function hl() {
    cr(ui), cr(Wr);
  }
  function Mg(u, f, x) {
    if (Wr.current !== hn) throw Error(t(168));
    gr(Wr, f), gr(ui, x);
  }
  function hb(u, f, x) {
    var _ = u.stateNode;
    if (f = f.childContextTypes, typeof _.getChildContext != "function") return x;
    _ = _.getChildContext();
    for (var A in _) if (!(A in f)) throw Error(t(108, it(u) || "Unknown", A));
    return ke({}, x, _);
  }
  function qu(u) {
    return u = (u = u.stateNode) && u.__reactInternalMemoizedMergedChildContext || hn, ea = Wr.current, gr(Wr, u), gr(ui, ui.current), !0;
  }
  function ta(u, f, x) {
    var _ = u.stateNode;
    if (!_) throw Error(t(169));
    x ? (u = hb(u, f, ea), _.__reactInternalMemoizedMergedChildContext = u, cr(ui), cr(Wr), gr(Wr, u)) : cr(ui), gr(ui, x);
  }
  var Fa = null, qh = !1, Yh = !1;
  function zc(u) {
    Fa === null ? Fa = [u] : Fa.push(u);
  }
  function gv(u) {
    qh = !0, zc(u);
  }
  function wo() {
    if (!Yh && Fa !== null) {
      Yh = !0;
      var u = 0, f = dn;
      try {
        var x = Fa;
        for (dn = 1; u < x.length; u++) {
          var _ = x[u];
          do
            _ = _(!0);
          while (_ !== null);
        }
        Fa = null, qh = !1;
      } catch (A) {
        throw Fa !== null && (Fa = Fa.slice(u + 1)), ar(Gt, wo), A;
      } finally {
        dn = f, Yh = !1;
      }
    }
    return null;
  }
  var Uc = [], $c = 0, pf = null, Bc = 0, Vi = [], fi = 0, Yu = null, bo = 1, pl = "";
  function Hc(u, f) {
    Uc[$c++] = Bc, Uc[$c++] = pf, pf = u, Bc = f;
  }
  function pb(u, f, x) {
    Vi[fi++] = bo, Vi[fi++] = pl, Vi[fi++] = Yu, Yu = u;
    var _ = bo;
    u = pl;
    var A = 32 - Bi(_) - 1;
    _ &= ~(1 << A), x += 1;
    var j = 32 - Bi(f) + A;
    if (30 < j) {
      var K = A - A % 5;
      j = (_ & (1 << K) - 1).toString(32), _ >>= K, A -= K, bo = 1 << 32 - Bi(f) + A | x << A | _, pl = j + u;
    } else bo = 1 << j | x << A | _, pl = u;
  }
  function mv(u) {
    u.return !== null && (Hc(u, 1), pb(u, 1, 0));
  }
  function Ag(u) {
    for (; u === pf; ) pf = Uc[--$c], Uc[$c] = null, Bc = Uc[--$c], Uc[$c] = null;
    for (; u === Yu; ) Yu = Vi[--fi], Vi[fi] = null, pl = Vi[--fi], Vi[fi] = null, bo = Vi[--fi], Vi[fi] = null;
  }
  var Zo = null, Qo = null, br = !1, za = null;
  function yv(u, f) {
    var x = sa(5, null, null, 0);
    x.elementType = "DELETED", x.stateNode = f, x.return = u, f = u.deletions, f === null ? (u.deletions = [x], u.flags |= 16) : f.push(x);
  }
  function vv(u, f) {
    switch (u.tag) {
      case 5:
        var x = u.type;
        return f = f.nodeType !== 1 || x.toLowerCase() !== f.nodeName.toLowerCase() ? null : f, f !== null ? (u.stateNode = f, Zo = u, Qo = Na(f.firstChild), !0) : !1;
      case 6:
        return f = u.pendingProps === "" || f.nodeType !== 3 ? null : f, f !== null ? (u.stateNode = f, Zo = u, Qo = null, !0) : !1;
      case 13:
        return f = f.nodeType !== 8 ? null : f, f !== null ? (x = Yu !== null ? { id: bo, overflow: pl } : null, u.memoizedState = { dehydrated: f, treeContext: x, retryLane: 1073741824 }, x = sa(18, null, null, 0), x.stateNode = f, x.return = u, u.child = x, Zo = u, Qo = null, !0) : !1;
      default:
        return !1;
    }
  }
  function Sv(u) {
    return (u.mode & 1) !== 0 && (u.flags & 128) === 0;
  }
  function xv(u) {
    if (br) {
      var f = Qo;
      if (f) {
        var x = f;
        if (!vv(u, f)) {
          if (Sv(u)) throw Error(t(418));
          f = Na(x.nextSibling);
          var _ = Zo;
          f && vv(u, f) ? yv(_, x) : (u.flags = u.flags & -4097 | 2, br = !1, Zo = u);
        }
      } else {
        if (Sv(u)) throw Error(t(418));
        u.flags = u.flags & -4097 | 2, br = !1, Zo = u;
      }
    }
  }
  function gb(u) {
    for (u = u.return; u !== null && u.tag !== 5 && u.tag !== 3 && u.tag !== 13; ) u = u.return;
    Zo = u;
  }
  function Jr(u) {
    if (u !== Zo) return !1;
    if (!br) return gb(u), br = !0, !1;
    var f;
    if ((f = u.tag !== 3) && !(f = u.tag !== 5) && (f = u.type, f = f !== "head" && f !== "body" && !Wu(u.type, u.memoizedProps)), f && (f = Qo)) {
      if (Sv(u)) throw mb(), Error(t(418));
      for (; f; ) yv(u, f), f = Na(f.nextSibling);
    }
    if (gb(u), u.tag === 13) {
      if (u = u.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(t(317));
      e: {
        for (u = u.nextSibling, f = 0; u; ) {
          if (u.nodeType === 8) {
            var x = u.data;
            if (x === "/$") {
              if (f === 0) {
                Qo = Na(u.nextSibling);
                break e;
              }
              f--;
            } else x !== "$" && x !== "$!" && x !== "$?" || f++;
          }
          u = u.nextSibling;
        }
        Qo = null;
      }
    } else Qo = Zo ? Na(u.stateNode.nextSibling) : null;
    return !0;
  }
  function mb() {
    for (var u = Qo; u; ) u = Na(u.nextSibling);
  }
  function Ql() {
    Qo = Zo = null, br = !1;
  }
  function Xh(u) {
    za === null ? za = [u] : za.push(u);
  }
  var Xu = O.ReactCurrentBatchConfig;
  function Zh(u, f, x) {
    if (u = x.ref, u !== null && typeof u != "function" && typeof u != "object") {
      if (x._owner) {
        if (x = x._owner, x) {
          if (x.tag !== 1) throw Error(t(309));
          var _ = x.stateNode;
        }
        if (!_) throw Error(t(147, u));
        var A = _, j = "" + u;
        return f !== null && f.ref !== null && typeof f.ref == "function" && f.ref._stringRef === j ? f.ref : (f = function(K) {
          var ee = A.refs;
          K === null ? delete ee[j] : ee[j] = K;
        }, f._stringRef = j, f);
      }
      if (typeof u != "string") throw Error(t(284));
      if (!x._owner) throw Error(t(290, u));
    }
    return u;
  }
  function gf(u, f) {
    throw u = Object.prototype.toString.call(f), Error(t(31, u === "[object Object]" ? "object with keys {" + Object.keys(f).join(", ") + "}" : u));
  }
  function yb(u) {
    var f = u._init;
    return f(u._payload);
  }
  function vb(u) {
    function f(ye, de) {
      if (u) {
        var Ce = ye.deletions;
        Ce === null ? (ye.deletions = [de], ye.flags |= 16) : Ce.push(de);
      }
    }
    function x(ye, de) {
      if (!u) return null;
      for (; de !== null; ) f(ye, de), de = de.sibling;
      return null;
    }
    function _(ye, de) {
      for (ye = /* @__PURE__ */ new Map(); de !== null; ) de.key !== null ? ye.set(de.key, de) : ye.set(de.index, de), de = de.sibling;
      return ye;
    }
    function A(ye, de) {
      return ye = eu(ye, de), ye.index = 0, ye.sibling = null, ye;
    }
    function j(ye, de, Ce) {
      return ye.index = Ce, u ? (Ce = ye.alternate, Ce !== null ? (Ce = Ce.index, Ce < de ? (ye.flags |= 2, de) : Ce) : (ye.flags |= 2, de)) : (ye.flags |= 1048576, de);
    }
    function K(ye) {
      return u && ye.alternate === null && (ye.flags |= 2), ye;
    }
    function ee(ye, de, Ce, Ye) {
      return de === null || de.tag !== 6 ? (de = hd(Ce, ye.mode, Ye), de.return = ye, de) : (de = A(de, Ce), de.return = ye, de);
    }
    function ae(ye, de, Ce, Ye) {
      var _t = Ce.type;
      return _t === H ? He(ye, de, Ce.props.children, Ye, Ce.key) : de !== null && (de.elementType === _t || typeof _t == "object" && _t !== null && _t.$$typeof === le && yb(_t) === de.type) ? (Ye = A(de, Ce.props), Ye.ref = Zh(ye, de, Ce), Ye.return = ye, Ye) : (Ye = ym(Ce.type, Ce.key, Ce.props, null, ye.mode, Ye), Ye.ref = Zh(ye, de, Ce), Ye.return = ye, Ye);
    }
    function Te(ye, de, Ce, Ye) {
      return de === null || de.tag !== 4 || de.stateNode.containerInfo !== Ce.containerInfo || de.stateNode.implementation !== Ce.implementation ? (de = Zv(Ce, ye.mode, Ye), de.return = ye, de) : (de = A(de, Ce.children || []), de.return = ye, de);
    }
    function He(ye, de, Ce, Ye, _t) {
      return de === null || de.tag !== 7 ? (de = tu(Ce, ye.mode, Ye, _t), de.return = ye, de) : (de = A(de, Ce), de.return = ye, de);
    }
    function Ke(ye, de, Ce) {
      if (typeof de == "string" && de !== "" || typeof de == "number") return de = hd("" + de, ye.mode, Ce), de.return = ye, de;
      if (typeof de == "object" && de !== null) {
        switch (de.$$typeof) {
          case z:
            return Ce = ym(de.type, de.key, de.props, null, ye.mode, Ce), Ce.ref = Zh(ye, null, de), Ce.return = ye, Ce;
          case F:
            return de = Zv(de, ye.mode, Ce), de.return = ye, de;
          case le:
            var Ye = de._init;
            return Ke(ye, Ye(de._payload), Ce);
        }
        if (Pr(de) || he(de)) return de = tu(de, ye.mode, Ce, null), de.return = ye, de;
        gf(ye, de);
      }
      return null;
    }
    function Be(ye, de, Ce, Ye) {
      var _t = de !== null ? de.key : null;
      if (typeof Ce == "string" && Ce !== "" || typeof Ce == "number") return _t !== null ? null : ee(ye, de, "" + Ce, Ye);
      if (typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case z:
            return Ce.key === _t ? ae(ye, de, Ce, Ye) : null;
          case F:
            return Ce.key === _t ? Te(ye, de, Ce, Ye) : null;
          case le:
            return _t = Ce._init, Be(
              ye,
              de,
              _t(Ce._payload),
              Ye
            );
        }
        if (Pr(Ce) || he(Ce)) return _t !== null ? null : He(ye, de, Ce, Ye, null);
        gf(ye, Ce);
      }
      return null;
    }
    function dt(ye, de, Ce, Ye, _t) {
      if (typeof Ye == "string" && Ye !== "" || typeof Ye == "number") return ye = ye.get(Ce) || null, ee(de, ye, "" + Ye, _t);
      if (typeof Ye == "object" && Ye !== null) {
        switch (Ye.$$typeof) {
          case z:
            return ye = ye.get(Ye.key === null ? Ce : Ye.key) || null, ae(de, ye, Ye, _t);
          case F:
            return ye = ye.get(Ye.key === null ? Ce : Ye.key) || null, Te(de, ye, Ye, _t);
          case le:
            var xt = Ye._init;
            return dt(ye, de, Ce, xt(Ye._payload), _t);
        }
        if (Pr(Ye) || he(Ye)) return ye = ye.get(Ce) || null, He(de, ye, Ye, _t, null);
        gf(de, Ye);
      }
      return null;
    }
    function St(ye, de, Ce, Ye) {
      for (var _t = null, xt = null, At = de, Kt = de = 0, zi = null; At !== null && Kt < Ce.length; Kt++) {
        At.index > Kt ? (zi = At, At = null) : zi = At.sibling;
        var Hn = Be(ye, At, Ce[Kt], Ye);
        if (Hn === null) {
          At === null && (At = zi);
          break;
        }
        u && At && Hn.alternate === null && f(ye, At), de = j(Hn, de, Kt), xt === null ? _t = Hn : xt.sibling = Hn, xt = Hn, At = zi;
      }
      if (Kt === Ce.length) return x(ye, At), br && Hc(ye, Kt), _t;
      if (At === null) {
        for (; Kt < Ce.length; Kt++) At = Ke(ye, Ce[Kt], Ye), At !== null && (de = j(At, de, Kt), xt === null ? _t = At : xt.sibling = At, xt = At);
        return br && Hc(ye, Kt), _t;
      }
      for (At = _(ye, At); Kt < Ce.length; Kt++) zi = dt(At, ye, Kt, Ce[Kt], Ye), zi !== null && (u && zi.alternate !== null && At.delete(zi.key === null ? Kt : zi.key), de = j(zi, de, Kt), xt === null ? _t = zi : xt.sibling = zi, xt = zi);
      return u && At.forEach(function(nu) {
        return f(ye, nu);
      }), br && Hc(ye, Kt), _t;
    }
    function Ct(ye, de, Ce, Ye) {
      var _t = he(Ce);
      if (typeof _t != "function") throw Error(t(150));
      if (Ce = _t.call(Ce), Ce == null) throw Error(t(151));
      for (var xt = _t = null, At = de, Kt = de = 0, zi = null, Hn = Ce.next(); At !== null && !Hn.done; Kt++, Hn = Ce.next()) {
        At.index > Kt ? (zi = At, At = null) : zi = At.sibling;
        var nu = Be(ye, At, Hn.value, Ye);
        if (nu === null) {
          At === null && (At = zi);
          break;
        }
        u && At && nu.alternate === null && f(ye, At), de = j(nu, de, Kt), xt === null ? _t = nu : xt.sibling = nu, xt = nu, At = zi;
      }
      if (Hn.done) return x(
        ye,
        At
      ), br && Hc(ye, Kt), _t;
      if (At === null) {
        for (; !Hn.done; Kt++, Hn = Ce.next()) Hn = Ke(ye, Hn.value, Ye), Hn !== null && (de = j(Hn, de, Kt), xt === null ? _t = Hn : xt.sibling = Hn, xt = Hn);
        return br && Hc(ye, Kt), _t;
      }
      for (At = _(ye, At); !Hn.done; Kt++, Hn = Ce.next()) Hn = dt(At, ye, Kt, Hn.value, Ye), Hn !== null && (u && Hn.alternate !== null && At.delete(Hn.key === null ? Kt : Hn.key), de = j(Hn, de, Kt), xt === null ? _t = Hn : xt.sibling = Hn, xt = Hn);
      return u && At.forEach(function(xP) {
        return f(ye, xP);
      }), br && Hc(ye, Kt), _t;
    }
    function ni(ye, de, Ce, Ye) {
      if (typeof Ce == "object" && Ce !== null && Ce.type === H && Ce.key === null && (Ce = Ce.props.children), typeof Ce == "object" && Ce !== null) {
        switch (Ce.$$typeof) {
          case z:
            e: {
              for (var _t = Ce.key, xt = de; xt !== null; ) {
                if (xt.key === _t) {
                  if (_t = Ce.type, _t === H) {
                    if (xt.tag === 7) {
                      x(ye, xt.sibling), de = A(xt, Ce.props.children), de.return = ye, ye = de;
                      break e;
                    }
                  } else if (xt.elementType === _t || typeof _t == "object" && _t !== null && _t.$$typeof === le && yb(_t) === xt.type) {
                    x(ye, xt.sibling), de = A(xt, Ce.props), de.ref = Zh(ye, xt, Ce), de.return = ye, ye = de;
                    break e;
                  }
                  x(ye, xt);
                  break;
                } else f(ye, xt);
                xt = xt.sibling;
              }
              Ce.type === H ? (de = tu(Ce.props.children, ye.mode, Ye, Ce.key), de.return = ye, ye = de) : (Ye = ym(Ce.type, Ce.key, Ce.props, null, ye.mode, Ye), Ye.ref = Zh(ye, de, Ce), Ye.return = ye, ye = Ye);
            }
            return K(ye);
          case F:
            e: {
              for (xt = Ce.key; de !== null; ) {
                if (de.key === xt) if (de.tag === 4 && de.stateNode.containerInfo === Ce.containerInfo && de.stateNode.implementation === Ce.implementation) {
                  x(ye, de.sibling), de = A(de, Ce.children || []), de.return = ye, ye = de;
                  break e;
                } else {
                  x(ye, de);
                  break;
                }
                else f(ye, de);
                de = de.sibling;
              }
              de = Zv(Ce, ye.mode, Ye), de.return = ye, ye = de;
            }
            return K(ye);
          case le:
            return xt = Ce._init, ni(ye, de, xt(Ce._payload), Ye);
        }
        if (Pr(Ce)) return St(ye, de, Ce, Ye);
        if (he(Ce)) return Ct(ye, de, Ce, Ye);
        gf(ye, Ce);
      }
      return typeof Ce == "string" && Ce !== "" || typeof Ce == "number" ? (Ce = "" + Ce, de !== null && de.tag === 6 ? (x(ye, de.sibling), de = A(de, Ce), de.return = ye, ye = de) : (x(ye, de), de = hd(Ce, ye.mode, Ye), de.return = ye, ye = de), K(ye)) : x(ye, de);
    }
    return ni;
  }
  var Ua = vb(!0), Ki = vb(!1), nt = Xo(null), Ms = null, uo = null, wv = null;
  function bv() {
    wv = uo = Ms = null;
  }
  function Cv(u) {
    var f = nt.current;
    cr(nt), u._currentValue = f;
  }
  function Ev(u, f, x) {
    for (; u !== null; ) {
      var _ = u.alternate;
      if ((u.childLanes & f) !== f ? (u.childLanes |= f, _ !== null && (_.childLanes |= f)) : _ !== null && (_.childLanes & f) !== f && (_.childLanes |= f), u === x) break;
      u = u.return;
    }
  }
  function mf(u, f) {
    Ms = u, wv = uo = null, u = u.dependencies, u !== null && u.firstContext !== null && (u.lanes & f && (Ni = !0), u.firstContext = null);
  }
  function rr(u) {
    var f = u._currentValue;
    if (wv !== u) if (u = { context: u, memoizedValue: f, next: null }, uo === null) {
      if (Ms === null) throw Error(t(308));
      uo = u, Ms.dependencies = { lanes: 0, firstContext: u };
    } else uo = uo.next = u;
    return f;
  }
  var Zu = null;
  function _v(u) {
    Zu === null ? Zu = [u] : Zu.push(u);
  }
  function Sb(u, f, x, _) {
    var A = f.interleaved;
    return A === null ? (x.next = x, _v(f)) : (x.next = A.next, A.next = x), f.interleaved = x, gl(u, _);
  }
  function gl(u, f) {
    u.lanes |= f;
    var x = u.alternate;
    for (x !== null && (x.lanes |= f), x = u, u = u.return; u !== null; ) u.childLanes |= f, x = u.alternate, x !== null && (x.childLanes |= f), x = u, u = u.return;
    return x.tag === 3 ? x.stateNode : null;
  }
  var na = !1;
  function Vc(u) {
    u.updateQueue = { baseState: u.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
  }
  function xb(u, f) {
    u = u.updateQueue, f.updateQueue === u && (f.updateQueue = { baseState: u.baseState, firstBaseUpdate: u.firstBaseUpdate, lastBaseUpdate: u.lastBaseUpdate, shared: u.shared, effects: u.effects });
  }
  function Jl(u, f) {
    return { eventTime: u, lane: f, tag: 0, payload: null, callback: null, next: null };
  }
  function Kc(u, f, x) {
    var _ = u.updateQueue;
    if (_ === null) return null;
    if (_ = _.shared, xn & 2) {
      var A = _.pending;
      return A === null ? f.next = f : (f.next = A.next, A.next = f), _.pending = f, gl(u, x);
    }
    return A = _.interleaved, A === null ? (f.next = f, _v(_)) : (f.next = A.next, A.next = f), _.interleaved = f, gl(u, x);
  }
  function Dg(u, f, x) {
    if (f = f.updateQueue, f !== null && (f = f.shared, (x & 4194240) !== 0)) {
      var _ = f.lanes;
      _ &= u.pendingLanes, x |= _, f.lanes = x, Dc(u, x);
    }
  }
  function wb(u, f) {
    var x = u.updateQueue, _ = u.alternate;
    if (_ !== null && (_ = _.updateQueue, x === _)) {
      var A = null, j = null;
      if (x = x.firstBaseUpdate, x !== null) {
        do {
          var K = { eventTime: x.eventTime, lane: x.lane, tag: x.tag, payload: x.payload, callback: x.callback, next: null };
          j === null ? A = j = K : j = j.next = K, x = x.next;
        } while (x !== null);
        j === null ? A = j = f : j = j.next = f;
      } else A = j = f;
      x = { baseState: _.baseState, firstBaseUpdate: A, lastBaseUpdate: j, shared: _.shared, effects: _.effects }, u.updateQueue = x;
      return;
    }
    u = x.lastBaseUpdate, u === null ? x.firstBaseUpdate = f : u.next = f, x.lastBaseUpdate = f;
  }
  function Og(u, f, x, _) {
    var A = u.updateQueue;
    na = !1;
    var j = A.firstBaseUpdate, K = A.lastBaseUpdate, ee = A.shared.pending;
    if (ee !== null) {
      A.shared.pending = null;
      var ae = ee, Te = ae.next;
      ae.next = null, K === null ? j = Te : K.next = Te, K = ae;
      var He = u.alternate;
      He !== null && (He = He.updateQueue, ee = He.lastBaseUpdate, ee !== K && (ee === null ? He.firstBaseUpdate = Te : ee.next = Te, He.lastBaseUpdate = ae));
    }
    if (j !== null) {
      var Ke = A.baseState;
      K = 0, He = Te = ae = null, ee = j;
      do {
        var Be = ee.lane, dt = ee.eventTime;
        if ((_ & Be) === Be) {
          He !== null && (He = He.next = {
            eventTime: dt,
            lane: 0,
            tag: ee.tag,
            payload: ee.payload,
            callback: ee.callback,
            next: null
          });
          e: {
            var St = u, Ct = ee;
            switch (Be = f, dt = x, Ct.tag) {
              case 1:
                if (St = Ct.payload, typeof St == "function") {
                  Ke = St.call(dt, Ke, Be);
                  break e;
                }
                Ke = St;
                break e;
              case 3:
                St.flags = St.flags & -65537 | 128;
              case 0:
                if (St = Ct.payload, Be = typeof St == "function" ? St.call(dt, Ke, Be) : St, Be == null) break e;
                Ke = ke({}, Ke, Be);
                break e;
              case 2:
                na = !0;
            }
          }
          ee.callback !== null && ee.lane !== 0 && (u.flags |= 64, Be = A.effects, Be === null ? A.effects = [ee] : Be.push(ee));
        } else dt = { eventTime: dt, lane: Be, tag: ee.tag, payload: ee.payload, callback: ee.callback, next: null }, He === null ? (Te = He = dt, ae = Ke) : He = He.next = dt, K |= Be;
        if (ee = ee.next, ee === null) {
          if (ee = A.shared.pending, ee === null) break;
          Be = ee, ee = Be.next, Be.next = null, A.lastBaseUpdate = Be, A.shared.pending = null;
        }
      } while (!0);
      if (He === null && (ae = Ke), A.baseState = ae, A.firstBaseUpdate = Te, A.lastBaseUpdate = He, f = A.shared.interleaved, f !== null) {
        A = f;
        do
          K |= A.lane, A = A.next;
        while (A !== f);
      } else j === null && (A.shared.lanes = 0);
      ad |= K, u.lanes = K, u.memoizedState = Ke;
    }
  }
  function Pv(u, f, x) {
    if (u = f.effects, f.effects = null, u !== null) for (f = 0; f < u.length; f++) {
      var _ = u[f], A = _.callback;
      if (A !== null) {
        if (_.callback = null, _ = x, typeof A != "function") throw Error(t(191, A));
        A.call(_);
      }
    }
  }
  var yf = {}, ml = Xo(yf), Qh = Xo(yf), Jh = Xo(yf);
  function Qu(u) {
    if (u === yf) throw Error(t(174));
    return u;
  }
  function Tv(u, f) {
    switch (gr(Jh, f), gr(Qh, u), gr(ml, yf), u = f.nodeType, u) {
      case 9:
      case 11:
        f = (f = f.documentElement) ? f.namespaceURI : Ir(null, "");
        break;
      default:
        u = u === 8 ? f.parentNode : f, f = u.namespaceURI || null, u = u.tagName, f = Ir(f, u);
    }
    cr(ml), gr(ml, f);
  }
  function vf() {
    cr(ml), cr(Qh), cr(Jh);
  }
  function Iv(u) {
    Qu(Jh.current);
    var f = Qu(ml.current), x = Ir(f, u.type);
    f !== x && (gr(Qh, u), gr(ml, x));
  }
  function kv(u) {
    Qh.current === u && (cr(ml), cr(Qh));
  }
  var Mr = Xo(0);
  function jg(u) {
    for (var f = u; f !== null; ) {
      if (f.tag === 13) {
        var x = f.memoizedState;
        if (x !== null && (x = x.dehydrated, x === null || x.data === "$?" || x.data === "$!")) return f;
      } else if (f.tag === 19 && f.memoizedProps.revealOrder !== void 0) {
        if (f.flags & 128) return f;
      } else if (f.child !== null) {
        f.child.return = f, f = f.child;
        continue;
      }
      if (f === u) break;
      for (; f.sibling === null; ) {
        if (f.return === null || f.return === u) return null;
        f = f.return;
      }
      f.sibling.return = f.return, f = f.sibling;
    }
    return null;
  }
  var Rv = [];
  function ep() {
    for (var u = 0; u < Rv.length; u++) Rv[u]._workInProgressVersionPrimary = null;
    Rv.length = 0;
  }
  var Mt = O.ReactCurrentDispatcher, pn = O.ReactCurrentBatchConfig, _n = 0, Jt = null, ur = null, Si = null, Lg = !1, tp = !1, np = 0, Mv = 0;
  function je() {
    throw Error(t(321));
  }
  function hi(u, f) {
    if (f === null) return !1;
    for (var x = 0; x < f.length && x < u.length; x++) if (!La(u[x], f[x])) return !1;
    return !0;
  }
  function Nt(u, f, x, _, A, j) {
    if (_n = j, Jt = f, f.memoizedState = null, f.updateQueue = null, f.lanes = 0, Mt.current = u === null || u.memoizedState === null ? Zg : Qg, u = x(_, A), tp) {
      j = 0;
      do {
        if (tp = !1, np = 0, 25 <= j) throw Error(t(301));
        j += 1, Si = ur = null, f.updateQueue = null, Mt.current = ap, u = x(_, A);
      } while (tp);
    }
    if (Mt.current = ir, f = ur !== null && ur.next !== null, _n = 0, Si = ur = Jt = null, Lg = !1, f) throw Error(t(300));
    return u;
  }
  function Wc() {
    var u = np !== 0;
    return np = 0, u;
  }
  function ji() {
    var u = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
    return Si === null ? Jt.memoizedState = Si = u : Si = Si.next = u, Si;
  }
  function Li() {
    if (ur === null) {
      var u = Jt.alternate;
      u = u !== null ? u.memoizedState : null;
    } else u = ur.next;
    var f = Si === null ? Jt.memoizedState : Si.next;
    if (f !== null) Si = f, ur = u;
    else {
      if (u === null) throw Error(t(310));
      ur = u, u = { memoizedState: ur.memoizedState, baseState: ur.baseState, baseQueue: ur.baseQueue, queue: ur.queue, next: null }, Si === null ? Jt.memoizedState = Si = u : Si = Si.next = u;
    }
    return Si;
  }
  function Jo(u, f) {
    return typeof f == "function" ? f(u) : f;
  }
  function Ju(u) {
    var f = Li(), x = f.queue;
    if (x === null) throw Error(t(311));
    x.lastRenderedReducer = u;
    var _ = ur, A = _.baseQueue, j = x.pending;
    if (j !== null) {
      if (A !== null) {
        var K = A.next;
        A.next = j.next, j.next = K;
      }
      _.baseQueue = A = j, x.pending = null;
    }
    if (A !== null) {
      j = A.next, _ = _.baseState;
      var ee = K = null, ae = null, Te = j;
      do {
        var He = Te.lane;
        if ((_n & He) === He) ae !== null && (ae = ae.next = { lane: 0, action: Te.action, hasEagerState: Te.hasEagerState, eagerState: Te.eagerState, next: null }), _ = Te.hasEagerState ? Te.eagerState : u(_, Te.action);
        else {
          var Ke = {
            lane: He,
            action: Te.action,
            hasEagerState: Te.hasEagerState,
            eagerState: Te.eagerState,
            next: null
          };
          ae === null ? (ee = ae = Ke, K = _) : ae = ae.next = Ke, Jt.lanes |= He, ad |= He;
        }
        Te = Te.next;
      } while (Te !== null && Te !== j);
      ae === null ? K = _ : ae.next = ee, La(_, f.memoizedState) || (Ni = !0), f.memoizedState = _, f.baseState = K, f.baseQueue = ae, x.lastRenderedState = _;
    }
    if (u = x.interleaved, u !== null) {
      A = u;
      do
        j = A.lane, Jt.lanes |= j, ad |= j, A = A.next;
      while (A !== u);
    } else A === null && (x.lanes = 0);
    return [f.memoizedState, x.dispatch];
  }
  function Gc(u) {
    var f = Li(), x = f.queue;
    if (x === null) throw Error(t(311));
    x.lastRenderedReducer = u;
    var _ = x.dispatch, A = x.pending, j = f.memoizedState;
    if (A !== null) {
      x.pending = null;
      var K = A = A.next;
      do
        j = u(j, K.action), K = K.next;
      while (K !== A);
      La(j, f.memoizedState) || (Ni = !0), f.memoizedState = j, f.baseQueue === null && (f.baseState = j), x.lastRenderedState = j;
    }
    return [j, _];
  }
  function Sf() {
  }
  function Ng(u, f) {
    var x = Jt, _ = Li(), A = f(), j = !La(_.memoizedState, A);
    if (j && (_.memoizedState = A, Ni = !0), _ = _.queue, rp(Ug.bind(null, x, _, u), [u]), _.getSnapshot !== f || j || Si !== null && Si.memoizedState.tag & 1) {
      if (x.flags |= 2048, ed(9, zg.bind(null, x, _, A, f), void 0, null), pi === null) throw Error(t(349));
      _n & 30 || Fg(x, f, A);
    }
    return A;
  }
  function Fg(u, f, x) {
    u.flags |= 16384, u = { getSnapshot: f, value: x }, f = Jt.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, Jt.updateQueue = f, f.stores = [u]) : (x = f.stores, x === null ? f.stores = [u] : x.push(u));
  }
  function zg(u, f, x, _) {
    f.value = x, f.getSnapshot = _, $g(f) && Bg(u);
  }
  function Ug(u, f, x) {
    return x(function() {
      $g(f) && Bg(u);
    });
  }
  function $g(u) {
    var f = u.getSnapshot;
    u = u.value;
    try {
      var x = f();
      return !La(u, x);
    } catch {
      return !0;
    }
  }
  function Bg(u) {
    var f = gl(u, 1);
    f !== null && Ls(f, u, 1, -1);
  }
  function Hg(u) {
    var f = ji();
    return typeof u == "function" && (u = u()), f.memoizedState = f.baseState = u, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Jo, lastRenderedState: u }, f.queue = u, u = u.dispatch = sp.bind(null, Jt, u), [f.memoizedState, u];
  }
  function ed(u, f, x, _) {
    return u = { tag: u, create: f, destroy: x, deps: _, next: null }, f = Jt.updateQueue, f === null ? (f = { lastEffect: null, stores: null }, Jt.updateQueue = f, f.lastEffect = u.next = u) : (x = f.lastEffect, x === null ? f.lastEffect = u.next = u : (_ = x.next, x.next = u, u.next = _, f.lastEffect = u)), u;
  }
  function Vg() {
    return Li().memoizedState;
  }
  function xf(u, f, x, _) {
    var A = ji();
    Jt.flags |= u, A.memoizedState = ed(1 | f, x, void 0, _ === void 0 ? null : _);
  }
  function wf(u, f, x, _) {
    var A = Li();
    _ = _ === void 0 ? null : _;
    var j = void 0;
    if (ur !== null) {
      var K = ur.memoizedState;
      if (j = K.destroy, _ !== null && hi(_, K.deps)) {
        A.memoizedState = ed(f, x, j, _);
        return;
      }
    }
    Jt.flags |= u, A.memoizedState = ed(1 | f, x, j, _);
  }
  function Kg(u, f) {
    return xf(8390656, 8, u, f);
  }
  function rp(u, f) {
    return wf(2048, 8, u, f);
  }
  function Wg(u, f) {
    return wf(4, 2, u, f);
  }
  function Gg(u, f) {
    return wf(4, 4, u, f);
  }
  function ip(u, f) {
    if (typeof f == "function") return u = u(), f(u), function() {
      f(null);
    };
    if (f != null) return u = u(), f.current = u, function() {
      f.current = null;
    };
  }
  function td(u, f, x) {
    return x = x != null ? x.concat([u]) : null, wf(4, 4, ip.bind(null, f, u), x);
  }
  function op() {
  }
  function qg(u, f) {
    var x = Li();
    f = f === void 0 ? null : f;
    var _ = x.memoizedState;
    return _ !== null && f !== null && hi(f, _[1]) ? _[0] : (x.memoizedState = [u, f], u);
  }
  function Yg(u, f) {
    var x = Li();
    f = f === void 0 ? null : f;
    var _ = x.memoizedState;
    return _ !== null && f !== null && hi(f, _[1]) ? _[0] : (u = u(), x.memoizedState = [u, f], u);
  }
  function Xg(u, f, x) {
    return _n & 21 ? (La(x, f) || (x = Bl(), Jt.lanes |= x, ad |= x, u.baseState = !0), f) : (u.baseState && (u.baseState = !1, Ni = !0), u.memoizedState = x);
  }
  function bb(u, f) {
    var x = dn;
    dn = x !== 0 && 4 > x ? x : 4, u(!0);
    var _ = pn.transition;
    pn.transition = {};
    try {
      u(!1), f();
    } finally {
      dn = x, pn.transition = _;
    }
  }
  function bf() {
    return Li().memoizedState;
  }
  function Cb(u, f, x) {
    var _ = js(u);
    if (x = { lane: _, action: x, hasEagerState: !1, eagerState: null, next: null }, qc(u)) As(f, x);
    else if (x = Sb(u, f, x, _), x !== null) {
      var A = mr();
      Ls(x, u, _, A), Eb(x, f, _);
    }
  }
  function sp(u, f, x) {
    var _ = js(u), A = { lane: _, action: x, hasEagerState: !1, eagerState: null, next: null };
    if (qc(u)) As(f, A);
    else {
      var j = u.alternate;
      if (u.lanes === 0 && (j === null || j.lanes === 0) && (j = f.lastRenderedReducer, j !== null)) try {
        var K = f.lastRenderedState, ee = j(K, x);
        if (A.hasEagerState = !0, A.eagerState = ee, La(ee, K)) {
          var ae = f.interleaved;
          ae === null ? (A.next = A, _v(f)) : (A.next = ae.next, ae.next = A), f.interleaved = A;
          return;
        }
      } catch {
      } finally {
      }
      x = Sb(u, f, A, _), x !== null && (A = mr(), Ls(x, u, _, A), Eb(x, f, _));
    }
  }
  function qc(u) {
    var f = u.alternate;
    return u === Jt || f !== null && f === Jt;
  }
  function As(u, f) {
    tp = Lg = !0;
    var x = u.pending;
    x === null ? f.next = f : (f.next = x.next, x.next = f), u.pending = f;
  }
  function Eb(u, f, x) {
    if (x & 4194240) {
      var _ = f.lanes;
      _ &= u.pendingLanes, x |= _, f.lanes = x, Dc(u, x);
    }
  }
  var ir = { readContext: rr, useCallback: je, useContext: je, useEffect: je, useImperativeHandle: je, useInsertionEffect: je, useLayoutEffect: je, useMemo: je, useReducer: je, useRef: je, useState: je, useDebugValue: je, useDeferredValue: je, useTransition: je, useMutableSource: je, useSyncExternalStore: je, useId: je, unstable_isNewReconciler: !1 }, Zg = { readContext: rr, useCallback: function(u, f) {
    return ji().memoizedState = [u, f === void 0 ? null : f], u;
  }, useContext: rr, useEffect: Kg, useImperativeHandle: function(u, f, x) {
    return x = x != null ? x.concat([u]) : null, xf(
      4194308,
      4,
      ip.bind(null, f, u),
      x
    );
  }, useLayoutEffect: function(u, f) {
    return xf(4194308, 4, u, f);
  }, useInsertionEffect: function(u, f) {
    return xf(4, 2, u, f);
  }, useMemo: function(u, f) {
    var x = ji();
    return f = f === void 0 ? null : f, u = u(), x.memoizedState = [u, f], u;
  }, useReducer: function(u, f, x) {
    var _ = ji();
    return f = x !== void 0 ? x(f) : f, _.memoizedState = _.baseState = f, u = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: u, lastRenderedState: f }, _.queue = u, u = u.dispatch = Cb.bind(null, Jt, u), [_.memoizedState, u];
  }, useRef: function(u) {
    var f = ji();
    return u = { current: u }, f.memoizedState = u;
  }, useState: Hg, useDebugValue: op, useDeferredValue: function(u) {
    return ji().memoizedState = u;
  }, useTransition: function() {
    var u = Hg(!1), f = u[0];
    return u = bb.bind(null, u[1]), ji().memoizedState = u, [f, u];
  }, useMutableSource: function() {
  }, useSyncExternalStore: function(u, f, x) {
    var _ = Jt, A = ji();
    if (br) {
      if (x === void 0) throw Error(t(407));
      x = x();
    } else {
      if (x = f(), pi === null) throw Error(t(349));
      _n & 30 || Fg(_, f, x);
    }
    A.memoizedState = x;
    var j = { value: x, getSnapshot: f };
    return A.queue = j, Kg(Ug.bind(
      null,
      _,
      j,
      u
    ), [u]), _.flags |= 2048, ed(9, zg.bind(null, _, j, x, f), void 0, null), x;
  }, useId: function() {
    var u = ji(), f = pi.identifierPrefix;
    if (br) {
      var x = pl, _ = bo;
      x = (_ & ~(1 << 32 - Bi(_) - 1)).toString(32) + x, f = ":" + f + "R" + x, x = np++, 0 < x && (f += "H" + x.toString(32)), f += ":";
    } else x = Mv++, f = ":" + f + "r" + x.toString(32) + ":";
    return u.memoizedState = f;
  }, unstable_isNewReconciler: !1 }, Qg = {
    readContext: rr,
    useCallback: qg,
    useContext: rr,
    useEffect: rp,
    useImperativeHandle: td,
    useInsertionEffect: Wg,
    useLayoutEffect: Gg,
    useMemo: Yg,
    useReducer: Ju,
    useRef: Vg,
    useState: function() {
      return Ju(Jo);
    },
    useDebugValue: op,
    useDeferredValue: function(u) {
      var f = Li();
      return Xg(f, ur.memoizedState, u);
    },
    useTransition: function() {
      var u = Ju(Jo)[0], f = Li().memoizedState;
      return [u, f];
    },
    useMutableSource: Sf,
    useSyncExternalStore: Ng,
    useId: bf,
    unstable_isNewReconciler: !1
  }, ap = { readContext: rr, useCallback: qg, useContext: rr, useEffect: rp, useImperativeHandle: td, useInsertionEffect: Wg, useLayoutEffect: Gg, useMemo: Yg, useReducer: Gc, useRef: Vg, useState: function() {
    return Gc(Jo);
  }, useDebugValue: op, useDeferredValue: function(u) {
    var f = Li();
    return ur === null ? f.memoizedState = u : Xg(f, ur.memoizedState, u);
  }, useTransition: function() {
    var u = Gc(Jo)[0], f = Li().memoizedState;
    return [u, f];
  }, useMutableSource: Sf, useSyncExternalStore: Ng, useId: bf, unstable_isNewReconciler: !1 };
  function es(u, f) {
    if (u && u.defaultProps) {
      f = ke({}, f), u = u.defaultProps;
      for (var x in u) f[x] === void 0 && (f[x] = u[x]);
      return f;
    }
    return f;
  }
  function Av(u, f, x, _) {
    f = u.memoizedState, x = x(_, f), x = x == null ? f : ke({}, f, x), u.memoizedState = x, u.lanes === 0 && (u.updateQueue.baseState = x);
  }
  var Jg = { isMounted: function(u) {
    return (u = u._reactInternals) ? rt(u) === u : !1;
  }, enqueueSetState: function(u, f, x) {
    u = u._reactInternals;
    var _ = mr(), A = js(u), j = Jl(_, A);
    j.payload = f, x != null && (j.callback = x), f = Kc(u, j, A), f !== null && (Ls(f, u, A, _), Dg(f, u, A));
  }, enqueueReplaceState: function(u, f, x) {
    u = u._reactInternals;
    var _ = mr(), A = js(u), j = Jl(_, A);
    j.tag = 1, j.payload = f, x != null && (j.callback = x), f = Kc(u, j, A), f !== null && (Ls(f, u, A, _), Dg(f, u, A));
  }, enqueueForceUpdate: function(u, f) {
    u = u._reactInternals;
    var x = mr(), _ = js(u), A = Jl(x, _);
    A.tag = 2, f != null && (A.callback = f), f = Kc(u, A, _), f !== null && (Ls(f, u, _, x), Dg(f, u, _));
  } };
  function _b(u, f, x, _, A, j, K) {
    return u = u.stateNode, typeof u.shouldComponentUpdate == "function" ? u.shouldComponentUpdate(_, j, K) : f.prototype && f.prototype.isPureReactComponent ? !Lh(x, _) || !Lh(A, j) : !0;
  }
  function Pb(u, f, x) {
    var _ = !1, A = hn, j = f.contextType;
    return typeof j == "object" && j !== null ? j = rr(j) : (A = di(f) ? ea : Wr.current, _ = f.contextTypes, j = (_ = _ != null) ? Rs(u, A) : hn), f = new f(x, j), u.memoizedState = f.state !== null && f.state !== void 0 ? f.state : null, f.updater = Jg, u.stateNode = f, f._reactInternals = u, _ && (u = u.stateNode, u.__reactInternalMemoizedUnmaskedChildContext = A, u.__reactInternalMemoizedMaskedChildContext = j), f;
  }
  function em(u, f, x, _) {
    u = f.state, typeof f.componentWillReceiveProps == "function" && f.componentWillReceiveProps(x, _), typeof f.UNSAFE_componentWillReceiveProps == "function" && f.UNSAFE_componentWillReceiveProps(x, _), f.state !== u && Jg.enqueueReplaceState(f, f.state, null);
  }
  function Dv(u, f, x, _) {
    var A = u.stateNode;
    A.props = x, A.state = u.memoizedState, A.refs = {}, Vc(u);
    var j = f.contextType;
    typeof j == "object" && j !== null ? A.context = rr(j) : (j = di(f) ? ea : Wr.current, A.context = Rs(u, j)), A.state = u.memoizedState, j = f.getDerivedStateFromProps, typeof j == "function" && (Av(u, f, j, x), A.state = u.memoizedState), typeof f.getDerivedStateFromProps == "function" || typeof A.getSnapshotBeforeUpdate == "function" || typeof A.UNSAFE_componentWillMount != "function" && typeof A.componentWillMount != "function" || (f = A.state, typeof A.componentWillMount == "function" && A.componentWillMount(), typeof A.UNSAFE_componentWillMount == "function" && A.UNSAFE_componentWillMount(), f !== A.state && Jg.enqueueReplaceState(A, A.state, null), Og(u, x, A, _), A.state = u.memoizedState), typeof A.componentDidMount == "function" && (u.flags |= 4194308);
  }
  function Yc(u, f) {
    try {
      var x = "", _ = f;
      do
        x += De(_), _ = _.return;
      while (_);
      var A = x;
    } catch (j) {
      A = `
Error generating stack: ` + j.message + `
` + j.stack;
    }
    return { value: u, source: f, stack: A, digest: null };
  }
  function tm(u, f, x) {
    return { value: u, source: null, stack: x ?? null, digest: f ?? null };
  }
  function Ov(u, f) {
    try {
      console.error(f.value);
    } catch (x) {
      setTimeout(function() {
        throw x;
      });
    }
  }
  var sP = typeof WeakMap == "function" ? WeakMap : Map;
  function lp(u, f, x) {
    x = Jl(-1, x), x.tag = 3, x.payload = { element: null };
    var _ = f.value;
    return x.callback = function() {
      Zc || (Zc = !0, mp = _), Ov(u, f);
    }, x;
  }
  function Tb(u, f, x) {
    x = Jl(-1, x), x.tag = 3;
    var _ = u.type.getDerivedStateFromError;
    if (typeof _ == "function") {
      var A = f.value;
      x.payload = function() {
        return _(A);
      }, x.callback = function() {
        Ov(u, f);
      };
    }
    var j = u.stateNode;
    return j !== null && typeof j.componentDidCatch == "function" && (x.callback = function() {
      Ov(u, f), typeof _ != "function" && (oa === null ? oa = /* @__PURE__ */ new Set([this]) : oa.add(this));
      var K = f.stack;
      this.componentDidCatch(f.value, { componentStack: K !== null ? K : "" });
    }), x;
  }
  function jv(u, f, x) {
    var _ = u.pingCache;
    if (_ === null) {
      _ = u.pingCache = new sP();
      var A = /* @__PURE__ */ new Set();
      _.set(f, A);
    } else A = _.get(f), A === void 0 && (A = /* @__PURE__ */ new Set(), _.set(f, A));
    A.has(x) || (A.add(x), u = qv.bind(null, u, f, x), f.then(u, u));
  }
  function Lv(u) {
    do {
      var f;
      if ((f = u.tag === 13) && (f = u.memoizedState, f = f !== null ? f.dehydrated !== null : !0), f) return u;
      u = u.return;
    } while (u !== null);
    return null;
  }
  function Ib(u, f, x, _, A) {
    return u.mode & 1 ? (u.flags |= 65536, u.lanes = A, u) : (u === f ? u.flags |= 65536 : (u.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (f = Jl(-1, 1), f.tag = 2, Kc(x, f, 1))), x.lanes |= 1), u);
  }
  var nd = O.ReactCurrentOwner, Ni = !1;
  function ei(u, f, x, _) {
    f.child = u === null ? Ki(f, null, x, _) : Ua(f, u.child, x, _);
  }
  function nm(u, f, x, _, A) {
    x = x.render;
    var j = f.ref;
    return mf(f, A), _ = Nt(u, f, x, _, j, A), x = Wc(), u !== null && !Ni ? (f.updateQueue = u.updateQueue, f.flags &= -2053, u.lanes &= ~A, Wi(u, f, A)) : (br && x && mv(f), f.flags |= 1, ei(u, f, _, A), f.child);
  }
  function ts(u, f, x, _, A) {
    if (u === null) {
      var j = x.type;
      return typeof j == "function" && !Xv(j) && j.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (f.tag = 15, f.type = j, rd(u, f, j, _, A)) : (u = ym(x.type, null, _, f, f.mode, A), u.ref = f.ref, u.return = f, f.child = u);
    }
    if (j = u.child, !(u.lanes & A)) {
      var K = j.memoizedProps;
      if (x = x.compare, x = x !== null ? x : Lh, x(K, _) && u.ref === f.ref) return Wi(u, f, A);
    }
    return f.flags |= 1, u = eu(j, _), u.ref = f.ref, u.return = f, f.child = u;
  }
  function rd(u, f, x, _, A) {
    if (u !== null) {
      var j = u.memoizedProps;
      if (Lh(j, _) && u.ref === f.ref) if (Ni = !1, f.pendingProps = _ = j, (u.lanes & A) !== 0) u.flags & 131072 && (Ni = !0);
      else return f.lanes = u.lanes, Wi(u, f, A);
    }
    return rm(u, f, x, _, A);
  }
  function nn(u, f, x) {
    var _ = f.pendingProps, A = _.children, j = u !== null ? u.memoizedState : null;
    if (_.mode === "hidden") if (!(f.mode & 1)) f.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, gr(Pf, Os), Os |= x;
    else {
      if (!(x & 1073741824)) return u = j !== null ? j.baseLanes | x : x, f.lanes = f.childLanes = 1073741824, f.memoizedState = { baseLanes: u, cachePool: null, transitions: null }, f.updateQueue = null, gr(Pf, Os), Os |= u, null;
      f.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, _ = j !== null ? j.baseLanes : x, gr(Pf, Os), Os |= _;
    }
    else j !== null ? (_ = j.baseLanes | x, f.memoizedState = null) : _ = x, gr(Pf, Os), Os |= _;
    return ei(u, f, A, x), f.child;
  }
  function cp(u, f) {
    var x = f.ref;
    (u === null && x !== null || u !== null && u.ref !== x) && (f.flags |= 512, f.flags |= 2097152);
  }
  function rm(u, f, x, _, A) {
    var j = di(x) ? ea : Wr.current;
    return j = Rs(f, j), mf(f, A), x = Nt(u, f, x, _, j, A), _ = Wc(), u !== null && !Ni ? (f.updateQueue = u.updateQueue, f.flags &= -2053, u.lanes &= ~A, Wi(u, f, A)) : (br && _ && mv(f), f.flags |= 1, ei(u, f, x, A), f.child);
  }
  function aP(u, f, x, _, A) {
    if (di(x)) {
      var j = !0;
      qu(f);
    } else j = !1;
    if (mf(f, A), f.stateNode === null) ra(u, f), Pb(f, x, _), Dv(f, x, _, A), _ = !0;
    else if (u === null) {
      var K = f.stateNode, ee = f.memoizedProps;
      K.props = ee;
      var ae = K.context, Te = x.contextType;
      typeof Te == "object" && Te !== null ? Te = rr(Te) : (Te = di(x) ? ea : Wr.current, Te = Rs(f, Te));
      var He = x.getDerivedStateFromProps, Ke = typeof He == "function" || typeof K.getSnapshotBeforeUpdate == "function";
      Ke || typeof K.UNSAFE_componentWillReceiveProps != "function" && typeof K.componentWillReceiveProps != "function" || (ee !== _ || ae !== Te) && em(f, K, _, Te), na = !1;
      var Be = f.memoizedState;
      K.state = Be, Og(f, _, K, A), ae = f.memoizedState, ee !== _ || Be !== ae || ui.current || na ? (typeof He == "function" && (Av(f, x, He, _), ae = f.memoizedState), (ee = na || _b(f, x, ee, _, Be, ae, Te)) ? (Ke || typeof K.UNSAFE_componentWillMount != "function" && typeof K.componentWillMount != "function" || (typeof K.componentWillMount == "function" && K.componentWillMount(), typeof K.UNSAFE_componentWillMount == "function" && K.UNSAFE_componentWillMount()), typeof K.componentDidMount == "function" && (f.flags |= 4194308)) : (typeof K.componentDidMount == "function" && (f.flags |= 4194308), f.memoizedProps = _, f.memoizedState = ae), K.props = _, K.state = ae, K.context = Te, _ = ee) : (typeof K.componentDidMount == "function" && (f.flags |= 4194308), _ = !1);
    } else {
      K = f.stateNode, xb(u, f), ee = f.memoizedProps, Te = f.type === f.elementType ? ee : es(f.type, ee), K.props = Te, Ke = f.pendingProps, Be = K.context, ae = x.contextType, typeof ae == "object" && ae !== null ? ae = rr(ae) : (ae = di(x) ? ea : Wr.current, ae = Rs(f, ae));
      var dt = x.getDerivedStateFromProps;
      (He = typeof dt == "function" || typeof K.getSnapshotBeforeUpdate == "function") || typeof K.UNSAFE_componentWillReceiveProps != "function" && typeof K.componentWillReceiveProps != "function" || (ee !== Ke || Be !== ae) && em(f, K, _, ae), na = !1, Be = f.memoizedState, K.state = Be, Og(f, _, K, A);
      var St = f.memoizedState;
      ee !== Ke || Be !== St || ui.current || na ? (typeof dt == "function" && (Av(f, x, dt, _), St = f.memoizedState), (Te = na || _b(f, x, Te, _, Be, St, ae) || !1) ? (He || typeof K.UNSAFE_componentWillUpdate != "function" && typeof K.componentWillUpdate != "function" || (typeof K.componentWillUpdate == "function" && K.componentWillUpdate(_, St, ae), typeof K.UNSAFE_componentWillUpdate == "function" && K.UNSAFE_componentWillUpdate(_, St, ae)), typeof K.componentDidUpdate == "function" && (f.flags |= 4), typeof K.getSnapshotBeforeUpdate == "function" && (f.flags |= 1024)) : (typeof K.componentDidUpdate != "function" || ee === u.memoizedProps && Be === u.memoizedState || (f.flags |= 4), typeof K.getSnapshotBeforeUpdate != "function" || ee === u.memoizedProps && Be === u.memoizedState || (f.flags |= 1024), f.memoizedProps = _, f.memoizedState = St), K.props = _, K.state = St, K.context = ae, _ = Te) : (typeof K.componentDidUpdate != "function" || ee === u.memoizedProps && Be === u.memoizedState || (f.flags |= 4), typeof K.getSnapshotBeforeUpdate != "function" || ee === u.memoizedProps && Be === u.memoizedState || (f.flags |= 1024), _ = !1);
    }
    return Nv(u, f, x, _, j, A);
  }
  function Nv(u, f, x, _, A, j) {
    cp(u, f);
    var K = (f.flags & 128) !== 0;
    if (!_ && !K) return A && ta(f, x, !1), Wi(u, f, j);
    _ = f.stateNode, nd.current = f;
    var ee = K && typeof x.getDerivedStateFromError != "function" ? null : _.render();
    return f.flags |= 1, u !== null && K ? (f.child = Ua(f, u.child, null, j), f.child = Ua(f, null, ee, j)) : ei(u, f, ee, j), f.memoizedState = _.state, A && ta(f, x, !0), f.child;
  }
  function im(u) {
    var f = u.stateNode;
    f.pendingContext ? Mg(u, f.pendingContext, f.pendingContext !== f.context) : f.context && Mg(u, f.context, !1), Tv(u, f.containerInfo);
  }
  function Cf(u, f, x, _, A) {
    return Ql(), Xh(A), f.flags |= 256, ei(u, f, x, _), f.child;
  }
  var Fv = { dehydrated: null, treeContext: null, retryLane: 0 };
  function om(u) {
    return { baseLanes: u, cachePool: null, transitions: null };
  }
  function kb(u, f, x) {
    var _ = f.pendingProps, A = Mr.current, j = !1, K = (f.flags & 128) !== 0, ee;
    if ((ee = K) || (ee = u !== null && u.memoizedState === null ? !1 : (A & 2) !== 0), ee ? (j = !0, f.flags &= -129) : (u === null || u.memoizedState !== null) && (A |= 1), gr(Mr, A & 1), u === null)
      return xv(f), u = f.memoizedState, u !== null && (u = u.dehydrated, u !== null) ? (f.mode & 1 ? u.data === "$!" ? f.lanes = 8 : f.lanes = 1073741824 : f.lanes = 1, null) : (K = _.children, u = _.fallback, j ? (_ = f.mode, j = f.child, K = { mode: "hidden", children: K }, !(_ & 1) && j !== null ? (j.childLanes = 0, j.pendingProps = K) : j = Af(K, _, 0, null), u = tu(u, _, x, null), j.return = f, u.return = f, j.sibling = u, f.child = j, f.child.memoizedState = om(x), f.memoizedState = Fv, u) : up(f, K));
    if (A = u.memoizedState, A !== null && (ee = A.dehydrated, ee !== null)) return Rb(u, f, K, _, ee, A, x);
    if (j) {
      j = _.fallback, K = f.mode, A = u.child, ee = A.sibling;
      var ae = { mode: "hidden", children: _.children };
      return !(K & 1) && f.child !== A ? (_ = f.child, _.childLanes = 0, _.pendingProps = ae, f.deletions = null) : (_ = eu(A, ae), _.subtreeFlags = A.subtreeFlags & 14680064), ee !== null ? j = eu(ee, j) : (j = tu(j, K, x, null), j.flags |= 2), j.return = f, _.return = f, _.sibling = j, f.child = _, _ = j, j = f.child, K = u.child.memoizedState, K = K === null ? om(x) : { baseLanes: K.baseLanes | x, cachePool: null, transitions: K.transitions }, j.memoizedState = K, j.childLanes = u.childLanes & ~x, f.memoizedState = Fv, _;
    }
    return j = u.child, u = j.sibling, _ = eu(j, { mode: "visible", children: _.children }), !(f.mode & 1) && (_.lanes = x), _.return = f, _.sibling = null, u !== null && (x = f.deletions, x === null ? (f.deletions = [u], f.flags |= 16) : x.push(u)), f.child = _, f.memoizedState = null, _;
  }
  function up(u, f) {
    return f = Af({ mode: "visible", children: f }, u.mode, 0, null), f.return = u, u.child = f;
  }
  function sm(u, f, x, _) {
    return _ !== null && Xh(_), Ua(f, u.child, null, x), u = up(f, f.pendingProps.children), u.flags |= 2, f.memoizedState = null, u;
  }
  function Rb(u, f, x, _, A, j, K) {
    if (x)
      return f.flags & 256 ? (f.flags &= -257, _ = tm(Error(t(422))), sm(u, f, K, _)) : f.memoizedState !== null ? (f.child = u.child, f.flags |= 128, null) : (j = _.fallback, A = f.mode, _ = Af({ mode: "visible", children: _.children }, A, 0, null), j = tu(j, A, K, null), j.flags |= 2, _.return = f, j.return = f, _.sibling = j, f.child = _, f.mode & 1 && Ua(f, u.child, null, K), f.child.memoizedState = om(K), f.memoizedState = Fv, j);
    if (!(f.mode & 1)) return sm(u, f, K, null);
    if (A.data === "$!") {
      if (_ = A.nextSibling && A.nextSibling.dataset, _) var ee = _.dgst;
      return _ = ee, j = Error(t(419)), _ = tm(j, _, void 0), sm(u, f, K, _);
    }
    if (ee = (K & u.childLanes) !== 0, Ni || ee) {
      if (_ = pi, _ !== null) {
        switch (K & -K) {
          case 4:
            A = 2;
            break;
          case 16:
            A = 8;
            break;
          case 64:
          case 128:
          case 256:
          case 512:
          case 1024:
          case 2048:
          case 4096:
          case 8192:
          case 16384:
          case 32768:
          case 65536:
          case 131072:
          case 262144:
          case 524288:
          case 1048576:
          case 2097152:
          case 4194304:
          case 8388608:
          case 16777216:
          case 33554432:
          case 67108864:
            A = 32;
            break;
          case 536870912:
            A = 268435456;
            break;
          default:
            A = 0;
        }
        A = A & (_.suspendedLanes | K) ? 0 : A, A !== 0 && A !== j.retryLane && (j.retryLane = A, gl(u, A), Ls(_, u, A, -1));
      }
      return Wv(), _ = tm(Error(t(421))), sm(u, f, K, _);
    }
    return A.data === "$?" ? (f.flags |= 128, f.child = u.child, f = hP.bind(null, u), A._reactRetry = f, null) : (u = j.treeContext, Qo = Na(A.nextSibling), Zo = f, br = !0, za = null, u !== null && (Vi[fi++] = bo, Vi[fi++] = pl, Vi[fi++] = Yu, bo = u.id, pl = u.overflow, Yu = f), f = up(f, _.children), f.flags |= 4096, f);
  }
  function zv(u, f, x) {
    u.lanes |= f;
    var _ = u.alternate;
    _ !== null && (_.lanes |= f), Ev(u.return, f, x);
  }
  function am(u, f, x, _, A) {
    var j = u.memoizedState;
    j === null ? u.memoizedState = { isBackwards: f, rendering: null, renderingStartTime: 0, last: _, tail: x, tailMode: A } : (j.isBackwards = f, j.rendering = null, j.renderingStartTime = 0, j.last = _, j.tail = x, j.tailMode = A);
  }
  function ns(u, f, x) {
    var _ = f.pendingProps, A = _.revealOrder, j = _.tail;
    if (ei(u, f, _.children, x), _ = Mr.current, _ & 2) _ = _ & 1 | 2, f.flags |= 128;
    else {
      if (u !== null && u.flags & 128) e: for (u = f.child; u !== null; ) {
        if (u.tag === 13) u.memoizedState !== null && zv(u, x, f);
        else if (u.tag === 19) zv(u, x, f);
        else if (u.child !== null) {
          u.child.return = u, u = u.child;
          continue;
        }
        if (u === f) break e;
        for (; u.sibling === null; ) {
          if (u.return === null || u.return === f) break e;
          u = u.return;
        }
        u.sibling.return = u.return, u = u.sibling;
      }
      _ &= 1;
    }
    if (gr(Mr, _), !(f.mode & 1)) f.memoizedState = null;
    else switch (A) {
      case "forwards":
        for (x = f.child, A = null; x !== null; ) u = x.alternate, u !== null && jg(u) === null && (A = x), x = x.sibling;
        x = A, x === null ? (A = f.child, f.child = null) : (A = x.sibling, x.sibling = null), am(f, !1, A, x, j);
        break;
      case "backwards":
        for (x = null, A = f.child, f.child = null; A !== null; ) {
          if (u = A.alternate, u !== null && jg(u) === null) {
            f.child = A;
            break;
          }
          u = A.sibling, A.sibling = x, x = A, A = u;
        }
        am(f, !0, x, null, j);
        break;
      case "together":
        am(f, !1, null, null, void 0);
        break;
      default:
        f.memoizedState = null;
    }
    return f.child;
  }
  function ra(u, f) {
    !(f.mode & 1) && u !== null && (u.alternate = null, f.alternate = null, f.flags |= 2);
  }
  function Wi(u, f, x) {
    if (u !== null && (f.dependencies = u.dependencies), ad |= f.lanes, !(x & f.childLanes)) return null;
    if (u !== null && f.child !== u.child) throw Error(t(153));
    if (f.child !== null) {
      for (u = f.child, x = eu(u, u.pendingProps), f.child = x, x.return = f; u.sibling !== null; ) u = u.sibling, x = x.sibling = eu(u, u.pendingProps), x.return = f;
      x.sibling = null;
    }
    return f.child;
  }
  function lm(u, f, x) {
    switch (f.tag) {
      case 3:
        im(f), Ql();
        break;
      case 5:
        Iv(f);
        break;
      case 1:
        di(f.type) && qu(f);
        break;
      case 4:
        Tv(f, f.stateNode.containerInfo);
        break;
      case 10:
        var _ = f.type._context, A = f.memoizedProps.value;
        gr(nt, _._currentValue), _._currentValue = A;
        break;
      case 13:
        if (_ = f.memoizedState, _ !== null)
          return _.dehydrated !== null ? (gr(Mr, Mr.current & 1), f.flags |= 128, null) : x & f.child.childLanes ? kb(u, f, x) : (gr(Mr, Mr.current & 1), u = Wi(u, f, x), u !== null ? u.sibling : null);
        gr(Mr, Mr.current & 1);
        break;
      case 19:
        if (_ = (x & f.childLanes) !== 0, u.flags & 128) {
          if (_) return ns(u, f, x);
          f.flags |= 128;
        }
        if (A = f.memoizedState, A !== null && (A.rendering = null, A.tail = null, A.lastEffect = null), gr(Mr, Mr.current), _) break;
        return null;
      case 22:
      case 23:
        return f.lanes = 0, nn(u, f, x);
    }
    return Wi(u, f, x);
  }
  var Ef, Ds, xi, Mb;
  Ef = function(u, f) {
    for (var x = f.child; x !== null; ) {
      if (x.tag === 5 || x.tag === 6) u.appendChild(x.stateNode);
      else if (x.tag !== 4 && x.child !== null) {
        x.child.return = x, x = x.child;
        continue;
      }
      if (x === f) break;
      for (; x.sibling === null; ) {
        if (x.return === null || x.return === f) return;
        x = x.return;
      }
      x.sibling.return = x.return, x = x.sibling;
    }
  }, Ds = function() {
  }, xi = function(u, f, x, _) {
    var A = u.memoizedProps;
    if (A !== _) {
      u = f.stateNode, Qu(ml.current);
      var j = null;
      switch (x) {
        case "input":
          A = an(u, A), _ = an(u, _), j = [];
          break;
        case "select":
          A = ke({}, A, { value: void 0 }), _ = ke({}, _, { value: void 0 }), j = [];
          break;
        case "textarea":
          A = Vr(u, A), _ = Vr(u, _), j = [];
          break;
        default:
          typeof A.onClick != "function" && typeof _.onClick == "function" && (u.onclick = Tg);
      }
      qn(x, _);
      var K;
      x = null;
      for (Te in A) if (!_.hasOwnProperty(Te) && A.hasOwnProperty(Te) && A[Te] != null) if (Te === "style") {
        var ee = A[Te];
        for (K in ee) ee.hasOwnProperty(K) && (x || (x = {}), x[K] = "");
      } else Te !== "dangerouslySetInnerHTML" && Te !== "children" && Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && Te !== "autoFocus" && (i.hasOwnProperty(Te) ? j || (j = []) : (j = j || []).push(Te, null));
      for (Te in _) {
        var ae = _[Te];
        if (ee = A != null ? A[Te] : void 0, _.hasOwnProperty(Te) && ae !== ee && (ae != null || ee != null)) if (Te === "style") if (ee) {
          for (K in ee) !ee.hasOwnProperty(K) || ae && ae.hasOwnProperty(K) || (x || (x = {}), x[K] = "");
          for (K in ae) ae.hasOwnProperty(K) && ee[K] !== ae[K] && (x || (x = {}), x[K] = ae[K]);
        } else x || (j || (j = []), j.push(
          Te,
          x
        )), x = ae;
        else Te === "dangerouslySetInnerHTML" ? (ae = ae ? ae.__html : void 0, ee = ee ? ee.__html : void 0, ae != null && ee !== ae && (j = j || []).push(Te, ae)) : Te === "children" ? typeof ae != "string" && typeof ae != "number" || (j = j || []).push(Te, "" + ae) : Te !== "suppressContentEditableWarning" && Te !== "suppressHydrationWarning" && (i.hasOwnProperty(Te) ? (ae != null && Te === "onScroll" && Jn("scroll", u), j || ee === ae || (j = [])) : (j = j || []).push(Te, ae));
      }
      x && (j = j || []).push("style", x);
      var Te = j;
      (f.updateQueue = Te) && (f.flags |= 4);
    }
  }, Mb = function(u, f, x, _) {
    x !== _ && (f.flags |= 4);
  };
  function dp(u, f) {
    if (!br) switch (u.tailMode) {
      case "hidden":
        f = u.tail;
        for (var x = null; f !== null; ) f.alternate !== null && (x = f), f = f.sibling;
        x === null ? u.tail = null : x.sibling = null;
        break;
      case "collapsed":
        x = u.tail;
        for (var _ = null; x !== null; ) x.alternate !== null && (_ = x), x = x.sibling;
        _ === null ? f || u.tail === null ? u.tail = null : u.tail.sibling = null : _.sibling = null;
    }
  }
  function fo(u) {
    var f = u.alternate !== null && u.alternate.child === u.child, x = 0, _ = 0;
    if (f) for (var A = u.child; A !== null; ) x |= A.lanes | A.childLanes, _ |= A.subtreeFlags & 14680064, _ |= A.flags & 14680064, A.return = u, A = A.sibling;
    else for (A = u.child; A !== null; ) x |= A.lanes | A.childLanes, _ |= A.subtreeFlags, _ |= A.flags, A.return = u, A = A.sibling;
    return u.subtreeFlags |= _, u.childLanes = x, f;
  }
  function Uv(u, f, x) {
    var _ = f.pendingProps;
    switch (Ag(f), f.tag) {
      case 2:
      case 16:
      case 15:
      case 0:
      case 11:
      case 7:
      case 8:
      case 12:
      case 9:
      case 14:
        return fo(f), null;
      case 1:
        return di(f.type) && hl(), fo(f), null;
      case 3:
        return _ = f.stateNode, vf(), cr(ui), cr(Wr), ep(), _.pendingContext && (_.context = _.pendingContext, _.pendingContext = null), (u === null || u.child === null) && (Jr(f) ? f.flags |= 4 : u === null || u.memoizedState.isDehydrated && !(f.flags & 256) || (f.flags |= 1024, za !== null && (xp(za), za = null))), Ds(u, f), fo(f), null;
      case 5:
        kv(f);
        var A = Qu(Jh.current);
        if (x = f.type, u !== null && f.stateNode != null) xi(u, f, x, _, A), u.ref !== f.ref && (f.flags |= 512, f.flags |= 2097152);
        else {
          if (!_) {
            if (f.stateNode === null) throw Error(t(166));
            return fo(f), null;
          }
          if (u = Qu(ml.current), Jr(f)) {
            _ = f.stateNode, x = f.type;
            var j = f.memoizedProps;
            switch (_[Js] = f, _[Wh] = j, u = (f.mode & 1) !== 0, x) {
              case "dialog":
                Jn("cancel", _), Jn("close", _);
                break;
              case "iframe":
              case "object":
              case "embed":
                Jn("load", _);
                break;
              case "video":
              case "audio":
                for (A = 0; A < $h.length; A++) Jn($h[A], _);
                break;
              case "source":
                Jn("error", _);
                break;
              case "img":
              case "image":
              case "link":
                Jn(
                  "error",
                  _
                ), Jn("load", _);
                break;
              case "details":
                Jn("toggle", _);
                break;
              case "input":
                ln(_, j), Jn("invalid", _);
                break;
              case "select":
                _._wrapperState = { wasMultiple: !!j.multiple }, Jn("invalid", _);
                break;
              case "textarea":
                Kr(_, j), Jn("invalid", _);
            }
            qn(x, j), A = null;
            for (var K in j) if (j.hasOwnProperty(K)) {
              var ee = j[K];
              K === "children" ? typeof ee == "string" ? _.textContent !== ee && (j.suppressHydrationWarning !== !0 && Pg(_.textContent, ee, u), A = ["children", ee]) : typeof ee == "number" && _.textContent !== "" + ee && (j.suppressHydrationWarning !== !0 && Pg(
                _.textContent,
                ee,
                u
              ), A = ["children", "" + ee]) : i.hasOwnProperty(K) && ee != null && K === "onScroll" && Jn("scroll", _);
            }
            switch (x) {
              case "input":
                Pt(_), xr(_, j, !0);
                break;
              case "textarea":
                Pt(_), mo(_);
                break;
              case "select":
              case "option":
                break;
              default:
                typeof j.onClick == "function" && (_.onclick = Tg);
            }
            _ = A, f.updateQueue = _, _ !== null && (f.flags |= 4);
          } else {
            K = A.nodeType === 9 ? A : A.ownerDocument, u === "http://www.w3.org/1999/xhtml" && (u = Tr(x)), u === "http://www.w3.org/1999/xhtml" ? x === "script" ? (u = K.createElement("div"), u.innerHTML = "<script><\/script>", u = u.removeChild(u.firstChild)) : typeof _.is == "string" ? u = K.createElement(x, { is: _.is }) : (u = K.createElement(x), x === "select" && (K = u, _.multiple ? K.multiple = !0 : _.size && (K.size = _.size))) : u = K.createElementNS(u, x), u[Js] = f, u[Wh] = _, Ef(u, f, !1, !1), f.stateNode = u;
            e: {
              switch (K = Rn(x, _), x) {
                case "dialog":
                  Jn("cancel", u), Jn("close", u), A = _;
                  break;
                case "iframe":
                case "object":
                case "embed":
                  Jn("load", u), A = _;
                  break;
                case "video":
                case "audio":
                  for (A = 0; A < $h.length; A++) Jn($h[A], u);
                  A = _;
                  break;
                case "source":
                  Jn("error", u), A = _;
                  break;
                case "img":
                case "image":
                case "link":
                  Jn(
                    "error",
                    u
                  ), Jn("load", u), A = _;
                  break;
                case "details":
                  Jn("toggle", u), A = _;
                  break;
                case "input":
                  ln(u, _), A = an(u, _), Jn("invalid", u);
                  break;
                case "option":
                  A = _;
                  break;
                case "select":
                  u._wrapperState = { wasMultiple: !!_.multiple }, A = ke({}, _, { value: void 0 }), Jn("invalid", u);
                  break;
                case "textarea":
                  Kr(u, _), A = Vr(u, _), Jn("invalid", u);
                  break;
                default:
                  A = _;
              }
              qn(x, A), ee = A;
              for (j in ee) if (ee.hasOwnProperty(j)) {
                var ae = ee[j];
                j === "style" ? cn(u, ae) : j === "dangerouslySetInnerHTML" ? (ae = ae ? ae.__html : void 0, ae != null && Ko(u, ae)) : j === "children" ? typeof ae == "string" ? (x !== "textarea" || ae !== "") && Ee(u, ae) : typeof ae == "number" && Ee(u, "" + ae) : j !== "suppressContentEditableWarning" && j !== "suppressHydrationWarning" && j !== "autoFocus" && (i.hasOwnProperty(j) ? ae != null && j === "onScroll" && Jn("scroll", u) : ae != null && L(u, j, ae, K));
              }
              switch (x) {
                case "input":
                  Pt(u), xr(u, _, !1);
                  break;
                case "textarea":
                  Pt(u), mo(u);
                  break;
                case "option":
                  _.value != null && u.setAttribute("value", "" + We(_.value));
                  break;
                case "select":
                  u.multiple = !!_.multiple, j = _.value, j != null ? wr(u, !!_.multiple, j, !1) : _.defaultValue != null && wr(
                    u,
                    !!_.multiple,
                    _.defaultValue,
                    !0
                  );
                  break;
                default:
                  typeof A.onClick == "function" && (u.onclick = Tg);
              }
              switch (x) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  _ = !!_.autoFocus;
                  break e;
                case "img":
                  _ = !0;
                  break e;
                default:
                  _ = !1;
              }
            }
            _ && (f.flags |= 4);
          }
          f.ref !== null && (f.flags |= 512, f.flags |= 2097152);
        }
        return fo(f), null;
      case 6:
        if (u && f.stateNode != null) Mb(u, f, u.memoizedProps, _);
        else {
          if (typeof _ != "string" && f.stateNode === null) throw Error(t(166));
          if (x = Qu(Jh.current), Qu(ml.current), Jr(f)) {
            if (_ = f.stateNode, x = f.memoizedProps, _[Js] = f, (j = _.nodeValue !== x) && (u = Zo, u !== null)) switch (u.tag) {
              case 3:
                Pg(_.nodeValue, x, (u.mode & 1) !== 0);
                break;
              case 5:
                u.memoizedProps.suppressHydrationWarning !== !0 && Pg(_.nodeValue, x, (u.mode & 1) !== 0);
            }
            j && (f.flags |= 4);
          } else _ = (x.nodeType === 9 ? x : x.ownerDocument).createTextNode(_), _[Js] = f, f.stateNode = _;
        }
        return fo(f), null;
      case 13:
        if (cr(Mr), _ = f.memoizedState, u === null || u.memoizedState !== null && u.memoizedState.dehydrated !== null) {
          if (br && Qo !== null && f.mode & 1 && !(f.flags & 128)) mb(), Ql(), f.flags |= 98560, j = !1;
          else if (j = Jr(f), _ !== null && _.dehydrated !== null) {
            if (u === null) {
              if (!j) throw Error(t(318));
              if (j = f.memoizedState, j = j !== null ? j.dehydrated : null, !j) throw Error(t(317));
              j[Js] = f;
            } else Ql(), !(f.flags & 128) && (f.memoizedState = null), f.flags |= 4;
            fo(f), j = !1;
          } else za !== null && (xp(za), za = null), j = !0;
          if (!j) return f.flags & 65536 ? f : null;
        }
        return f.flags & 128 ? (f.lanes = x, f) : (_ = _ !== null, _ !== (u !== null && u.memoizedState !== null) && _ && (f.child.flags |= 8192, f.mode & 1 && (u === null || Mr.current & 1 ? wi === 0 && (wi = 3) : Wv())), f.updateQueue !== null && (f.flags |= 4), fo(f), null);
      case 4:
        return vf(), Ds(u, f), u === null && Hh(f.stateNode.containerInfo), fo(f), null;
      case 10:
        return Cv(f.type._context), fo(f), null;
      case 17:
        return di(f.type) && hl(), fo(f), null;
      case 19:
        if (cr(Mr), j = f.memoizedState, j === null) return fo(f), null;
        if (_ = (f.flags & 128) !== 0, K = j.rendering, K === null) if (_) dp(j, !1);
        else {
          if (wi !== 0 || u !== null && u.flags & 128) for (u = f.child; u !== null; ) {
            if (K = jg(u), K !== null) {
              for (f.flags |= 128, dp(j, !1), _ = K.updateQueue, _ !== null && (f.updateQueue = _, f.flags |= 4), f.subtreeFlags = 0, _ = x, x = f.child; x !== null; ) j = x, u = _, j.flags &= 14680066, K = j.alternate, K === null ? (j.childLanes = 0, j.lanes = u, j.child = null, j.subtreeFlags = 0, j.memoizedProps = null, j.memoizedState = null, j.updateQueue = null, j.dependencies = null, j.stateNode = null) : (j.childLanes = K.childLanes, j.lanes = K.lanes, j.child = K.child, j.subtreeFlags = 0, j.deletions = null, j.memoizedProps = K.memoizedProps, j.memoizedState = K.memoizedState, j.updateQueue = K.updateQueue, j.type = K.type, u = K.dependencies, j.dependencies = u === null ? null : { lanes: u.lanes, firstContext: u.firstContext }), x = x.sibling;
              return gr(Mr, Mr.current & 1 | 2), f.child;
            }
            u = u.sibling;
          }
          j.tail !== null && Un() > If && (f.flags |= 128, _ = !0, dp(j, !1), f.lanes = 4194304);
        }
        else {
          if (!_) if (u = jg(K), u !== null) {
            if (f.flags |= 128, _ = !0, x = u.updateQueue, x !== null && (f.updateQueue = x, f.flags |= 4), dp(j, !0), j.tail === null && j.tailMode === "hidden" && !K.alternate && !br) return fo(f), null;
          } else 2 * Un() - j.renderingStartTime > If && x !== 1073741824 && (f.flags |= 128, _ = !0, dp(j, !1), f.lanes = 4194304);
          j.isBackwards ? (K.sibling = f.child, f.child = K) : (x = j.last, x !== null ? x.sibling = K : f.child = K, j.last = K);
        }
        return j.tail !== null ? (f = j.tail, j.rendering = f, j.tail = f.sibling, j.renderingStartTime = Un(), f.sibling = null, x = Mr.current, gr(Mr, _ ? x & 1 | 2 : x & 1), f) : (fo(f), null);
      case 22:
      case 23:
        return Kv(), _ = f.memoizedState !== null, u !== null && u.memoizedState !== null !== _ && (f.flags |= 8192), _ && f.mode & 1 ? Os & 1073741824 && (fo(f), f.subtreeFlags & 6 && (f.flags |= 8192)) : fo(f), null;
      case 24:
        return null;
      case 25:
        return null;
    }
    throw Error(t(156, f.tag));
  }
  function Ab(u, f) {
    switch (Ag(f), f.tag) {
      case 1:
        return di(f.type) && hl(), u = f.flags, u & 65536 ? (f.flags = u & -65537 | 128, f) : null;
      case 3:
        return vf(), cr(ui), cr(Wr), ep(), u = f.flags, u & 65536 && !(u & 128) ? (f.flags = u & -65537 | 128, f) : null;
      case 5:
        return kv(f), null;
      case 13:
        if (cr(Mr), u = f.memoizedState, u !== null && u.dehydrated !== null) {
          if (f.alternate === null) throw Error(t(340));
          Ql();
        }
        return u = f.flags, u & 65536 ? (f.flags = u & -65537 | 128, f) : null;
      case 19:
        return cr(Mr), null;
      case 4:
        return vf(), null;
      case 10:
        return Cv(f.type._context), null;
      case 22:
      case 23:
        return Kv(), null;
      case 24:
        return null;
      default:
        return null;
    }
  }
  var id = !1, Gi = !1, lP = typeof WeakSet == "function" ? WeakSet : Set, vt = null;
  function Xc(u, f) {
    var x = u.ref;
    if (x !== null) if (typeof x == "function") try {
      x(null);
    } catch (_) {
      Gr(u, f, _);
    }
    else x.current = null;
  }
  function $v(u, f, x) {
    try {
      x();
    } catch (_) {
      Gr(u, f, _);
    }
  }
  var Bv = !1;
  function cP(u, f) {
    if (Ku = pe, u = Nc(), of(u)) {
      if ("selectionStart" in u) var x = { start: u.selectionStart, end: u.selectionEnd };
      else e: {
        x = (x = u.ownerDocument) && x.defaultView || window;
        var _ = x.getSelection && x.getSelection();
        if (_ && _.rangeCount !== 0) {
          x = _.anchorNode;
          var A = _.anchorOffset, j = _.focusNode;
          _ = _.focusOffset;
          try {
            x.nodeType, j.nodeType;
          } catch {
            x = null;
            break e;
          }
          var K = 0, ee = -1, ae = -1, Te = 0, He = 0, Ke = u, Be = null;
          t: for (; ; ) {
            for (var dt; Ke !== x || A !== 0 && Ke.nodeType !== 3 || (ee = K + A), Ke !== j || _ !== 0 && Ke.nodeType !== 3 || (ae = K + _), Ke.nodeType === 3 && (K += Ke.nodeValue.length), (dt = Ke.firstChild) !== null; )
              Be = Ke, Ke = dt;
            for (; ; ) {
              if (Ke === u) break t;
              if (Be === x && ++Te === A && (ee = K), Be === j && ++He === _ && (ae = K), (dt = Ke.nextSibling) !== null) break;
              Ke = Be, Be = Ke.parentNode;
            }
            Ke = dt;
          }
          x = ee === -1 || ae === -1 ? null : { start: ee, end: ae };
        } else x = null;
      }
      x = x || { start: 0, end: 0 };
    } else x = null;
    for (Kh = { focusedElem: u, selectionRange: x }, pe = !1, vt = f; vt !== null; ) if (f = vt, u = f.child, (f.subtreeFlags & 1028) !== 0 && u !== null) u.return = f, vt = u;
    else for (; vt !== null; ) {
      f = vt;
      try {
        var St = f.alternate;
        if (f.flags & 1024) switch (f.tag) {
          case 0:
          case 11:
          case 15:
            break;
          case 1:
            if (St !== null) {
              var Ct = St.memoizedProps, ni = St.memoizedState, ye = f.stateNode, de = ye.getSnapshotBeforeUpdate(f.elementType === f.type ? Ct : es(f.type, Ct), ni);
              ye.__reactInternalSnapshotBeforeUpdate = de;
            }
            break;
          case 3:
            var Ce = f.stateNode.containerInfo;
            Ce.nodeType === 1 ? Ce.textContent = "" : Ce.nodeType === 9 && Ce.documentElement && Ce.removeChild(Ce.documentElement);
            break;
          case 5:
          case 6:
          case 4:
          case 17:
            break;
          default:
            throw Error(t(163));
        }
      } catch (Ye) {
        Gr(f, f.return, Ye);
      }
      if (u = f.sibling, u !== null) {
        u.return = f.return, vt = u;
        break;
      }
      vt = f.return;
    }
    return St = Bv, Bv = !1, St;
  }
  function _f(u, f, x) {
    var _ = f.updateQueue;
    if (_ = _ !== null ? _.lastEffect : null, _ !== null) {
      var A = _ = _.next;
      do {
        if ((A.tag & u) === u) {
          var j = A.destroy;
          A.destroy = void 0, j !== void 0 && $v(f, x, j);
        }
        A = A.next;
      } while (A !== _);
    }
  }
  function cm(u, f) {
    if (f = f.updateQueue, f = f !== null ? f.lastEffect : null, f !== null) {
      var x = f = f.next;
      do {
        if ((x.tag & u) === u) {
          var _ = x.create;
          x.destroy = _();
        }
        x = x.next;
      } while (x !== f);
    }
  }
  function um(u) {
    var f = u.ref;
    if (f !== null) {
      var x = u.stateNode;
      switch (u.tag) {
        case 5:
          u = x;
          break;
        default:
          u = x;
      }
      typeof f == "function" ? f(u) : f.current = u;
    }
  }
  function Db(u) {
    var f = u.alternate;
    f !== null && (u.alternate = null, Db(f)), u.child = null, u.deletions = null, u.sibling = null, u.tag === 5 && (f = u.stateNode, f !== null && (delete f[Js], delete f[Wh], delete f[hv], delete f[pv], delete f[hf])), u.stateNode = null, u.return = null, u.dependencies = null, u.memoizedProps = null, u.memoizedState = null, u.pendingProps = null, u.stateNode = null, u.updateQueue = null;
  }
  function dm(u) {
    return u.tag === 5 || u.tag === 3 || u.tag === 4;
  }
  function fp(u) {
    e: for (; ; ) {
      for (; u.sibling === null; ) {
        if (u.return === null || dm(u.return)) return null;
        u = u.return;
      }
      for (u.sibling.return = u.return, u = u.sibling; u.tag !== 5 && u.tag !== 6 && u.tag !== 18; ) {
        if (u.flags & 2 || u.child === null || u.tag === 4) continue e;
        u.child.return = u, u = u.child;
      }
      if (!(u.flags & 2)) return u.stateNode;
    }
  }
  function yl(u, f, x) {
    var _ = u.tag;
    if (_ === 5 || _ === 6) u = u.stateNode, f ? x.nodeType === 8 ? x.parentNode.insertBefore(u, f) : x.insertBefore(u, f) : (x.nodeType === 8 ? (f = x.parentNode, f.insertBefore(u, x)) : (f = x, f.appendChild(u)), x = x._reactRootContainer, x != null || f.onclick !== null || (f.onclick = Tg));
    else if (_ !== 4 && (u = u.child, u !== null)) for (yl(u, f, x), u = u.sibling; u !== null; ) yl(u, f, x), u = u.sibling;
  }
  function vl(u, f, x) {
    var _ = u.tag;
    if (_ === 5 || _ === 6) u = u.stateNode, f ? x.insertBefore(u, f) : x.appendChild(u);
    else if (_ !== 4 && (u = u.child, u !== null)) for (vl(u, f, x), u = u.sibling; u !== null; ) vl(u, f, x), u = u.sibling;
  }
  var Ar = null, Co = !1;
  function ia(u, f, x) {
    for (x = x.child; x !== null; ) ec(u, f, x), x = x.sibling;
  }
  function ec(u, f, x) {
    if (so && typeof so.onCommitFiberUnmount == "function") try {
      so.onCommitFiberUnmount(al, x);
    } catch {
    }
    switch (x.tag) {
      case 5:
        Gi || Xc(x, f);
      case 6:
        var _ = Ar, A = Co;
        Ar = null, ia(u, f, x), Ar = _, Co = A, Ar !== null && (Co ? (u = Ar, x = x.stateNode, u.nodeType === 8 ? u.parentNode.removeChild(x) : u.removeChild(x)) : Ar.removeChild(x.stateNode));
        break;
      case 18:
        Ar !== null && (Co ? (u = Ar, x = x.stateNode, u.nodeType === 8 ? df(u.parentNode, x) : u.nodeType === 1 && df(u, x), qo(u)) : df(Ar, x.stateNode));
        break;
      case 4:
        _ = Ar, A = Co, Ar = x.stateNode.containerInfo, Co = !0, ia(u, f, x), Ar = _, Co = A;
        break;
      case 0:
      case 11:
      case 14:
      case 15:
        if (!Gi && (_ = x.updateQueue, _ !== null && (_ = _.lastEffect, _ !== null))) {
          A = _ = _.next;
          do {
            var j = A, K = j.destroy;
            j = j.tag, K !== void 0 && (j & 2 || j & 4) && $v(x, f, K), A = A.next;
          } while (A !== _);
        }
        ia(u, f, x);
        break;
      case 1:
        if (!Gi && (Xc(x, f), _ = x.stateNode, typeof _.componentWillUnmount == "function")) try {
          _.props = x.memoizedProps, _.state = x.memoizedState, _.componentWillUnmount();
        } catch (ee) {
          Gr(x, f, ee);
        }
        ia(u, f, x);
        break;
      case 21:
        ia(u, f, x);
        break;
      case 22:
        x.mode & 1 ? (Gi = (_ = Gi) || x.memoizedState !== null, ia(u, f, x), Gi = _) : ia(u, f, x);
        break;
      default:
        ia(u, f, x);
    }
  }
  function Ob(u) {
    var f = u.updateQueue;
    if (f !== null) {
      u.updateQueue = null;
      var x = u.stateNode;
      x === null && (x = u.stateNode = new lP()), f.forEach(function(_) {
        var A = pP.bind(null, u, _);
        x.has(_) || (x.add(_), _.then(A, A));
      });
    }
  }
  function $a(u, f) {
    var x = f.deletions;
    if (x !== null) for (var _ = 0; _ < x.length; _++) {
      var A = x[_];
      try {
        var j = u, K = f, ee = K;
        e: for (; ee !== null; ) {
          switch (ee.tag) {
            case 5:
              Ar = ee.stateNode, Co = !1;
              break e;
            case 3:
              Ar = ee.stateNode.containerInfo, Co = !0;
              break e;
            case 4:
              Ar = ee.stateNode.containerInfo, Co = !0;
              break e;
          }
          ee = ee.return;
        }
        if (Ar === null) throw Error(t(160));
        ec(j, K, A), Ar = null, Co = !1;
        var ae = A.alternate;
        ae !== null && (ae.return = null), A.return = null;
      } catch (Te) {
        Gr(A, f, Te);
      }
    }
    if (f.subtreeFlags & 12854) for (f = f.child; f !== null; ) jb(f, u), f = f.sibling;
  }
  function jb(u, f) {
    var x = u.alternate, _ = u.flags;
    switch (u.tag) {
      case 0:
      case 11:
      case 14:
      case 15:
        if ($a(f, u), Ba(u), _ & 4) {
          try {
            _f(3, u, u.return), cm(3, u);
          } catch (Ct) {
            Gr(u, u.return, Ct);
          }
          try {
            _f(5, u, u.return);
          } catch (Ct) {
            Gr(u, u.return, Ct);
          }
        }
        break;
      case 1:
        $a(f, u), Ba(u), _ & 512 && x !== null && Xc(x, x.return);
        break;
      case 5:
        if ($a(f, u), Ba(u), _ & 512 && x !== null && Xc(x, x.return), u.flags & 32) {
          var A = u.stateNode;
          try {
            Ee(A, "");
          } catch (Ct) {
            Gr(u, u.return, Ct);
          }
        }
        if (_ & 4 && (A = u.stateNode, A != null)) {
          var j = u.memoizedProps, K = x !== null ? x.memoizedProps : j, ee = u.type, ae = u.updateQueue;
          if (u.updateQueue = null, ae !== null) try {
            ee === "input" && j.type === "radio" && j.name != null && Yt(A, j), Rn(ee, K);
            var Te = Rn(ee, j);
            for (K = 0; K < ae.length; K += 2) {
              var He = ae[K], Ke = ae[K + 1];
              He === "style" ? cn(A, Ke) : He === "dangerouslySetInnerHTML" ? Ko(A, Ke) : He === "children" ? Ee(A, Ke) : L(A, He, Ke, Te);
            }
            switch (ee) {
              case "input":
                Gn(A, j);
                break;
              case "textarea":
                si(A, j);
                break;
              case "select":
                var Be = A._wrapperState.wasMultiple;
                A._wrapperState.wasMultiple = !!j.multiple;
                var dt = j.value;
                dt != null ? wr(A, !!j.multiple, dt, !1) : Be !== !!j.multiple && (j.defaultValue != null ? wr(
                  A,
                  !!j.multiple,
                  j.defaultValue,
                  !0
                ) : wr(A, !!j.multiple, j.multiple ? [] : "", !1));
            }
            A[Wh] = j;
          } catch (Ct) {
            Gr(u, u.return, Ct);
          }
        }
        break;
      case 6:
        if ($a(f, u), Ba(u), _ & 4) {
          if (u.stateNode === null) throw Error(t(162));
          A = u.stateNode, j = u.memoizedProps;
          try {
            A.nodeValue = j;
          } catch (Ct) {
            Gr(u, u.return, Ct);
          }
        }
        break;
      case 3:
        if ($a(f, u), Ba(u), _ & 4 && x !== null && x.memoizedState.isDehydrated) try {
          qo(f.containerInfo);
        } catch (Ct) {
          Gr(u, u.return, Ct);
        }
        break;
      case 4:
        $a(f, u), Ba(u);
        break;
      case 13:
        $a(f, u), Ba(u), A = u.child, A.flags & 8192 && (j = A.memoizedState !== null, A.stateNode.isHidden = j, !j || A.alternate !== null && A.alternate.memoizedState !== null || (Vv = Un())), _ & 4 && Ob(u);
        break;
      case 22:
        if (He = x !== null && x.memoizedState !== null, u.mode & 1 ? (Gi = (Te = Gi) || He, $a(f, u), Gi = Te) : $a(f, u), Ba(u), _ & 8192) {
          if (Te = u.memoizedState !== null, (u.stateNode.isHidden = Te) && !He && u.mode & 1) for (vt = u, He = u.child; He !== null; ) {
            for (Ke = vt = He; vt !== null; ) {
              switch (Be = vt, dt = Be.child, Be.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                  _f(4, Be, Be.return);
                  break;
                case 1:
                  Xc(Be, Be.return);
                  var St = Be.stateNode;
                  if (typeof St.componentWillUnmount == "function") {
                    _ = Be, x = Be.return;
                    try {
                      f = _, St.props = f.memoizedProps, St.state = f.memoizedState, St.componentWillUnmount();
                    } catch (Ct) {
                      Gr(_, x, Ct);
                    }
                  }
                  break;
                case 5:
                  Xc(Be, Be.return);
                  break;
                case 22:
                  if (Be.memoizedState !== null) {
                    Nb(Ke);
                    continue;
                  }
              }
              dt !== null ? (dt.return = Be, vt = dt) : Nb(Ke);
            }
            He = He.sibling;
          }
          e: for (He = null, Ke = u; ; ) {
            if (Ke.tag === 5) {
              if (He === null) {
                He = Ke;
                try {
                  A = Ke.stateNode, Te ? (j = A.style, typeof j.setProperty == "function" ? j.setProperty("display", "none", "important") : j.display = "none") : (ee = Ke.stateNode, ae = Ke.memoizedProps.style, K = ae != null && ae.hasOwnProperty("display") ? ae.display : null, ee.style.display = mt("display", K));
                } catch (Ct) {
                  Gr(u, u.return, Ct);
                }
              }
            } else if (Ke.tag === 6) {
              if (He === null) try {
                Ke.stateNode.nodeValue = Te ? "" : Ke.memoizedProps;
              } catch (Ct) {
                Gr(u, u.return, Ct);
              }
            } else if ((Ke.tag !== 22 && Ke.tag !== 23 || Ke.memoizedState === null || Ke === u) && Ke.child !== null) {
              Ke.child.return = Ke, Ke = Ke.child;
              continue;
            }
            if (Ke === u) break e;
            for (; Ke.sibling === null; ) {
              if (Ke.return === null || Ke.return === u) break e;
              He === Ke && (He = null), Ke = Ke.return;
            }
            He === Ke && (He = null), Ke.sibling.return = Ke.return, Ke = Ke.sibling;
          }
        }
        break;
      case 19:
        $a(f, u), Ba(u), _ & 4 && Ob(u);
        break;
      case 21:
        break;
      default:
        $a(
          f,
          u
        ), Ba(u);
    }
  }
  function Ba(u) {
    var f = u.flags;
    if (f & 2) {
      try {
        e: {
          for (var x = u.return; x !== null; ) {
            if (dm(x)) {
              var _ = x;
              break e;
            }
            x = x.return;
          }
          throw Error(t(160));
        }
        switch (_.tag) {
          case 5:
            var A = _.stateNode;
            _.flags & 32 && (Ee(A, ""), _.flags &= -33);
            var j = fp(u);
            vl(u, j, A);
            break;
          case 3:
          case 4:
            var K = _.stateNode.containerInfo, ee = fp(u);
            yl(u, ee, K);
            break;
          default:
            throw Error(t(161));
        }
      } catch (ae) {
        Gr(u, u.return, ae);
      }
      u.flags &= -3;
    }
    f & 4096 && (u.flags &= -4097);
  }
  function hp(u, f, x) {
    vt = u, Lb(u);
  }
  function Lb(u, f, x) {
    for (var _ = (u.mode & 1) !== 0; vt !== null; ) {
      var A = vt, j = A.child;
      if (A.tag === 22 && _) {
        var K = A.memoizedState !== null || id;
        if (!K) {
          var ee = A.alternate, ae = ee !== null && ee.memoizedState !== null || Gi;
          ee = id;
          var Te = Gi;
          if (id = K, (Gi = ae) && !Te) for (vt = A; vt !== null; ) K = vt, ae = K.child, K.tag === 22 && K.memoizedState !== null ? pp(A) : ae !== null ? (ae.return = K, vt = ae) : pp(A);
          for (; j !== null; ) vt = j, Lb(j), j = j.sibling;
          vt = A, id = ee, Gi = Te;
        }
        Hv(u);
      } else A.subtreeFlags & 8772 && j !== null ? (j.return = A, vt = j) : Hv(u);
    }
  }
  function Hv(u) {
    for (; vt !== null; ) {
      var f = vt;
      if (f.flags & 8772) {
        var x = f.alternate;
        try {
          if (f.flags & 8772) switch (f.tag) {
            case 0:
            case 11:
            case 15:
              Gi || cm(5, f);
              break;
            case 1:
              var _ = f.stateNode;
              if (f.flags & 4 && !Gi) if (x === null) _.componentDidMount();
              else {
                var A = f.elementType === f.type ? x.memoizedProps : es(f.type, x.memoizedProps);
                _.componentDidUpdate(A, x.memoizedState, _.__reactInternalSnapshotBeforeUpdate);
              }
              var j = f.updateQueue;
              j !== null && Pv(f, j, _);
              break;
            case 3:
              var K = f.updateQueue;
              if (K !== null) {
                if (x = null, f.child !== null) switch (f.child.tag) {
                  case 5:
                    x = f.child.stateNode;
                    break;
                  case 1:
                    x = f.child.stateNode;
                }
                Pv(f, K, x);
              }
              break;
            case 5:
              var ee = f.stateNode;
              if (x === null && f.flags & 4) {
                x = ee;
                var ae = f.memoizedProps;
                switch (f.type) {
                  case "button":
                  case "input":
                  case "select":
                  case "textarea":
                    ae.autoFocus && x.focus();
                    break;
                  case "img":
                    ae.src && (x.src = ae.src);
                }
              }
              break;
            case 6:
              break;
            case 4:
              break;
            case 12:
              break;
            case 13:
              if (f.memoizedState === null) {
                var Te = f.alternate;
                if (Te !== null) {
                  var He = Te.memoizedState;
                  if (He !== null) {
                    var Ke = He.dehydrated;
                    Ke !== null && qo(Ke);
                  }
                }
              }
              break;
            case 19:
            case 17:
            case 21:
            case 22:
            case 23:
            case 25:
              break;
            default:
              throw Error(t(163));
          }
          Gi || f.flags & 512 && um(f);
        } catch (Be) {
          Gr(f, f.return, Be);
        }
      }
      if (f === u) {
        vt = null;
        break;
      }
      if (x = f.sibling, x !== null) {
        x.return = f.return, vt = x;
        break;
      }
      vt = f.return;
    }
  }
  function Nb(u) {
    for (; vt !== null; ) {
      var f = vt;
      if (f === u) {
        vt = null;
        break;
      }
      var x = f.sibling;
      if (x !== null) {
        x.return = f.return, vt = x;
        break;
      }
      vt = f.return;
    }
  }
  function pp(u) {
    for (; vt !== null; ) {
      var f = vt;
      try {
        switch (f.tag) {
          case 0:
          case 11:
          case 15:
            var x = f.return;
            try {
              cm(4, f);
            } catch (ae) {
              Gr(f, x, ae);
            }
            break;
          case 1:
            var _ = f.stateNode;
            if (typeof _.componentDidMount == "function") {
              var A = f.return;
              try {
                _.componentDidMount();
              } catch (ae) {
                Gr(f, A, ae);
              }
            }
            var j = f.return;
            try {
              um(f);
            } catch (ae) {
              Gr(f, j, ae);
            }
            break;
          case 5:
            var K = f.return;
            try {
              um(f);
            } catch (ae) {
              Gr(f, K, ae);
            }
        }
      } catch (ae) {
        Gr(f, f.return, ae);
      }
      if (f === u) {
        vt = null;
        break;
      }
      var ee = f.sibling;
      if (ee !== null) {
        ee.return = f.return, vt = ee;
        break;
      }
      vt = f.return;
    }
  }
  var Fb = Math.ceil, fm = O.ReactCurrentDispatcher, od = O.ReactCurrentOwner, ho = O.ReactCurrentBatchConfig, xn = 0, pi = null, ti = null, qi = 0, Os = 0, Pf = Xo(0), wi = 0, sd = null, ad = 0, ld = 0, gp = 0, Tf = null, rs = null, Vv = 0, If = 1 / 0, tc = null, Zc = !1, mp = null, oa = null, hm = !1, Qc = null, yp = 0, kf = 0, Rf = null, cd = -1, vp = 0;
  function mr() {
    return xn & 6 ? Un() : cd !== -1 ? cd : cd = Un();
  }
  function js(u) {
    return u.mode & 1 ? xn & 2 && qi !== 0 ? qi & -qi : Xu.transition !== null ? (vp === 0 && (vp = Bl()), vp) : (u = dn, u !== 0 || (u = window.event, u = u === void 0 ? 16 : Rr(u.type)), u) : 1;
  }
  function Ls(u, f, x, _) {
    if (50 < kf) throw kf = 0, Rf = null, Error(t(185));
    ul(u, x, _), (!(xn & 2) || u !== pi) && (u === pi && (!(xn & 2) && (ld |= x), wi === 4 && Jc(u, qi)), Fi(u, _), x === 1 && xn === 0 && !(f.mode & 1) && (If = Un() + 500, qh && wo()));
  }
  function Fi(u, f) {
    var x = u.callbackNode;
    Ac(u, f);
    var _ = _s(u, u === pi ? qi : 0);
    if (_ === 0) x !== null && zn(x), u.callbackNode = null, u.callbackPriority = 0;
    else if (f = _ & -_, u.callbackPriority !== f) {
      if (x != null && zn(x), f === 1) u.tag === 0 ? gv(bp.bind(null, u)) : zc(bp.bind(null, u)), oP(function() {
        !(xn & 6) && wo();
      }), x = null;
      else {
        switch (Zs(_)) {
          case 1:
            x = Gt;
            break;
          case 4:
            x = xo;
            break;
          case 16:
            x = Aa;
            break;
          case 536870912:
            x = Ai;
            break;
          default:
            x = Aa;
        }
        x = Vb(x, zb.bind(null, u));
      }
      u.callbackPriority = f, u.callbackNode = x;
    }
  }
  function zb(u, f) {
    if (cd = -1, vp = 0, xn & 6) throw Error(t(327));
    var x = u.callbackNode;
    if (Mf() && u.callbackNode !== x) return null;
    var _ = _s(u, u === pi ? qi : 0);
    if (_ === 0) return null;
    if (_ & 30 || _ & u.expiredLanes || f) f = mm(u, _);
    else {
      f = _;
      var A = xn;
      xn |= 2;
      var j = Ub();
      (pi !== u || qi !== f) && (tc = null, If = Un() + 500, dd(u, f));
      do
        try {
          dP();
          break;
        } catch (ee) {
          gm(u, ee);
        }
      while (!0);
      bv(), fm.current = j, xn = A, ti !== null ? f = 0 : (pi = null, qi = 0, f = wi);
    }
    if (f !== 0) {
      if (f === 2 && (A = Oa(u), A !== 0 && (_ = A, f = Sp(u, A))), f === 1) throw x = sd, dd(u, 0), Jc(u, _), Fi(u, Un()), x;
      if (f === 6) Jc(u, _);
      else {
        if (A = u.current.alternate, !(_ & 30) && !wp(A) && (f = mm(u, _), f === 2 && (j = Oa(u), j !== 0 && (_ = j, f = Sp(u, j))), f === 1)) throw x = sd, dd(u, 0), Jc(u, _), Fi(u, Un()), x;
        switch (u.finishedWork = A, u.finishedLanes = _, f) {
          case 0:
          case 1:
            throw Error(t(345));
          case 2:
            fd(u, rs, tc);
            break;
          case 3:
            if (Jc(u, _), (_ & 130023424) === _ && (f = Vv + 500 - Un(), 10 < f)) {
              if (_s(u, 0) !== 0) break;
              if (A = u.suspendedLanes, (A & _) !== _) {
                mr(), u.pingedLanes |= u.suspendedLanes & A;
                break;
              }
              u.timeoutHandle = Ig(fd.bind(null, u, rs, tc), f);
              break;
            }
            fd(u, rs, tc);
            break;
          case 4:
            if (Jc(u, _), (_ & 4194240) === _) break;
            for (f = u.eventTimes, A = -1; 0 < _; ) {
              var K = 31 - Bi(_);
              j = 1 << K, K = f[K], K > A && (A = K), _ &= ~j;
            }
            if (_ = A, _ = Un() - _, _ = (120 > _ ? 120 : 480 > _ ? 480 : 1080 > _ ? 1080 : 1920 > _ ? 1920 : 3e3 > _ ? 3e3 : 4320 > _ ? 4320 : 1960 * Fb(_ / 1960)) - _, 10 < _) {
              u.timeoutHandle = Ig(fd.bind(null, u, rs, tc), _);
              break;
            }
            fd(u, rs, tc);
            break;
          case 5:
            fd(u, rs, tc);
            break;
          default:
            throw Error(t(329));
        }
      }
    }
    return Fi(u, Un()), u.callbackNode === x ? zb.bind(null, u) : null;
  }
  function Sp(u, f) {
    var x = Tf;
    return u.current.memoizedState.isDehydrated && (dd(u, f).flags |= 256), u = mm(u, f), u !== 2 && (f = rs, rs = x, f !== null && xp(f)), u;
  }
  function xp(u) {
    rs === null ? rs = u : rs.push.apply(rs, u);
  }
  function wp(u) {
    for (var f = u; ; ) {
      if (f.flags & 16384) {
        var x = f.updateQueue;
        if (x !== null && (x = x.stores, x !== null)) for (var _ = 0; _ < x.length; _++) {
          var A = x[_], j = A.getSnapshot;
          A = A.value;
          try {
            if (!La(j(), A)) return !1;
          } catch {
            return !1;
          }
        }
      }
      if (x = f.child, f.subtreeFlags & 16384 && x !== null) x.return = f, f = x;
      else {
        if (f === u) break;
        for (; f.sibling === null; ) {
          if (f.return === null || f.return === u) return !0;
          f = f.return;
        }
        f.sibling.return = f.return, f = f.sibling;
      }
    }
    return !0;
  }
  function Jc(u, f) {
    for (f &= ~gp, f &= ~ld, u.suspendedLanes |= f, u.pingedLanes &= ~f, u = u.expirationTimes; 0 < f; ) {
      var x = 31 - Bi(f), _ = 1 << x;
      u[x] = -1, f &= ~_;
    }
  }
  function bp(u) {
    if (xn & 6) throw Error(t(327));
    Mf();
    var f = _s(u, 0);
    if (!(f & 1)) return Fi(u, Un()), null;
    var x = mm(u, f);
    if (u.tag !== 0 && x === 2) {
      var _ = Oa(u);
      _ !== 0 && (f = _, x = Sp(u, _));
    }
    if (x === 1) throw x = sd, dd(u, 0), Jc(u, f), Fi(u, Un()), x;
    if (x === 6) throw Error(t(345));
    return u.finishedWork = u.current.alternate, u.finishedLanes = f, fd(u, rs, tc), Fi(u, Un()), null;
  }
  function pm(u, f) {
    var x = xn;
    xn |= 1;
    try {
      return u(f);
    } finally {
      xn = x, xn === 0 && (If = Un() + 500, qh && wo());
    }
  }
  function ud(u) {
    Qc !== null && Qc.tag === 0 && !(xn & 6) && Mf();
    var f = xn;
    xn |= 1;
    var x = ho.transition, _ = dn;
    try {
      if (ho.transition = null, dn = 1, u) return u();
    } finally {
      dn = _, ho.transition = x, xn = f, !(xn & 6) && wo();
    }
  }
  function Kv() {
    Os = Pf.current, cr(Pf);
  }
  function dd(u, f) {
    u.finishedWork = null, u.finishedLanes = 0;
    var x = u.timeoutHandle;
    if (x !== -1 && (u.timeoutHandle = -1, fb(x)), ti !== null) for (x = ti.return; x !== null; ) {
      var _ = x;
      switch (Ag(_), _.tag) {
        case 1:
          _ = _.type.childContextTypes, _ != null && hl();
          break;
        case 3:
          vf(), cr(ui), cr(Wr), ep();
          break;
        case 5:
          kv(_);
          break;
        case 4:
          vf();
          break;
        case 13:
          cr(Mr);
          break;
        case 19:
          cr(Mr);
          break;
        case 10:
          Cv(_.type._context);
          break;
        case 22:
        case 23:
          Kv();
      }
      x = x.return;
    }
    if (pi = u, ti = u = eu(u.current, null), qi = Os = f, wi = 0, sd = null, gp = ld = ad = 0, rs = Tf = null, Zu !== null) {
      for (f = 0; f < Zu.length; f++) if (x = Zu[f], _ = x.interleaved, _ !== null) {
        x.interleaved = null;
        var A = _.next, j = x.pending;
        if (j !== null) {
          var K = j.next;
          j.next = A, _.next = K;
        }
        x.pending = _;
      }
      Zu = null;
    }
    return u;
  }
  function gm(u, f) {
    do {
      var x = ti;
      try {
        if (bv(), Mt.current = ir, Lg) {
          for (var _ = Jt.memoizedState; _ !== null; ) {
            var A = _.queue;
            A !== null && (A.pending = null), _ = _.next;
          }
          Lg = !1;
        }
        if (_n = 0, Si = ur = Jt = null, tp = !1, np = 0, od.current = null, x === null || x.return === null) {
          wi = 1, sd = f, ti = null;
          break;
        }
        e: {
          var j = u, K = x.return, ee = x, ae = f;
          if (f = qi, ee.flags |= 32768, ae !== null && typeof ae == "object" && typeof ae.then == "function") {
            var Te = ae, He = ee, Ke = He.tag;
            if (!(He.mode & 1) && (Ke === 0 || Ke === 11 || Ke === 15)) {
              var Be = He.alternate;
              Be ? (He.updateQueue = Be.updateQueue, He.memoizedState = Be.memoizedState, He.lanes = Be.lanes) : (He.updateQueue = null, He.memoizedState = null);
            }
            var dt = Lv(K);
            if (dt !== null) {
              dt.flags &= -257, Ib(dt, K, ee, j, f), dt.mode & 1 && jv(j, Te, f), f = dt, ae = Te;
              var St = f.updateQueue;
              if (St === null) {
                var Ct = /* @__PURE__ */ new Set();
                Ct.add(ae), f.updateQueue = Ct;
              } else St.add(ae);
              break e;
            } else {
              if (!(f & 1)) {
                jv(j, Te, f), Wv();
                break e;
              }
              ae = Error(t(426));
            }
          } else if (br && ee.mode & 1) {
            var ni = Lv(K);
            if (ni !== null) {
              !(ni.flags & 65536) && (ni.flags |= 256), Ib(ni, K, ee, j, f), Xh(Yc(ae, ee));
              break e;
            }
          }
          j = ae = Yc(ae, ee), wi !== 4 && (wi = 2), Tf === null ? Tf = [j] : Tf.push(j), j = K;
          do {
            switch (j.tag) {
              case 3:
                j.flags |= 65536, f &= -f, j.lanes |= f;
                var ye = lp(j, ae, f);
                wb(j, ye);
                break e;
              case 1:
                ee = ae;
                var de = j.type, Ce = j.stateNode;
                if (!(j.flags & 128) && (typeof de.getDerivedStateFromError == "function" || Ce !== null && typeof Ce.componentDidCatch == "function" && (oa === null || !oa.has(Ce)))) {
                  j.flags |= 65536, f &= -f, j.lanes |= f;
                  var Ye = Tb(j, ee, f);
                  wb(j, Ye);
                  break e;
                }
            }
            j = j.return;
          } while (j !== null);
        }
        $b(x);
      } catch (_t) {
        f = _t, ti === x && x !== null && (ti = x = x.return);
        continue;
      }
      break;
    } while (!0);
  }
  function Ub() {
    var u = fm.current;
    return fm.current = ir, u === null ? ir : u;
  }
  function Wv() {
    (wi === 0 || wi === 3 || wi === 2) && (wi = 4), pi === null || !(ad & 268435455) && !(ld & 268435455) || Jc(pi, qi);
  }
  function mm(u, f) {
    var x = xn;
    xn |= 2;
    var _ = Ub();
    (pi !== u || qi !== f) && (tc = null, dd(u, f));
    do
      try {
        uP();
        break;
      } catch (A) {
        gm(u, A);
      }
    while (!0);
    if (bv(), xn = x, fm.current = _, ti !== null) throw Error(t(261));
    return pi = null, qi = 0, wi;
  }
  function uP() {
    for (; ti !== null; ) Gv(ti);
  }
  function dP() {
    for (; ti !== null && !Mi(); ) Gv(ti);
  }
  function Gv(u) {
    var f = Yv(u.alternate, u, Os);
    u.memoizedProps = u.pendingProps, f === null ? $b(u) : ti = f, od.current = null;
  }
  function $b(u) {
    var f = u;
    do {
      var x = f.alternate;
      if (u = f.return, f.flags & 32768) {
        if (x = Ab(x, f), x !== null) {
          x.flags &= 32767, ti = x;
          return;
        }
        if (u !== null) u.flags |= 32768, u.subtreeFlags = 0, u.deletions = null;
        else {
          wi = 6, ti = null;
          return;
        }
      } else if (x = Uv(x, f, Os), x !== null) {
        ti = x;
        return;
      }
      if (f = f.sibling, f !== null) {
        ti = f;
        return;
      }
      ti = f = u;
    } while (f !== null);
    wi === 0 && (wi = 5);
  }
  function fd(u, f, x) {
    var _ = dn, A = ho.transition;
    try {
      ho.transition = null, dn = 1, fP(u, f, x, _);
    } finally {
      ho.transition = A, dn = _;
    }
    return null;
  }
  function fP(u, f, x, _) {
    do
      Mf();
    while (Qc !== null);
    if (xn & 6) throw Error(t(327));
    x = u.finishedWork;
    var A = u.finishedLanes;
    if (x === null) return null;
    if (u.finishedWork = null, u.finishedLanes = 0, x === u.current) throw Error(t(177));
    u.callbackNode = null, u.callbackPriority = 0;
    var j = x.lanes | x.childLanes;
    if (Uu(u, j), u === pi && (ti = pi = null, qi = 0), !(x.subtreeFlags & 2064) && !(x.flags & 2064) || hm || (hm = !0, Vb(Aa, function() {
      return Mf(), null;
    })), j = (x.flags & 15990) !== 0, x.subtreeFlags & 15990 || j) {
      j = ho.transition, ho.transition = null;
      var K = dn;
      dn = 1;
      var ee = xn;
      xn |= 4, od.current = null, cP(u, x), jb(x, u), rb(Kh), pe = !!Ku, Kh = Ku = null, u.current = x, hp(x), Es(), xn = ee, dn = K, ho.transition = j;
    } else u.current = x;
    if (hm && (hm = !1, Qc = u, yp = A), j = u.pendingLanes, j === 0 && (oa = null), Fu(x.stateNode), Fi(u, Un()), f !== null) for (_ = u.onRecoverableError, x = 0; x < f.length; x++) A = f[x], _(A.value, { componentStack: A.stack, digest: A.digest });
    if (Zc) throw Zc = !1, u = mp, mp = null, u;
    return yp & 1 && u.tag !== 0 && Mf(), j = u.pendingLanes, j & 1 ? u === Rf ? kf++ : (kf = 0, Rf = u) : kf = 0, wo(), null;
  }
  function Mf() {
    if (Qc !== null) {
      var u = Zs(yp), f = ho.transition, x = dn;
      try {
        if (ho.transition = null, dn = 16 > u ? 16 : u, Qc === null) var _ = !1;
        else {
          if (u = Qc, Qc = null, yp = 0, xn & 6) throw Error(t(331));
          var A = xn;
          for (xn |= 4, vt = u.current; vt !== null; ) {
            var j = vt, K = j.child;
            if (vt.flags & 16) {
              var ee = j.deletions;
              if (ee !== null) {
                for (var ae = 0; ae < ee.length; ae++) {
                  var Te = ee[ae];
                  for (vt = Te; vt !== null; ) {
                    var He = vt;
                    switch (He.tag) {
                      case 0:
                      case 11:
                      case 15:
                        _f(8, He, j);
                    }
                    var Ke = He.child;
                    if (Ke !== null) Ke.return = He, vt = Ke;
                    else for (; vt !== null; ) {
                      He = vt;
                      var Be = He.sibling, dt = He.return;
                      if (Db(He), He === Te) {
                        vt = null;
                        break;
                      }
                      if (Be !== null) {
                        Be.return = dt, vt = Be;
                        break;
                      }
                      vt = dt;
                    }
                  }
                }
                var St = j.alternate;
                if (St !== null) {
                  var Ct = St.child;
                  if (Ct !== null) {
                    St.child = null;
                    do {
                      var ni = Ct.sibling;
                      Ct.sibling = null, Ct = ni;
                    } while (Ct !== null);
                  }
                }
                vt = j;
              }
            }
            if (j.subtreeFlags & 2064 && K !== null) K.return = j, vt = K;
            else e: for (; vt !== null; ) {
              if (j = vt, j.flags & 2048) switch (j.tag) {
                case 0:
                case 11:
                case 15:
                  _f(9, j, j.return);
              }
              var ye = j.sibling;
              if (ye !== null) {
                ye.return = j.return, vt = ye;
                break e;
              }
              vt = j.return;
            }
          }
          var de = u.current;
          for (vt = de; vt !== null; ) {
            K = vt;
            var Ce = K.child;
            if (K.subtreeFlags & 2064 && Ce !== null) Ce.return = K, vt = Ce;
            else e: for (K = de; vt !== null; ) {
              if (ee = vt, ee.flags & 2048) try {
                switch (ee.tag) {
                  case 0:
                  case 11:
                  case 15:
                    cm(9, ee);
                }
              } catch (_t) {
                Gr(ee, ee.return, _t);
              }
              if (ee === K) {
                vt = null;
                break e;
              }
              var Ye = ee.sibling;
              if (Ye !== null) {
                Ye.return = ee.return, vt = Ye;
                break e;
              }
              vt = ee.return;
            }
          }
          if (xn = A, wo(), so && typeof so.onPostCommitFiberRoot == "function") try {
            so.onPostCommitFiberRoot(al, u);
          } catch {
          }
          _ = !0;
        }
        return _;
      } finally {
        dn = x, ho.transition = f;
      }
    }
    return !1;
  }
  function Bb(u, f, x) {
    f = Yc(x, f), f = lp(u, f, 1), u = Kc(u, f, 1), f = mr(), u !== null && (ul(u, 1, f), Fi(u, f));
  }
  function Gr(u, f, x) {
    if (u.tag === 3) Bb(u, u, x);
    else for (; f !== null; ) {
      if (f.tag === 3) {
        Bb(f, u, x);
        break;
      } else if (f.tag === 1) {
        var _ = f.stateNode;
        if (typeof f.type.getDerivedStateFromError == "function" || typeof _.componentDidCatch == "function" && (oa === null || !oa.has(_))) {
          u = Yc(x, u), u = Tb(f, u, 1), f = Kc(f, u, 1), u = mr(), f !== null && (ul(f, 1, u), Fi(f, u));
          break;
        }
      }
      f = f.return;
    }
  }
  function qv(u, f, x) {
    var _ = u.pingCache;
    _ !== null && _.delete(f), f = mr(), u.pingedLanes |= u.suspendedLanes & x, pi === u && (qi & x) === x && (wi === 4 || wi === 3 && (qi & 130023424) === qi && 500 > Un() - Vv ? dd(u, 0) : gp |= x), Fi(u, f);
  }
  function Hb(u, f) {
    f === 0 && (u.mode & 1 ? (f = Go, Go <<= 1, !(Go & 130023424) && (Go = 4194304)) : f = 1);
    var x = mr();
    u = gl(u, f), u !== null && (ul(u, f, x), Fi(u, x));
  }
  function hP(u) {
    var f = u.memoizedState, x = 0;
    f !== null && (x = f.retryLane), Hb(u, x);
  }
  function pP(u, f) {
    var x = 0;
    switch (u.tag) {
      case 13:
        var _ = u.stateNode, A = u.memoizedState;
        A !== null && (x = A.retryLane);
        break;
      case 19:
        _ = u.stateNode;
        break;
      default:
        throw Error(t(314));
    }
    _ !== null && _.delete(f), Hb(u, x);
  }
  var Yv;
  Yv = function(u, f, x) {
    if (u !== null) if (u.memoizedProps !== f.pendingProps || ui.current) Ni = !0;
    else {
      if (!(u.lanes & x) && !(f.flags & 128)) return Ni = !1, lm(u, f, x);
      Ni = !!(u.flags & 131072);
    }
    else Ni = !1, br && f.flags & 1048576 && pb(f, Bc, f.index);
    switch (f.lanes = 0, f.tag) {
      case 2:
        var _ = f.type;
        ra(u, f), u = f.pendingProps;
        var A = Rs(f, Wr.current);
        mf(f, x), A = Nt(null, f, _, u, A, x);
        var j = Wc();
        return f.flags |= 1, typeof A == "object" && A !== null && typeof A.render == "function" && A.$$typeof === void 0 ? (f.tag = 1, f.memoizedState = null, f.updateQueue = null, di(_) ? (j = !0, qu(f)) : j = !1, f.memoizedState = A.state !== null && A.state !== void 0 ? A.state : null, Vc(f), A.updater = Jg, f.stateNode = A, A._reactInternals = f, Dv(f, _, u, x), f = Nv(null, f, _, !0, j, x)) : (f.tag = 0, br && j && mv(f), ei(null, f, A, x), f = f.child), f;
      case 16:
        _ = f.elementType;
        e: {
          switch (ra(u, f), u = f.pendingProps, A = _._init, _ = A(_._payload), f.type = _, A = f.tag = mP(_), u = es(_, u), A) {
            case 0:
              f = rm(null, f, _, u, x);
              break e;
            case 1:
              f = aP(null, f, _, u, x);
              break e;
            case 11:
              f = nm(null, f, _, u, x);
              break e;
            case 14:
              f = ts(null, f, _, es(_.type, u), x);
              break e;
          }
          throw Error(t(
            306,
            _,
            ""
          ));
        }
        return f;
      case 0:
        return _ = f.type, A = f.pendingProps, A = f.elementType === _ ? A : es(_, A), rm(u, f, _, A, x);
      case 1:
        return _ = f.type, A = f.pendingProps, A = f.elementType === _ ? A : es(_, A), aP(u, f, _, A, x);
      case 3:
        e: {
          if (im(f), u === null) throw Error(t(387));
          _ = f.pendingProps, j = f.memoizedState, A = j.element, xb(u, f), Og(f, _, null, x);
          var K = f.memoizedState;
          if (_ = K.element, j.isDehydrated) if (j = { element: _, isDehydrated: !1, cache: K.cache, pendingSuspenseBoundaries: K.pendingSuspenseBoundaries, transitions: K.transitions }, f.updateQueue.baseState = j, f.memoizedState = j, f.flags & 256) {
            A = Yc(Error(t(423)), f), f = Cf(u, f, _, x, A);
            break e;
          } else if (_ !== A) {
            A = Yc(Error(t(424)), f), f = Cf(u, f, _, x, A);
            break e;
          } else for (Qo = Na(f.stateNode.containerInfo.firstChild), Zo = f, br = !0, za = null, x = Ki(f, null, _, x), f.child = x; x; ) x.flags = x.flags & -3 | 4096, x = x.sibling;
          else {
            if (Ql(), _ === A) {
              f = Wi(u, f, x);
              break e;
            }
            ei(u, f, _, x);
          }
          f = f.child;
        }
        return f;
      case 5:
        return Iv(f), u === null && xv(f), _ = f.type, A = f.pendingProps, j = u !== null ? u.memoizedProps : null, K = A.children, Wu(_, A) ? K = null : j !== null && Wu(_, j) && (f.flags |= 32), cp(u, f), ei(u, f, K, x), f.child;
      case 6:
        return u === null && xv(f), null;
      case 13:
        return kb(u, f, x);
      case 4:
        return Tv(f, f.stateNode.containerInfo), _ = f.pendingProps, u === null ? f.child = Ua(f, null, _, x) : ei(u, f, _, x), f.child;
      case 11:
        return _ = f.type, A = f.pendingProps, A = f.elementType === _ ? A : es(_, A), nm(u, f, _, A, x);
      case 7:
        return ei(u, f, f.pendingProps, x), f.child;
      case 8:
        return ei(u, f, f.pendingProps.children, x), f.child;
      case 12:
        return ei(u, f, f.pendingProps.children, x), f.child;
      case 10:
        e: {
          if (_ = f.type._context, A = f.pendingProps, j = f.memoizedProps, K = A.value, gr(nt, _._currentValue), _._currentValue = K, j !== null) if (La(j.value, K)) {
            if (j.children === A.children && !ui.current) {
              f = Wi(u, f, x);
              break e;
            }
          } else for (j = f.child, j !== null && (j.return = f); j !== null; ) {
            var ee = j.dependencies;
            if (ee !== null) {
              K = j.child;
              for (var ae = ee.firstContext; ae !== null; ) {
                if (ae.context === _) {
                  if (j.tag === 1) {
                    ae = Jl(-1, x & -x), ae.tag = 2;
                    var Te = j.updateQueue;
                    if (Te !== null) {
                      Te = Te.shared;
                      var He = Te.pending;
                      He === null ? ae.next = ae : (ae.next = He.next, He.next = ae), Te.pending = ae;
                    }
                  }
                  j.lanes |= x, ae = j.alternate, ae !== null && (ae.lanes |= x), Ev(
                    j.return,
                    x,
                    f
                  ), ee.lanes |= x;
                  break;
                }
                ae = ae.next;
              }
            } else if (j.tag === 10) K = j.type === f.type ? null : j.child;
            else if (j.tag === 18) {
              if (K = j.return, K === null) throw Error(t(341));
              K.lanes |= x, ee = K.alternate, ee !== null && (ee.lanes |= x), Ev(K, x, f), K = j.sibling;
            } else K = j.child;
            if (K !== null) K.return = j;
            else for (K = j; K !== null; ) {
              if (K === f) {
                K = null;
                break;
              }
              if (j = K.sibling, j !== null) {
                j.return = K.return, K = j;
                break;
              }
              K = K.return;
            }
            j = K;
          }
          ei(u, f, A.children, x), f = f.child;
        }
        return f;
      case 9:
        return A = f.type, _ = f.pendingProps.children, mf(f, x), A = rr(A), _ = _(A), f.flags |= 1, ei(u, f, _, x), f.child;
      case 14:
        return _ = f.type, A = es(_, f.pendingProps), A = es(_.type, A), ts(u, f, _, A, x);
      case 15:
        return rd(u, f, f.type, f.pendingProps, x);
      case 17:
        return _ = f.type, A = f.pendingProps, A = f.elementType === _ ? A : es(_, A), ra(u, f), f.tag = 1, di(_) ? (u = !0, qu(f)) : u = !1, mf(f, x), Pb(f, _, A), Dv(f, _, A, x), Nv(null, f, _, !0, u, x);
      case 19:
        return ns(u, f, x);
      case 22:
        return nn(u, f, x);
    }
    throw Error(t(156, f.tag));
  };
  function Vb(u, f) {
    return ar(u, f);
  }
  function gP(u, f, x, _) {
    this.tag = u, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = f, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = _, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null;
  }
  function sa(u, f, x, _) {
    return new gP(u, f, x, _);
  }
  function Xv(u) {
    return u = u.prototype, !(!u || !u.isReactComponent);
  }
  function mP(u) {
    if (typeof u == "function") return Xv(u) ? 1 : 0;
    if (u != null) {
      if (u = u.$$typeof, u === ie) return 11;
      if (u === oe) return 14;
    }
    return 2;
  }
  function eu(u, f) {
    var x = u.alternate;
    return x === null ? (x = sa(u.tag, f, u.key, u.mode), x.elementType = u.elementType, x.type = u.type, x.stateNode = u.stateNode, x.alternate = u, u.alternate = x) : (x.pendingProps = f, x.type = u.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = u.flags & 14680064, x.childLanes = u.childLanes, x.lanes = u.lanes, x.child = u.child, x.memoizedProps = u.memoizedProps, x.memoizedState = u.memoizedState, x.updateQueue = u.updateQueue, f = u.dependencies, x.dependencies = f === null ? null : { lanes: f.lanes, firstContext: f.firstContext }, x.sibling = u.sibling, x.index = u.index, x.ref = u.ref, x;
  }
  function ym(u, f, x, _, A, j) {
    var K = 2;
    if (_ = u, typeof u == "function") Xv(u) && (K = 1);
    else if (typeof u == "string") K = 5;
    else e: switch (u) {
      case H:
        return tu(x.children, A, j, f);
      case V:
        K = 8, A |= 8;
        break;
      case re:
        return u = sa(12, x, f, A | 2), u.elementType = re, u.lanes = j, u;
      case W:
        return u = sa(13, x, f, A), u.elementType = W, u.lanes = j, u;
      case Y:
        return u = sa(19, x, f, A), u.elementType = Y, u.lanes = j, u;
      case ce:
        return Af(x, A, j, f);
      default:
        if (typeof u == "object" && u !== null) switch (u.$$typeof) {
          case q:
            K = 10;
            break e;
          case J:
            K = 9;
            break e;
          case ie:
            K = 11;
            break e;
          case oe:
            K = 14;
            break e;
          case le:
            K = 16, _ = null;
            break e;
        }
        throw Error(t(130, u == null ? u : typeof u, ""));
    }
    return f = sa(K, x, f, A), f.elementType = u, f.type = _, f.lanes = j, f;
  }
  function tu(u, f, x, _) {
    return u = sa(7, u, _, f), u.lanes = x, u;
  }
  function Af(u, f, x, _) {
    return u = sa(22, u, _, f), u.elementType = ce, u.lanes = x, u.stateNode = { isHidden: !1 }, u;
  }
  function hd(u, f, x) {
    return u = sa(6, u, null, f), u.lanes = x, u;
  }
  function Zv(u, f, x) {
    return f = sa(4, u.children !== null ? u.children : [], u.key, f), f.lanes = x, f.stateNode = { containerInfo: u.containerInfo, pendingChildren: null, implementation: u.implementation }, f;
  }
  function Kb(u, f, x, _, A) {
    this.tag = f, this.containerInfo = u, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = cl(0), this.expirationTimes = cl(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = cl(0), this.identifierPrefix = _, this.onRecoverableError = A, this.mutableSourceEagerHydrationData = null;
  }
  function vm(u, f, x, _, A, j, K, ee, ae) {
    return u = new Kb(u, f, x, ee, ae), f === 1 ? (f = 1, j === !0 && (f |= 8)) : f = 0, j = sa(3, null, null, f), u.current = j, j.stateNode = u, j.memoizedState = { element: _, isDehydrated: x, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Vc(j), u;
  }
  function Wb(u, f, x) {
    var _ = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return { $$typeof: F, key: _ == null ? null : "" + _, children: u, containerInfo: f, implementation: x };
  }
  function Gb(u) {
    if (!u) return hn;
    u = u._reactInternals;
    e: {
      if (rt(u) !== u || u.tag !== 1) throw Error(t(170));
      var f = u;
      do {
        switch (f.tag) {
          case 3:
            f = f.stateNode.context;
            break e;
          case 1:
            if (di(f.type)) {
              f = f.stateNode.__reactInternalMemoizedMergedChildContext;
              break e;
            }
        }
        f = f.return;
      } while (f !== null);
      throw Error(t(171));
    }
    if (u.tag === 1) {
      var x = u.type;
      if (di(x)) return hb(u, x, f);
    }
    return f;
  }
  function Qv(u, f, x, _, A, j, K, ee, ae) {
    return u = vm(x, _, !0, u, A, j, K, ee, ae), u.context = Gb(null), x = u.current, _ = mr(), A = js(x), j = Jl(_, A), j.callback = f ?? null, Kc(x, j, A), u.current.lanes = A, ul(u, A, _), Fi(u, _), u;
  }
  function Sm(u, f, x, _) {
    var A = f.current, j = mr(), K = js(A);
    return x = Gb(x), f.context === null ? f.context = x : f.pendingContext = x, f = Jl(j, K), f.payload = { element: u }, _ = _ === void 0 ? null : _, _ !== null && (f.callback = _), u = Kc(A, f, K), u !== null && (Ls(u, A, K, j), Dg(u, A, K)), K;
  }
  function xm(u) {
    if (u = u.current, !u.child) return null;
    switch (u.child.tag) {
      case 5:
        return u.child.stateNode;
      default:
        return u.child.stateNode;
    }
  }
  function qb(u, f) {
    if (u = u.memoizedState, u !== null && u.dehydrated !== null) {
      var x = u.retryLane;
      u.retryLane = x !== 0 && x < f ? x : f;
    }
  }
  function wm(u, f) {
    qb(u, f), (u = u.alternate) && qb(u, f);
  }
  var Jv = typeof reportError == "function" ? reportError : function(u) {
    console.error(u);
  };
  function bm(u) {
    this._internalRoot = u;
  }
  nc.prototype.render = bm.prototype.render = function(u) {
    var f = this._internalRoot;
    if (f === null) throw Error(t(409));
    Sm(u, f, null, null);
  }, nc.prototype.unmount = bm.prototype.unmount = function() {
    var u = this._internalRoot;
    if (u !== null) {
      this._internalRoot = null;
      var f = u.containerInfo;
      ud(function() {
        Sm(null, u, null, null);
      }), f[Xl] = null;
    }
  };
  function nc(u) {
    this._internalRoot = u;
  }
  nc.prototype.unstable_scheduleHydration = function(u) {
    if (u) {
      var f = Qs();
      u = { blockedOn: null, target: u, priority: f };
      for (var x = 0; x < Is.length && f !== 0 && f < Is[x].priority; x++) ;
      Is.splice(x, 0, u), x === 0 && Vl(u);
    }
  };
  function eS(u) {
    return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11);
  }
  function Cm(u) {
    return !(!u || u.nodeType !== 1 && u.nodeType !== 9 && u.nodeType !== 11 && (u.nodeType !== 8 || u.nodeValue !== " react-mount-point-unstable "));
  }
  function Yb() {
  }
  function yP(u, f, x, _, A) {
    if (A) {
      if (typeof _ == "function") {
        var j = _;
        _ = function() {
          var Te = xm(K);
          j.call(Te);
        };
      }
      var K = Qv(f, _, u, 0, null, !1, !1, "", Yb);
      return u._reactRootContainer = K, u[Xl] = K.current, Hh(u.nodeType === 8 ? u.parentNode : u), ud(), K;
    }
    for (; A = u.lastChild; ) u.removeChild(A);
    if (typeof _ == "function") {
      var ee = _;
      _ = function() {
        var Te = xm(ae);
        ee.call(Te);
      };
    }
    var ae = vm(u, 0, !1, null, null, !1, !1, "", Yb);
    return u._reactRootContainer = ae, u[Xl] = ae.current, Hh(u.nodeType === 8 ? u.parentNode : u), ud(function() {
      Sm(f, ae, x, _);
    }), ae;
  }
  function Em(u, f, x, _, A) {
    var j = x._reactRootContainer;
    if (j) {
      var K = j;
      if (typeof A == "function") {
        var ee = A;
        A = function() {
          var ae = xm(K);
          ee.call(ae);
        };
      }
      Sm(f, K, u, A);
    } else K = yP(x, f, u, A, _);
    return xm(K);
  }
  Oc = function(u) {
    switch (u.tag) {
      case 3:
        var f = u.stateNode;
        if (f.current.memoizedState.isDehydrated) {
          var x = Hi(f.pendingLanes);
          x !== 0 && (Dc(f, x | 1), Fi(f, Un()), !(xn & 6) && (If = Un() + 500, wo()));
        }
        break;
      case 13:
        ud(function() {
          var _ = gl(u, 1);
          if (_ !== null) {
            var A = mr();
            Ls(_, u, 1, A);
          }
        }), wm(u, 1);
    }
  }, Cn = function(u) {
    if (u.tag === 13) {
      var f = gl(u, 134217728);
      if (f !== null) {
        var x = mr();
        Ls(f, u, 134217728, x);
      }
      wm(u, 134217728);
    }
  }, Ps = function(u) {
    if (u.tag === 13) {
      var f = js(u), x = gl(u, f);
      if (x !== null) {
        var _ = mr();
        Ls(x, u, f, _);
      }
      wm(u, f);
    }
  }, Qs = function() {
    return dn;
  }, Ut = function(u, f) {
    var x = dn;
    try {
      return dn = u, f();
    } finally {
      dn = x;
    }
  }, vn = function(u, f, x) {
    switch (f) {
      case "input":
        if (Gn(u, x), f = x.name, x.type === "radio" && f != null) {
          for (x = u; x.parentNode; ) x = x.parentNode;
          for (x = x.querySelectorAll("input[name=" + JSON.stringify("" + f) + '][type="radio"]'), f = 0; f < x.length; f++) {
            var _ = x[f];
            if (_ !== u && _.form === u.form) {
              var A = Zl(_);
              if (!A) throw Error(t(90));
              mn(_), Gn(_, A);
            }
          }
        }
        break;
      case "textarea":
        si(u, x);
        break;
      case "select":
        f = x.value, f != null && wr(u, !!x.multiple, f, !1);
    }
  }, ka = pm, Ra = ud;
  var vP = { usingClientEntryPoint: !1, Events: [Gh, Rt, Zl, ki, Cs, pm] }, Df = { findFiberByHostInstance: Gu, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, SP = { bundleType: Df.bundleType, version: Df.version, rendererPackageName: Df.rendererPackageName, rendererConfig: Df.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: O.ReactCurrentDispatcher, findHostInstanceByFiber: function(u) {
    return u = en(u), u === null ? null : u.stateNode;
  }, findFiberByHostInstance: Df.findFiberByHostInstance, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var _m = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!_m.isDisabled && _m.supportsFiber) try {
      al = _m.inject(SP), so = _m;
    } catch {
    }
  }
  return fa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = vP, fa.createPortal = function(u, f) {
    var x = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!eS(f)) throw Error(t(200));
    return Wb(u, f, null, x);
  }, fa.createRoot = function(u, f) {
    if (!eS(u)) throw Error(t(299));
    var x = !1, _ = "", A = Jv;
    return f != null && (f.unstable_strictMode === !0 && (x = !0), f.identifierPrefix !== void 0 && (_ = f.identifierPrefix), f.onRecoverableError !== void 0 && (A = f.onRecoverableError)), f = vm(u, 1, !1, null, null, x, !1, _, A), u[Xl] = f.current, Hh(u.nodeType === 8 ? u.parentNode : u), new bm(f);
  }, fa.findDOMNode = function(u) {
    if (u == null) return null;
    if (u.nodeType === 1) return u;
    var f = u._reactInternals;
    if (f === void 0)
      throw typeof u.render == "function" ? Error(t(188)) : (u = Object.keys(u).join(","), Error(t(268, u)));
    return u = en(f), u = u === null ? null : u.stateNode, u;
  }, fa.flushSync = function(u) {
    return ud(u);
  }, fa.hydrate = function(u, f, x) {
    if (!Cm(f)) throw Error(t(200));
    return Em(null, u, f, !0, x);
  }, fa.hydrateRoot = function(u, f, x) {
    if (!eS(u)) throw Error(t(405));
    var _ = x != null && x.hydratedSources || null, A = !1, j = "", K = Jv;
    if (x != null && (x.unstable_strictMode === !0 && (A = !0), x.identifierPrefix !== void 0 && (j = x.identifierPrefix), x.onRecoverableError !== void 0 && (K = x.onRecoverableError)), f = Qv(f, null, u, 1, x ?? null, A, !1, j, K), u[Xl] = f.current, Hh(u), _) for (u = 0; u < _.length; u++) x = _[u], A = x._getVersion, A = A(x._source), f.mutableSourceEagerHydrationData == null ? f.mutableSourceEagerHydrationData = [x, A] : f.mutableSourceEagerHydrationData.push(
      x,
      A
    );
    return new nc(f);
  }, fa.render = function(u, f, x) {
    if (!Cm(f)) throw Error(t(200));
    return Em(null, u, f, !1, x);
  }, fa.unmountComponentAtNode = function(u) {
    if (!Cm(u)) throw Error(t(40));
    return u._reactRootContainer ? (ud(function() {
      Em(null, null, u, !1, function() {
        u._reactRootContainer = null, u[Xl] = null;
      });
    }), !0) : !1;
  }, fa.unstable_batchedUpdates = pm, fa.unstable_renderSubtreeIntoContainer = function(u, f, x, _) {
    if (!Cm(x)) throw Error(t(200));
    if (u == null || u._reactInternals === void 0) throw Error(t(38));
    return Em(u, f, x, !1, _);
  }, fa.version = "18.3.1-next-f1338f8080-20240426", fa;
}
var ha = {}, uF;
function fte() {
  if (uF) return ha;
  uF = 1;
  var n = {};
  /**
   * @license React
   * react-dom.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return n.NODE_ENV !== "production" && function() {
    typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());
    var e = aw(), t = O$(), r = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, i = !1;
    function s(o) {
      i = o;
    }
    function l(o) {
      if (!i) {
        for (var a = arguments.length, p = new Array(a > 1 ? a - 1 : 0), S = 1; S < a; S++)
          p[S - 1] = arguments[S];
        d("warn", o, p);
      }
    }
    function c(o) {
      if (!i) {
        for (var a = arguments.length, p = new Array(a > 1 ? a - 1 : 0), S = 1; S < a; S++)
          p[S - 1] = arguments[S];
        d("error", o, p);
      }
    }
    function d(o, a, p) {
      {
        var S = r.ReactDebugCurrentFrame, b = S.getStackAddendum();
        b !== "" && (a += "%s", p = p.concat([b]));
        var T = p.map(function(D) {
          return String(D);
        });
        T.unshift("Warning: " + a), Function.prototype.apply.call(console[o], console, T);
      }
    }
    var h = 0, g = 1, y = 2, v = 3, w = 4, C = 5, E = 6, P = 7, I = 8, k = 9, L = 10, O = 11, z = 12, F = 13, H = 14, V = 15, re = 16, q = 17, J = 18, ie = 19, W = 21, Y = 22, oe = 23, le = 24, ce = 25, Q = !0, he = !1, ke = !1, te = !1, me = !1, Oe = !0, Ze = !0, De = !0, yt = !0, it = /* @__PURE__ */ new Set(), We = {}, Qe = {};
    function gt(o, a) {
      Pt(o, a), Pt(o + "Capture", a);
    }
    function Pt(o, a) {
      We[o] && c("EventRegistry: More than one plugin attempted to publish the same registration name, `%s`.", o), We[o] = a;
      {
        var p = o.toLowerCase();
        Qe[p] = o, o === "onDoubleClick" && (Qe.ondblclick = o);
      }
      for (var S = 0; S < a.length; S++)
        it.add(a[S]);
    }
    var mn = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Zt = Object.prototype.hasOwnProperty;
    function an(o) {
      {
        var a = typeof Symbol == "function" && Symbol.toStringTag, p = a && o[Symbol.toStringTag] || o.constructor.name || "Object";
        return p;
      }
    }
    function ln(o) {
      try {
        return Yt(o), !1;
      } catch {
        return !0;
      }
    }
    function Yt(o) {
      return "" + o;
    }
    function Gn(o, a) {
      if (ln(o))
        return c("The provided `%s` attribute is an unsupported type %s. This value must be coerced to a string before before using it here.", a, an(o)), Yt(o);
    }
    function xr(o) {
      if (ln(o))
        return c("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", an(o)), Yt(o);
    }
    function Hr(o, a) {
      if (ln(o))
        return c("The provided `%s` prop is an unsupported type %s. This value must be coerced to a string before before using it here.", a, an(o)), Yt(o);
    }
    function Pr(o, a) {
      if (ln(o))
        return c("The provided `%s` CSS property is an unsupported type %s. This value must be coerced to a string before before using it here.", a, an(o)), Yt(o);
    }
    function wr(o) {
      if (ln(o))
        return c("The provided HTML markup uses a value of unsupported type %s. This value must be coerced to a string before before using it here.", an(o)), Yt(o);
    }
    function Vr(o) {
      if (ln(o))
        return c("Form field values (value, checked, defaultValue, or defaultChecked props) must be strings, not %s. This value must be coerced to a string before before using it here.", an(o)), Yt(o);
    }
    var Kr = 0, si = 1, mo = 2, Tr = 3, Ir = 4, Zr = 5, Ko = 6, Ee = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ve = Ee + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", $e = new RegExp("^[" + Ee + "][" + ve + "]*$"), mt = {}, cn = {};
    function yn(o) {
      return Zt.call(cn, o) ? !0 : Zt.call(mt, o) ? !1 : $e.test(o) ? (cn[o] = !0, !0) : (mt[o] = !0, c("Invalid attribute name: `%s`", o), !1);
    }
    function qn(o, a, p) {
      return a !== null ? a.type === Kr : p ? !1 : o.length > 2 && (o[0] === "o" || o[0] === "O") && (o[1] === "n" || o[1] === "N");
    }
    function Rn(o, a, p, S) {
      if (p !== null && p.type === Kr)
        return !1;
      switch (typeof a) {
        case "function":
        // $FlowIssue symbol is perfectly valid here
        case "symbol":
          return !0;
        case "boolean": {
          if (S)
            return !1;
          if (p !== null)
            return !p.acceptsBooleans;
          var b = o.toLowerCase().slice(0, 5);
          return b !== "data-" && b !== "aria-";
        }
        default:
          return !1;
      }
    }
    function sr(o, a, p, S) {
      if (a === null || typeof a > "u" || Rn(o, a, p, S))
        return !0;
      if (S)
        return !1;
      if (p !== null)
        switch (p.type) {
          case Tr:
            return !a;
          case Ir:
            return a === !1;
          case Zr:
            return isNaN(a);
          case Ko:
            return isNaN(a) || a < 1;
        }
      return !1;
    }
    function bn(o) {
      return fn.hasOwnProperty(o) ? fn[o] : null;
    }
    function vn(o, a, p, S, b, T, D) {
      this.acceptsBooleans = a === mo || a === Tr || a === Ir, this.attributeName = S, this.attributeNamespace = b, this.mustUseProperty = p, this.propertyName = o, this.type = a, this.sanitizeURL = T, this.removeEmptyString = D;
    }
    var fn = {}, Ii = [
      "children",
      "dangerouslySetInnerHTML",
      // TODO: This prevents the assignment of defaultValue to regular
      // elements (not just inputs). Now that ReactDOMInput assigns to the
      // defaultValue property -- do we need this?
      "defaultValue",
      "defaultChecked",
      "innerHTML",
      "suppressContentEditableWarning",
      "suppressHydrationWarning",
      "style"
    ];
    Ii.forEach(function(o) {
      fn[o] = new vn(
        o,
        Kr,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(o) {
      var a = o[0], p = o[1];
      fn[a] = new vn(
        a,
        si,
        !1,
        // mustUseProperty
        p,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(o) {
      fn[o] = new vn(
        o,
        mo,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(o) {
      fn[o] = new vn(
        o,
        mo,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "allowFullScreen",
      "async",
      // Note: there is a special case that prevents it from being written to the DOM
      // on the client side because the browsers are inconsistent. Instead we call focus().
      "autoFocus",
      "autoPlay",
      "controls",
      "default",
      "defer",
      "disabled",
      "disablePictureInPicture",
      "disableRemotePlayback",
      "formNoValidate",
      "hidden",
      "loop",
      "noModule",
      "noValidate",
      "open",
      "playsInline",
      "readOnly",
      "required",
      "reversed",
      "scoped",
      "seamless",
      // Microdata
      "itemScope"
    ].forEach(function(o) {
      fn[o] = new vn(
        o,
        Tr,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "checked",
      // Note: `option.selected` is not updated if `select.multiple` is
      // disabled with `removeAttribute`. We have special logic for handling this.
      "multiple",
      "muted",
      "selected"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      fn[o] = new vn(
        o,
        Tr,
        !0,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "capture",
      "download"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      fn[o] = new vn(
        o,
        Ir,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "cols",
      "rows",
      "size",
      "span"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      fn[o] = new vn(
        o,
        Ko,
        !1,
        // mustUseProperty
        o,
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), ["rowSpan", "start"].forEach(function(o) {
      fn[o] = new vn(
        o,
        Zr,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var oo = /[\-\:]([a-z])/g, ki = function(o) {
      return o[1].toUpperCase();
    };
    [
      "accent-height",
      "alignment-baseline",
      "arabic-form",
      "baseline-shift",
      "cap-height",
      "clip-path",
      "clip-rule",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "dominant-baseline",
      "enable-background",
      "fill-opacity",
      "fill-rule",
      "flood-color",
      "flood-opacity",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-name",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "horiz-adv-x",
      "horiz-origin-x",
      "image-rendering",
      "letter-spacing",
      "lighting-color",
      "marker-end",
      "marker-mid",
      "marker-start",
      "overline-position",
      "overline-thickness",
      "paint-order",
      "panose-1",
      "pointer-events",
      "rendering-intent",
      "shape-rendering",
      "stop-color",
      "stop-opacity",
      "strikethrough-position",
      "strikethrough-thickness",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-decoration",
      "text-rendering",
      "underline-position",
      "underline-thickness",
      "unicode-bidi",
      "unicode-range",
      "units-per-em",
      "v-alphabetic",
      "v-hanging",
      "v-ideographic",
      "v-mathematical",
      "vector-effect",
      "vert-adv-y",
      "vert-origin-x",
      "vert-origin-y",
      "word-spacing",
      "writing-mode",
      "xmlns:xlink",
      "x-height"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var a = o.replace(oo, ki);
      fn[a] = new vn(
        a,
        si,
        !1,
        // mustUseProperty
        o,
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xlink:actuate",
      "xlink:arcrole",
      "xlink:role",
      "xlink:show",
      "xlink:title",
      "xlink:type"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var a = o.replace(oo, ki);
      fn[a] = new vn(
        a,
        si,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/1999/xlink",
        !1,
        // sanitizeURL
        !1
      );
    }), [
      "xml:base",
      "xml:lang",
      "xml:space"
      // NOTE: if you add a camelCased prop to this list,
      // you'll need to set attributeName to name.toLowerCase()
      // instead in the assignment below.
    ].forEach(function(o) {
      var a = o.replace(oo, ki);
      fn[a] = new vn(
        a,
        si,
        !1,
        // mustUseProperty
        o,
        "http://www.w3.org/XML/1998/namespace",
        !1,
        // sanitizeURL
        !1
      );
    }), ["tabIndex", "crossOrigin"].forEach(function(o) {
      fn[o] = new vn(
        o,
        si,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !1,
        // sanitizeURL
        !1
      );
    });
    var Cs = "xlinkHref";
    fn[Cs] = new vn(
      "xlinkHref",
      si,
      !1,
      // mustUseProperty
      "xlink:href",
      "http://www.w3.org/1999/xlink",
      !0,
      // sanitizeURL
      !1
    ), ["src", "href", "action", "formAction"].forEach(function(o) {
      fn[o] = new vn(
        o,
        si,
        !1,
        // mustUseProperty
        o.toLowerCase(),
        // attributeName
        null,
        // attributeNamespace
        !0,
        // sanitizeURL
        !0
      );
    });
    var ka = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i, Ra = !1;
    function yo(o) {
      !Ra && ka.test(o) && (Ra = !0, c("A future version of React will block javascript: URLs as a security precaution. Use event handlers instead if you can. If you need to generate unsafe HTML try using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(o)));
    }
    function Ul(o, a, p, S) {
      if (S.mustUseProperty) {
        var b = S.propertyName;
        return o[b];
      } else {
        Gn(p, a), S.sanitizeURL && yo("" + p);
        var T = S.attributeName, D = null;
        if (S.type === Ir) {
          if (o.hasAttribute(T)) {
            var N = o.getAttribute(T);
            return N === "" ? !0 : sr(a, p, S, !1) ? N : N === "" + p ? p : N;
          }
        } else if (o.hasAttribute(T)) {
          if (sr(a, p, S, !1))
            return o.getAttribute(T);
          if (S.type === Tr)
            return p;
          D = o.getAttribute(T);
        }
        return sr(a, p, S, !1) ? D === null ? p : D : D === "" + p ? p : D;
      }
    }
    function Xs(o, a, p, S) {
      {
        if (!yn(a))
          return;
        if (!o.hasAttribute(a))
          return p === void 0 ? void 0 : null;
        var b = o.getAttribute(a);
        return Gn(p, a), b === "" + p ? p : b;
      }
    }
    function vo(o, a, p, S) {
      var b = bn(a);
      if (!qn(a, b, S)) {
        if (sr(a, p, b, S) && (p = null), S || b === null) {
          if (yn(a)) {
            var T = a;
            p === null ? o.removeAttribute(T) : (Gn(p, a), o.setAttribute(T, "" + p));
          }
          return;
        }
        var D = b.mustUseProperty;
        if (D) {
          var N = b.propertyName;
          if (p === null) {
            var $ = b.type;
            o[N] = $ === Tr ? !1 : "";
          } else
            o[N] = p;
          return;
        }
        var G = b.attributeName, X = b.attributeNamespace;
        if (p === null)
          o.removeAttribute(G);
        else {
          var fe = b.type, ue;
          fe === Tr || fe === Ir && p === !0 ? ue = "" : (Gn(p, G), ue = "" + p, b.sanitizeURL && yo(ue.toString())), X ? o.setAttributeNS(X, G, ue) : o.setAttribute(G, ue);
        }
      }
    }
    var vi = Symbol.for("react.element"), So = Symbol.for("react.portal"), $i = Symbol.for("react.fragment"), Wo = Symbol.for("react.strict_mode"), Ri = Symbol.for("react.profiler"), Ma = Symbol.for("react.provider"), se = Symbol.for("react.context"), Ue = Symbol.for("react.forward_ref"), tt = Symbol.for("react.suspense"), rt = Symbol.for("react.suspense_list"), zt = Symbol.for("react.memo"), Vt = Symbol.for("react.lazy"), un = Symbol.for("react.scope"), en = Symbol.for("react.debug_trace_mode"), Lr = Symbol.for("react.offscreen"), ar = Symbol.for("react.legacy_hidden"), zn = Symbol.for("react.cache"), Mi = Symbol.for("react.tracing_marker"), Es = Symbol.iterator, Un = "@@iterator";
    function yr(o) {
      if (o === null || typeof o != "object")
        return null;
      var a = Es && o[Es] || o[Un];
      return typeof a == "function" ? a : null;
    }
    var Gt = Object.assign, xo = 0, Aa, Qd, Ai, al, so, Fu, Bi;
    function zu() {
    }
    zu.__reactDisabledLog = !0;
    function Jd() {
      {
        if (xo === 0) {
          Aa = console.log, Qd = console.info, Ai = console.warn, al = console.error, so = console.group, Fu = console.groupCollapsed, Bi = console.groupEnd;
          var o = {
            configurable: !0,
            enumerable: !0,
            value: zu,
            writable: !0
          };
          Object.defineProperties(console, {
            info: o,
            log: o,
            warn: o,
            error: o,
            group: o,
            groupCollapsed: o,
            groupEnd: o
          });
        }
        xo++;
      }
    }
    function $l() {
      {
        if (xo--, xo === 0) {
          var o = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: Gt({}, o, {
              value: Aa
            }),
            info: Gt({}, o, {
              value: Qd
            }),
            warn: Gt({}, o, {
              value: Ai
            }),
            error: Gt({}, o, {
              value: al
            }),
            group: Gt({}, o, {
              value: so
            }),
            groupCollapsed: Gt({}, o, {
              value: Fu
            }),
            groupEnd: Gt({}, o, {
              value: Bi
            })
          });
        }
        xo < 0 && c("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var Da = r.ReactCurrentDispatcher, Go;
    function Hi(o, a, p) {
      {
        if (Go === void 0)
          try {
            throw Error();
          } catch (b) {
            var S = b.stack.trim().match(/\n( *(at )?)/);
            Go = S && S[1] || "";
          }
        return `
` + Go + o;
      }
    }
    var _s = !1, ll;
    {
      var Ac = typeof WeakMap == "function" ? WeakMap : Map;
      ll = new Ac();
    }
    function Oa(o, a) {
      if (!o || _s)
        return "";
      {
        var p = ll.get(o);
        if (p !== void 0)
          return p;
      }
      var S;
      _s = !0;
      var b = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var T;
      T = Da.current, Da.current = null, Jd();
      try {
        if (a) {
          var D = function() {
            throw Error();
          };
          if (Object.defineProperty(D.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(D, []);
            } catch (Ie) {
              S = Ie;
            }
            Reflect.construct(o, [], D);
          } else {
            try {
              D.call();
            } catch (Ie) {
              S = Ie;
            }
            o.call(D.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Ie) {
            S = Ie;
          }
          o();
        }
      } catch (Ie) {
        if (Ie && S && typeof Ie.stack == "string") {
          for (var N = Ie.stack.split(`
`), $ = S.stack.split(`
`), G = N.length - 1, X = $.length - 1; G >= 1 && X >= 0 && N[G] !== $[X]; )
            X--;
          for (; G >= 1 && X >= 0; G--, X--)
            if (N[G] !== $[X]) {
              if (G !== 1 || X !== 1)
                do
                  if (G--, X--, X < 0 || N[G] !== $[X]) {
                    var fe = `
` + N[G].replace(" at new ", " at ");
                    return o.displayName && fe.includes("<anonymous>") && (fe = fe.replace("<anonymous>", o.displayName)), typeof o == "function" && ll.set(o, fe), fe;
                  }
                while (G >= 1 && X >= 0);
              break;
            }
        }
      } finally {
        _s = !1, Da.current = T, $l(), Error.prepareStackTrace = b;
      }
      var ue = o ? o.displayName || o.name : "", _e = ue ? Hi(ue) : "";
      return typeof o == "function" && ll.set(o, _e), _e;
    }
    function Bl(o, a, p) {
      return Oa(o, !0);
    }
    function cl(o, a, p) {
      return Oa(o, !1);
    }
    function ul(o) {
      var a = o.prototype;
      return !!(a && a.isReactComponent);
    }
    function Uu(o, a, p) {
      if (o == null)
        return "";
      if (typeof o == "function")
        return Oa(o, ul(o));
      if (typeof o == "string")
        return Hi(o);
      switch (o) {
        case tt:
          return Hi("Suspense");
        case rt:
          return Hi("SuspenseList");
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case Ue:
            return cl(o.render);
          case zt:
            return Uu(o.type, a, p);
          case Vt: {
            var S = o, b = S._payload, T = S._init;
            try {
              return Uu(T(b), a, p);
            } catch {
            }
          }
        }
      return "";
    }
    function Dc(o) {
      switch (o._debugOwner && o._debugOwner.type, o._debugSource, o.tag) {
        case C:
          return Hi(o.type);
        case re:
          return Hi("Lazy");
        case F:
          return Hi("Suspense");
        case ie:
          return Hi("SuspenseList");
        case h:
        case y:
        case V:
          return cl(o.type);
        case O:
          return cl(o.type.render);
        case g:
          return Bl(o.type);
        default:
          return "";
      }
    }
    function dn(o) {
      try {
        var a = "", p = o;
        do
          a += Dc(p), p = p.return;
        while (p);
        return a;
      } catch (S) {
        return `
Error generating stack: ` + S.message + `
` + S.stack;
      }
    }
    function Zs(o, a, p) {
      var S = o.displayName;
      if (S)
        return S;
      var b = a.displayName || a.name || "";
      return b !== "" ? p + "(" + b + ")" : p;
    }
    function Oc(o) {
      return o.displayName || "Context";
    }
    function Cn(o) {
      if (o == null)
        return null;
      if (typeof o.tag == "number" && c("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof o == "function")
        return o.displayName || o.name || null;
      if (typeof o == "string")
        return o;
      switch (o) {
        case $i:
          return "Fragment";
        case So:
          return "Portal";
        case Ri:
          return "Profiler";
        case Wo:
          return "StrictMode";
        case tt:
          return "Suspense";
        case rt:
          return "SuspenseList";
      }
      if (typeof o == "object")
        switch (o.$$typeof) {
          case se:
            var a = o;
            return Oc(a) + ".Consumer";
          case Ma:
            var p = o;
            return Oc(p._context) + ".Provider";
          case Ue:
            return Zs(o, o.render, "ForwardRef");
          case zt:
            var S = o.displayName || null;
            return S !== null ? S : Cn(o.type) || "Memo";
          case Vt: {
            var b = o, T = b._payload, D = b._init;
            try {
              return Cn(D(T));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    function Ps(o, a, p) {
      var S = a.displayName || a.name || "";
      return o.displayName || (S !== "" ? p + "(" + S + ")" : p);
    }
    function Qs(o) {
      return o.displayName || "Context";
    }
    function Ut(o) {
      var a = o.tag, p = o.type;
      switch (a) {
        case le:
          return "Cache";
        case k:
          var S = p;
          return Qs(S) + ".Consumer";
        case L:
          var b = p;
          return Qs(b._context) + ".Provider";
        case J:
          return "DehydratedFragment";
        case O:
          return Ps(p, p.render, "ForwardRef");
        case P:
          return "Fragment";
        case C:
          return p;
        case w:
          return "Portal";
        case v:
          return "Root";
        case E:
          return "Text";
        case re:
          return Cn(p);
        case I:
          return p === Wo ? "StrictMode" : "Mode";
        case Y:
          return "Offscreen";
        case z:
          return "Profiler";
        case W:
          return "Scope";
        case F:
          return "Suspense";
        case ie:
          return "SuspenseList";
        case ce:
          return "TracingMarker";
        // The display name for this tags come from the user-provided type:
        case g:
        case h:
        case q:
        case y:
        case H:
        case V:
          if (typeof p == "function")
            return p.displayName || p.name || null;
          if (typeof p == "string")
            return p;
          break;
      }
      return null;
    }
    var Hl = r.ReactDebugCurrentFrame, ai = null, ao = !1;
    function Nr() {
      {
        if (ai === null)
          return null;
        var o = ai._debugOwner;
        if (o !== null && typeof o < "u")
          return Ut(o);
      }
      return null;
    }
    function Ts() {
      return ai === null ? "" : dn(ai);
    }
    function kr() {
      Hl.getCurrentStack = null, ai = null, ao = !1;
    }
    function $n(o) {
      Hl.getCurrentStack = o === null ? null : Ts, ai = o, ao = !1;
    }
    function Is() {
      return ai;
    }
    function lo(o) {
      ao = o;
    }
    function Di(o) {
      return "" + o;
    }
    function Oi(o) {
      switch (typeof o) {
        case "boolean":
        case "number":
        case "string":
        case "undefined":
          return o;
        case "object":
          return Vr(o), o;
        default:
          return "";
      }
    }
    var ef = {
      button: !0,
      checkbox: !0,
      image: !0,
      hidden: !0,
      radio: !0,
      reset: !0,
      submit: !0
    };
    function Vl(o, a) {
      ef[a.type] || a.onChange || a.onInput || a.readOnly || a.disabled || a.value == null || c("You provided a `value` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultValue`. Otherwise, set either `onChange` or `readOnly`."), a.onChange || a.readOnly || a.disabled || a.checked == null || c("You provided a `checked` prop to a form field without an `onChange` handler. This will render a read-only field. If the field should be mutable use `defaultChecked`. Otherwise, set either `onChange` or `readOnly`.");
    }
    function ks(o) {
      var a = o.type, p = o.nodeName;
      return p && p.toLowerCase() === "input" && (a === "checkbox" || a === "radio");
    }
    function Kl(o) {
      return o._valueTracker;
    }
    function jc(o) {
      o._valueTracker = null;
    }
    function Wl(o) {
      var a = "";
      return o && (ks(o) ? a = o.checked ? "true" : "false" : a = o.value), a;
    }
    function qo(o) {
      var a = ks(o) ? "checked" : "value", p = Object.getOwnPropertyDescriptor(o.constructor.prototype, a);
      Vr(o[a]);
      var S = "" + o[a];
      if (!(o.hasOwnProperty(a) || typeof p > "u" || typeof p.get != "function" || typeof p.set != "function")) {
        var b = p.get, T = p.set;
        Object.defineProperty(o, a, {
          configurable: !0,
          get: function() {
            return b.call(this);
          },
          set: function(N) {
            Vr(N), S = "" + N, T.call(this, N);
          }
        }), Object.defineProperty(o, a, {
          enumerable: p.enumerable
        });
        var D = {
          getValue: function() {
            return S;
          },
          setValue: function(N) {
            Vr(N), S = "" + N;
          },
          stopTracking: function() {
            jc(o), delete o[a];
          }
        };
        return D;
      }
    }
    function Z(o) {
      Kl(o) || (o._valueTracker = qo(o));
    }
    function pe(o) {
      if (!o)
        return !1;
      var a = Kl(o);
      if (!a)
        return !0;
      var p = a.getValue(), S = Wl(o);
      return S !== p ? (a.setValue(S), !0) : !1;
    }
    function ze(o) {
      if (o = o || (typeof document < "u" ? document : void 0), typeof o > "u")
        return null;
      try {
        return o.activeElement || o.body;
      } catch {
        return o.body;
      }
    }
    var lt = !1, Nn = !1, Lt = !1, nr = !1;
    function Rr(o) {
      var a = o.type === "checkbox" || o.type === "radio";
      return a ? o.checked != null : o.value != null;
    }
    function Zn(o, a) {
      var p = o, S = a.checked, b = Gt({}, a, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: S ?? p._wrapperState.initialChecked
      });
      return b;
    }
    function Qn(o, a) {
      Vl("input", a), a.checked !== void 0 && a.defaultChecked !== void 0 && !Nn && (c("%s contains an input of type %s with both checked and defaultChecked props. Input elements must be either controlled or uncontrolled (specify either the checked prop, or the defaultChecked prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Nr() || "A component", a.type), Nn = !0), a.value !== void 0 && a.defaultValue !== void 0 && !lt && (c("%s contains an input of type %s with both value and defaultValue props. Input elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled input element and remove one of these props. More info: https://reactjs.org/link/controlled-components", Nr() || "A component", a.type), lt = !0);
      var p = o, S = a.defaultValue == null ? "" : a.defaultValue;
      p._wrapperState = {
        initialChecked: a.checked != null ? a.checked : a.defaultChecked,
        initialValue: Oi(a.value != null ? a.value : S),
        controlled: Rr(a)
      };
    }
    function B(o, a) {
      var p = o, S = a.checked;
      S != null && vo(p, "checked", S, !1);
    }
    function ne(o, a) {
      var p = o;
      {
        var S = Rr(a);
        !p._wrapperState.controlled && S && !nr && (c("A component is changing an uncontrolled input to be controlled. This is likely caused by the value changing from undefined to a defined value, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), nr = !0), p._wrapperState.controlled && !S && !Lt && (c("A component is changing a controlled input to be uncontrolled. This is likely caused by the value changing from a defined to undefined, which should not happen. Decide between using a controlled or uncontrolled input element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components"), Lt = !0);
      }
      B(o, a);
      var b = Oi(a.value), T = a.type;
      if (b != null)
        T === "number" ? (b === 0 && p.value === "" || // We explicitly want to coerce to number here if possible.
        // eslint-disable-next-line
        p.value != b) && (p.value = Di(b)) : p.value !== Di(b) && (p.value = Di(b));
      else if (T === "submit" || T === "reset") {
        p.removeAttribute("value");
        return;
      }
      a.hasOwnProperty("value") ? ot(p, a.type, b) : a.hasOwnProperty("defaultValue") && ot(p, a.type, Oi(a.defaultValue)), a.checked == null && a.defaultChecked != null && (p.defaultChecked = !!a.defaultChecked);
    }
    function ge(o, a, p) {
      var S = o;
      if (a.hasOwnProperty("value") || a.hasOwnProperty("defaultValue")) {
        var b = a.type, T = b === "submit" || b === "reset";
        if (T && (a.value === void 0 || a.value === null))
          return;
        var D = Di(S._wrapperState.initialValue);
        p || D !== S.value && (S.value = D), S.defaultValue = D;
      }
      var N = S.name;
      N !== "" && (S.name = ""), S.defaultChecked = !S.defaultChecked, S.defaultChecked = !!S._wrapperState.initialChecked, N !== "" && (S.name = N);
    }
    function Re(o, a) {
      var p = o;
      ne(p, a), Ve(p, a);
    }
    function Ve(o, a) {
      var p = a.name;
      if (a.type === "radio" && p != null) {
        for (var S = o; S.parentNode; )
          S = S.parentNode;
        Gn(p, "name");
        for (var b = S.querySelectorAll("input[name=" + JSON.stringify("" + p) + '][type="radio"]'), T = 0; T < b.length; T++) {
          var D = b[T];
          if (!(D === o || D.form !== o.form)) {
            var N = f0(D);
            if (!N)
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the same `name` is not supported.");
            pe(D), ne(D, N);
          }
        }
      }
    }
    function ot(o, a, p) {
      // Focused number inputs synchronize on blur. See ChangeEventPlugin.js
      (a !== "number" || ze(o.ownerDocument) !== o) && (p == null ? o.defaultValue = Di(o._wrapperState.initialValue) : o.defaultValue !== Di(p) && (o.defaultValue = Di(p)));
    }
    var Je = !1, kt = !1, Qt = !1;
    function Mn(o, a) {
      a.value == null && (typeof a.children == "object" && a.children !== null ? e.Children.forEach(a.children, function(p) {
        p != null && (typeof p == "string" || typeof p == "number" || kt || (kt = !0, c("Cannot infer the option value of complex children. Pass a `value` prop or use a plain string as children to <option>.")));
      }) : a.dangerouslySetInnerHTML != null && (Qt || (Qt = !0, c("Pass a `value` prop if you set dangerouslyInnerHTML so React knows which value should be selected.")))), a.selected != null && !Je && (c("Use the `defaultValue` or `value` props on <select> instead of setting `selected` on <option>."), Je = !0);
    }
    function Bn(o, a) {
      a.value != null && o.setAttribute("value", Di(Oi(a.value)));
    }
    var lr = Array.isArray;
    function tn(o) {
      return lr(o);
    }
    var pr;
    pr = !1;
    function Qr() {
      var o = Nr();
      return o ? `

Check the render method of \`` + o + "`." : "";
    }
    var $u = ["value", "defaultValue"];
    function Ah(o) {
      {
        Vl("select", o);
        for (var a = 0; a < $u.length; a++) {
          var p = $u[a];
          if (o[p] != null) {
            var S = tn(o[p]);
            o.multiple && !S ? c("The `%s` prop supplied to <select> must be an array if `multiple` is true.%s", p, Qr()) : !o.multiple && S && c("The `%s` prop supplied to <select> must be a scalar value if `multiple` is false.%s", p, Qr());
          }
        }
      }
    }
    function Gl(o, a, p, S) {
      var b = o.options;
      if (a) {
        for (var T = p, D = {}, N = 0; N < T.length; N++)
          D["$" + T[N]] = !0;
        for (var $ = 0; $ < b.length; $++) {
          var G = D.hasOwnProperty("$" + b[$].value);
          b[$].selected !== G && (b[$].selected = G), G && S && (b[$].defaultSelected = !0);
        }
      } else {
        for (var X = Di(Oi(p)), fe = null, ue = 0; ue < b.length; ue++) {
          if (b[ue].value === X) {
            b[ue].selected = !0, S && (b[ue].defaultSelected = !0);
            return;
          }
          fe === null && !b[ue].disabled && (fe = b[ue]);
        }
        fe !== null && (fe.selected = !0);
      }
    }
    function Bu(o, a) {
      return Gt({}, a, {
        value: void 0
      });
    }
    function Dh(o, a) {
      var p = o;
      Ah(a), p._wrapperState = {
        wasMultiple: !!a.multiple
      }, a.value !== void 0 && a.defaultValue !== void 0 && !pr && (c("Select elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled select element and remove one of these props. More info: https://reactjs.org/link/controlled-components"), pr = !0);
    }
    function ev(o, a) {
      var p = o;
      p.multiple = !!a.multiple;
      var S = a.value;
      S != null ? Gl(p, !!a.multiple, S, !1) : a.defaultValue != null && Gl(p, !!a.multiple, a.defaultValue, !0);
    }
    function mg(o, a) {
      var p = o, S = p._wrapperState.wasMultiple;
      p._wrapperState.wasMultiple = !!a.multiple;
      var b = a.value;
      b != null ? Gl(p, !!a.multiple, b, !1) : S !== !!a.multiple && (a.defaultValue != null ? Gl(p, !!a.multiple, a.defaultValue, !0) : Gl(p, !!a.multiple, a.multiple ? [] : "", !1));
    }
    function tv(o, a) {
      var p = o, S = a.value;
      S != null && Gl(p, !!a.multiple, S, !1);
    }
    var Nw = !1;
    function yg(o, a) {
      var p = o;
      if (a.dangerouslySetInnerHTML != null)
        throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
      var S = Gt({}, a, {
        value: void 0,
        defaultValue: void 0,
        children: Di(p._wrapperState.initialValue)
      });
      return S;
    }
    function Fw(o, a) {
      var p = o;
      Vl("textarea", a), a.value !== void 0 && a.defaultValue !== void 0 && !Nw && (c("%s contains a textarea with both value and defaultValue props. Textarea elements must be either controlled or uncontrolled (specify either the value prop, or the defaultValue prop, but not both). Decide between using a controlled or uncontrolled textarea and remove one of these props. More info: https://reactjs.org/link/controlled-components", Nr() || "A component"), Nw = !0);
      var S = a.value;
      if (S == null) {
        var b = a.children, T = a.defaultValue;
        if (b != null) {
          c("Use the `defaultValue` or `value` props instead of setting children on <textarea>.");
          {
            if (T != null)
              throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
            if (tn(b)) {
              if (b.length > 1)
                throw new Error("<textarea> can only have at most one child.");
              b = b[0];
            }
            T = b;
          }
        }
        T == null && (T = ""), S = T;
      }
      p._wrapperState = {
        initialValue: Oi(S)
      };
    }
    function zw(o, a) {
      var p = o, S = Oi(a.value), b = Oi(a.defaultValue);
      if (S != null) {
        var T = Di(S);
        T !== p.value && (p.value = T), a.defaultValue == null && p.defaultValue !== T && (p.defaultValue = T);
      }
      b != null && (p.defaultValue = Di(b));
    }
    function Uw(o, a) {
      var p = o, S = p.textContent;
      S === p._wrapperState.initialValue && S !== "" && S !== null && (p.value = S);
    }
    function G_(o, a) {
      zw(o, a);
    }
    var ja = "http://www.w3.org/1999/xhtml", q_ = "http://www.w3.org/1998/Math/MathML", nv = "http://www.w3.org/2000/svg";
    function rv(o) {
      switch (o) {
        case "svg":
          return nv;
        case "math":
          return q_;
        default:
          return ja;
      }
    }
    function vg(o, a) {
      return o == null || o === ja ? rv(a) : o === nv && a === "foreignObject" ? ja : o;
    }
    var Y_ = function(o) {
      return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(a, p, S, b) {
        MSApp.execUnsafeLocalFunction(function() {
          return o(a, p, S, b);
        });
      } : o;
    }, Sg, $w = Y_(function(o, a) {
      if (o.namespaceURI === nv && !("innerHTML" in o)) {
        Sg = Sg || document.createElement("div"), Sg.innerHTML = "<svg>" + a.valueOf().toString() + "</svg>";
        for (var p = Sg.firstChild; o.firstChild; )
          o.removeChild(o.firstChild);
        for (; p.firstChild; )
          o.appendChild(p.firstChild);
        return;
      }
      o.innerHTML = a;
    }), Yo = 1, ql = 3, li = 8, Yl = 9, Oh = 11, Lc = function(o, a) {
      if (a) {
        var p = o.firstChild;
        if (p && p === o.lastChild && p.nodeType === ql) {
          p.nodeValue = a;
          return;
        }
      }
      o.textContent = a;
    }, X_ = {
      animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
      background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
      backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
      border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
      borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
      borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
      borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
      borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
      borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
      borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
      borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
      borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
      borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
      borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
      borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
      borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
      columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
      columns: ["columnCount", "columnWidth"],
      flex: ["flexBasis", "flexGrow", "flexShrink"],
      flexFlow: ["flexDirection", "flexWrap"],
      font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
      fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
      gap: ["columnGap", "rowGap"],
      grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
      gridColumn: ["gridColumnEnd", "gridColumnStart"],
      gridColumnGap: ["columnGap"],
      gridGap: ["columnGap", "rowGap"],
      gridRow: ["gridRowEnd", "gridRowStart"],
      gridRowGap: ["rowGap"],
      gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
      listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
      margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
      marker: ["markerEnd", "markerMid", "markerStart"],
      mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
      maskPosition: ["maskPositionX", "maskPositionY"],
      outline: ["outlineColor", "outlineStyle", "outlineWidth"],
      overflow: ["overflowX", "overflowY"],
      padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
      placeContent: ["alignContent", "justifyContent"],
      placeItems: ["alignItems", "justifyItems"],
      placeSelf: ["alignSelf", "justifySelf"],
      textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
      textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
      transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
      wordWrap: ["overflowWrap"]
    }, tf = {
      animationIterationCount: !0,
      aspectRatio: !0,
      borderImageOutset: !0,
      borderImageSlice: !0,
      borderImageWidth: !0,
      boxFlex: !0,
      boxFlexGroup: !0,
      boxOrdinalGroup: !0,
      columnCount: !0,
      columns: !0,
      flex: !0,
      flexGrow: !0,
      flexPositive: !0,
      flexShrink: !0,
      flexNegative: !0,
      flexOrder: !0,
      gridArea: !0,
      gridRow: !0,
      gridRowEnd: !0,
      gridRowSpan: !0,
      gridRowStart: !0,
      gridColumn: !0,
      gridColumnEnd: !0,
      gridColumnSpan: !0,
      gridColumnStart: !0,
      fontWeight: !0,
      lineClamp: !0,
      lineHeight: !0,
      opacity: !0,
      order: !0,
      orphans: !0,
      tabSize: !0,
      widows: !0,
      zIndex: !0,
      zoom: !0,
      // SVG-related properties
      fillOpacity: !0,
      floodOpacity: !0,
      stopOpacity: !0,
      strokeDasharray: !0,
      strokeDashoffset: !0,
      strokeMiterlimit: !0,
      strokeOpacity: !0,
      strokeWidth: !0
    };
    function Bw(o, a) {
      return o + a.charAt(0).toUpperCase() + a.substring(1);
    }
    var Hw = ["Webkit", "ms", "Moz", "O"];
    Object.keys(tf).forEach(function(o) {
      Hw.forEach(function(a) {
        tf[Bw(a, o)] = tf[o];
      });
    });
    function xg(o, a, p) {
      var S = a == null || typeof a == "boolean" || a === "";
      return S ? "" : !p && typeof a == "number" && a !== 0 && !(tf.hasOwnProperty(o) && tf[o]) ? a + "px" : (Pr(a, o), ("" + a).trim());
    }
    var Vw = /([A-Z])/g, nf = /^ms-/;
    function Z_(o) {
      return o.replace(Vw, "-$1").toLowerCase().replace(nf, "-ms-");
    }
    var Kw = function() {
    };
    {
      var Q_ = /^(?:webkit|moz|o)[A-Z]/, Ww = /^-ms-/, Gw = /-(.)/g, rf = /;\s*$/, dl = {}, iv = {}, jh = !1, qw = !1, Yw = function(o) {
        return o.replace(Gw, function(a, p) {
          return p.toUpperCase();
        });
      }, ov = function(o) {
        dl.hasOwnProperty(o) && dl[o] || (dl[o] = !0, c(
          "Unsupported style property %s. Did you mean %s?",
          o,
          // As Andi Smith suggests
          // (http://www.andismith.com/blog/2012/02/modernizr-prefixed/), an `-ms` prefix
          // is converted to lowercase `ms`.
          Yw(o.replace(Ww, "ms-"))
        ));
      }, sv = function(o) {
        dl.hasOwnProperty(o) && dl[o] || (dl[o] = !0, c("Unsupported vendor-prefixed style property %s. Did you mean %s?", o, o.charAt(0).toUpperCase() + o.slice(1)));
      }, Xw = function(o, a) {
        iv.hasOwnProperty(a) && iv[a] || (iv[a] = !0, c(`Style property values shouldn't contain a semicolon. Try "%s: %s" instead.`, o, a.replace(rf, "")));
      }, Zw = function(o, a) {
        jh || (jh = !0, c("`NaN` is an invalid value for the `%s` css style property.", o));
      }, Qw = function(o, a) {
        qw || (qw = !0, c("`Infinity` is an invalid value for the `%s` css style property.", o));
      };
      Kw = function(o, a) {
        o.indexOf("-") > -1 ? ov(o) : Q_.test(o) ? sv(o) : rf.test(a) && Xw(o, a), typeof a == "number" && (isNaN(a) ? Zw(o, a) : isFinite(a) || Qw(o, a));
      };
    }
    var J_ = Kw;
    function eP(o) {
      {
        var a = "", p = "";
        for (var S in o)
          if (o.hasOwnProperty(S)) {
            var b = o[S];
            if (b != null) {
              var T = S.indexOf("--") === 0;
              a += p + (T ? S : Z_(S)) + ":", a += xg(S, b, T), p = ";";
            }
          }
        return a || null;
      }
    }
    function Jw(o, a) {
      var p = o.style;
      for (var S in a)
        if (a.hasOwnProperty(S)) {
          var b = S.indexOf("--") === 0;
          b || J_(S, a[S]);
          var T = xg(S, a[S], b);
          S === "float" && (S = "cssFloat"), b ? p.setProperty(S, T) : p[S] = T;
        }
    }
    function tP(o) {
      return o == null || typeof o == "boolean" || o === "";
    }
    function eb(o) {
      var a = {};
      for (var p in o)
        for (var S = X_[p] || [p], b = 0; b < S.length; b++)
          a[S[b]] = p;
      return a;
    }
    function La(o, a) {
      {
        if (!a)
          return;
        var p = eb(o), S = eb(a), b = {};
        for (var T in p) {
          var D = p[T], N = S[T];
          if (N && D !== N) {
            var $ = D + "," + N;
            if (b[$])
              continue;
            b[$] = !0, c("%s a style property during rerender (%s) when a conflicting property is set (%s) can lead to styling bugs. To avoid this, don't mix shorthand and non-shorthand properties for the same value; instead, replace the shorthand with separate values.", tP(o[D]) ? "Removing" : "Updating", D, N);
          }
        }
      }
    }
    var Lh = {
      area: !0,
      base: !0,
      br: !0,
      col: !0,
      embed: !0,
      hr: !0,
      img: !0,
      input: !0,
      keygen: !0,
      link: !0,
      meta: !0,
      param: !0,
      source: !0,
      track: !0,
      wbr: !0
      // NOTE: menuitem's close tag should be omitted, but that causes problems.
    }, tb = Gt({
      menuitem: !0
    }, Lh), nb = "__html";
    function wg(o, a) {
      if (a) {
        if (tb[o] && (a.children != null || a.dangerouslySetInnerHTML != null))
          throw new Error(o + " is a void element tag and must neither have `children` nor use `dangerouslySetInnerHTML`.");
        if (a.dangerouslySetInnerHTML != null) {
          if (a.children != null)
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          if (typeof a.dangerouslySetInnerHTML != "object" || !(nb in a.dangerouslySetInnerHTML))
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. Please visit https://reactjs.org/link/dangerously-set-inner-html for more information.");
        }
        if (!a.suppressContentEditableWarning && a.contentEditable && a.children != null && c("A component is `contentEditable` and contains `children` managed by React. It is now your responsibility to guarantee that none of those nodes are unexpectedly modified or duplicated. This is probably not intentional."), a.style != null && typeof a.style != "object")
          throw new Error("The `style` prop expects a mapping from style properties to values, not a string. For example, style={{marginRight: spacing + 'em'}} when using JSX.");
      }
    }
    function Nc(o, a) {
      if (o.indexOf("-") === -1)
        return typeof a.is == "string";
      switch (o) {
        // These are reserved SVG and MathML elements.
        // We don't mind this list too much because we expect it to never grow.
        // The alternative is to track the namespace in a few places which is convoluted.
        // https://w3c.github.io/webcomponents/spec/custom/#custom-elements-core-concepts
        case "annotation-xml":
        case "color-profile":
        case "font-face":
        case "font-face-src":
        case "font-face-uri":
        case "font-face-format":
        case "font-face-name":
        case "missing-glyph":
          return !1;
        default:
          return !0;
      }
    }
    var of = {
      // HTML
      accept: "accept",
      acceptcharset: "acceptCharset",
      "accept-charset": "acceptCharset",
      accesskey: "accessKey",
      action: "action",
      allowfullscreen: "allowFullScreen",
      alt: "alt",
      as: "as",
      async: "async",
      autocapitalize: "autoCapitalize",
      autocomplete: "autoComplete",
      autocorrect: "autoCorrect",
      autofocus: "autoFocus",
      autoplay: "autoPlay",
      autosave: "autoSave",
      capture: "capture",
      cellpadding: "cellPadding",
      cellspacing: "cellSpacing",
      challenge: "challenge",
      charset: "charSet",
      checked: "checked",
      children: "children",
      cite: "cite",
      class: "className",
      classid: "classID",
      classname: "className",
      cols: "cols",
      colspan: "colSpan",
      content: "content",
      contenteditable: "contentEditable",
      contextmenu: "contextMenu",
      controls: "controls",
      controlslist: "controlsList",
      coords: "coords",
      crossorigin: "crossOrigin",
      dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
      data: "data",
      datetime: "dateTime",
      default: "default",
      defaultchecked: "defaultChecked",
      defaultvalue: "defaultValue",
      defer: "defer",
      dir: "dir",
      disabled: "disabled",
      disablepictureinpicture: "disablePictureInPicture",
      disableremoteplayback: "disableRemotePlayback",
      download: "download",
      draggable: "draggable",
      enctype: "encType",
      enterkeyhint: "enterKeyHint",
      for: "htmlFor",
      form: "form",
      formmethod: "formMethod",
      formaction: "formAction",
      formenctype: "formEncType",
      formnovalidate: "formNoValidate",
      formtarget: "formTarget",
      frameborder: "frameBorder",
      headers: "headers",
      height: "height",
      hidden: "hidden",
      high: "high",
      href: "href",
      hreflang: "hrefLang",
      htmlfor: "htmlFor",
      httpequiv: "httpEquiv",
      "http-equiv": "httpEquiv",
      icon: "icon",
      id: "id",
      imagesizes: "imageSizes",
      imagesrcset: "imageSrcSet",
      innerhtml: "innerHTML",
      inputmode: "inputMode",
      integrity: "integrity",
      is: "is",
      itemid: "itemID",
      itemprop: "itemProp",
      itemref: "itemRef",
      itemscope: "itemScope",
      itemtype: "itemType",
      keyparams: "keyParams",
      keytype: "keyType",
      kind: "kind",
      label: "label",
      lang: "lang",
      list: "list",
      loop: "loop",
      low: "low",
      manifest: "manifest",
      marginwidth: "marginWidth",
      marginheight: "marginHeight",
      max: "max",
      maxlength: "maxLength",
      media: "media",
      mediagroup: "mediaGroup",
      method: "method",
      min: "min",
      minlength: "minLength",
      multiple: "multiple",
      muted: "muted",
      name: "name",
      nomodule: "noModule",
      nonce: "nonce",
      novalidate: "noValidate",
      open: "open",
      optimum: "optimum",
      pattern: "pattern",
      placeholder: "placeholder",
      playsinline: "playsInline",
      poster: "poster",
      preload: "preload",
      profile: "profile",
      radiogroup: "radioGroup",
      readonly: "readOnly",
      referrerpolicy: "referrerPolicy",
      rel: "rel",
      required: "required",
      reversed: "reversed",
      role: "role",
      rows: "rows",
      rowspan: "rowSpan",
      sandbox: "sandbox",
      scope: "scope",
      scoped: "scoped",
      scrolling: "scrolling",
      seamless: "seamless",
      selected: "selected",
      shape: "shape",
      size: "size",
      sizes: "sizes",
      span: "span",
      spellcheck: "spellCheck",
      src: "src",
      srcdoc: "srcDoc",
      srclang: "srcLang",
      srcset: "srcSet",
      start: "start",
      step: "step",
      style: "style",
      summary: "summary",
      tabindex: "tabIndex",
      target: "target",
      title: "title",
      type: "type",
      usemap: "useMap",
      value: "value",
      width: "width",
      wmode: "wmode",
      wrap: "wrap",
      // SVG
      about: "about",
      accentheight: "accentHeight",
      "accent-height": "accentHeight",
      accumulate: "accumulate",
      additive: "additive",
      alignmentbaseline: "alignmentBaseline",
      "alignment-baseline": "alignmentBaseline",
      allowreorder: "allowReorder",
      alphabetic: "alphabetic",
      amplitude: "amplitude",
      arabicform: "arabicForm",
      "arabic-form": "arabicForm",
      ascent: "ascent",
      attributename: "attributeName",
      attributetype: "attributeType",
      autoreverse: "autoReverse",
      azimuth: "azimuth",
      basefrequency: "baseFrequency",
      baselineshift: "baselineShift",
      "baseline-shift": "baselineShift",
      baseprofile: "baseProfile",
      bbox: "bbox",
      begin: "begin",
      bias: "bias",
      by: "by",
      calcmode: "calcMode",
      capheight: "capHeight",
      "cap-height": "capHeight",
      clip: "clip",
      clippath: "clipPath",
      "clip-path": "clipPath",
      clippathunits: "clipPathUnits",
      cliprule: "clipRule",
      "clip-rule": "clipRule",
      color: "color",
      colorinterpolation: "colorInterpolation",
      "color-interpolation": "colorInterpolation",
      colorinterpolationfilters: "colorInterpolationFilters",
      "color-interpolation-filters": "colorInterpolationFilters",
      colorprofile: "colorProfile",
      "color-profile": "colorProfile",
      colorrendering: "colorRendering",
      "color-rendering": "colorRendering",
      contentscripttype: "contentScriptType",
      contentstyletype: "contentStyleType",
      cursor: "cursor",
      cx: "cx",
      cy: "cy",
      d: "d",
      datatype: "datatype",
      decelerate: "decelerate",
      descent: "descent",
      diffuseconstant: "diffuseConstant",
      direction: "direction",
      display: "display",
      divisor: "divisor",
      dominantbaseline: "dominantBaseline",
      "dominant-baseline": "dominantBaseline",
      dur: "dur",
      dx: "dx",
      dy: "dy",
      edgemode: "edgeMode",
      elevation: "elevation",
      enablebackground: "enableBackground",
      "enable-background": "enableBackground",
      end: "end",
      exponent: "exponent",
      externalresourcesrequired: "externalResourcesRequired",
      fill: "fill",
      fillopacity: "fillOpacity",
      "fill-opacity": "fillOpacity",
      fillrule: "fillRule",
      "fill-rule": "fillRule",
      filter: "filter",
      filterres: "filterRes",
      filterunits: "filterUnits",
      floodopacity: "floodOpacity",
      "flood-opacity": "floodOpacity",
      floodcolor: "floodColor",
      "flood-color": "floodColor",
      focusable: "focusable",
      fontfamily: "fontFamily",
      "font-family": "fontFamily",
      fontsize: "fontSize",
      "font-size": "fontSize",
      fontsizeadjust: "fontSizeAdjust",
      "font-size-adjust": "fontSizeAdjust",
      fontstretch: "fontStretch",
      "font-stretch": "fontStretch",
      fontstyle: "fontStyle",
      "font-style": "fontStyle",
      fontvariant: "fontVariant",
      "font-variant": "fontVariant",
      fontweight: "fontWeight",
      "font-weight": "fontWeight",
      format: "format",
      from: "from",
      fx: "fx",
      fy: "fy",
      g1: "g1",
      g2: "g2",
      glyphname: "glyphName",
      "glyph-name": "glyphName",
      glyphorientationhorizontal: "glyphOrientationHorizontal",
      "glyph-orientation-horizontal": "glyphOrientationHorizontal",
      glyphorientationvertical: "glyphOrientationVertical",
      "glyph-orientation-vertical": "glyphOrientationVertical",
      glyphref: "glyphRef",
      gradienttransform: "gradientTransform",
      gradientunits: "gradientUnits",
      hanging: "hanging",
      horizadvx: "horizAdvX",
      "horiz-adv-x": "horizAdvX",
      horizoriginx: "horizOriginX",
      "horiz-origin-x": "horizOriginX",
      ideographic: "ideographic",
      imagerendering: "imageRendering",
      "image-rendering": "imageRendering",
      in2: "in2",
      in: "in",
      inlist: "inlist",
      intercept: "intercept",
      k1: "k1",
      k2: "k2",
      k3: "k3",
      k4: "k4",
      k: "k",
      kernelmatrix: "kernelMatrix",
      kernelunitlength: "kernelUnitLength",
      kerning: "kerning",
      keypoints: "keyPoints",
      keysplines: "keySplines",
      keytimes: "keyTimes",
      lengthadjust: "lengthAdjust",
      letterspacing: "letterSpacing",
      "letter-spacing": "letterSpacing",
      lightingcolor: "lightingColor",
      "lighting-color": "lightingColor",
      limitingconeangle: "limitingConeAngle",
      local: "local",
      markerend: "markerEnd",
      "marker-end": "markerEnd",
      markerheight: "markerHeight",
      markermid: "markerMid",
      "marker-mid": "markerMid",
      markerstart: "markerStart",
      "marker-start": "markerStart",
      markerunits: "markerUnits",
      markerwidth: "markerWidth",
      mask: "mask",
      maskcontentunits: "maskContentUnits",
      maskunits: "maskUnits",
      mathematical: "mathematical",
      mode: "mode",
      numoctaves: "numOctaves",
      offset: "offset",
      opacity: "opacity",
      operator: "operator",
      order: "order",
      orient: "orient",
      orientation: "orientation",
      origin: "origin",
      overflow: "overflow",
      overlineposition: "overlinePosition",
      "overline-position": "overlinePosition",
      overlinethickness: "overlineThickness",
      "overline-thickness": "overlineThickness",
      paintorder: "paintOrder",
      "paint-order": "paintOrder",
      panose1: "panose1",
      "panose-1": "panose1",
      pathlength: "pathLength",
      patterncontentunits: "patternContentUnits",
      patterntransform: "patternTransform",
      patternunits: "patternUnits",
      pointerevents: "pointerEvents",
      "pointer-events": "pointerEvents",
      points: "points",
      pointsatx: "pointsAtX",
      pointsaty: "pointsAtY",
      pointsatz: "pointsAtZ",
      prefix: "prefix",
      preservealpha: "preserveAlpha",
      preserveaspectratio: "preserveAspectRatio",
      primitiveunits: "primitiveUnits",
      property: "property",
      r: "r",
      radius: "radius",
      refx: "refX",
      refy: "refY",
      renderingintent: "renderingIntent",
      "rendering-intent": "renderingIntent",
      repeatcount: "repeatCount",
      repeatdur: "repeatDur",
      requiredextensions: "requiredExtensions",
      requiredfeatures: "requiredFeatures",
      resource: "resource",
      restart: "restart",
      result: "result",
      results: "results",
      rotate: "rotate",
      rx: "rx",
      ry: "ry",
      scale: "scale",
      security: "security",
      seed: "seed",
      shaperendering: "shapeRendering",
      "shape-rendering": "shapeRendering",
      slope: "slope",
      spacing: "spacing",
      specularconstant: "specularConstant",
      specularexponent: "specularExponent",
      speed: "speed",
      spreadmethod: "spreadMethod",
      startoffset: "startOffset",
      stddeviation: "stdDeviation",
      stemh: "stemh",
      stemv: "stemv",
      stitchtiles: "stitchTiles",
      stopcolor: "stopColor",
      "stop-color": "stopColor",
      stopopacity: "stopOpacity",
      "stop-opacity": "stopOpacity",
      strikethroughposition: "strikethroughPosition",
      "strikethrough-position": "strikethroughPosition",
      strikethroughthickness: "strikethroughThickness",
      "strikethrough-thickness": "strikethroughThickness",
      string: "string",
      stroke: "stroke",
      strokedasharray: "strokeDasharray",
      "stroke-dasharray": "strokeDasharray",
      strokedashoffset: "strokeDashoffset",
      "stroke-dashoffset": "strokeDashoffset",
      strokelinecap: "strokeLinecap",
      "stroke-linecap": "strokeLinecap",
      strokelinejoin: "strokeLinejoin",
      "stroke-linejoin": "strokeLinejoin",
      strokemiterlimit: "strokeMiterlimit",
      "stroke-miterlimit": "strokeMiterlimit",
      strokewidth: "strokeWidth",
      "stroke-width": "strokeWidth",
      strokeopacity: "strokeOpacity",
      "stroke-opacity": "strokeOpacity",
      suppresscontenteditablewarning: "suppressContentEditableWarning",
      suppresshydrationwarning: "suppressHydrationWarning",
      surfacescale: "surfaceScale",
      systemlanguage: "systemLanguage",
      tablevalues: "tableValues",
      targetx: "targetX",
      targety: "targetY",
      textanchor: "textAnchor",
      "text-anchor": "textAnchor",
      textdecoration: "textDecoration",
      "text-decoration": "textDecoration",
      textlength: "textLength",
      textrendering: "textRendering",
      "text-rendering": "textRendering",
      to: "to",
      transform: "transform",
      typeof: "typeof",
      u1: "u1",
      u2: "u2",
      underlineposition: "underlinePosition",
      "underline-position": "underlinePosition",
      underlinethickness: "underlineThickness",
      "underline-thickness": "underlineThickness",
      unicode: "unicode",
      unicodebidi: "unicodeBidi",
      "unicode-bidi": "unicodeBidi",
      unicoderange: "unicodeRange",
      "unicode-range": "unicodeRange",
      unitsperem: "unitsPerEm",
      "units-per-em": "unitsPerEm",
      unselectable: "unselectable",
      valphabetic: "vAlphabetic",
      "v-alphabetic": "vAlphabetic",
      values: "values",
      vectoreffect: "vectorEffect",
      "vector-effect": "vectorEffect",
      version: "version",
      vertadvy: "vertAdvY",
      "vert-adv-y": "vertAdvY",
      vertoriginx: "vertOriginX",
      "vert-origin-x": "vertOriginX",
      vertoriginy: "vertOriginY",
      "vert-origin-y": "vertOriginY",
      vhanging: "vHanging",
      "v-hanging": "vHanging",
      videographic: "vIdeographic",
      "v-ideographic": "vIdeographic",
      viewbox: "viewBox",
      viewtarget: "viewTarget",
      visibility: "visibility",
      vmathematical: "vMathematical",
      "v-mathematical": "vMathematical",
      vocab: "vocab",
      widths: "widths",
      wordspacing: "wordSpacing",
      "word-spacing": "wordSpacing",
      writingmode: "writingMode",
      "writing-mode": "writingMode",
      x1: "x1",
      x2: "x2",
      x: "x",
      xchannelselector: "xChannelSelector",
      xheight: "xHeight",
      "x-height": "xHeight",
      xlinkactuate: "xlinkActuate",
      "xlink:actuate": "xlinkActuate",
      xlinkarcrole: "xlinkArcrole",
      "xlink:arcrole": "xlinkArcrole",
      xlinkhref: "xlinkHref",
      "xlink:href": "xlinkHref",
      xlinkrole: "xlinkRole",
      "xlink:role": "xlinkRole",
      xlinkshow: "xlinkShow",
      "xlink:show": "xlinkShow",
      xlinktitle: "xlinkTitle",
      "xlink:title": "xlinkTitle",
      xlinktype: "xlinkType",
      "xlink:type": "xlinkType",
      xmlbase: "xmlBase",
      "xml:base": "xmlBase",
      xmllang: "xmlLang",
      "xml:lang": "xmlLang",
      xmlns: "xmlns",
      "xml:space": "xmlSpace",
      xmlnsxlink: "xmlnsXlink",
      "xmlns:xlink": "xmlnsXlink",
      xmlspace: "xmlSpace",
      y1: "y1",
      y2: "y2",
      y: "y",
      ychannelselector: "yChannelSelector",
      z: "z",
      zoomandpan: "zoomAndPan"
    }, rb = {
      "aria-current": 0,
      // state
      "aria-description": 0,
      "aria-details": 0,
      "aria-disabled": 0,
      // state
      "aria-hidden": 0,
      // state
      "aria-invalid": 0,
      // state
      "aria-keyshortcuts": 0,
      "aria-label": 0,
      "aria-roledescription": 0,
      // Widget Attributes
      "aria-autocomplete": 0,
      "aria-checked": 0,
      "aria-expanded": 0,
      "aria-haspopup": 0,
      "aria-level": 0,
      "aria-modal": 0,
      "aria-multiline": 0,
      "aria-multiselectable": 0,
      "aria-orientation": 0,
      "aria-placeholder": 0,
      "aria-pressed": 0,
      "aria-readonly": 0,
      "aria-required": 0,
      "aria-selected": 0,
      "aria-sort": 0,
      "aria-valuemax": 0,
      "aria-valuemin": 0,
      "aria-valuenow": 0,
      "aria-valuetext": 0,
      // Live Region Attributes
      "aria-atomic": 0,
      "aria-busy": 0,
      "aria-live": 0,
      "aria-relevant": 0,
      // Drag-and-Drop Attributes
      "aria-dropeffect": 0,
      "aria-grabbed": 0,
      // Relationship Attributes
      "aria-activedescendant": 0,
      "aria-colcount": 0,
      "aria-colindex": 0,
      "aria-colspan": 0,
      "aria-controls": 0,
      "aria-describedby": 0,
      "aria-errormessage": 0,
      "aria-flowto": 0,
      "aria-labelledby": 0,
      "aria-owns": 0,
      "aria-posinset": 0,
      "aria-rowcount": 0,
      "aria-rowindex": 0,
      "aria-rowspan": 0,
      "aria-setsize": 0
    }, sf = {}, af = new RegExp("^(aria)-[" + ve + "]*$"), av = new RegExp("^(aria)[A-Z][" + ve + "]*$");
    function Nh(o, a) {
      {
        if (Zt.call(sf, a) && sf[a])
          return !0;
        if (av.test(a)) {
          var p = "aria-" + a.slice(4).toLowerCase(), S = rb.hasOwnProperty(p) ? p : null;
          if (S == null)
            return c("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", a), sf[a] = !0, !0;
          if (a !== S)
            return c("Invalid ARIA attribute `%s`. Did you mean `%s`?", a, S), sf[a] = !0, !0;
        }
        if (af.test(a)) {
          var b = a.toLowerCase(), T = rb.hasOwnProperty(b) ? b : null;
          if (T == null)
            return sf[a] = !0, !1;
          if (a !== T)
            return c("Unknown ARIA attribute `%s`. Did you mean `%s`?", a, T), sf[a] = !0, !0;
        }
      }
      return !0;
    }
    function lv(o, a) {
      {
        var p = [];
        for (var S in a) {
          var b = Nh(o, S);
          b || p.push(S);
        }
        var T = p.map(function(D) {
          return "`" + D + "`";
        }).join(", ");
        p.length === 1 ? c("Invalid aria prop %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", T, o) : p.length > 1 && c("Invalid aria props %s on <%s> tag. For details, see https://reactjs.org/link/invalid-aria-props", T, o);
      }
    }
    function ib(o, a) {
      Nc(o, a) || lv(o, a);
    }
    var Fh = !1;
    function lf(o, a) {
      {
        if (o !== "input" && o !== "textarea" && o !== "select")
          return;
        a != null && a.value === null && !Fh && (Fh = !0, o === "select" && a.multiple ? c("`value` prop on `%s` should not be null. Consider using an empty array when `multiple` is set to `true` to clear the component or `undefined` for uncontrolled components.", o) : c("`value` prop on `%s` should not be null. Consider using an empty string to clear the component or `undefined` for uncontrolled components.", o));
      }
    }
    var bg = function() {
    };
    {
      var co = {}, zh = /^on./, ob = /^on[^A-Z]/, sb = new RegExp("^(aria)-[" + ve + "]*$"), ab = new RegExp("^(aria)[A-Z][" + ve + "]*$");
      bg = function(o, a, p, S) {
        if (Zt.call(co, a) && co[a])
          return !0;
        var b = a.toLowerCase();
        if (b === "onfocusin" || b === "onfocusout")
          return c("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. All React events are normalized to bubble, so onFocusIn and onFocusOut are not needed/supported by React."), co[a] = !0, !0;
        if (S != null) {
          var T = S.registrationNameDependencies, D = S.possibleRegistrationNames;
          if (T.hasOwnProperty(a))
            return !0;
          var N = D.hasOwnProperty(b) ? D[b] : null;
          if (N != null)
            return c("Invalid event handler property `%s`. Did you mean `%s`?", a, N), co[a] = !0, !0;
          if (zh.test(a))
            return c("Unknown event handler property `%s`. It will be ignored.", a), co[a] = !0, !0;
        } else if (zh.test(a))
          return ob.test(a) && c("Invalid event handler property `%s`. React events use the camelCase naming convention, for example `onClick`.", a), co[a] = !0, !0;
        if (sb.test(a) || ab.test(a))
          return !0;
        if (b === "innerhtml")
          return c("Directly setting property `innerHTML` is not permitted. For more information, lookup documentation on `dangerouslySetInnerHTML`."), co[a] = !0, !0;
        if (b === "aria")
          return c("The `aria` attribute is reserved for future use in React. Pass individual `aria-` attributes instead."), co[a] = !0, !0;
        if (b === "is" && p !== null && p !== void 0 && typeof p != "string")
          return c("Received a `%s` for a string attribute `is`. If this is expected, cast the value to a string.", typeof p), co[a] = !0, !0;
        if (typeof p == "number" && isNaN(p))
          return c("Received NaN for the `%s` attribute. If this is expected, cast the value to a string.", a), co[a] = !0, !0;
        var $ = bn(a), G = $ !== null && $.type === Kr;
        if (of.hasOwnProperty(b)) {
          var X = of[b];
          if (X !== a)
            return c("Invalid DOM property `%s`. Did you mean `%s`?", a, X), co[a] = !0, !0;
        } else if (!G && a !== b)
          return c("React does not recognize the `%s` prop on a DOM element. If you intentionally want it to appear in the DOM as a custom attribute, spell it as lowercase `%s` instead. If you accidentally passed it from a parent component, remove it from the DOM element.", a, b), co[a] = !0, !0;
        return typeof p == "boolean" && Rn(a, p, $, !1) ? (p ? c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.', p, a, a, p, a) : c('Received `%s` for a non-boolean attribute `%s`.\n\nIf you want to write it to the DOM, pass a string instead: %s="%s" or %s={value.toString()}.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.', p, a, a, p, a, a, a), co[a] = !0, !0) : G ? !0 : Rn(a, p, $, !1) ? (co[a] = !0, !1) : ((p === "false" || p === "true") && $ !== null && $.type === Tr && (c("Received the string `%s` for the boolean attribute `%s`. %s Did you mean %s={%s}?", p, a, p === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', a, p), co[a] = !0), !0);
      };
    }
    var lb = function(o, a, p) {
      {
        var S = [];
        for (var b in a) {
          var T = bg(o, b, a[b], p);
          T || S.push(b);
        }
        var D = S.map(function(N) {
          return "`" + N + "`";
        }).join(", ");
        S.length === 1 ? c("Invalid value for prop %s on <%s> tag. Either remove it from the element, or pass a string or number value to keep it in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", D, o) : S.length > 1 && c("Invalid values for props %s on <%s> tag. Either remove them from the element, or pass a string or number value to keep them in the DOM. For details, see https://reactjs.org/link/attribute-behavior ", D, o);
      }
    };
    function cb(o, a, p) {
      Nc(o, a) || lb(o, a, p);
    }
    var cv = 1, fl = 2, Hu = 4, uv = cv | fl | Hu, Uh = null;
    function nP(o) {
      Uh !== null && c("Expected currently replaying event to be null. This error is likely caused by a bug in React. Please file an issue."), Uh = o;
    }
    function $h() {
      Uh === null && c("Expected currently replaying event to not be null. This error is likely caused by a bug in React. Please file an issue."), Uh = null;
    }
    function rP(o) {
      return o === Uh;
    }
    function Cg(o) {
      var a = o.target || o.srcElement || window;
      return a.correspondingUseElement && (a = a.correspondingUseElement), a.nodeType === ql ? a.parentNode : a;
    }
    var Eg = null, Jn = null, Fc = null;
    function Bh(o) {
      var a = Lf(o);
      if (a) {
        if (typeof Eg != "function")
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled events. This error is likely caused by a bug in React. Please file an issue.");
        var p = a.stateNode;
        if (p) {
          var S = f0(p);
          Eg(a.stateNode, a.type, S);
        }
      }
    }
    function Hh(o) {
      Eg = o;
    }
    function dv(o) {
      Jn ? Fc ? Fc.push(o) : Fc = [o] : Jn = o;
    }
    function fv() {
      return Jn !== null || Fc !== null;
    }
    function cf() {
      if (Jn) {
        var o = Jn, a = Fc;
        if (Jn = null, Fc = null, Bh(o), a)
          for (var p = 0; p < a.length; p++)
            Bh(a[p]);
      }
    }
    var Vh = function(o, a) {
      return o(a);
    }, Vu = function() {
    }, _g = !1;
    function iP() {
      var o = fv();
      o && (Vu(), cf());
    }
    function ub(o, a, p) {
      if (_g)
        return o(a, p);
      _g = !0;
      try {
        return Vh(o, a, p);
      } finally {
        _g = !1, iP();
      }
    }
    function db(o, a, p) {
      Vh = o, Vu = p;
    }
    function Pg(o) {
      return o === "button" || o === "input" || o === "select" || o === "textarea";
    }
    function Tg(o, a, p) {
      switch (o) {
        case "onClick":
        case "onClickCapture":
        case "onDoubleClick":
        case "onDoubleClickCapture":
        case "onMouseDown":
        case "onMouseDownCapture":
        case "onMouseMove":
        case "onMouseMoveCapture":
        case "onMouseUp":
        case "onMouseUpCapture":
        case "onMouseEnter":
          return !!(p.disabled && Pg(a));
        default:
          return !1;
      }
    }
    function Ku(o, a) {
      var p = o.stateNode;
      if (p === null)
        return null;
      var S = f0(p);
      if (S === null)
        return null;
      var b = S[a];
      if (Tg(a, o.type, S))
        return null;
      if (b && typeof b != "function")
        throw new Error("Expected `" + a + "` listener to be a function, instead got a value of `" + typeof b + "` type.");
      return b;
    }
    var Kh = !1;
    if (mn)
      try {
        var Wu = {};
        Object.defineProperty(Wu, "passive", {
          get: function() {
            Kh = !0;
          }
        }), window.addEventListener("test", Wu, Wu), window.removeEventListener("test", Wu, Wu);
      } catch {
        Kh = !1;
      }
    function Ig(o, a, p, S, b, T, D, N, $) {
      var G = Array.prototype.slice.call(arguments, 3);
      try {
        a.apply(p, G);
      } catch (X) {
        this.onError(X);
      }
    }
    var fb = Ig;
    if (typeof window < "u" && typeof window.dispatchEvent == "function" && typeof document < "u" && typeof document.createEvent == "function") {
      var kg = document.createElement("react");
      fb = function(a, p, S, b, T, D, N, $, G) {
        if (typeof document > "u" || document === null)
          throw new Error("The `document` global was defined when React was initialized, but is not defined anymore. This can happen in a test environment if a component schedules an update from an asynchronous callback, but the test has already finished running. To solve this, you can either unmount the component at the end of your test (and ensure that any asynchronous operations get canceled in `componentWillUnmount`), or you can change the test itself to be asynchronous.");
        var X = document.createEvent("Event"), fe = !1, ue = !0, _e = window.event, Ie = Object.getOwnPropertyDescriptor(window, "event");
        function Me() {
          kg.removeEventListener(Ae, Dt, !1), typeof window.event < "u" && window.hasOwnProperty("event") && (window.event = _e);
        }
        var st = Array.prototype.slice.call(arguments, 3);
        function Dt() {
          fe = !0, Me(), p.apply(S, st), ue = !1;
        }
        var Tt, Dn = !1, En = !1;
        function xe(we) {
          if (Tt = we.error, Dn = !0, Tt === null && we.colno === 0 && we.lineno === 0 && (En = !0), we.defaultPrevented && Tt != null && typeof Tt == "object")
            try {
              Tt._suppressLogging = !0;
            } catch {
            }
        }
        var Ae = "react-" + (a || "invokeguardedcallback");
        if (window.addEventListener("error", xe), kg.addEventListener(Ae, Dt, !1), X.initEvent(Ae, !1, !1), kg.dispatchEvent(X), Ie && Object.defineProperty(window, "event", Ie), fe && ue && (Dn ? En && (Tt = new Error("A cross-origin error was thrown. React doesn't have access to the actual error object in development. See https://reactjs.org/link/crossorigin-error for more information.")) : Tt = new Error(`An error was thrown inside one of your components, but React doesn't know what it was. This is likely due to browser flakiness. React does its best to preserve the "Pause on exceptions" behavior of the DevTools, which requires some DEV-mode only tricks. It's possible that these don't work in your browser. Try triggering the error in production mode, or switching to a modern browser. If you suspect that this is actually an issue with React, please file an issue.`), this.onError(Tt)), window.removeEventListener("error", xe), !fe)
          return Me(), Ig.apply(this, arguments);
      };
    }
    var oP = fb, uf = !1, df = null, Na = !1, Rg = null, ff = {
      onError: function(o) {
        uf = !0, df = o;
      }
    };
    function Js(o, a, p, S, b, T, D, N, $) {
      uf = !1, df = null, oP.apply(ff, arguments);
    }
    function Wh(o, a, p, S, b, T, D, N, $) {
      if (Js.apply(this, arguments), uf) {
        var G = pv();
        Na || (Na = !0, Rg = G);
      }
    }
    function Xl() {
      if (Na) {
        var o = Rg;
        throw Na = !1, Rg = null, o;
      }
    }
    function hv() {
      return uf;
    }
    function pv() {
      if (uf) {
        var o = df;
        return uf = !1, df = null, o;
      } else
        throw new Error("clearCaughtError was called but no error was captured. This error is likely caused by a bug in React. Please file an issue.");
    }
    function hf(o) {
      return o._reactInternals;
    }
    function Gu(o) {
      return o._reactInternals !== void 0;
    }
    function Gh(o, a) {
      o._reactInternals = a;
    }
    var Rt = (
      /*                      */
      0
    ), Zl = (
      /*                */
      1
    ), ci = (
      /*                    */
      2
    ), Sn = (
      /*                       */
      4
    ), Xo = (
      /*                */
      16
    ), cr = (
      /*                 */
      32
    ), gr = (
      /*                     */
      64
    ), hn = (
      /*                   */
      128
    ), Wr = (
      /*            */
      256
    ), ui = (
      /*                          */
      512
    ), ea = (
      /*                     */
      1024
    ), Rs = (
      /*                      */
      2048
    ), di = (
      /*                    */
      4096
    ), hl = (
      /*                   */
      8192
    ), Mg = (
      /*             */
      16384
    ), hb = (
      /*               */
      32767
    ), qu = (
      /*                   */
      32768
    ), ta = (
      /*                */
      65536
    ), Fa = (
      /* */
      131072
    ), qh = (
      /*                       */
      1048576
    ), Yh = (
      /*                    */
      2097152
    ), zc = (
      /*                 */
      4194304
    ), gv = (
      /*                */
      8388608
    ), wo = (
      /*               */
      16777216
    ), Uc = (
      /*              */
      33554432
    ), $c = (
      // TODO: Remove Update flag from before mutation phase by re-landing Visibility
      // flag logic (see #20043)
      Sn | ea | 0
    ), pf = ci | Sn | Xo | cr | ui | di | hl, Bc = Sn | gr | ui | hl, Vi = Rs | Xo, fi = zc | gv | Yh, Yu = r.ReactCurrentOwner;
    function bo(o) {
      var a = o, p = o;
      if (o.alternate)
        for (; a.return; )
          a = a.return;
      else {
        var S = a;
        do
          a = S, (a.flags & (ci | di)) !== Rt && (p = a.return), S = a.return;
        while (S);
      }
      return a.tag === v ? p : null;
    }
    function pl(o) {
      if (o.tag === F) {
        var a = o.memoizedState;
        if (a === null) {
          var p = o.alternate;
          p !== null && (a = p.memoizedState);
        }
        if (a !== null)
          return a.dehydrated;
      }
      return null;
    }
    function Hc(o) {
      return o.tag === v ? o.stateNode.containerInfo : null;
    }
    function pb(o) {
      return bo(o) === o;
    }
    function mv(o) {
      {
        var a = Yu.current;
        if (a !== null && a.tag === g) {
          var p = a, S = p.stateNode;
          S._warnedAboutRefsInRender || c("%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Ut(p) || "A component"), S._warnedAboutRefsInRender = !0;
        }
      }
      var b = hf(o);
      return b ? bo(b) === b : !1;
    }
    function Ag(o) {
      if (bo(o) !== o)
        throw new Error("Unable to find node on an unmounted component.");
    }
    function Zo(o) {
      var a = o.alternate;
      if (!a) {
        var p = bo(o);
        if (p === null)
          throw new Error("Unable to find node on an unmounted component.");
        return p !== o ? null : o;
      }
      for (var S = o, b = a; ; ) {
        var T = S.return;
        if (T === null)
          break;
        var D = T.alternate;
        if (D === null) {
          var N = T.return;
          if (N !== null) {
            S = b = N;
            continue;
          }
          break;
        }
        if (T.child === D.child) {
          for (var $ = T.child; $; ) {
            if ($ === S)
              return Ag(T), o;
            if ($ === b)
              return Ag(T), a;
            $ = $.sibling;
          }
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (S.return !== b.return)
          S = T, b = D;
        else {
          for (var G = !1, X = T.child; X; ) {
            if (X === S) {
              G = !0, S = T, b = D;
              break;
            }
            if (X === b) {
              G = !0, b = T, S = D;
              break;
            }
            X = X.sibling;
          }
          if (!G) {
            for (X = D.child; X; ) {
              if (X === S) {
                G = !0, S = D, b = T;
                break;
              }
              if (X === b) {
                G = !0, b = D, S = T;
                break;
              }
              X = X.sibling;
            }
            if (!G)
              throw new Error("Child was not found in either parent set. This indicates a bug in React related to the return pointer. Please file an issue.");
          }
        }
        if (S.alternate !== b)
          throw new Error("Return fibers should always be each others' alternates. This error is likely caused by a bug in React. Please file an issue.");
      }
      if (S.tag !== v)
        throw new Error("Unable to find node on an unmounted component.");
      return S.stateNode.current === S ? o : a;
    }
    function Qo(o) {
      var a = Zo(o);
      return a !== null ? br(a) : null;
    }
    function br(o) {
      if (o.tag === C || o.tag === E)
        return o;
      for (var a = o.child; a !== null; ) {
        var p = br(a);
        if (p !== null)
          return p;
        a = a.sibling;
      }
      return null;
    }
    function za(o) {
      var a = Zo(o);
      return a !== null ? yv(a) : null;
    }
    function yv(o) {
      if (o.tag === C || o.tag === E)
        return o;
      for (var a = o.child; a !== null; ) {
        if (a.tag !== w) {
          var p = yv(a);
          if (p !== null)
            return p;
        }
        a = a.sibling;
      }
      return null;
    }
    var vv = t.unstable_scheduleCallback, Sv = t.unstable_cancelCallback, xv = t.unstable_shouldYield, gb = t.unstable_requestPaint, Jr = t.unstable_now, mb = t.unstable_getCurrentPriorityLevel, Ql = t.unstable_ImmediatePriority, Xh = t.unstable_UserBlockingPriority, Xu = t.unstable_NormalPriority, Zh = t.unstable_LowPriority, gf = t.unstable_IdlePriority, yb = t.unstable_yieldValue, vb = t.unstable_setDisableYieldValue, Ua = null, Ki = null, nt = null, Ms = !1, uo = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u";
    function wv(o) {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u")
        return !1;
      var a = __REACT_DEVTOOLS_GLOBAL_HOOK__;
      if (a.isDisabled)
        return !0;
      if (!a.supportsFiber)
        return c("The installed version of React DevTools is too old and will not work with the current version of React. Please update React DevTools. https://reactjs.org/link/react-devtools"), !0;
      try {
        Ze && (o = Gt({}, o, {
          getLaneLabelMap: _v,
          injectProfilingHooks: Zu
        })), Ua = a.inject(o), Ki = a;
      } catch (p) {
        c("React instrumentation encountered an error: %s.", p);
      }
      return !!a.checkDCE;
    }
    function bv(o, a) {
      if (Ki && typeof Ki.onScheduleFiberRoot == "function")
        try {
          Ki.onScheduleFiberRoot(Ua, o, a);
        } catch (p) {
          Ms || (Ms = !0, c("React instrumentation encountered an error: %s", p));
        }
    }
    function Cv(o, a) {
      if (Ki && typeof Ki.onCommitFiberRoot == "function")
        try {
          var p = (o.current.flags & hn) === hn;
          if (De) {
            var S;
            switch (a) {
              case ns:
                S = Ql;
                break;
              case ra:
                S = Xh;
                break;
              case Wi:
                S = Xu;
                break;
              case lm:
                S = gf;
                break;
              default:
                S = Xu;
                break;
            }
            Ki.onCommitFiberRoot(Ua, o, S, p);
          }
        } catch (b) {
          Ms || (Ms = !0, c("React instrumentation encountered an error: %s", b));
        }
    }
    function Ev(o) {
      if (Ki && typeof Ki.onPostCommitFiberRoot == "function")
        try {
          Ki.onPostCommitFiberRoot(Ua, o);
        } catch (a) {
          Ms || (Ms = !0, c("React instrumentation encountered an error: %s", a));
        }
    }
    function mf(o) {
      if (Ki && typeof Ki.onCommitFiberUnmount == "function")
        try {
          Ki.onCommitFiberUnmount(Ua, o);
        } catch (a) {
          Ms || (Ms = !0, c("React instrumentation encountered an error: %s", a));
        }
    }
    function rr(o) {
      if (typeof yb == "function" && (vb(o), s(o)), Ki && typeof Ki.setStrictMode == "function")
        try {
          Ki.setStrictMode(Ua, o);
        } catch (a) {
          Ms || (Ms = !0, c("React instrumentation encountered an error: %s", a));
        }
    }
    function Zu(o) {
      nt = o;
    }
    function _v() {
      {
        for (var o = /* @__PURE__ */ new Map(), a = 1, p = 0; p < Mv; p++) {
          var S = Eb(a);
          o.set(a, S), a *= 2;
        }
        return o;
      }
    }
    function Sb(o) {
      nt !== null && typeof nt.markCommitStarted == "function" && nt.markCommitStarted(o);
    }
    function gl() {
      nt !== null && typeof nt.markCommitStopped == "function" && nt.markCommitStopped();
    }
    function na(o) {
      nt !== null && typeof nt.markComponentRenderStarted == "function" && nt.markComponentRenderStarted(o);
    }
    function Vc() {
      nt !== null && typeof nt.markComponentRenderStopped == "function" && nt.markComponentRenderStopped();
    }
    function xb(o) {
      nt !== null && typeof nt.markComponentPassiveEffectMountStarted == "function" && nt.markComponentPassiveEffectMountStarted(o);
    }
    function Jl() {
      nt !== null && typeof nt.markComponentPassiveEffectMountStopped == "function" && nt.markComponentPassiveEffectMountStopped();
    }
    function Kc(o) {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStarted == "function" && nt.markComponentPassiveEffectUnmountStarted(o);
    }
    function Dg() {
      nt !== null && typeof nt.markComponentPassiveEffectUnmountStopped == "function" && nt.markComponentPassiveEffectUnmountStopped();
    }
    function wb(o) {
      nt !== null && typeof nt.markComponentLayoutEffectMountStarted == "function" && nt.markComponentLayoutEffectMountStarted(o);
    }
    function Og() {
      nt !== null && typeof nt.markComponentLayoutEffectMountStopped == "function" && nt.markComponentLayoutEffectMountStopped();
    }
    function Pv(o) {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStarted == "function" && nt.markComponentLayoutEffectUnmountStarted(o);
    }
    function yf() {
      nt !== null && typeof nt.markComponentLayoutEffectUnmountStopped == "function" && nt.markComponentLayoutEffectUnmountStopped();
    }
    function ml(o, a, p) {
      nt !== null && typeof nt.markComponentErrored == "function" && nt.markComponentErrored(o, a, p);
    }
    function Qh(o, a, p) {
      nt !== null && typeof nt.markComponentSuspended == "function" && nt.markComponentSuspended(o, a, p);
    }
    function Jh(o) {
      nt !== null && typeof nt.markLayoutEffectsStarted == "function" && nt.markLayoutEffectsStarted(o);
    }
    function Qu() {
      nt !== null && typeof nt.markLayoutEffectsStopped == "function" && nt.markLayoutEffectsStopped();
    }
    function Tv(o) {
      nt !== null && typeof nt.markPassiveEffectsStarted == "function" && nt.markPassiveEffectsStarted(o);
    }
    function vf() {
      nt !== null && typeof nt.markPassiveEffectsStopped == "function" && nt.markPassiveEffectsStopped();
    }
    function Iv(o) {
      nt !== null && typeof nt.markRenderStarted == "function" && nt.markRenderStarted(o);
    }
    function kv() {
      nt !== null && typeof nt.markRenderYielded == "function" && nt.markRenderYielded();
    }
    function Mr() {
      nt !== null && typeof nt.markRenderStopped == "function" && nt.markRenderStopped();
    }
    function jg(o) {
      nt !== null && typeof nt.markRenderScheduled == "function" && nt.markRenderScheduled(o);
    }
    function Rv(o, a) {
      nt !== null && typeof nt.markForceUpdateScheduled == "function" && nt.markForceUpdateScheduled(o, a);
    }
    function ep(o, a) {
      nt !== null && typeof nt.markStateUpdateScheduled == "function" && nt.markStateUpdateScheduled(o, a);
    }
    var Mt = (
      /*                         */
      0
    ), pn = (
      /*                 */
      1
    ), _n = (
      /*                    */
      2
    ), Jt = (
      /*               */
      8
    ), ur = (
      /*              */
      16
    ), Si = Math.clz32 ? Math.clz32 : np, Lg = Math.log, tp = Math.LN2;
    function np(o) {
      var a = o >>> 0;
      return a === 0 ? 32 : 31 - (Lg(a) / tp | 0) | 0;
    }
    var Mv = 31, je = (
      /*                        */
      0
    ), hi = (
      /*                          */
      0
    ), Nt = (
      /*                        */
      1
    ), Wc = (
      /*    */
      2
    ), ji = (
      /*             */
      4
    ), Li = (
      /*            */
      8
    ), Jo = (
      /*                     */
      16
    ), Ju = (
      /*                */
      32
    ), Gc = (
      /*                       */
      4194240
    ), Sf = (
      /*                        */
      64
    ), Ng = (
      /*                        */
      128
    ), Fg = (
      /*                        */
      256
    ), zg = (
      /*                        */
      512
    ), Ug = (
      /*                        */
      1024
    ), $g = (
      /*                        */
      2048
    ), Bg = (
      /*                        */
      4096
    ), Hg = (
      /*                        */
      8192
    ), ed = (
      /*                        */
      16384
    ), Vg = (
      /*                       */
      32768
    ), xf = (
      /*                       */
      65536
    ), wf = (
      /*                       */
      131072
    ), Kg = (
      /*                       */
      262144
    ), rp = (
      /*                       */
      524288
    ), Wg = (
      /*                       */
      1048576
    ), Gg = (
      /*                       */
      2097152
    ), ip = (
      /*                            */
      130023424
    ), td = (
      /*                             */
      4194304
    ), op = (
      /*                             */
      8388608
    ), qg = (
      /*                             */
      16777216
    ), Yg = (
      /*                             */
      33554432
    ), Xg = (
      /*                             */
      67108864
    ), bb = td, bf = (
      /*          */
      134217728
    ), Cb = (
      /*                          */
      268435455
    ), sp = (
      /*               */
      268435456
    ), qc = (
      /*                        */
      536870912
    ), As = (
      /*                   */
      1073741824
    );
    function Eb(o) {
      {
        if (o & Nt)
          return "Sync";
        if (o & Wc)
          return "InputContinuousHydration";
        if (o & ji)
          return "InputContinuous";
        if (o & Li)
          return "DefaultHydration";
        if (o & Jo)
          return "Default";
        if (o & Ju)
          return "TransitionHydration";
        if (o & Gc)
          return "Transition";
        if (o & ip)
          return "Retry";
        if (o & bf)
          return "SelectiveHydration";
        if (o & sp)
          return "IdleHydration";
        if (o & qc)
          return "Idle";
        if (o & As)
          return "Offscreen";
      }
    }
    var ir = -1, Zg = Sf, Qg = td;
    function ap(o) {
      switch (nd(o)) {
        case Nt:
          return Nt;
        case Wc:
          return Wc;
        case ji:
          return ji;
        case Li:
          return Li;
        case Jo:
          return Jo;
        case Ju:
          return Ju;
        case Sf:
        case Ng:
        case Fg:
        case zg:
        case Ug:
        case $g:
        case Bg:
        case Hg:
        case ed:
        case Vg:
        case xf:
        case wf:
        case Kg:
        case rp:
        case Wg:
        case Gg:
          return o & Gc;
        case td:
        case op:
        case qg:
        case Yg:
        case Xg:
          return o & ip;
        case bf:
          return bf;
        case sp:
          return sp;
        case qc:
          return qc;
        case As:
          return As;
        default:
          return c("Should have found matching lanes. This is a bug in React."), o;
      }
    }
    function es(o, a) {
      var p = o.pendingLanes;
      if (p === je)
        return je;
      var S = je, b = o.suspendedLanes, T = o.pingedLanes, D = p & Cb;
      if (D !== je) {
        var N = D & ~b;
        if (N !== je)
          S = ap(N);
        else {
          var $ = D & T;
          $ !== je && (S = ap($));
        }
      } else {
        var G = p & ~b;
        G !== je ? S = ap(G) : T !== je && (S = ap(T));
      }
      if (S === je)
        return je;
      if (a !== je && a !== S && // If we already suspended with a delay, then interrupting is fine. Don't
      // bother waiting until the root is complete.
      (a & b) === je) {
        var X = nd(S), fe = nd(a);
        if (
          // Tests whether the next lane is equal or lower priority than the wip
          // one. This works because the bits decrease in priority as you go left.
          X >= fe || // Default priority updates should not interrupt transition updates. The
          // only difference between default updates and transition updates is that
          // default updates do not support refresh transitions.
          X === Jo && (fe & Gc) !== je
        )
          return a;
      }
      (S & ji) !== je && (S |= p & Jo);
      var ue = o.entangledLanes;
      if (ue !== je)
        for (var _e = o.entanglements, Ie = S & ue; Ie > 0; ) {
          var Me = ei(Ie), st = 1 << Me;
          S |= _e[Me], Ie &= ~st;
        }
      return S;
    }
    function Av(o, a) {
      for (var p = o.eventTimes, S = ir; a > 0; ) {
        var b = ei(a), T = 1 << b, D = p[b];
        D > S && (S = D), a &= ~T;
      }
      return S;
    }
    function Jg(o, a) {
      switch (o) {
        case Nt:
        case Wc:
        case ji:
          return a + 250;
        case Li:
        case Jo:
        case Ju:
        case Sf:
        case Ng:
        case Fg:
        case zg:
        case Ug:
        case $g:
        case Bg:
        case Hg:
        case ed:
        case Vg:
        case xf:
        case wf:
        case Kg:
        case rp:
        case Wg:
        case Gg:
          return a + 5e3;
        case td:
        case op:
        case qg:
        case Yg:
        case Xg:
          return ir;
        case bf:
        case sp:
        case qc:
        case As:
          return ir;
        default:
          return c("Should have found matching lanes. This is a bug in React."), ir;
      }
    }
    function _b(o, a) {
      for (var p = o.pendingLanes, S = o.suspendedLanes, b = o.pingedLanes, T = o.expirationTimes, D = p; D > 0; ) {
        var N = ei(D), $ = 1 << N, G = T[N];
        G === ir ? (($ & S) === je || ($ & b) !== je) && (T[N] = Jg($, a)) : G <= a && (o.expiredLanes |= $), D &= ~$;
      }
    }
    function Pb(o) {
      return ap(o.pendingLanes);
    }
    function em(o) {
      var a = o.pendingLanes & -1073741825;
      return a !== je ? a : a & As ? As : je;
    }
    function Dv(o) {
      return (o & Nt) !== je;
    }
    function Yc(o) {
      return (o & Cb) !== je;
    }
    function tm(o) {
      return (o & ip) === o;
    }
    function Ov(o) {
      var a = Nt | ji | Jo;
      return (o & a) === je;
    }
    function sP(o) {
      return (o & Gc) === o;
    }
    function lp(o, a) {
      var p = Wc | ji | Li | Jo;
      return (a & p) !== je;
    }
    function Tb(o, a) {
      return (a & o.expiredLanes) !== je;
    }
    function jv(o) {
      return (o & Gc) !== je;
    }
    function Lv() {
      var o = Zg;
      return Zg <<= 1, (Zg & Gc) === je && (Zg = Sf), o;
    }
    function Ib() {
      var o = Qg;
      return Qg <<= 1, (Qg & ip) === je && (Qg = td), o;
    }
    function nd(o) {
      return o & -o;
    }
    function Ni(o) {
      return nd(o);
    }
    function ei(o) {
      return 31 - Si(o);
    }
    function nm(o) {
      return ei(o);
    }
    function ts(o, a) {
      return (o & a) !== je;
    }
    function rd(o, a) {
      return (o & a) === a;
    }
    function nn(o, a) {
      return o | a;
    }
    function cp(o, a) {
      return o & ~a;
    }
    function rm(o, a) {
      return o & a;
    }
    function aP(o) {
      return o;
    }
    function Nv(o, a) {
      return o !== hi && o < a ? o : a;
    }
    function im(o) {
      for (var a = [], p = 0; p < Mv; p++)
        a.push(o);
      return a;
    }
    function Cf(o, a, p) {
      o.pendingLanes |= a, a !== qc && (o.suspendedLanes = je, o.pingedLanes = je);
      var S = o.eventTimes, b = nm(a);
      S[b] = p;
    }
    function Fv(o, a) {
      o.suspendedLanes |= a, o.pingedLanes &= ~a;
      for (var p = o.expirationTimes, S = a; S > 0; ) {
        var b = ei(S), T = 1 << b;
        p[b] = ir, S &= ~T;
      }
    }
    function om(o, a, p) {
      o.pingedLanes |= o.suspendedLanes & a;
    }
    function kb(o, a) {
      var p = o.pendingLanes & ~a;
      o.pendingLanes = a, o.suspendedLanes = je, o.pingedLanes = je, o.expiredLanes &= a, o.mutableReadLanes &= a, o.entangledLanes &= a;
      for (var S = o.entanglements, b = o.eventTimes, T = o.expirationTimes, D = p; D > 0; ) {
        var N = ei(D), $ = 1 << N;
        S[N] = je, b[N] = ir, T[N] = ir, D &= ~$;
      }
    }
    function up(o, a) {
      for (var p = o.entangledLanes |= a, S = o.entanglements, b = p; b; ) {
        var T = ei(b), D = 1 << T;
        // Is this one of the newly entangled lanes?
        D & a | // Is this lane transitively entangled with the newly entangled lanes?
        S[T] & a && (S[T] |= a), b &= ~D;
      }
    }
    function sm(o, a) {
      var p = nd(a), S;
      switch (p) {
        case ji:
          S = Wc;
          break;
        case Jo:
          S = Li;
          break;
        case Sf:
        case Ng:
        case Fg:
        case zg:
        case Ug:
        case $g:
        case Bg:
        case Hg:
        case ed:
        case Vg:
        case xf:
        case wf:
        case Kg:
        case rp:
        case Wg:
        case Gg:
        case td:
        case op:
        case qg:
        case Yg:
        case Xg:
          S = Ju;
          break;
        case qc:
          S = sp;
          break;
        default:
          S = hi;
          break;
      }
      return (S & (o.suspendedLanes | a)) !== hi ? hi : S;
    }
    function Rb(o, a, p) {
      if (uo)
        for (var S = o.pendingUpdatersLaneMap; p > 0; ) {
          var b = nm(p), T = 1 << b, D = S[b];
          D.add(a), p &= ~T;
        }
    }
    function zv(o, a) {
      if (uo)
        for (var p = o.pendingUpdatersLaneMap, S = o.memoizedUpdaters; a > 0; ) {
          var b = nm(a), T = 1 << b, D = p[b];
          D.size > 0 && (D.forEach(function(N) {
            var $ = N.alternate;
            ($ === null || !S.has($)) && S.add(N);
          }), D.clear()), a &= ~T;
        }
    }
    function am(o, a) {
      return null;
    }
    var ns = Nt, ra = ji, Wi = Jo, lm = qc, Ef = hi;
    function Ds() {
      return Ef;
    }
    function xi(o) {
      Ef = o;
    }
    function Mb(o, a) {
      var p = Ef;
      try {
        return Ef = o, a();
      } finally {
        Ef = p;
      }
    }
    function dp(o, a) {
      return o !== 0 && o < a ? o : a;
    }
    function fo(o, a) {
      return o > a ? o : a;
    }
    function Uv(o, a) {
      return o !== 0 && o < a;
    }
    function Ab(o) {
      var a = nd(o);
      return Uv(ns, a) ? Uv(ra, a) ? Yc(a) ? Wi : lm : ra : ns;
    }
    function id(o) {
      var a = o.current.memoizedState;
      return a.isDehydrated;
    }
    var Gi;
    function lP(o) {
      Gi = o;
    }
    function vt(o) {
      Gi(o);
    }
    var Xc;
    function $v(o) {
      Xc = o;
    }
    var Bv;
    function cP(o) {
      Bv = o;
    }
    var _f;
    function cm(o) {
      _f = o;
    }
    var um;
    function Db(o) {
      um = o;
    }
    var dm = !1, fp = [], yl = null, vl = null, Ar = null, Co = /* @__PURE__ */ new Map(), ia = /* @__PURE__ */ new Map(), ec = [], Ob = [
      "mousedown",
      "mouseup",
      "touchcancel",
      "touchend",
      "touchstart",
      "auxclick",
      "dblclick",
      "pointercancel",
      "pointerdown",
      "pointerup",
      "dragend",
      "dragstart",
      "drop",
      "compositionend",
      "compositionstart",
      "keydown",
      "keypress",
      "keyup",
      "input",
      "textInput",
      // Intentionally camelCase
      "copy",
      "cut",
      "paste",
      "click",
      "change",
      "contextmenu",
      "reset",
      "submit"
    ];
    function $a(o) {
      return Ob.indexOf(o) > -1;
    }
    function jb(o, a, p, S, b) {
      return {
        blockedOn: o,
        domEventName: a,
        eventSystemFlags: p,
        nativeEvent: b,
        targetContainers: [S]
      };
    }
    function Ba(o, a) {
      switch (o) {
        case "focusin":
        case "focusout":
          yl = null;
          break;
        case "dragenter":
        case "dragleave":
          vl = null;
          break;
        case "mouseover":
        case "mouseout":
          Ar = null;
          break;
        case "pointerover":
        case "pointerout": {
          var p = a.pointerId;
          Co.delete(p);
          break;
        }
        case "gotpointercapture":
        case "lostpointercapture": {
          var S = a.pointerId;
          ia.delete(S);
          break;
        }
      }
    }
    function hp(o, a, p, S, b, T) {
      if (o === null || o.nativeEvent !== T) {
        var D = jb(a, p, S, b, T);
        if (a !== null) {
          var N = Lf(a);
          N !== null && Xc(N);
        }
        return D;
      }
      o.eventSystemFlags |= S;
      var $ = o.targetContainers;
      return b !== null && $.indexOf(b) === -1 && $.push(b), o;
    }
    function Lb(o, a, p, S, b) {
      switch (a) {
        case "focusin": {
          var T = b;
          return yl = hp(yl, o, a, p, S, T), !0;
        }
        case "dragenter": {
          var D = b;
          return vl = hp(vl, o, a, p, S, D), !0;
        }
        case "mouseover": {
          var N = b;
          return Ar = hp(Ar, o, a, p, S, N), !0;
        }
        case "pointerover": {
          var $ = b, G = $.pointerId;
          return Co.set(G, hp(Co.get(G) || null, o, a, p, S, $)), !0;
        }
        case "gotpointercapture": {
          var X = b, fe = X.pointerId;
          return ia.set(fe, hp(ia.get(fe) || null, o, a, p, S, X)), !0;
        }
      }
      return !1;
    }
    function Hv(o) {
      var a = _p(o.target);
      if (a !== null) {
        var p = bo(a);
        if (p !== null) {
          var S = p.tag;
          if (S === F) {
            var b = pl(p);
            if (b !== null) {
              o.blockedOn = b, um(o.priority, function() {
                Bv(p);
              });
              return;
            }
          } else if (S === v) {
            var T = p.stateNode;
            if (id(T)) {
              o.blockedOn = Hc(p);
              return;
            }
          }
        }
      }
      o.blockedOn = null;
    }
    function Nb(o) {
      for (var a = _f(), p = {
        blockedOn: null,
        target: o,
        priority: a
      }, S = 0; S < ec.length && Uv(a, ec[S].priority); S++)
        ;
      ec.splice(S, 0, p), S === 0 && Hv(p);
    }
    function pp(o) {
      if (o.blockedOn !== null)
        return !1;
      for (var a = o.targetContainers; a.length > 0; ) {
        var p = a[0], S = gp(o.domEventName, o.eventSystemFlags, p, o.nativeEvent);
        if (S === null) {
          var b = o.nativeEvent, T = new b.constructor(b.type, b);
          nP(T), b.target.dispatchEvent(T), $h();
        } else {
          var D = Lf(S);
          return D !== null && Xc(D), o.blockedOn = S, !1;
        }
        a.shift();
      }
      return !0;
    }
    function Fb(o, a, p) {
      pp(o) && p.delete(a);
    }
    function fm() {
      dm = !1, yl !== null && pp(yl) && (yl = null), vl !== null && pp(vl) && (vl = null), Ar !== null && pp(Ar) && (Ar = null), Co.forEach(Fb), ia.forEach(Fb);
    }
    function od(o, a) {
      o.blockedOn === a && (o.blockedOn = null, dm || (dm = !0, t.unstable_scheduleCallback(t.unstable_NormalPriority, fm)));
    }
    function ho(o) {
      if (fp.length > 0) {
        od(fp[0], o);
        for (var a = 1; a < fp.length; a++) {
          var p = fp[a];
          p.blockedOn === o && (p.blockedOn = null);
        }
      }
      yl !== null && od(yl, o), vl !== null && od(vl, o), Ar !== null && od(Ar, o);
      var S = function(N) {
        return od(N, o);
      };
      Co.forEach(S), ia.forEach(S);
      for (var b = 0; b < ec.length; b++) {
        var T = ec[b];
        T.blockedOn === o && (T.blockedOn = null);
      }
      for (; ec.length > 0; ) {
        var D = ec[0];
        if (D.blockedOn !== null)
          break;
        Hv(D), D.blockedOn === null && ec.shift();
      }
    }
    var xn = r.ReactCurrentBatchConfig, pi = !0;
    function ti(o) {
      pi = !!o;
    }
    function qi() {
      return pi;
    }
    function Os(o, a, p) {
      var S = Tf(a), b;
      switch (S) {
        case ns:
          b = Pf;
          break;
        case ra:
          b = wi;
          break;
        case Wi:
        default:
          b = sd;
          break;
      }
      return b.bind(null, a, p, o);
    }
    function Pf(o, a, p, S) {
      var b = Ds(), T = xn.transition;
      xn.transition = null;
      try {
        xi(ns), sd(o, a, p, S);
      } finally {
        xi(b), xn.transition = T;
      }
    }
    function wi(o, a, p, S) {
      var b = Ds(), T = xn.transition;
      xn.transition = null;
      try {
        xi(ra), sd(o, a, p, S);
      } finally {
        xi(b), xn.transition = T;
      }
    }
    function sd(o, a, p, S) {
      pi && ad(o, a, p, S);
    }
    function ad(o, a, p, S) {
      var b = gp(o, a, p, S);
      if (b === null) {
        TP(o, a, S, ld, p), Ba(o, S);
        return;
      }
      if (Lb(b, o, a, p, S)) {
        S.stopPropagation();
        return;
      }
      if (Ba(o, S), a & Hu && $a(o)) {
        for (; b !== null; ) {
          var T = Lf(b);
          T !== null && vt(T);
          var D = gp(o, a, p, S);
          if (D === null && TP(o, a, S, ld, p), D === b)
            break;
          b = D;
        }
        b !== null && S.stopPropagation();
        return;
      }
      TP(o, a, S, null, p);
    }
    var ld = null;
    function gp(o, a, p, S) {
      ld = null;
      var b = Cg(S), T = _p(b);
      if (T !== null) {
        var D = bo(T);
        if (D === null)
          T = null;
        else {
          var N = D.tag;
          if (N === F) {
            var $ = pl(D);
            if ($ !== null)
              return $;
            T = null;
          } else if (N === v) {
            var G = D.stateNode;
            if (id(G))
              return Hc(D);
            T = null;
          } else D !== T && (T = null);
        }
      }
      return ld = T, null;
    }
    function Tf(o) {
      switch (o) {
        // Used by SimpleEventPlugin:
        case "cancel":
        case "click":
        case "close":
        case "contextmenu":
        case "copy":
        case "cut":
        case "auxclick":
        case "dblclick":
        case "dragend":
        case "dragstart":
        case "drop":
        case "focusin":
        case "focusout":
        case "input":
        case "invalid":
        case "keydown":
        case "keypress":
        case "keyup":
        case "mousedown":
        case "mouseup":
        case "paste":
        case "pause":
        case "play":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
        case "ratechange":
        case "reset":
        case "resize":
        case "seeked":
        case "submit":
        case "touchcancel":
        case "touchend":
        case "touchstart":
        case "volumechange":
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case "change":
        case "selectionchange":
        case "textInput":
        case "compositionstart":
        case "compositionend":
        case "compositionupdate":
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case "beforeblur":
        case "afterblur":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "beforeinput":
        case "blur":
        case "fullscreenchange":
        case "focus":
        case "hashchange":
        case "popstate":
        case "select":
        case "selectstart":
          return ns;
        case "drag":
        case "dragenter":
        case "dragexit":
        case "dragleave":
        case "dragover":
        case "mousemove":
        case "mouseout":
        case "mouseover":
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "scroll":
        case "toggle":
        case "touchmove":
        case "wheel":
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case "mouseenter":
        case "mouseleave":
        case "pointerenter":
        case "pointerleave":
          return ra;
        case "message": {
          var a = mb();
          switch (a) {
            case Ql:
              return ns;
            case Xh:
              return ra;
            case Xu:
            case Zh:
              return Wi;
            case gf:
              return lm;
            default:
              return Wi;
          }
        }
        default:
          return Wi;
      }
    }
    function rs(o, a, p) {
      return o.addEventListener(a, p, !1), p;
    }
    function Vv(o, a, p) {
      return o.addEventListener(a, p, !0), p;
    }
    function If(o, a, p, S) {
      return o.addEventListener(a, p, {
        capture: !0,
        passive: S
      }), p;
    }
    function tc(o, a, p, S) {
      return o.addEventListener(a, p, {
        passive: S
      }), p;
    }
    var Zc = null, mp = null, oa = null;
    function hm(o) {
      return Zc = o, mp = kf(), !0;
    }
    function Qc() {
      Zc = null, mp = null, oa = null;
    }
    function yp() {
      if (oa)
        return oa;
      var o, a = mp, p = a.length, S, b = kf(), T = b.length;
      for (o = 0; o < p && a[o] === b[o]; o++)
        ;
      var D = p - o;
      for (S = 1; S <= D && a[p - S] === b[T - S]; S++)
        ;
      var N = S > 1 ? 1 - S : void 0;
      return oa = b.slice(o, N), oa;
    }
    function kf() {
      return "value" in Zc ? Zc.value : Zc.textContent;
    }
    function Rf(o) {
      var a, p = o.keyCode;
      return "charCode" in o ? (a = o.charCode, a === 0 && p === 13 && (a = 13)) : a = p, a === 10 && (a = 13), a >= 32 || a === 13 ? a : 0;
    }
    function cd() {
      return !0;
    }
    function vp() {
      return !1;
    }
    function mr(o) {
      function a(p, S, b, T, D) {
        this._reactName = p, this._targetInst = b, this.type = S, this.nativeEvent = T, this.target = D, this.currentTarget = null;
        for (var N in o)
          if (o.hasOwnProperty(N)) {
            var $ = o[N];
            $ ? this[N] = $(T) : this[N] = T[N];
          }
        var G = T.defaultPrevented != null ? T.defaultPrevented : T.returnValue === !1;
        return G ? this.isDefaultPrevented = cd : this.isDefaultPrevented = vp, this.isPropagationStopped = vp, this;
      }
      return Gt(a.prototype, {
        preventDefault: function() {
          this.defaultPrevented = !0;
          var p = this.nativeEvent;
          p && (p.preventDefault ? p.preventDefault() : typeof p.returnValue != "unknown" && (p.returnValue = !1), this.isDefaultPrevented = cd);
        },
        stopPropagation: function() {
          var p = this.nativeEvent;
          p && (p.stopPropagation ? p.stopPropagation() : typeof p.cancelBubble != "unknown" && (p.cancelBubble = !0), this.isPropagationStopped = cd);
        },
        /**
         * We release all dispatched `SyntheticEvent`s after each event loop, adding
         * them back into the pool. This allows a way to hold onto a reference that
         * won't be added back into the pool.
         */
        persist: function() {
        },
        /**
         * Checks if this event should be released back into the pool.
         *
         * @return {boolean} True if this should not be released, false otherwise.
         */
        isPersistent: cd
      }), a;
    }
    var js = {
      eventPhase: 0,
      bubbles: 0,
      cancelable: 0,
      timeStamp: function(o) {
        return o.timeStamp || Date.now();
      },
      defaultPrevented: 0,
      isTrusted: 0
    }, Ls = mr(js), Fi = Gt({}, js, {
      view: 0,
      detail: 0
    }), zb = mr(Fi), Sp, xp, wp;
    function Jc(o) {
      o !== wp && (wp && o.type === "mousemove" ? (Sp = o.screenX - wp.screenX, xp = o.screenY - wp.screenY) : (Sp = 0, xp = 0), wp = o);
    }
    var bp = Gt({}, Fi, {
      screenX: 0,
      screenY: 0,
      clientX: 0,
      clientY: 0,
      pageX: 0,
      pageY: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      getModifierState: qv,
      button: 0,
      buttons: 0,
      relatedTarget: function(o) {
        return o.relatedTarget === void 0 ? o.fromElement === o.srcElement ? o.toElement : o.fromElement : o.relatedTarget;
      },
      movementX: function(o) {
        return "movementX" in o ? o.movementX : (Jc(o), Sp);
      },
      movementY: function(o) {
        return "movementY" in o ? o.movementY : xp;
      }
    }), pm = mr(bp), ud = Gt({}, bp, {
      dataTransfer: 0
    }), Kv = mr(ud), dd = Gt({}, Fi, {
      relatedTarget: 0
    }), gm = mr(dd), Ub = Gt({}, js, {
      animationName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Wv = mr(Ub), mm = Gt({}, js, {
      clipboardData: function(o) {
        return "clipboardData" in o ? o.clipboardData : window.clipboardData;
      }
    }), uP = mr(mm), dP = Gt({}, js, {
      data: 0
    }), Gv = mr(dP), $b = Gv, fd = {
      Esc: "Escape",
      Spacebar: " ",
      Left: "ArrowLeft",
      Up: "ArrowUp",
      Right: "ArrowRight",
      Down: "ArrowDown",
      Del: "Delete",
      Win: "OS",
      Menu: "ContextMenu",
      Apps: "ContextMenu",
      Scroll: "ScrollLock",
      MozPrintableKey: "Unidentified"
    }, fP = {
      8: "Backspace",
      9: "Tab",
      12: "Clear",
      13: "Enter",
      16: "Shift",
      17: "Control",
      18: "Alt",
      19: "Pause",
      20: "CapsLock",
      27: "Escape",
      32: " ",
      33: "PageUp",
      34: "PageDown",
      35: "End",
      36: "Home",
      37: "ArrowLeft",
      38: "ArrowUp",
      39: "ArrowRight",
      40: "ArrowDown",
      45: "Insert",
      46: "Delete",
      112: "F1",
      113: "F2",
      114: "F3",
      115: "F4",
      116: "F5",
      117: "F6",
      118: "F7",
      119: "F8",
      120: "F9",
      121: "F10",
      122: "F11",
      123: "F12",
      144: "NumLock",
      145: "ScrollLock",
      224: "Meta"
    };
    function Mf(o) {
      if (o.key) {
        var a = fd[o.key] || o.key;
        if (a !== "Unidentified")
          return a;
      }
      if (o.type === "keypress") {
        var p = Rf(o);
        return p === 13 ? "Enter" : String.fromCharCode(p);
      }
      return o.type === "keydown" || o.type === "keyup" ? fP[o.keyCode] || "Unidentified" : "";
    }
    var Bb = {
      Alt: "altKey",
      Control: "ctrlKey",
      Meta: "metaKey",
      Shift: "shiftKey"
    };
    function Gr(o) {
      var a = this, p = a.nativeEvent;
      if (p.getModifierState)
        return p.getModifierState(o);
      var S = Bb[o];
      return S ? !!p[S] : !1;
    }
    function qv(o) {
      return Gr;
    }
    var Hb = Gt({}, Fi, {
      key: Mf,
      code: 0,
      location: 0,
      ctrlKey: 0,
      shiftKey: 0,
      altKey: 0,
      metaKey: 0,
      repeat: 0,
      locale: 0,
      getModifierState: qv,
      // Legacy Interface
      charCode: function(o) {
        return o.type === "keypress" ? Rf(o) : 0;
      },
      keyCode: function(o) {
        return o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
      },
      which: function(o) {
        return o.type === "keypress" ? Rf(o) : o.type === "keydown" || o.type === "keyup" ? o.keyCode : 0;
      }
    }), hP = mr(Hb), pP = Gt({}, bp, {
      pointerId: 0,
      width: 0,
      height: 0,
      pressure: 0,
      tangentialPressure: 0,
      tiltX: 0,
      tiltY: 0,
      twist: 0,
      pointerType: 0,
      isPrimary: 0
    }), Yv = mr(pP), Vb = Gt({}, Fi, {
      touches: 0,
      targetTouches: 0,
      changedTouches: 0,
      altKey: 0,
      metaKey: 0,
      ctrlKey: 0,
      shiftKey: 0,
      getModifierState: qv
    }), gP = mr(Vb), sa = Gt({}, js, {
      propertyName: 0,
      elapsedTime: 0,
      pseudoElement: 0
    }), Xv = mr(sa), mP = Gt({}, bp, {
      deltaX: function(o) {
        return "deltaX" in o ? o.deltaX : (
          // Fallback to `wheelDeltaX` for Webkit and normalize (right is positive).
          "wheelDeltaX" in o ? -o.wheelDeltaX : 0
        );
      },
      deltaY: function(o) {
        return "deltaY" in o ? o.deltaY : (
          // Fallback to `wheelDeltaY` for Webkit and normalize (down is positive).
          "wheelDeltaY" in o ? -o.wheelDeltaY : (
            // Fallback to `wheelDelta` for IE<9 and normalize (down is positive).
            "wheelDelta" in o ? -o.wheelDelta : 0
          )
        );
      },
      deltaZ: 0,
      // Browsers without "deltaMode" is reporting in raw wheel delta where one
      // notch on the scroll is always +/- 120, roughly equivalent to pixels.
      // A good approximation of DOM_DELTA_LINE (1) is 5% of viewport size or
      // ~40 pixels, for DOM_DELTA_SCREEN (2) it is 87.5% of viewport size.
      deltaMode: 0
    }), eu = mr(mP), ym = [9, 13, 27, 32], tu = 229, Af = mn && "CompositionEvent" in window, hd = null;
    mn && "documentMode" in document && (hd = document.documentMode);
    var Zv = mn && "TextEvent" in window && !hd, Kb = mn && (!Af || hd && hd > 8 && hd <= 11), vm = 32, Wb = String.fromCharCode(vm);
    function Gb() {
      gt("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]), gt("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]), gt("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]), gt("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
    }
    var Qv = !1;
    function Sm(o) {
      return (o.ctrlKey || o.altKey || o.metaKey) && // ctrlKey && altKey is equivalent to AltGr, and is not a command.
      !(o.ctrlKey && o.altKey);
    }
    function xm(o) {
      switch (o) {
        case "compositionstart":
          return "onCompositionStart";
        case "compositionend":
          return "onCompositionEnd";
        case "compositionupdate":
          return "onCompositionUpdate";
      }
    }
    function qb(o, a) {
      return o === "keydown" && a.keyCode === tu;
    }
    function wm(o, a) {
      switch (o) {
        case "keyup":
          return ym.indexOf(a.keyCode) !== -1;
        case "keydown":
          return a.keyCode !== tu;
        case "keypress":
        case "mousedown":
        case "focusout":
          return !0;
        default:
          return !1;
      }
    }
    function Jv(o) {
      var a = o.detail;
      return typeof a == "object" && "data" in a ? a.data : null;
    }
    function bm(o) {
      return o.locale === "ko";
    }
    var nc = !1;
    function eS(o, a, p, S, b) {
      var T, D;
      if (Af ? T = xm(a) : nc ? wm(a, S) && (T = "onCompositionEnd") : qb(a, S) && (T = "onCompositionStart"), !T)
        return null;
      Kb && !bm(S) && (!nc && T === "onCompositionStart" ? nc = hm(b) : T === "onCompositionEnd" && nc && (D = yp()));
      var N = Jb(p, T);
      if (N.length > 0) {
        var $ = new Gv(T, a, null, S, b);
        if (o.push({
          event: $,
          listeners: N
        }), D)
          $.data = D;
        else {
          var G = Jv(S);
          G !== null && ($.data = G);
        }
      }
    }
    function Cm(o, a) {
      switch (o) {
        case "compositionend":
          return Jv(a);
        case "keypress":
          var p = a.which;
          return p !== vm ? null : (Qv = !0, Wb);
        case "textInput":
          var S = a.data;
          return S === Wb && Qv ? null : S;
        default:
          return null;
      }
    }
    function Yb(o, a) {
      if (nc) {
        if (o === "compositionend" || !Af && wm(o, a)) {
          var p = yp();
          return Qc(), nc = !1, p;
        }
        return null;
      }
      switch (o) {
        case "paste":
          return null;
        case "keypress":
          if (!Sm(a)) {
            if (a.char && a.char.length > 1)
              return a.char;
            if (a.which)
              return String.fromCharCode(a.which);
          }
          return null;
        case "compositionend":
          return Kb && !bm(a) ? null : a.data;
        default:
          return null;
      }
    }
    function yP(o, a, p, S, b) {
      var T;
      if (Zv ? T = Cm(a, S) : T = Yb(a, S), !T)
        return null;
      var D = Jb(p, "onBeforeInput");
      if (D.length > 0) {
        var N = new $b("onBeforeInput", "beforeinput", null, S, b);
        o.push({
          event: N,
          listeners: D
        }), N.data = T;
      }
    }
    function Em(o, a, p, S, b, T, D) {
      eS(o, a, p, S, b), yP(o, a, p, S, b);
    }
    var vP = {
      color: !0,
      date: !0,
      datetime: !0,
      "datetime-local": !0,
      email: !0,
      month: !0,
      number: !0,
      password: !0,
      range: !0,
      search: !0,
      tel: !0,
      text: !0,
      time: !0,
      url: !0,
      week: !0
    };
    function Df(o) {
      var a = o && o.nodeName && o.nodeName.toLowerCase();
      return a === "input" ? !!vP[o.type] : a === "textarea";
    }
    /**
     * Checks if an event is supported in the current execution environment.
     *
     * NOTE: This will not work correctly for non-generic events such as `change`,
     * `reset`, `load`, `error`, and `select`.
     *
     * Borrows from Modernizr.
     *
     * @param {string} eventNameSuffix Event name, e.g. "click".
     * @return {boolean} True if the event is supported.
     * @internal
     * @license Modernizr 3.0.0pre (Custom Build) | MIT
     */
    function SP(o) {
      if (!mn)
        return !1;
      var a = "on" + o, p = a in document;
      if (!p) {
        var S = document.createElement("div");
        S.setAttribute(a, "return;"), p = typeof S[a] == "function";
      }
      return p;
    }
    function _m() {
      gt("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
    }
    function u(o, a, p, S) {
      dv(S);
      var b = Jb(a, "onChange");
      if (b.length > 0) {
        var T = new Ls("onChange", "change", null, p, S);
        o.push({
          event: T,
          listeners: b
        });
      }
    }
    var f = null, x = null;
    function _(o) {
      var a = o.nodeName && o.nodeName.toLowerCase();
      return a === "select" || a === "input" && o.type === "file";
    }
    function A(o) {
      var a = [];
      u(a, x, o, Cg(o)), ub(j, a);
    }
    function j(o) {
      OL(o, 0);
    }
    function K(o) {
      var a = Mm(o);
      if (pe(a))
        return o;
    }
    function ee(o, a) {
      if (o === "change")
        return a;
    }
    var ae = !1;
    mn && (ae = SP("input") && (!document.documentMode || document.documentMode > 9));
    function Te(o, a) {
      f = o, x = a, f.attachEvent("onpropertychange", Ke);
    }
    function He() {
      f && (f.detachEvent("onpropertychange", Ke), f = null, x = null);
    }
    function Ke(o) {
      o.propertyName === "value" && K(x) && A(o);
    }
    function Be(o, a, p) {
      o === "focusin" ? (He(), Te(a, p)) : o === "focusout" && He();
    }
    function dt(o, a) {
      if (o === "selectionchange" || o === "keyup" || o === "keydown")
        return K(x);
    }
    function St(o) {
      var a = o.nodeName;
      return a && a.toLowerCase() === "input" && (o.type === "checkbox" || o.type === "radio");
    }
    function Ct(o, a) {
      if (o === "click")
        return K(a);
    }
    function ni(o, a) {
      if (o === "input" || o === "change")
        return K(a);
    }
    function ye(o) {
      var a = o._wrapperState;
      !a || !a.controlled || o.type !== "number" || ot(o, "number", o.value);
    }
    function de(o, a, p, S, b, T, D) {
      var N = p ? Mm(p) : window, $, G;
      if (_(N) ? $ = ee : Df(N) ? ae ? $ = ni : ($ = dt, G = Be) : St(N) && ($ = Ct), $) {
        var X = $(a, p);
        if (X) {
          u(o, X, S, b);
          return;
        }
      }
      G && G(a, N, p), a === "focusout" && ye(N);
    }
    function Ce() {
      Pt("onMouseEnter", ["mouseout", "mouseover"]), Pt("onMouseLeave", ["mouseout", "mouseover"]), Pt("onPointerEnter", ["pointerout", "pointerover"]), Pt("onPointerLeave", ["pointerout", "pointerover"]);
    }
    function Ye(o, a, p, S, b, T, D) {
      var N = a === "mouseover" || a === "pointerover", $ = a === "mouseout" || a === "pointerout";
      if (N && !rP(S)) {
        var G = S.relatedTarget || S.fromElement;
        if (G && (_p(G) || pS(G)))
          return;
      }
      if (!(!$ && !N)) {
        var X;
        if (b.window === b)
          X = b;
        else {
          var fe = b.ownerDocument;
          fe ? X = fe.defaultView || fe.parentWindow : X = window;
        }
        var ue, _e;
        if ($) {
          var Ie = S.relatedTarget || S.toElement;
          if (ue = p, _e = Ie ? _p(Ie) : null, _e !== null) {
            var Me = bo(_e);
            (_e !== Me || _e.tag !== C && _e.tag !== E) && (_e = null);
          }
        } else
          ue = null, _e = p;
        if (ue !== _e) {
          var st = pm, Dt = "onMouseLeave", Tt = "onMouseEnter", Dn = "mouse";
          (a === "pointerout" || a === "pointerover") && (st = Yv, Dt = "onPointerLeave", Tt = "onPointerEnter", Dn = "pointer");
          var En = ue == null ? X : Mm(ue), xe = _e == null ? X : Mm(_e), Ae = new st(Dt, Dn + "leave", ue, S, b);
          Ae.target = En, Ae.relatedTarget = xe;
          var we = null, Ge = _p(b);
          if (Ge === p) {
            var pt = new st(Tt, Dn + "enter", _e, S, b);
            pt.target = xe, pt.relatedTarget = En, we = pt;
          }
          jY(o, Ae, we, ue, _e);
        }
      }
    }
    function _t(o, a) {
      return o === a && (o !== 0 || 1 / o === 1 / a) || o !== o && a !== a;
    }
    var xt = typeof Object.is == "function" ? Object.is : _t;
    function At(o, a) {
      if (xt(o, a))
        return !0;
      if (typeof o != "object" || o === null || typeof a != "object" || a === null)
        return !1;
      var p = Object.keys(o), S = Object.keys(a);
      if (p.length !== S.length)
        return !1;
      for (var b = 0; b < p.length; b++) {
        var T = p[b];
        if (!Zt.call(a, T) || !xt(o[T], a[T]))
          return !1;
      }
      return !0;
    }
    function Kt(o) {
      for (; o && o.firstChild; )
        o = o.firstChild;
      return o;
    }
    function zi(o) {
      for (; o; ) {
        if (o.nextSibling)
          return o.nextSibling;
        o = o.parentNode;
      }
    }
    function Hn(o, a) {
      for (var p = Kt(o), S = 0, b = 0; p; ) {
        if (p.nodeType === ql) {
          if (b = S + p.textContent.length, S <= a && b >= a)
            return {
              node: p,
              offset: a - S
            };
          S = b;
        }
        p = Kt(zi(p));
      }
    }
    function nu(o) {
      var a = o.ownerDocument, p = a && a.defaultView || window, S = p.getSelection && p.getSelection();
      if (!S || S.rangeCount === 0)
        return null;
      var b = S.anchorNode, T = S.anchorOffset, D = S.focusNode, N = S.focusOffset;
      try {
        b.nodeType, D.nodeType;
      } catch {
        return null;
      }
      return xP(o, b, T, D, N);
    }
    function xP(o, a, p, S, b) {
      var T = 0, D = -1, N = -1, $ = 0, G = 0, X = o, fe = null;
      e: for (; ; ) {
        for (var ue = null; X === a && (p === 0 || X.nodeType === ql) && (D = T + p), X === S && (b === 0 || X.nodeType === ql) && (N = T + b), X.nodeType === ql && (T += X.nodeValue.length), (ue = X.firstChild) !== null; )
          fe = X, X = ue;
        for (; ; ) {
          if (X === o)
            break e;
          if (fe === a && ++$ === p && (D = T), fe === S && ++G === b && (N = T), (ue = X.nextSibling) !== null)
            break;
          X = fe, fe = X.parentNode;
        }
        X = ue;
      }
      return D === -1 || N === -1 ? null : {
        start: D,
        end: N
      };
    }
    function mY(o, a) {
      var p = o.ownerDocument || document, S = p && p.defaultView || window;
      if (S.getSelection) {
        var b = S.getSelection(), T = o.textContent.length, D = Math.min(a.start, T), N = a.end === void 0 ? D : Math.min(a.end, T);
        if (!b.extend && D > N) {
          var $ = N;
          N = D, D = $;
        }
        var G = Hn(o, D), X = Hn(o, N);
        if (G && X) {
          if (b.rangeCount === 1 && b.anchorNode === G.node && b.anchorOffset === G.offset && b.focusNode === X.node && b.focusOffset === X.offset)
            return;
          var fe = p.createRange();
          fe.setStart(G.node, G.offset), b.removeAllRanges(), D > N ? (b.addRange(fe), b.extend(X.node, X.offset)) : (fe.setEnd(X.node, X.offset), b.addRange(fe));
        }
      }
    }
    function bL(o) {
      return o && o.nodeType === ql;
    }
    function CL(o, a) {
      return !o || !a ? !1 : o === a ? !0 : bL(o) ? !1 : bL(a) ? CL(o, a.parentNode) : "contains" in o ? o.contains(a) : o.compareDocumentPosition ? !!(o.compareDocumentPosition(a) & 16) : !1;
    }
    function yY(o) {
      return o && o.ownerDocument && CL(o.ownerDocument.documentElement, o);
    }
    function vY(o) {
      try {
        return typeof o.contentWindow.location.href == "string";
      } catch {
        return !1;
      }
    }
    function EL() {
      for (var o = window, a = ze(); a instanceof o.HTMLIFrameElement; ) {
        if (vY(a))
          o = a.contentWindow;
        else
          return a;
        a = ze(o.document);
      }
      return a;
    }
    function wP(o) {
      var a = o && o.nodeName && o.nodeName.toLowerCase();
      return a && (a === "input" && (o.type === "text" || o.type === "search" || o.type === "tel" || o.type === "url" || o.type === "password") || a === "textarea" || o.contentEditable === "true");
    }
    function SY() {
      var o = EL();
      return {
        focusedElem: o,
        selectionRange: wP(o) ? wY(o) : null
      };
    }
    function xY(o) {
      var a = EL(), p = o.focusedElem, S = o.selectionRange;
      if (a !== p && yY(p)) {
        S !== null && wP(p) && bY(p, S);
        for (var b = [], T = p; T = T.parentNode; )
          T.nodeType === Yo && b.push({
            element: T,
            left: T.scrollLeft,
            top: T.scrollTop
          });
        typeof p.focus == "function" && p.focus();
        for (var D = 0; D < b.length; D++) {
          var N = b[D];
          N.element.scrollLeft = N.left, N.element.scrollTop = N.top;
        }
      }
    }
    function wY(o) {
      var a;
      return "selectionStart" in o ? a = {
        start: o.selectionStart,
        end: o.selectionEnd
      } : a = nu(o), a || {
        start: 0,
        end: 0
      };
    }
    function bY(o, a) {
      var p = a.start, S = a.end;
      S === void 0 && (S = p), "selectionStart" in o ? (o.selectionStart = p, o.selectionEnd = Math.min(S, o.value.length)) : mY(o, a);
    }
    var CY = mn && "documentMode" in document && document.documentMode <= 11;
    function EY() {
      gt("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
    }
    var Pm = null, bP = null, tS = null, CP = !1;
    function _Y(o) {
      if ("selectionStart" in o && wP(o))
        return {
          start: o.selectionStart,
          end: o.selectionEnd
        };
      var a = o.ownerDocument && o.ownerDocument.defaultView || window, p = a.getSelection();
      return {
        anchorNode: p.anchorNode,
        anchorOffset: p.anchorOffset,
        focusNode: p.focusNode,
        focusOffset: p.focusOffset
      };
    }
    function PY(o) {
      return o.window === o ? o.document : o.nodeType === Yl ? o : o.ownerDocument;
    }
    function _L(o, a, p) {
      var S = PY(p);
      if (!(CP || Pm == null || Pm !== ze(S))) {
        var b = _Y(Pm);
        if (!tS || !At(tS, b)) {
          tS = b;
          var T = Jb(bP, "onSelect");
          if (T.length > 0) {
            var D = new Ls("onSelect", "select", null, a, p);
            o.push({
              event: D,
              listeners: T
            }), D.target = Pm;
          }
        }
      }
    }
    function TY(o, a, p, S, b, T, D) {
      var N = p ? Mm(p) : window;
      switch (a) {
        // Track the input node that has focus.
        case "focusin":
          (Df(N) || N.contentEditable === "true") && (Pm = N, bP = p, tS = null);
          break;
        case "focusout":
          Pm = null, bP = null, tS = null;
          break;
        // Don't fire the event while the user is dragging. This matches the
        // semantics of the native select event.
        case "mousedown":
          CP = !0;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          CP = !1, _L(o, S, b);
          break;
        // Chrome and IE fire non-standard event when selection is changed (and
        // sometimes when it hasn't). IE's event fires out of order with respect
        // to key and input events on deletion, so we discard it.
        //
        // Firefox doesn't support selectionchange, so check selection status
        // after each key entry. The selection changes after keydown and before
        // keyup, but we check on keydown as well in the case of holding down a
        // key, when multiple keydown events are fired but only one keyup is.
        // This is also our approach for IE handling, for the reason above.
        case "selectionchange":
          if (CY)
            break;
        // falls through
        case "keydown":
        case "keyup":
          _L(o, S, b);
      }
    }
    function Xb(o, a) {
      var p = {};
      return p[o.toLowerCase()] = a.toLowerCase(), p["Webkit" + o] = "webkit" + a, p["Moz" + o] = "moz" + a, p;
    }
    var Tm = {
      animationend: Xb("Animation", "AnimationEnd"),
      animationiteration: Xb("Animation", "AnimationIteration"),
      animationstart: Xb("Animation", "AnimationStart"),
      transitionend: Xb("Transition", "TransitionEnd")
    }, EP = {}, PL = {};
    mn && (PL = document.createElement("div").style, "AnimationEvent" in window || (delete Tm.animationend.animation, delete Tm.animationiteration.animation, delete Tm.animationstart.animation), "TransitionEvent" in window || delete Tm.transitionend.transition);
    function Zb(o) {
      if (EP[o])
        return EP[o];
      if (!Tm[o])
        return o;
      var a = Tm[o];
      for (var p in a)
        if (a.hasOwnProperty(p) && p in PL)
          return EP[o] = a[p];
      return o;
    }
    var TL = Zb("animationend"), IL = Zb("animationiteration"), kL = Zb("animationstart"), RL = Zb("transitionend"), ML = /* @__PURE__ */ new Map(), AL = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
    function Of(o, a) {
      ML.set(o, a), gt(a, [o]);
    }
    function IY() {
      for (var o = 0; o < AL.length; o++) {
        var a = AL[o], p = a.toLowerCase(), S = a[0].toUpperCase() + a.slice(1);
        Of(p, "on" + S);
      }
      Of(TL, "onAnimationEnd"), Of(IL, "onAnimationIteration"), Of(kL, "onAnimationStart"), Of("dblclick", "onDoubleClick"), Of("focusin", "onFocus"), Of("focusout", "onBlur"), Of(RL, "onTransitionEnd");
    }
    function kY(o, a, p, S, b, T, D) {
      var N = ML.get(a);
      if (N !== void 0) {
        var $ = Ls, G = a;
        switch (a) {
          case "keypress":
            if (Rf(S) === 0)
              return;
          /* falls through */
          case "keydown":
          case "keyup":
            $ = hP;
            break;
          case "focusin":
            G = "focus", $ = gm;
            break;
          case "focusout":
            G = "blur", $ = gm;
            break;
          case "beforeblur":
          case "afterblur":
            $ = gm;
            break;
          case "click":
            if (S.button === 2)
              return;
          /* falls through */
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          // TODO: Disabled elements should not respond to mouse events
          /* falls through */
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            $ = pm;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            $ = Kv;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            $ = gP;
            break;
          case TL:
          case IL:
          case kL:
            $ = Wv;
            break;
          case RL:
            $ = Xv;
            break;
          case "scroll":
            $ = zb;
            break;
          case "wheel":
            $ = eu;
            break;
          case "copy":
          case "cut":
          case "paste":
            $ = uP;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            $ = Yv;
            break;
        }
        var X = (T & Hu) !== 0;
        {
          var fe = !X && // TODO: ideally, we'd eventually add all events from
          // nonDelegatedEvents list in DOMPluginEventSystem.
          // Then we can remove this special list.
          // This is a breaking change that can wait until React 18.
          a === "scroll", ue = DY(p, N, S.type, X, fe);
          if (ue.length > 0) {
            var _e = new $(N, G, null, S, b);
            o.push({
              event: _e,
              listeners: ue
            });
          }
        }
      }
    }
    IY(), Ce(), _m(), EY(), Gb();
    function RY(o, a, p, S, b, T, D) {
      kY(o, a, p, S, b, T);
      var N = (T & uv) === 0;
      N && (Ye(o, a, p, S, b), de(o, a, p, S, b), TY(o, a, p, S, b), Em(o, a, p, S, b));
    }
    var nS = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"], _P = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(nS));
    function DL(o, a, p) {
      var S = o.type || "unknown-event";
      o.currentTarget = p, Wh(S, a, void 0, o), o.currentTarget = null;
    }
    function MY(o, a, p) {
      var S;
      if (p)
        for (var b = a.length - 1; b >= 0; b--) {
          var T = a[b], D = T.instance, N = T.currentTarget, $ = T.listener;
          if (D !== S && o.isPropagationStopped())
            return;
          DL(o, $, N), S = D;
        }
      else
        for (var G = 0; G < a.length; G++) {
          var X = a[G], fe = X.instance, ue = X.currentTarget, _e = X.listener;
          if (fe !== S && o.isPropagationStopped())
            return;
          DL(o, _e, ue), S = fe;
        }
    }
    function OL(o, a) {
      for (var p = (a & Hu) !== 0, S = 0; S < o.length; S++) {
        var b = o[S], T = b.event, D = b.listeners;
        MY(T, D, p);
      }
      Xl();
    }
    function AY(o, a, p, S, b) {
      var T = Cg(p), D = [];
      RY(D, o, S, p, T, a), OL(D, a);
    }
    function Fr(o, a) {
      _P.has(o) || c('Did not expect a listenToNonDelegatedEvent() call for "%s". This is a bug in React. Please file an issue.', o);
      var p = !1, S = lZ(a), b = LY(o);
      S.has(b) || (jL(a, o, fl, p), S.add(b));
    }
    function PP(o, a, p) {
      _P.has(o) && !a && c('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. This is a bug in React. Please file an issue.', o);
      var S = 0;
      a && (S |= Hu), jL(p, o, S, a);
    }
    var Qb = "_reactListening" + Math.random().toString(36).slice(2);
    function rS(o) {
      if (!o[Qb]) {
        o[Qb] = !0, it.forEach(function(p) {
          p !== "selectionchange" && (_P.has(p) || PP(p, !1, o), PP(p, !0, o));
        });
        var a = o.nodeType === Yl ? o : o.ownerDocument;
        a !== null && (a[Qb] || (a[Qb] = !0, PP("selectionchange", !1, a)));
      }
    }
    function jL(o, a, p, S, b) {
      var T = Os(o, a, p), D = void 0;
      Kh && (a === "touchstart" || a === "touchmove" || a === "wheel") && (D = !0), o = o, S ? D !== void 0 ? If(o, a, T, D) : Vv(o, a, T) : D !== void 0 ? tc(o, a, T, D) : rs(o, a, T);
    }
    function LL(o, a) {
      return o === a || o.nodeType === li && o.parentNode === a;
    }
    function TP(o, a, p, S, b) {
      var T = S;
      if (!(a & cv) && !(a & fl)) {
        var D = b;
        if (S !== null) {
          var N = S;
          e: for (; ; ) {
            if (N === null)
              return;
            var $ = N.tag;
            if ($ === v || $ === w) {
              var G = N.stateNode.containerInfo;
              if (LL(G, D))
                break;
              if ($ === w)
                for (var X = N.return; X !== null; ) {
                  var fe = X.tag;
                  if (fe === v || fe === w) {
                    var ue = X.stateNode.containerInfo;
                    if (LL(ue, D))
                      return;
                  }
                  X = X.return;
                }
              for (; G !== null; ) {
                var _e = _p(G);
                if (_e === null)
                  return;
                var Ie = _e.tag;
                if (Ie === C || Ie === E) {
                  N = T = _e;
                  continue e;
                }
                G = G.parentNode;
              }
            }
            N = N.return;
          }
        }
      }
      ub(function() {
        return AY(o, a, p, T);
      });
    }
    function iS(o, a, p) {
      return {
        instance: o,
        listener: a,
        currentTarget: p
      };
    }
    function DY(o, a, p, S, b, T) {
      for (var D = a !== null ? a + "Capture" : null, N = S ? D : a, $ = [], G = o, X = null; G !== null; ) {
        var fe = G, ue = fe.stateNode, _e = fe.tag;
        if (_e === C && ue !== null && (X = ue, N !== null)) {
          var Ie = Ku(G, N);
          Ie != null && $.push(iS(G, Ie, X));
        }
        if (b)
          break;
        G = G.return;
      }
      return $;
    }
    function Jb(o, a) {
      for (var p = a + "Capture", S = [], b = o; b !== null; ) {
        var T = b, D = T.stateNode, N = T.tag;
        if (N === C && D !== null) {
          var $ = D, G = Ku(b, p);
          G != null && S.unshift(iS(b, G, $));
          var X = Ku(b, a);
          X != null && S.push(iS(b, X, $));
        }
        b = b.return;
      }
      return S;
    }
    function Im(o) {
      if (o === null)
        return null;
      do
        o = o.return;
      while (o && o.tag !== C);
      return o || null;
    }
    function OY(o, a) {
      for (var p = o, S = a, b = 0, T = p; T; T = Im(T))
        b++;
      for (var D = 0, N = S; N; N = Im(N))
        D++;
      for (; b - D > 0; )
        p = Im(p), b--;
      for (; D - b > 0; )
        S = Im(S), D--;
      for (var $ = b; $--; ) {
        if (p === S || S !== null && p === S.alternate)
          return p;
        p = Im(p), S = Im(S);
      }
      return null;
    }
    function NL(o, a, p, S, b) {
      for (var T = a._reactName, D = [], N = p; N !== null && N !== S; ) {
        var $ = N, G = $.alternate, X = $.stateNode, fe = $.tag;
        if (G !== null && G === S)
          break;
        if (fe === C && X !== null) {
          var ue = X;
          if (b) {
            var _e = Ku(N, T);
            _e != null && D.unshift(iS(N, _e, ue));
          } else if (!b) {
            var Ie = Ku(N, T);
            Ie != null && D.push(iS(N, Ie, ue));
          }
        }
        N = N.return;
      }
      D.length !== 0 && o.push({
        event: a,
        listeners: D
      });
    }
    function jY(o, a, p, S, b) {
      var T = S && b ? OY(S, b) : null;
      S !== null && NL(o, a, S, T, !1), b !== null && p !== null && NL(o, p, b, T, !0);
    }
    function LY(o, a) {
      return o + "__bubble";
    }
    var aa = !1, oS = "dangerouslySetInnerHTML", e0 = "suppressContentEditableWarning", jf = "suppressHydrationWarning", FL = "autoFocus", Cp = "children", Ep = "style", t0 = "__html", IP, n0, sS, zL, r0, UL, $L;
    IP = {
      // There are working polyfills for <dialog>. Let people use it.
      dialog: !0,
      // Electron ships a custom <webview> tag to display external web content in
      // an isolated frame and process.
      // This tag is not present in non Electron environments such as JSDom which
      // is often used for testing purposes.
      // @see https://electronjs.org/docs/api/webview-tag
      webview: !0
    }, n0 = function(o, a) {
      ib(o, a), lf(o, a), cb(o, a, {
        registrationNameDependencies: We,
        possibleRegistrationNames: Qe
      });
    }, UL = mn && !document.documentMode, sS = function(o, a, p) {
      if (!aa) {
        var S = i0(p), b = i0(a);
        b !== S && (aa = !0, c("Prop `%s` did not match. Server: %s Client: %s", o, JSON.stringify(b), JSON.stringify(S)));
      }
    }, zL = function(o) {
      if (!aa) {
        aa = !0;
        var a = [];
        o.forEach(function(p) {
          a.push(p);
        }), c("Extra attributes from the server: %s", a);
      }
    }, r0 = function(o, a) {
      a === !1 ? c("Expected `%s` listener to be a function, instead got `false`.\n\nIf you used to conditionally omit it with %s={condition && value}, pass %s={condition ? value : undefined} instead.", o, o, o) : c("Expected `%s` listener to be a function, instead got a value of `%s` type.", o, typeof a);
    }, $L = function(o, a) {
      var p = o.namespaceURI === ja ? o.ownerDocument.createElement(o.tagName) : o.ownerDocument.createElementNS(o.namespaceURI, o.tagName);
      return p.innerHTML = a, p.innerHTML;
    };
    var NY = /\r\n?/g, FY = /\u0000|\uFFFD/g;
    function i0(o) {
      wr(o);
      var a = typeof o == "string" ? o : "" + o;
      return a.replace(NY, `
`).replace(FY, "");
    }
    function o0(o, a, p, S) {
      var b = i0(a), T = i0(o);
      if (T !== b && (S && (aa || (aa = !0, c('Text content did not match. Server: "%s" Client: "%s"', T, b))), p && Q))
        throw new Error("Text content does not match server-rendered HTML.");
    }
    function BL(o) {
      return o.nodeType === Yl ? o : o.ownerDocument;
    }
    function zY() {
    }
    function s0(o) {
      o.onclick = zY;
    }
    function UY(o, a, p, S, b) {
      for (var T in S)
        if (S.hasOwnProperty(T)) {
          var D = S[T];
          if (T === Ep)
            D && Object.freeze(D), Jw(a, D);
          else if (T === oS) {
            var N = D ? D[t0] : void 0;
            N != null && $w(a, N);
          } else if (T === Cp)
            if (typeof D == "string") {
              var $ = o !== "textarea" || D !== "";
              $ && Lc(a, D);
            } else typeof D == "number" && Lc(a, "" + D);
          else T === e0 || T === jf || T === FL || (We.hasOwnProperty(T) ? D != null && (typeof D != "function" && r0(T, D), T === "onScroll" && Fr("scroll", a)) : D != null && vo(a, T, D, b));
        }
    }
    function $Y(o, a, p, S) {
      for (var b = 0; b < a.length; b += 2) {
        var T = a[b], D = a[b + 1];
        T === Ep ? Jw(o, D) : T === oS ? $w(o, D) : T === Cp ? Lc(o, D) : vo(o, T, D, S);
      }
    }
    function BY(o, a, p, S) {
      var b, T = BL(p), D, N = S;
      if (N === ja && (N = rv(o)), N === ja) {
        if (b = Nc(o, a), !b && o !== o.toLowerCase() && c("<%s /> is using incorrect casing. Use PascalCase for React components, or lowercase for HTML elements.", o), o === "script") {
          var $ = T.createElement("div");
          $.innerHTML = "<script><\/script>";
          var G = $.firstChild;
          D = $.removeChild(G);
        } else if (typeof a.is == "string")
          D = T.createElement(o, {
            is: a.is
          });
        else if (D = T.createElement(o), o === "select") {
          var X = D;
          a.multiple ? X.multiple = !0 : a.size && (X.size = a.size);
        }
      } else
        D = T.createElementNS(N, o);
      return N === ja && !b && Object.prototype.toString.call(D) === "[object HTMLUnknownElement]" && !Zt.call(IP, o) && (IP[o] = !0, c("The tag <%s> is unrecognized in this browser. If you meant to render a React component, start its name with an uppercase letter.", o)), D;
    }
    function HY(o, a) {
      return BL(a).createTextNode(o);
    }
    function VY(o, a, p, S) {
      var b = Nc(a, p);
      n0(a, p);
      var T;
      switch (a) {
        case "dialog":
          Fr("cancel", o), Fr("close", o), T = p;
          break;
        case "iframe":
        case "object":
        case "embed":
          Fr("load", o), T = p;
          break;
        case "video":
        case "audio":
          for (var D = 0; D < nS.length; D++)
            Fr(nS[D], o);
          T = p;
          break;
        case "source":
          Fr("error", o), T = p;
          break;
        case "img":
        case "image":
        case "link":
          Fr("error", o), Fr("load", o), T = p;
          break;
        case "details":
          Fr("toggle", o), T = p;
          break;
        case "input":
          Qn(o, p), T = Zn(o, p), Fr("invalid", o);
          break;
        case "option":
          Mn(o, p), T = p;
          break;
        case "select":
          Dh(o, p), T = Bu(o, p), Fr("invalid", o);
          break;
        case "textarea":
          Fw(o, p), T = yg(o, p), Fr("invalid", o);
          break;
        default:
          T = p;
      }
      switch (wg(a, T), UY(a, o, S, T, b), a) {
        case "input":
          Z(o), ge(o, p, !1);
          break;
        case "textarea":
          Z(o), Uw(o);
          break;
        case "option":
          Bn(o, p);
          break;
        case "select":
          ev(o, p);
          break;
        default:
          typeof T.onClick == "function" && s0(o);
          break;
      }
    }
    function KY(o, a, p, S, b) {
      n0(a, S);
      var T = null, D, N;
      switch (a) {
        case "input":
          D = Zn(o, p), N = Zn(o, S), T = [];
          break;
        case "select":
          D = Bu(o, p), N = Bu(o, S), T = [];
          break;
        case "textarea":
          D = yg(o, p), N = yg(o, S), T = [];
          break;
        default:
          D = p, N = S, typeof D.onClick != "function" && typeof N.onClick == "function" && s0(o);
          break;
      }
      wg(a, N);
      var $, G, X = null;
      for ($ in D)
        if (!(N.hasOwnProperty($) || !D.hasOwnProperty($) || D[$] == null))
          if ($ === Ep) {
            var fe = D[$];
            for (G in fe)
              fe.hasOwnProperty(G) && (X || (X = {}), X[G] = "");
          } else $ === oS || $ === Cp || $ === e0 || $ === jf || $ === FL || (We.hasOwnProperty($) ? T || (T = []) : (T = T || []).push($, null));
      for ($ in N) {
        var ue = N[$], _e = D != null ? D[$] : void 0;
        if (!(!N.hasOwnProperty($) || ue === _e || ue == null && _e == null))
          if ($ === Ep)
            if (ue && Object.freeze(ue), _e) {
              for (G in _e)
                _e.hasOwnProperty(G) && (!ue || !ue.hasOwnProperty(G)) && (X || (X = {}), X[G] = "");
              for (G in ue)
                ue.hasOwnProperty(G) && _e[G] !== ue[G] && (X || (X = {}), X[G] = ue[G]);
            } else
              X || (T || (T = []), T.push($, X)), X = ue;
          else if ($ === oS) {
            var Ie = ue ? ue[t0] : void 0, Me = _e ? _e[t0] : void 0;
            Ie != null && Me !== Ie && (T = T || []).push($, Ie);
          } else $ === Cp ? (typeof ue == "string" || typeof ue == "number") && (T = T || []).push($, "" + ue) : $ === e0 || $ === jf || (We.hasOwnProperty($) ? (ue != null && (typeof ue != "function" && r0($, ue), $ === "onScroll" && Fr("scroll", o)), !T && _e !== ue && (T = [])) : (T = T || []).push($, ue));
      }
      return X && (La(X, N[Ep]), (T = T || []).push(Ep, X)), T;
    }
    function WY(o, a, p, S, b) {
      p === "input" && b.type === "radio" && b.name != null && B(o, b);
      var T = Nc(p, S), D = Nc(p, b);
      switch ($Y(o, a, T, D), p) {
        case "input":
          ne(o, b);
          break;
        case "textarea":
          zw(o, b);
          break;
        case "select":
          mg(o, b);
          break;
      }
    }
    function GY(o) {
      {
        var a = o.toLowerCase();
        return of.hasOwnProperty(a) && of[a] || null;
      }
    }
    function qY(o, a, p, S, b, T, D) {
      var N, $;
      switch (N = Nc(a, p), n0(a, p), a) {
        case "dialog":
          Fr("cancel", o), Fr("close", o);
          break;
        case "iframe":
        case "object":
        case "embed":
          Fr("load", o);
          break;
        case "video":
        case "audio":
          for (var G = 0; G < nS.length; G++)
            Fr(nS[G], o);
          break;
        case "source":
          Fr("error", o);
          break;
        case "img":
        case "image":
        case "link":
          Fr("error", o), Fr("load", o);
          break;
        case "details":
          Fr("toggle", o);
          break;
        case "input":
          Qn(o, p), Fr("invalid", o);
          break;
        case "option":
          Mn(o, p);
          break;
        case "select":
          Dh(o, p), Fr("invalid", o);
          break;
        case "textarea":
          Fw(o, p), Fr("invalid", o);
          break;
      }
      wg(a, p);
      {
        $ = /* @__PURE__ */ new Set();
        for (var X = o.attributes, fe = 0; fe < X.length; fe++) {
          var ue = X[fe].name.toLowerCase();
          switch (ue) {
            // Controlled attributes are not validated
            // TODO: Only ignore them on controlled tags.
            case "value":
              break;
            case "checked":
              break;
            case "selected":
              break;
            default:
              $.add(X[fe].name);
          }
        }
      }
      var _e = null;
      for (var Ie in p)
        if (p.hasOwnProperty(Ie)) {
          var Me = p[Ie];
          if (Ie === Cp)
            typeof Me == "string" ? o.textContent !== Me && (p[jf] !== !0 && o0(o.textContent, Me, T, D), _e = [Cp, Me]) : typeof Me == "number" && o.textContent !== "" + Me && (p[jf] !== !0 && o0(o.textContent, Me, T, D), _e = [Cp, "" + Me]);
          else if (We.hasOwnProperty(Ie))
            Me != null && (typeof Me != "function" && r0(Ie, Me), Ie === "onScroll" && Fr("scroll", o));
          else if (D && // Convince Flow we've calculated it (it's DEV-only in this method.)
          typeof N == "boolean") {
            var st = void 0, Dt = bn(Ie);
            if (p[jf] !== !0) {
              if (!(Ie === e0 || Ie === jf || // Controlled attributes are not validated
              // TODO: Only ignore them on controlled tags.
              Ie === "value" || Ie === "checked" || Ie === "selected")) {
                if (Ie === oS) {
                  var Tt = o.innerHTML, Dn = Me ? Me[t0] : void 0;
                  if (Dn != null) {
                    var En = $L(o, Dn);
                    En !== Tt && sS(Ie, Tt, En);
                  }
                } else if (Ie === Ep) {
                  if ($.delete(Ie), UL) {
                    var xe = eP(Me);
                    st = o.getAttribute("style"), xe !== st && sS(Ie, st, xe);
                  }
                } else if (N)
                  $.delete(Ie.toLowerCase()), st = Xs(o, Ie, Me), Me !== st && sS(Ie, st, Me);
                else if (!qn(Ie, Dt, N) && !sr(Ie, Me, Dt, N)) {
                  var Ae = !1;
                  if (Dt !== null)
                    $.delete(Dt.attributeName), st = Ul(o, Ie, Me, Dt);
                  else {
                    var we = S;
                    if (we === ja && (we = rv(a)), we === ja)
                      $.delete(Ie.toLowerCase());
                    else {
                      var Ge = GY(Ie);
                      Ge !== null && Ge !== Ie && (Ae = !0, $.delete(Ge)), $.delete(Ie);
                    }
                    st = Xs(o, Ie, Me);
                  }
                  var pt = me;
                  !pt && Me !== st && !Ae && sS(Ie, st, Me);
                }
              }
            }
          }
        }
      switch (D && // $FlowFixMe - Should be inferred as not undefined.
      $.size > 0 && p[jf] !== !0 && zL($), a) {
        case "input":
          Z(o), ge(o, p, !0);
          break;
        case "textarea":
          Z(o), Uw(o);
          break;
        case "select":
        case "option":
          break;
        default:
          typeof p.onClick == "function" && s0(o);
          break;
      }
      return _e;
    }
    function YY(o, a, p) {
      var S = o.nodeValue !== a;
      return S;
    }
    function kP(o, a) {
      {
        if (aa)
          return;
        aa = !0, c("Did not expect server HTML to contain a <%s> in <%s>.", a.nodeName.toLowerCase(), o.nodeName.toLowerCase());
      }
    }
    function RP(o, a) {
      {
        if (aa)
          return;
        aa = !0, c('Did not expect server HTML to contain the text node "%s" in <%s>.', a.nodeValue, o.nodeName.toLowerCase());
      }
    }
    function MP(o, a, p) {
      {
        if (aa)
          return;
        aa = !0, c("Expected server HTML to contain a matching <%s> in <%s>.", a, o.nodeName.toLowerCase());
      }
    }
    function AP(o, a) {
      {
        if (a === "" || aa)
          return;
        aa = !0, c('Expected server HTML to contain a matching text node for "%s" in <%s>.', a, o.nodeName.toLowerCase());
      }
    }
    function XY(o, a, p) {
      switch (a) {
        case "input":
          Re(o, p);
          return;
        case "textarea":
          G_(o, p);
          return;
        case "select":
          tv(o, p);
          return;
      }
    }
    var aS = function() {
    }, lS = function() {
    };
    {
      var ZY = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"], HL = [
        "applet",
        "caption",
        "html",
        "table",
        "td",
        "th",
        "marquee",
        "object",
        "template",
        // https://html.spec.whatwg.org/multipage/syntax.html#html-integration-point
        // TODO: Distinguish by namespace here -- for <title>, including it here
        // errs on the side of fewer warnings
        "foreignObject",
        "desc",
        "title"
      ], QY = HL.concat(["button"]), JY = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"], VL = {
        current: null,
        formTag: null,
        aTagInScope: null,
        buttonTagInScope: null,
        nobrTagInScope: null,
        pTagInButtonScope: null,
        listItemTagAutoclosing: null,
        dlItemTagAutoclosing: null
      };
      lS = function(o, a) {
        var p = Gt({}, o || VL), S = {
          tag: a
        };
        return HL.indexOf(a) !== -1 && (p.aTagInScope = null, p.buttonTagInScope = null, p.nobrTagInScope = null), QY.indexOf(a) !== -1 && (p.pTagInButtonScope = null), ZY.indexOf(a) !== -1 && a !== "address" && a !== "div" && a !== "p" && (p.listItemTagAutoclosing = null, p.dlItemTagAutoclosing = null), p.current = S, a === "form" && (p.formTag = S), a === "a" && (p.aTagInScope = S), a === "button" && (p.buttonTagInScope = S), a === "nobr" && (p.nobrTagInScope = S), a === "p" && (p.pTagInButtonScope = S), a === "li" && (p.listItemTagAutoclosing = S), (a === "dd" || a === "dt") && (p.dlItemTagAutoclosing = S), p;
      };
      var eX = function(o, a) {
        switch (a) {
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inselect
          case "select":
            return o === "option" || o === "optgroup" || o === "#text";
          case "optgroup":
            return o === "option" || o === "#text";
          // Strictly speaking, seeing an <option> doesn't mean we're in a <select>
          // but
          case "option":
            return o === "#text";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intd
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incaption
          // No special behavior since these rules fall back to "in body" mode for
          // all except special table nodes which cause bad parsing behavior anyway.
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intr
          case "tr":
            return o === "th" || o === "td" || o === "style" || o === "script" || o === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intbody
          case "tbody":
          case "thead":
          case "tfoot":
            return o === "tr" || o === "style" || o === "script" || o === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-incolgroup
          case "colgroup":
            return o === "col" || o === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-intable
          case "table":
            return o === "caption" || o === "colgroup" || o === "tbody" || o === "tfoot" || o === "thead" || o === "style" || o === "script" || o === "template";
          // https://html.spec.whatwg.org/multipage/syntax.html#parsing-main-inhead
          case "head":
            return o === "base" || o === "basefont" || o === "bgsound" || o === "link" || o === "meta" || o === "title" || o === "noscript" || o === "noframes" || o === "style" || o === "script" || o === "template";
          // https://html.spec.whatwg.org/multipage/semantics.html#the-html-element
          case "html":
            return o === "head" || o === "body" || o === "frameset";
          case "frameset":
            return o === "frame";
          case "#document":
            return o === "html";
        }
        switch (o) {
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return a !== "h1" && a !== "h2" && a !== "h3" && a !== "h4" && a !== "h5" && a !== "h6";
          case "rp":
          case "rt":
            return JY.indexOf(a) === -1;
          case "body":
          case "caption":
          case "col":
          case "colgroup":
          case "frameset":
          case "frame":
          case "head":
          case "html":
          case "tbody":
          case "td":
          case "tfoot":
          case "th":
          case "thead":
          case "tr":
            return a == null;
        }
        return !0;
      }, tX = function(o, a) {
        switch (o) {
          case "address":
          case "article":
          case "aside":
          case "blockquote":
          case "center":
          case "details":
          case "dialog":
          case "dir":
          case "div":
          case "dl":
          case "fieldset":
          case "figcaption":
          case "figure":
          case "footer":
          case "header":
          case "hgroup":
          case "main":
          case "menu":
          case "nav":
          case "ol":
          case "p":
          case "section":
          case "summary":
          case "ul":
          case "pre":
          case "listing":
          case "table":
          case "hr":
          case "xmp":
          case "h1":
          case "h2":
          case "h3":
          case "h4":
          case "h5":
          case "h6":
            return a.pTagInButtonScope;
          case "form":
            return a.formTag || a.pTagInButtonScope;
          case "li":
            return a.listItemTagAutoclosing;
          case "dd":
          case "dt":
            return a.dlItemTagAutoclosing;
          case "button":
            return a.buttonTagInScope;
          case "a":
            return a.aTagInScope;
          case "nobr":
            return a.nobrTagInScope;
        }
        return null;
      }, KL = {};
      aS = function(o, a, p) {
        p = p || VL;
        var S = p.current, b = S && S.tag;
        a != null && (o != null && c("validateDOMNesting: when childText is passed, childTag should be null"), o = "#text");
        var T = eX(o, b) ? null : S, D = T ? null : tX(o, p), N = T || D;
        if (N) {
          var $ = N.tag, G = !!T + "|" + o + "|" + $;
          if (!KL[G]) {
            KL[G] = !0;
            var X = o, fe = "";
            if (o === "#text" ? /\S/.test(a) ? X = "Text nodes" : (X = "Whitespace text nodes", fe = " Make sure you don't have any extra whitespace between tags on each line of your source code.") : X = "<" + o + ">", T) {
              var ue = "";
              $ === "table" && o === "tr" && (ue += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by the browser."), c("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", X, $, fe, ue);
            } else
              c("validateDOMNesting(...): %s cannot appear as a descendant of <%s>.", X, $);
          }
        }
      };
    }
    var a0 = "suppressHydrationWarning", l0 = "$", c0 = "/$", cS = "$?", uS = "$!", nX = "style", DP = null, OP = null;
    function rX(o) {
      var a, p, S = o.nodeType;
      switch (S) {
        case Yl:
        case Oh: {
          a = S === Yl ? "#document" : "#fragment";
          var b = o.documentElement;
          p = b ? b.namespaceURI : vg(null, "");
          break;
        }
        default: {
          var T = S === li ? o.parentNode : o, D = T.namespaceURI || null;
          a = T.tagName, p = vg(D, a);
          break;
        }
      }
      {
        var N = a.toLowerCase(), $ = lS(null, N);
        return {
          namespace: p,
          ancestorInfo: $
        };
      }
    }
    function iX(o, a, p) {
      {
        var S = o, b = vg(S.namespace, a), T = lS(S.ancestorInfo, a);
        return {
          namespace: b,
          ancestorInfo: T
        };
      }
    }
    function oEe(o) {
      return o;
    }
    function oX(o) {
      DP = qi(), OP = SY();
      var a = null;
      return ti(!1), a;
    }
    function sX(o) {
      xY(OP), ti(DP), DP = null, OP = null;
    }
    function aX(o, a, p, S, b) {
      var T;
      {
        var D = S;
        if (aS(o, null, D.ancestorInfo), typeof a.children == "string" || typeof a.children == "number") {
          var N = "" + a.children, $ = lS(D.ancestorInfo, o);
          aS(null, N, $);
        }
        T = D.namespace;
      }
      var G = BY(o, a, p, T);
      return hS(b, G), BP(G, a), G;
    }
    function lX(o, a) {
      o.appendChild(a);
    }
    function cX(o, a, p, S, b) {
      switch (VY(o, a, p, S), a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          return !!p.autoFocus;
        case "img":
          return !0;
        default:
          return !1;
      }
    }
    function uX(o, a, p, S, b, T) {
      {
        var D = T;
        if (typeof S.children != typeof p.children && (typeof S.children == "string" || typeof S.children == "number")) {
          var N = "" + S.children, $ = lS(D.ancestorInfo, a);
          aS(null, N, $);
        }
      }
      return KY(o, a, p, S);
    }
    function jP(o, a) {
      return o === "textarea" || o === "noscript" || typeof a.children == "string" || typeof a.children == "number" || typeof a.dangerouslySetInnerHTML == "object" && a.dangerouslySetInnerHTML !== null && a.dangerouslySetInnerHTML.__html != null;
    }
    function dX(o, a, p, S) {
      {
        var b = p;
        aS(null, o, b.ancestorInfo);
      }
      var T = HY(o, a);
      return hS(S, T), T;
    }
    function fX() {
      var o = window.event;
      return o === void 0 ? Wi : Tf(o.type);
    }
    var LP = typeof setTimeout == "function" ? setTimeout : void 0, hX = typeof clearTimeout == "function" ? clearTimeout : void 0, NP = -1, WL = typeof Promise == "function" ? Promise : void 0, pX = typeof queueMicrotask == "function" ? queueMicrotask : typeof WL < "u" ? function(o) {
      return WL.resolve(null).then(o).catch(gX);
    } : LP;
    function gX(o) {
      setTimeout(function() {
        throw o;
      });
    }
    function mX(o, a, p, S) {
      switch (a) {
        case "button":
        case "input":
        case "select":
        case "textarea":
          p.autoFocus && o.focus();
          return;
        case "img": {
          p.src && (o.src = p.src);
          return;
        }
      }
    }
    function yX(o, a, p, S, b, T) {
      WY(o, a, p, S, b), BP(o, b);
    }
    function GL(o) {
      Lc(o, "");
    }
    function vX(o, a, p) {
      o.nodeValue = p;
    }
    function SX(o, a) {
      o.appendChild(a);
    }
    function xX(o, a) {
      var p;
      o.nodeType === li ? (p = o.parentNode, p.insertBefore(a, o)) : (p = o, p.appendChild(a));
      var S = o._reactRootContainer;
      S == null && p.onclick === null && s0(p);
    }
    function wX(o, a, p) {
      o.insertBefore(a, p);
    }
    function bX(o, a, p) {
      o.nodeType === li ? o.parentNode.insertBefore(a, p) : o.insertBefore(a, p);
    }
    function CX(o, a) {
      o.removeChild(a);
    }
    function EX(o, a) {
      o.nodeType === li ? o.parentNode.removeChild(a) : o.removeChild(a);
    }
    function FP(o, a) {
      var p = a, S = 0;
      do {
        var b = p.nextSibling;
        if (o.removeChild(p), b && b.nodeType === li) {
          var T = b.data;
          if (T === c0)
            if (S === 0) {
              o.removeChild(b), ho(a);
              return;
            } else
              S--;
          else (T === l0 || T === cS || T === uS) && S++;
        }
        p = b;
      } while (p);
      ho(a);
    }
    function _X(o, a) {
      o.nodeType === li ? FP(o.parentNode, a) : o.nodeType === Yo && FP(o, a), ho(o);
    }
    function PX(o) {
      o = o;
      var a = o.style;
      typeof a.setProperty == "function" ? a.setProperty("display", "none", "important") : a.display = "none";
    }
    function TX(o) {
      o.nodeValue = "";
    }
    function IX(o, a) {
      o = o;
      var p = a[nX], S = p != null && p.hasOwnProperty("display") ? p.display : null;
      o.style.display = xg("display", S);
    }
    function kX(o, a) {
      o.nodeValue = a;
    }
    function RX(o) {
      o.nodeType === Yo ? o.textContent = "" : o.nodeType === Yl && o.documentElement && o.removeChild(o.documentElement);
    }
    function MX(o, a, p) {
      return o.nodeType !== Yo || a.toLowerCase() !== o.nodeName.toLowerCase() ? null : o;
    }
    function AX(o, a) {
      return a === "" || o.nodeType !== ql ? null : o;
    }
    function DX(o) {
      return o.nodeType !== li ? null : o;
    }
    function qL(o) {
      return o.data === cS;
    }
    function zP(o) {
      return o.data === uS;
    }
    function OX(o) {
      var a = o.nextSibling && o.nextSibling.dataset, p, S, b;
      return a && (p = a.dgst, S = a.msg, b = a.stck), {
        message: S,
        digest: p,
        stack: b
      };
    }
    function jX(o, a) {
      o._reactRetry = a;
    }
    function u0(o) {
      for (; o != null; o = o.nextSibling) {
        var a = o.nodeType;
        if (a === Yo || a === ql)
          break;
        if (a === li) {
          var p = o.data;
          if (p === l0 || p === uS || p === cS)
            break;
          if (p === c0)
            return null;
        }
      }
      return o;
    }
    function dS(o) {
      return u0(o.nextSibling);
    }
    function LX(o) {
      return u0(o.firstChild);
    }
    function NX(o) {
      return u0(o.firstChild);
    }
    function FX(o) {
      return u0(o.nextSibling);
    }
    function zX(o, a, p, S, b, T, D) {
      hS(T, o), BP(o, p);
      var N;
      {
        var $ = b;
        N = $.namespace;
      }
      var G = (T.mode & pn) !== Mt;
      return qY(o, a, p, N, S, G, D);
    }
    function UX(o, a, p, S) {
      return hS(p, o), p.mode & pn, YY(o, a);
    }
    function $X(o, a) {
      hS(a, o);
    }
    function BX(o) {
      for (var a = o.nextSibling, p = 0; a; ) {
        if (a.nodeType === li) {
          var S = a.data;
          if (S === c0) {
            if (p === 0)
              return dS(a);
            p--;
          } else (S === l0 || S === uS || S === cS) && p++;
        }
        a = a.nextSibling;
      }
      return null;
    }
    function YL(o) {
      for (var a = o.previousSibling, p = 0; a; ) {
        if (a.nodeType === li) {
          var S = a.data;
          if (S === l0 || S === uS || S === cS) {
            if (p === 0)
              return a;
            p--;
          } else S === c0 && p++;
        }
        a = a.previousSibling;
      }
      return null;
    }
    function HX(o) {
      ho(o);
    }
    function VX(o) {
      ho(o);
    }
    function KX(o) {
      return o !== "head" && o !== "body";
    }
    function WX(o, a, p, S) {
      var b = !0;
      o0(a.nodeValue, p, S, b);
    }
    function GX(o, a, p, S, b, T) {
      if (a[a0] !== !0) {
        var D = !0;
        o0(S.nodeValue, b, T, D);
      }
    }
    function qX(o, a) {
      a.nodeType === Yo ? kP(o, a) : a.nodeType === li || RP(o, a);
    }
    function YX(o, a) {
      {
        var p = o.parentNode;
        p !== null && (a.nodeType === Yo ? kP(p, a) : a.nodeType === li || RP(p, a));
      }
    }
    function XX(o, a, p, S, b) {
      (b || a[a0] !== !0) && (S.nodeType === Yo ? kP(p, S) : S.nodeType === li || RP(p, S));
    }
    function ZX(o, a, p) {
      MP(o, a);
    }
    function QX(o, a) {
      AP(o, a);
    }
    function JX(o, a, p) {
      {
        var S = o.parentNode;
        S !== null && MP(S, a);
      }
    }
    function eZ(o, a) {
      {
        var p = o.parentNode;
        p !== null && AP(p, a);
      }
    }
    function tZ(o, a, p, S, b, T) {
      (T || a[a0] !== !0) && MP(p, S);
    }
    function nZ(o, a, p, S, b) {
      (b || a[a0] !== !0) && AP(p, S);
    }
    function rZ(o) {
      c("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", o.nodeName.toLowerCase());
    }
    function iZ(o) {
      rS(o);
    }
    var km = Math.random().toString(36).slice(2), Rm = "__reactFiber$" + km, UP = "__reactProps$" + km, fS = "__reactContainer$" + km, $P = "__reactEvents$" + km, oZ = "__reactListeners$" + km, sZ = "__reactHandles$" + km;
    function aZ(o) {
      delete o[Rm], delete o[UP], delete o[$P], delete o[oZ], delete o[sZ];
    }
    function hS(o, a) {
      a[Rm] = o;
    }
    function d0(o, a) {
      a[fS] = o;
    }
    function XL(o) {
      o[fS] = null;
    }
    function pS(o) {
      return !!o[fS];
    }
    function _p(o) {
      var a = o[Rm];
      if (a)
        return a;
      for (var p = o.parentNode; p; ) {
        if (a = p[fS] || p[Rm], a) {
          var S = a.alternate;
          if (a.child !== null || S !== null && S.child !== null)
            for (var b = YL(o); b !== null; ) {
              var T = b[Rm];
              if (T)
                return T;
              b = YL(b);
            }
          return a;
        }
        o = p, p = o.parentNode;
      }
      return null;
    }
    function Lf(o) {
      var a = o[Rm] || o[fS];
      return a && (a.tag === C || a.tag === E || a.tag === F || a.tag === v) ? a : null;
    }
    function Mm(o) {
      if (o.tag === C || o.tag === E)
        return o.stateNode;
      throw new Error("getNodeFromInstance: Invalid argument.");
    }
    function f0(o) {
      return o[UP] || null;
    }
    function BP(o, a) {
      o[UP] = a;
    }
    function lZ(o) {
      var a = o[$P];
      return a === void 0 && (a = o[$P] = /* @__PURE__ */ new Set()), a;
    }
    var ZL = {}, QL = r.ReactDebugCurrentFrame;
    function h0(o) {
      if (o) {
        var a = o._owner, p = Uu(o.type, o._source, a ? a.type : null);
        QL.setExtraStackFrame(p);
      } else
        QL.setExtraStackFrame(null);
    }
    function rc(o, a, p, S, b) {
      {
        var T = Function.call.bind(Zt);
        for (var D in o)
          if (T(o, D)) {
            var N = void 0;
            try {
              if (typeof o[D] != "function") {
                var $ = Error((S || "React class") + ": " + p + " type `" + D + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof o[D] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw $.name = "Invariant Violation", $;
              }
              N = o[D](a, D, S, p, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (G) {
              N = G;
            }
            N && !(N instanceof Error) && (h0(b), c("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", S || "React class", p, D, typeof N), h0(null)), N instanceof Error && !(N.message in ZL) && (ZL[N.message] = !0, h0(b), c("Failed %s type: %s", p, N.message), h0(null));
          }
      }
    }
    var HP = [], p0;
    p0 = [];
    var pd = -1;
    function Nf(o) {
      return {
        current: o
      };
    }
    function is(o, a) {
      if (pd < 0) {
        c("Unexpected pop.");
        return;
      }
      a !== p0[pd] && c("Unexpected Fiber popped."), o.current = HP[pd], HP[pd] = null, p0[pd] = null, pd--;
    }
    function os(o, a, p) {
      pd++, HP[pd] = o.current, p0[pd] = p, o.current = a;
    }
    var VP;
    VP = {};
    var Ha = {};
    Object.freeze(Ha);
    var gd = Nf(Ha), ru = Nf(!1), KP = Ha;
    function Am(o, a, p) {
      return p && iu(a) ? KP : gd.current;
    }
    function JL(o, a, p) {
      {
        var S = o.stateNode;
        S.__reactInternalMemoizedUnmaskedChildContext = a, S.__reactInternalMemoizedMaskedChildContext = p;
      }
    }
    function Dm(o, a) {
      {
        var p = o.type, S = p.contextTypes;
        if (!S)
          return Ha;
        var b = o.stateNode;
        if (b && b.__reactInternalMemoizedUnmaskedChildContext === a)
          return b.__reactInternalMemoizedMaskedChildContext;
        var T = {};
        for (var D in S)
          T[D] = a[D];
        {
          var N = Ut(o) || "Unknown";
          rc(S, T, "context", N);
        }
        return b && JL(o, a, T), T;
      }
    }
    function g0() {
      return ru.current;
    }
    function iu(o) {
      {
        var a = o.childContextTypes;
        return a != null;
      }
    }
    function m0(o) {
      is(ru, o), is(gd, o);
    }
    function WP(o) {
      is(ru, o), is(gd, o);
    }
    function e2(o, a, p) {
      {
        if (gd.current !== Ha)
          throw new Error("Unexpected context found on stack. This error is likely caused by a bug in React. Please file an issue.");
        os(gd, a, o), os(ru, p, o);
      }
    }
    function t2(o, a, p) {
      {
        var S = o.stateNode, b = a.childContextTypes;
        if (typeof S.getChildContext != "function") {
          {
            var T = Ut(o) || "Unknown";
            VP[T] || (VP[T] = !0, c("%s.childContextTypes is specified but there is no getChildContext() method on the instance. You can either define getChildContext() on %s or remove childContextTypes from it.", T, T));
          }
          return p;
        }
        var D = S.getChildContext();
        for (var N in D)
          if (!(N in b))
            throw new Error((Ut(o) || "Unknown") + '.getChildContext(): key "' + N + '" is not defined in childContextTypes.');
        {
          var $ = Ut(o) || "Unknown";
          rc(b, D, "child context", $);
        }
        return Gt({}, p, D);
      }
    }
    function y0(o) {
      {
        var a = o.stateNode, p = a && a.__reactInternalMemoizedMergedChildContext || Ha;
        return KP = gd.current, os(gd, p, o), os(ru, ru.current, o), !0;
      }
    }
    function n2(o, a, p) {
      {
        var S = o.stateNode;
        if (!S)
          throw new Error("Expected to have an instance by this point. This error is likely caused by a bug in React. Please file an issue.");
        if (p) {
          var b = t2(o, a, KP);
          S.__reactInternalMemoizedMergedChildContext = b, is(ru, o), is(gd, o), os(gd, b, o), os(ru, p, o);
        } else
          is(ru, o), os(ru, p, o);
      }
    }
    function cZ(o) {
      {
        if (!pb(o) || o.tag !== g)
          throw new Error("Expected subtree parent to be a mounted class component. This error is likely caused by a bug in React. Please file an issue.");
        var a = o;
        do {
          switch (a.tag) {
            case v:
              return a.stateNode.context;
            case g: {
              var p = a.type;
              if (iu(p))
                return a.stateNode.__reactInternalMemoizedMergedChildContext;
              break;
            }
          }
          a = a.return;
        } while (a !== null);
        throw new Error("Found unexpected detached subtree parent. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    var Ff = 0, v0 = 1, md = null, GP = !1, qP = !1;
    function r2(o) {
      md === null ? md = [o] : md.push(o);
    }
    function uZ(o) {
      GP = !0, r2(o);
    }
    function i2() {
      GP && zf();
    }
    function zf() {
      if (!qP && md !== null) {
        qP = !0;
        var o = 0, a = Ds();
        try {
          var p = !0, S = md;
          for (xi(ns); o < S.length; o++) {
            var b = S[o];
            do
              b = b(p);
            while (b !== null);
          }
          md = null, GP = !1;
        } catch (T) {
          throw md !== null && (md = md.slice(o + 1)), vv(Ql, zf), T;
        } finally {
          xi(a), qP = !1;
        }
      }
      return null;
    }
    var Om = [], jm = 0, S0 = null, x0 = 0, Sl = [], xl = 0, Pp = null, yd = 1, vd = "";
    function dZ(o) {
      return Ip(), (o.flags & qh) !== Rt;
    }
    function fZ(o) {
      return Ip(), x0;
    }
    function hZ() {
      var o = vd, a = yd, p = a & ~pZ(a);
      return p.toString(32) + o;
    }
    function Tp(o, a) {
      Ip(), Om[jm++] = x0, Om[jm++] = S0, S0 = o, x0 = a;
    }
    function o2(o, a, p) {
      Ip(), Sl[xl++] = yd, Sl[xl++] = vd, Sl[xl++] = Pp, Pp = o;
      var S = yd, b = vd, T = w0(S) - 1, D = S & ~(1 << T), N = p + 1, $ = w0(a) + T;
      if ($ > 30) {
        var G = T - T % 5, X = (1 << G) - 1, fe = (D & X).toString(32), ue = D >> G, _e = T - G, Ie = w0(a) + _e, Me = N << _e, st = Me | ue, Dt = fe + b;
        yd = 1 << Ie | st, vd = Dt;
      } else {
        var Tt = N << T, Dn = Tt | D, En = b;
        yd = 1 << $ | Dn, vd = En;
      }
    }
    function YP(o) {
      Ip();
      var a = o.return;
      if (a !== null) {
        var p = 1, S = 0;
        Tp(o, p), o2(o, p, S);
      }
    }
    function w0(o) {
      return 32 - Si(o);
    }
    function pZ(o) {
      return 1 << w0(o) - 1;
    }
    function XP(o) {
      for (; o === S0; )
        S0 = Om[--jm], Om[jm] = null, x0 = Om[--jm], Om[jm] = null;
      for (; o === Pp; )
        Pp = Sl[--xl], Sl[xl] = null, vd = Sl[--xl], Sl[xl] = null, yd = Sl[--xl], Sl[xl] = null;
    }
    function gZ() {
      return Ip(), Pp !== null ? {
        id: yd,
        overflow: vd
      } : null;
    }
    function mZ(o, a) {
      Ip(), Sl[xl++] = yd, Sl[xl++] = vd, Sl[xl++] = Pp, yd = a.id, vd = a.overflow, Pp = o;
    }
    function Ip() {
      _o() || c("Expected to be hydrating. This is a bug in React. Please file an issue.");
    }
    var Eo = null, wl = null, ic = !1, kp = !1, Uf = null;
    function yZ() {
      ic && c("We should not be hydrating here. This is a bug in React. Please file a bug.");
    }
    function s2() {
      kp = !0;
    }
    function vZ() {
      return kp;
    }
    function SZ(o) {
      var a = o.stateNode.containerInfo;
      return wl = NX(a), Eo = o, ic = !0, Uf = null, kp = !1, !0;
    }
    function xZ(o, a, p) {
      return wl = FX(a), Eo = o, ic = !0, Uf = null, kp = !1, p !== null && mZ(o, p), !0;
    }
    function a2(o, a) {
      switch (o.tag) {
        case v: {
          qX(o.stateNode.containerInfo, a);
          break;
        }
        case C: {
          var p = (o.mode & pn) !== Mt;
          XX(
            o.type,
            o.memoizedProps,
            o.stateNode,
            a,
            // TODO: Delete this argument when we remove the legacy root API.
            p
          );
          break;
        }
        case F: {
          var S = o.memoizedState;
          S.dehydrated !== null && YX(S.dehydrated, a);
          break;
        }
      }
    }
    function l2(o, a) {
      a2(o, a);
      var p = Eee();
      p.stateNode = a, p.return = o;
      var S = o.deletions;
      S === null ? (o.deletions = [p], o.flags |= Xo) : S.push(p);
    }
    function ZP(o, a) {
      {
        if (kp)
          return;
        switch (o.tag) {
          case v: {
            var p = o.stateNode.containerInfo;
            switch (a.tag) {
              case C:
                var S = a.type;
                a.pendingProps, ZX(p, S);
                break;
              case E:
                var b = a.pendingProps;
                QX(p, b);
                break;
            }
            break;
          }
          case C: {
            var T = o.type, D = o.memoizedProps, N = o.stateNode;
            switch (a.tag) {
              case C: {
                var $ = a.type, G = a.pendingProps, X = (o.mode & pn) !== Mt;
                tZ(
                  T,
                  D,
                  N,
                  $,
                  G,
                  // TODO: Delete this argument when we remove the legacy root API.
                  X
                );
                break;
              }
              case E: {
                var fe = a.pendingProps, ue = (o.mode & pn) !== Mt;
                nZ(
                  T,
                  D,
                  N,
                  fe,
                  // TODO: Delete this argument when we remove the legacy root API.
                  ue
                );
                break;
              }
            }
            break;
          }
          case F: {
            var _e = o.memoizedState, Ie = _e.dehydrated;
            if (Ie !== null) switch (a.tag) {
              case C:
                var Me = a.type;
                a.pendingProps, JX(Ie, Me);
                break;
              case E:
                var st = a.pendingProps;
                eZ(Ie, st);
                break;
            }
            break;
          }
          default:
            return;
        }
      }
    }
    function c2(o, a) {
      a.flags = a.flags & -4097 | ci, ZP(o, a);
    }
    function u2(o, a) {
      switch (o.tag) {
        case C: {
          var p = o.type;
          o.pendingProps;
          var S = MX(a, p);
          return S !== null ? (o.stateNode = S, Eo = o, wl = LX(S), !0) : !1;
        }
        case E: {
          var b = o.pendingProps, T = AX(a, b);
          return T !== null ? (o.stateNode = T, Eo = o, wl = null, !0) : !1;
        }
        case F: {
          var D = DX(a);
          if (D !== null) {
            var N = {
              dehydrated: D,
              treeContext: gZ(),
              retryLane: As
            };
            o.memoizedState = N;
            var $ = _ee(D);
            return $.return = o, o.child = $, Eo = o, wl = null, !0;
          }
          return !1;
        }
        default:
          return !1;
      }
    }
    function QP(o) {
      return (o.mode & pn) !== Mt && (o.flags & hn) === Rt;
    }
    function JP(o) {
      throw new Error("Hydration failed because the initial UI does not match what was rendered on the server.");
    }
    function eT(o) {
      if (ic) {
        var a = wl;
        if (!a) {
          QP(o) && (ZP(Eo, o), JP()), c2(Eo, o), ic = !1, Eo = o;
          return;
        }
        var p = a;
        if (!u2(o, a)) {
          QP(o) && (ZP(Eo, o), JP()), a = dS(p);
          var S = Eo;
          if (!a || !u2(o, a)) {
            c2(Eo, o), ic = !1, Eo = o;
            return;
          }
          l2(S, p);
        }
      }
    }
    function wZ(o, a, p) {
      var S = o.stateNode, b = !kp, T = zX(S, o.type, o.memoizedProps, a, p, o, b);
      return o.updateQueue = T, T !== null;
    }
    function bZ(o) {
      var a = o.stateNode, p = o.memoizedProps, S = UX(a, p, o);
      if (S) {
        var b = Eo;
        if (b !== null)
          switch (b.tag) {
            case v: {
              var T = b.stateNode.containerInfo, D = (b.mode & pn) !== Mt;
              WX(
                T,
                a,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                D
              );
              break;
            }
            case C: {
              var N = b.type, $ = b.memoizedProps, G = b.stateNode, X = (b.mode & pn) !== Mt;
              GX(
                N,
                $,
                G,
                a,
                p,
                // TODO: Delete this argument when we remove the legacy root API.
                X
              );
              break;
            }
          }
      }
      return S;
    }
    function CZ(o) {
      var a = o.memoizedState, p = a !== null ? a.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      $X(p, o);
    }
    function EZ(o) {
      var a = o.memoizedState, p = a !== null ? a.dehydrated : null;
      if (!p)
        throw new Error("Expected to have a hydrated suspense instance. This error is likely caused by a bug in React. Please file an issue.");
      return BX(p);
    }
    function d2(o) {
      for (var a = o.return; a !== null && a.tag !== C && a.tag !== v && a.tag !== F; )
        a = a.return;
      Eo = a;
    }
    function b0(o) {
      if (o !== Eo)
        return !1;
      if (!ic)
        return d2(o), ic = !0, !1;
      if (o.tag !== v && (o.tag !== C || KX(o.type) && !jP(o.type, o.memoizedProps))) {
        var a = wl;
        if (a)
          if (QP(o))
            f2(o), JP();
          else
            for (; a; )
              l2(o, a), a = dS(a);
      }
      return d2(o), o.tag === F ? wl = EZ(o) : wl = Eo ? dS(o.stateNode) : null, !0;
    }
    function _Z() {
      return ic && wl !== null;
    }
    function f2(o) {
      for (var a = wl; a; )
        a2(o, a), a = dS(a);
    }
    function Lm() {
      Eo = null, wl = null, ic = !1, kp = !1;
    }
    function h2() {
      Uf !== null && (s3(Uf), Uf = null);
    }
    function _o() {
      return ic;
    }
    function tT(o) {
      Uf === null ? Uf = [o] : Uf.push(o);
    }
    var PZ = r.ReactCurrentBatchConfig, TZ = null;
    function IZ() {
      return PZ.transition;
    }
    var oc = {
      recordUnsafeLifecycleWarnings: function(o, a) {
      },
      flushPendingUnsafeLifecycleWarnings: function() {
      },
      recordLegacyContextWarning: function(o, a) {
      },
      flushLegacyContextWarning: function() {
      },
      discardPendingWarnings: function() {
      }
    };
    {
      var kZ = function(o) {
        for (var a = null, p = o; p !== null; )
          p.mode & Jt && (a = p), p = p.return;
        return a;
      }, Rp = function(o) {
        var a = [];
        return o.forEach(function(p) {
          a.push(p);
        }), a.sort().join(", ");
      }, gS = [], mS = [], yS = [], vS = [], SS = [], xS = [], Mp = /* @__PURE__ */ new Set();
      oc.recordUnsafeLifecycleWarnings = function(o, a) {
        Mp.has(o.type) || (typeof a.componentWillMount == "function" && // Don't warn about react-lifecycles-compat polyfilled components.
        a.componentWillMount.__suppressDeprecationWarning !== !0 && gS.push(o), o.mode & Jt && typeof a.UNSAFE_componentWillMount == "function" && mS.push(o), typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps.__suppressDeprecationWarning !== !0 && yS.push(o), o.mode & Jt && typeof a.UNSAFE_componentWillReceiveProps == "function" && vS.push(o), typeof a.componentWillUpdate == "function" && a.componentWillUpdate.__suppressDeprecationWarning !== !0 && SS.push(o), o.mode & Jt && typeof a.UNSAFE_componentWillUpdate == "function" && xS.push(o));
      }, oc.flushPendingUnsafeLifecycleWarnings = function() {
        var o = /* @__PURE__ */ new Set();
        gS.length > 0 && (gS.forEach(function(ue) {
          o.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), gS = []);
        var a = /* @__PURE__ */ new Set();
        mS.length > 0 && (mS.forEach(function(ue) {
          a.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), mS = []);
        var p = /* @__PURE__ */ new Set();
        yS.length > 0 && (yS.forEach(function(ue) {
          p.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), yS = []);
        var S = /* @__PURE__ */ new Set();
        vS.length > 0 && (vS.forEach(function(ue) {
          S.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), vS = []);
        var b = /* @__PURE__ */ new Set();
        SS.length > 0 && (SS.forEach(function(ue) {
          b.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), SS = []);
        var T = /* @__PURE__ */ new Set();
        if (xS.length > 0 && (xS.forEach(function(ue) {
          T.add(Ut(ue) || "Component"), Mp.add(ue.type);
        }), xS = []), a.size > 0) {
          var D = Rp(a);
          c(`Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.

Please update the following components: %s`, D);
        }
        if (S.size > 0) {
          var N = Rp(S);
          c(`Using UNSAFE_componentWillReceiveProps in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state

Please update the following components: %s`, N);
        }
        if (T.size > 0) {
          var $ = Rp(T);
          c(`Using UNSAFE_componentWillUpdate in strict mode is not recommended and may indicate bugs in your code. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.

Please update the following components: %s`, $);
        }
        if (o.size > 0) {
          var G = Rp(o);
          l(`componentWillMount has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move code with side effects to componentDidMount, and set initial state in the constructor.
* Rename componentWillMount to UNSAFE_componentWillMount to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, G);
        }
        if (p.size > 0) {
          var X = Rp(p);
          l(`componentWillReceiveProps has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* If you're updating state whenever props change, refactor your code to use memoization techniques or move it to static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, X);
        }
        if (b.size > 0) {
          var fe = Rp(b);
          l(`componentWillUpdate has been renamed, and is not recommended for use. See https://reactjs.org/link/unsafe-component-lifecycles for details.

* Move data fetching code or side effects to componentDidUpdate.
* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. To rename all deprecated lifecycles to their new names, you can run \`npx react-codemod rename-unsafe-lifecycles\` in your project source folder.

Please update the following components: %s`, fe);
        }
      };
      var C0 = /* @__PURE__ */ new Map(), p2 = /* @__PURE__ */ new Set();
      oc.recordLegacyContextWarning = function(o, a) {
        var p = kZ(o);
        if (p === null) {
          c("Expected to find a StrictMode component in a strict mode tree. This error is likely caused by a bug in React. Please file an issue.");
          return;
        }
        if (!p2.has(o.type)) {
          var S = C0.get(p);
          (o.type.contextTypes != null || o.type.childContextTypes != null || a !== null && typeof a.getChildContext == "function") && (S === void 0 && (S = [], C0.set(p, S)), S.push(o));
        }
      }, oc.flushLegacyContextWarning = function() {
        C0.forEach(function(o, a) {
          if (o.length !== 0) {
            var p = o[0], S = /* @__PURE__ */ new Set();
            o.forEach(function(T) {
              S.add(Ut(T) || "Component"), p2.add(T.type);
            });
            var b = Rp(S);
            try {
              $n(p), c(`Legacy context API has been detected within a strict-mode tree.

The old API will be supported in all 16.x releases, but applications using it should migrate to the new version.

Please update the following components: %s

Learn more about this warning here: https://reactjs.org/link/legacy-context`, b);
            } finally {
              kr();
            }
          }
        });
      }, oc.discardPendingWarnings = function() {
        gS = [], mS = [], yS = [], vS = [], SS = [], xS = [], C0 = /* @__PURE__ */ new Map();
      };
    }
    var nT, rT, iT, oT, sT, g2 = function(o, a) {
    };
    nT = !1, rT = !1, iT = {}, oT = {}, sT = {}, g2 = function(o, a) {
      if (!(o === null || typeof o != "object") && !(!o._store || o._store.validated || o.key != null)) {
        if (typeof o._store != "object")
          throw new Error("React Component in warnForMissingKey should have a _store. This error is likely caused by a bug in React. Please file an issue.");
        o._store.validated = !0;
        var p = Ut(a) || "Component";
        oT[p] || (oT[p] = !0, c('Each child in a list should have a unique "key" prop. See https://reactjs.org/link/warning-keys for more information.'));
      }
    };
    function RZ(o) {
      return o.prototype && o.prototype.isReactComponent;
    }
    function wS(o, a, p) {
      var S = p.ref;
      if (S !== null && typeof S != "function" && typeof S != "object") {
        if ((o.mode & Jt || Oe) && // We warn in ReactElement.js if owner and self are equal for string refs
        // because these cannot be automatically converted to an arrow function
        // using a codemod. Therefore, we don't have to warn about string refs again.
        !(p._owner && p._self && p._owner.stateNode !== p._self) && // Will already throw with "Function components cannot have string refs"
        !(p._owner && p._owner.tag !== g) && // Will already warn with "Function components cannot be given refs"
        !(typeof p.type == "function" && !RZ(p.type)) && // Will already throw with "Element ref was specified as a string (someStringRef) but no owner was set"
        p._owner) {
          var b = Ut(o) || "Component";
          iT[b] || (c('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. We recommend using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', b, S), iT[b] = !0);
        }
        if (p._owner) {
          var T = p._owner, D;
          if (T) {
            var N = T;
            if (N.tag !== g)
              throw new Error("Function components cannot have string refs. We recommend using useRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref");
            D = N.stateNode;
          }
          if (!D)
            throw new Error("Missing owner for string ref " + S + ". This error is likely caused by a bug in React. Please file an issue.");
          var $ = D;
          Hr(S, "ref");
          var G = "" + S;
          if (a !== null && a.ref !== null && typeof a.ref == "function" && a.ref._stringRef === G)
            return a.ref;
          var X = function(fe) {
            var ue = $.refs;
            fe === null ? delete ue[G] : ue[G] = fe;
          };
          return X._stringRef = G, X;
        } else {
          if (typeof S != "string")
            throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
          if (!p._owner)
            throw new Error("Element ref was specified as a string (" + S + `) but no owner was set. This could happen for one of the following reasons:
1. You may be adding a ref to a function component
2. You may be adding a ref to a component that was not created inside a component's render method
3. You have multiple copies of React loaded
See https://reactjs.org/link/refs-must-have-owner for more information.`);
        }
      }
      return S;
    }
    function E0(o, a) {
      var p = Object.prototype.toString.call(a);
      throw new Error("Objects are not valid as a React child (found: " + (p === "[object Object]" ? "object with keys {" + Object.keys(a).join(", ") + "}" : p) + "). If you meant to render a collection of children, use an array instead.");
    }
    function _0(o) {
      {
        var a = Ut(o) || "Component";
        if (sT[a])
          return;
        sT[a] = !0, c("Functions are not valid as a React child. This may happen if you return a Component instead of <Component /> from render. Or maybe you meant to call this function rather than return it.");
      }
    }
    function m2(o) {
      var a = o._payload, p = o._init;
      return p(a);
    }
    function y2(o) {
      function a(xe, Ae) {
        if (o) {
          var we = xe.deletions;
          we === null ? (xe.deletions = [Ae], xe.flags |= Xo) : we.push(Ae);
        }
      }
      function p(xe, Ae) {
        if (!o)
          return null;
        for (var we = Ae; we !== null; )
          a(xe, we), we = we.sibling;
        return null;
      }
      function S(xe, Ae) {
        for (var we = /* @__PURE__ */ new Map(), Ge = Ae; Ge !== null; )
          Ge.key !== null ? we.set(Ge.key, Ge) : we.set(Ge.index, Ge), Ge = Ge.sibling;
        return we;
      }
      function b(xe, Ae) {
        var we = Up(xe, Ae);
        return we.index = 0, we.sibling = null, we;
      }
      function T(xe, Ae, we) {
        if (xe.index = we, !o)
          return xe.flags |= qh, Ae;
        var Ge = xe.alternate;
        if (Ge !== null) {
          var pt = Ge.index;
          return pt < Ae ? (xe.flags |= ci, Ae) : pt;
        } else
          return xe.flags |= ci, Ae;
      }
      function D(xe) {
        return o && xe.alternate === null && (xe.flags |= ci), xe;
      }
      function N(xe, Ae, we, Ge) {
        if (Ae === null || Ae.tag !== E) {
          var pt = tk(we, xe.mode, Ge);
          return pt.return = xe, pt;
        } else {
          var ut = b(Ae, we);
          return ut.return = xe, ut;
        }
      }
      function $(xe, Ae, we, Ge) {
        var pt = we.type;
        if (pt === $i)
          return X(xe, Ae, we.props.children, Ge, we.key);
        if (Ae !== null && (Ae.elementType === pt || // Keep this check inline so it only runs on the false path:
        b3(Ae, we) || // Lazy types should reconcile their resolved type.
        // We need to do this after the Hot Reloading check above,
        // because hot reloading has different semantics than prod because
        // it doesn't resuspend. So we can't let the call below suspend.
        typeof pt == "object" && pt !== null && pt.$$typeof === Vt && m2(pt) === Ae.type)) {
          var ut = b(Ae, we.props);
          return ut.ref = wS(xe, Ae, we), ut.return = xe, ut._debugSource = we._source, ut._debugOwner = we._owner, ut;
        }
        var $t = ek(we, xe.mode, Ge);
        return $t.ref = wS(xe, Ae, we), $t.return = xe, $t;
      }
      function G(xe, Ae, we, Ge) {
        if (Ae === null || Ae.tag !== w || Ae.stateNode.containerInfo !== we.containerInfo || Ae.stateNode.implementation !== we.implementation) {
          var pt = nk(we, xe.mode, Ge);
          return pt.return = xe, pt;
        } else {
          var ut = b(Ae, we.children || []);
          return ut.return = xe, ut;
        }
      }
      function X(xe, Ae, we, Ge, pt) {
        if (Ae === null || Ae.tag !== P) {
          var ut = Zf(we, xe.mode, Ge, pt);
          return ut.return = xe, ut;
        } else {
          var $t = b(Ae, we);
          return $t.return = xe, $t;
        }
      }
      function fe(xe, Ae, we) {
        if (typeof Ae == "string" && Ae !== "" || typeof Ae == "number") {
          var Ge = tk("" + Ae, xe.mode, we);
          return Ge.return = xe, Ge;
        }
        if (typeof Ae == "object" && Ae !== null) {
          switch (Ae.$$typeof) {
            case vi: {
              var pt = ek(Ae, xe.mode, we);
              return pt.ref = wS(xe, null, Ae), pt.return = xe, pt;
            }
            case So: {
              var ut = nk(Ae, xe.mode, we);
              return ut.return = xe, ut;
            }
            case Vt: {
              var $t = Ae._payload, Xt = Ae._init;
              return fe(xe, Xt($t), we);
            }
          }
          if (tn(Ae) || yr(Ae)) {
            var fr = Zf(Ae, xe.mode, we, null);
            return fr.return = xe, fr;
          }
          E0(xe, Ae);
        }
        return typeof Ae == "function" && _0(xe), null;
      }
      function ue(xe, Ae, we, Ge) {
        var pt = Ae !== null ? Ae.key : null;
        if (typeof we == "string" && we !== "" || typeof we == "number")
          return pt !== null ? null : N(xe, Ae, "" + we, Ge);
        if (typeof we == "object" && we !== null) {
          switch (we.$$typeof) {
            case vi:
              return we.key === pt ? $(xe, Ae, we, Ge) : null;
            case So:
              return we.key === pt ? G(xe, Ae, we, Ge) : null;
            case Vt: {
              var ut = we._payload, $t = we._init;
              return ue(xe, Ae, $t(ut), Ge);
            }
          }
          if (tn(we) || yr(we))
            return pt !== null ? null : X(xe, Ae, we, Ge, null);
          E0(xe, we);
        }
        return typeof we == "function" && _0(xe), null;
      }
      function _e(xe, Ae, we, Ge, pt) {
        if (typeof Ge == "string" && Ge !== "" || typeof Ge == "number") {
          var ut = xe.get(we) || null;
          return N(Ae, ut, "" + Ge, pt);
        }
        if (typeof Ge == "object" && Ge !== null) {
          switch (Ge.$$typeof) {
            case vi: {
              var $t = xe.get(Ge.key === null ? we : Ge.key) || null;
              return $(Ae, $t, Ge, pt);
            }
            case So: {
              var Xt = xe.get(Ge.key === null ? we : Ge.key) || null;
              return G(Ae, Xt, Ge, pt);
            }
            case Vt:
              var fr = Ge._payload, Vn = Ge._init;
              return _e(xe, Ae, we, Vn(fr), pt);
          }
          if (tn(Ge) || yr(Ge)) {
            var bi = xe.get(we) || null;
            return X(Ae, bi, Ge, pt, null);
          }
          E0(Ae, Ge);
        }
        return typeof Ge == "function" && _0(Ae), null;
      }
      function Ie(xe, Ae, we) {
        {
          if (typeof xe != "object" || xe === null)
            return Ae;
          switch (xe.$$typeof) {
            case vi:
            case So:
              g2(xe, we);
              var Ge = xe.key;
              if (typeof Ge != "string")
                break;
              if (Ae === null) {
                Ae = /* @__PURE__ */ new Set(), Ae.add(Ge);
                break;
              }
              if (!Ae.has(Ge)) {
                Ae.add(Ge);
                break;
              }
              c("Encountered two children with the same key, `%s`. Keys should be unique so that components maintain their identity across updates. Non-unique keys may cause children to be duplicated and/or omitted — the behavior is unsupported and could change in a future version.", Ge);
              break;
            case Vt:
              var pt = xe._payload, ut = xe._init;
              Ie(ut(pt), Ae, we);
              break;
          }
        }
        return Ae;
      }
      function Me(xe, Ae, we, Ge) {
        for (var pt = null, ut = 0; ut < we.length; ut++) {
          var $t = we[ut];
          pt = Ie($t, pt, xe);
        }
        for (var Xt = null, fr = null, Vn = Ae, bi = 0, Kn = 0, gi = null; Vn !== null && Kn < we.length; Kn++) {
          Vn.index > Kn ? (gi = Vn, Vn = null) : gi = Vn.sibling;
          var as = ue(xe, Vn, we[Kn], Ge);
          if (as === null) {
            Vn === null && (Vn = gi);
            break;
          }
          o && Vn && as.alternate === null && a(xe, Vn), bi = T(as, bi, Kn), fr === null ? Xt = as : fr.sibling = as, fr = as, Vn = gi;
        }
        if (Kn === we.length) {
          if (p(xe, Vn), _o()) {
            var Ao = Kn;
            Tp(xe, Ao);
          }
          return Xt;
        }
        if (Vn === null) {
          for (; Kn < we.length; Kn++) {
            var Ka = fe(xe, we[Kn], Ge);
            Ka !== null && (bi = T(Ka, bi, Kn), fr === null ? Xt = Ka : fr.sibling = Ka, fr = Ka);
          }
          if (_o()) {
            var Us = Kn;
            Tp(xe, Us);
          }
          return Xt;
        }
        for (var $s = S(xe, Vn); Kn < we.length; Kn++) {
          var ls = _e($s, xe, Kn, we[Kn], Ge);
          ls !== null && (o && ls.alternate !== null && $s.delete(ls.key === null ? Kn : ls.key), bi = T(ls, bi, Kn), fr === null ? Xt = ls : fr.sibling = ls, fr = ls);
        }
        if (o && $s.forEach(function(ty) {
          return a(xe, ty);
        }), _o()) {
          var _d = Kn;
          Tp(xe, _d);
        }
        return Xt;
      }
      function st(xe, Ae, we, Ge) {
        var pt = yr(we);
        if (typeof pt != "function")
          throw new Error("An object is not an iterable. This error is likely caused by a bug in React. Please file an issue.");
        {
          typeof Symbol == "function" && // $FlowFixMe Flow doesn't know about toStringTag
          we[Symbol.toStringTag] === "Generator" && (rT || c("Using Generators as children is unsupported and will likely yield unexpected results because enumerating a generator mutates it. You may convert it to an array with `Array.from()` or the `[...spread]` operator before rendering. Keep in mind you might need to polyfill these features for older browsers."), rT = !0), we.entries === pt && (nT || c("Using Maps as children is not supported. Use an array of keyed ReactElements instead."), nT = !0);
          var ut = pt.call(we);
          if (ut)
            for (var $t = null, Xt = ut.next(); !Xt.done; Xt = ut.next()) {
              var fr = Xt.value;
              $t = Ie(fr, $t, xe);
            }
        }
        var Vn = pt.call(we);
        if (Vn == null)
          throw new Error("An iterable object provided no iterator.");
        for (var bi = null, Kn = null, gi = Ae, as = 0, Ao = 0, Ka = null, Us = Vn.next(); gi !== null && !Us.done; Ao++, Us = Vn.next()) {
          gi.index > Ao ? (Ka = gi, gi = null) : Ka = gi.sibling;
          var $s = ue(xe, gi, Us.value, Ge);
          if ($s === null) {
            gi === null && (gi = Ka);
            break;
          }
          o && gi && $s.alternate === null && a(xe, gi), as = T($s, as, Ao), Kn === null ? bi = $s : Kn.sibling = $s, Kn = $s, gi = Ka;
        }
        if (Us.done) {
          if (p(xe, gi), _o()) {
            var ls = Ao;
            Tp(xe, ls);
          }
          return bi;
        }
        if (gi === null) {
          for (; !Us.done; Ao++, Us = Vn.next()) {
            var _d = fe(xe, Us.value, Ge);
            _d !== null && (as = T(_d, as, Ao), Kn === null ? bi = _d : Kn.sibling = _d, Kn = _d);
          }
          if (_o()) {
            var ty = Ao;
            Tp(xe, ty);
          }
          return bi;
        }
        for (var JS = S(xe, gi); !Us.done; Ao++, Us = Vn.next()) {
          var fu = _e(JS, xe, Ao, Us.value, Ge);
          fu !== null && (o && fu.alternate !== null && JS.delete(fu.key === null ? Ao : fu.key), as = T(fu, as, Ao), Kn === null ? bi = fu : Kn.sibling = fu, Kn = fu);
        }
        if (o && JS.forEach(function(nte) {
          return a(xe, nte);
        }), _o()) {
          var tte = Ao;
          Tp(xe, tte);
        }
        return bi;
      }
      function Dt(xe, Ae, we, Ge) {
        if (Ae !== null && Ae.tag === E) {
          p(xe, Ae.sibling);
          var pt = b(Ae, we);
          return pt.return = xe, pt;
        }
        p(xe, Ae);
        var ut = tk(we, xe.mode, Ge);
        return ut.return = xe, ut;
      }
      function Tt(xe, Ae, we, Ge) {
        for (var pt = we.key, ut = Ae; ut !== null; ) {
          if (ut.key === pt) {
            var $t = we.type;
            if ($t === $i) {
              if (ut.tag === P) {
                p(xe, ut.sibling);
                var Xt = b(ut, we.props.children);
                return Xt.return = xe, Xt._debugSource = we._source, Xt._debugOwner = we._owner, Xt;
              }
            } else if (ut.elementType === $t || // Keep this check inline so it only runs on the false path:
            b3(ut, we) || // Lazy types should reconcile their resolved type.
            // We need to do this after the Hot Reloading check above,
            // because hot reloading has different semantics than prod because
            // it doesn't resuspend. So we can't let the call below suspend.
            typeof $t == "object" && $t !== null && $t.$$typeof === Vt && m2($t) === ut.type) {
              p(xe, ut.sibling);
              var fr = b(ut, we.props);
              return fr.ref = wS(xe, ut, we), fr.return = xe, fr._debugSource = we._source, fr._debugOwner = we._owner, fr;
            }
            p(xe, ut);
            break;
          } else
            a(xe, ut);
          ut = ut.sibling;
        }
        if (we.type === $i) {
          var Vn = Zf(we.props.children, xe.mode, Ge, we.key);
          return Vn.return = xe, Vn;
        } else {
          var bi = ek(we, xe.mode, Ge);
          return bi.ref = wS(xe, Ae, we), bi.return = xe, bi;
        }
      }
      function Dn(xe, Ae, we, Ge) {
        for (var pt = we.key, ut = Ae; ut !== null; ) {
          if (ut.key === pt)
            if (ut.tag === w && ut.stateNode.containerInfo === we.containerInfo && ut.stateNode.implementation === we.implementation) {
              p(xe, ut.sibling);
              var $t = b(ut, we.children || []);
              return $t.return = xe, $t;
            } else {
              p(xe, ut);
              break;
            }
          else
            a(xe, ut);
          ut = ut.sibling;
        }
        var Xt = nk(we, xe.mode, Ge);
        return Xt.return = xe, Xt;
      }
      function En(xe, Ae, we, Ge) {
        var pt = typeof we == "object" && we !== null && we.type === $i && we.key === null;
        if (pt && (we = we.props.children), typeof we == "object" && we !== null) {
          switch (we.$$typeof) {
            case vi:
              return D(Tt(xe, Ae, we, Ge));
            case So:
              return D(Dn(xe, Ae, we, Ge));
            case Vt:
              var ut = we._payload, $t = we._init;
              return En(xe, Ae, $t(ut), Ge);
          }
          if (tn(we))
            return Me(xe, Ae, we, Ge);
          if (yr(we))
            return st(xe, Ae, we, Ge);
          E0(xe, we);
        }
        return typeof we == "string" && we !== "" || typeof we == "number" ? D(Dt(xe, Ae, "" + we, Ge)) : (typeof we == "function" && _0(xe), p(xe, Ae));
      }
      return En;
    }
    var Nm = y2(!0), v2 = y2(!1);
    function MZ(o, a) {
      if (o !== null && a.child !== o.child)
        throw new Error("Resuming work not yet implemented.");
      if (a.child !== null) {
        var p = a.child, S = Up(p, p.pendingProps);
        for (a.child = S, S.return = a; p.sibling !== null; )
          p = p.sibling, S = S.sibling = Up(p, p.pendingProps), S.return = a;
        S.sibling = null;
      }
    }
    function AZ(o, a) {
      for (var p = o.child; p !== null; )
        See(p, a), p = p.sibling;
    }
    var aT = Nf(null), lT;
    lT = {};
    var P0 = null, Fm = null, cT = null, T0 = !1;
    function I0() {
      P0 = null, Fm = null, cT = null, T0 = !1;
    }
    function S2() {
      T0 = !0;
    }
    function x2() {
      T0 = !1;
    }
    function w2(o, a, p) {
      os(aT, a._currentValue, o), a._currentValue = p, a._currentRenderer !== void 0 && a._currentRenderer !== null && a._currentRenderer !== lT && c("Detected multiple renderers concurrently rendering the same context provider. This is currently unsupported."), a._currentRenderer = lT;
    }
    function uT(o, a) {
      var p = aT.current;
      is(aT, a), o._currentValue = p;
    }
    function dT(o, a, p) {
      for (var S = o; S !== null; ) {
        var b = S.alternate;
        if (rd(S.childLanes, a) ? b !== null && !rd(b.childLanes, a) && (b.childLanes = nn(b.childLanes, a)) : (S.childLanes = nn(S.childLanes, a), b !== null && (b.childLanes = nn(b.childLanes, a))), S === p)
          break;
        S = S.return;
      }
      S !== p && c("Expected to find the propagation root when scheduling context work. This error is likely caused by a bug in React. Please file an issue.");
    }
    function DZ(o, a, p) {
      OZ(o, a, p);
    }
    function OZ(o, a, p) {
      var S = o.child;
      for (S !== null && (S.return = o); S !== null; ) {
        var b = void 0, T = S.dependencies;
        if (T !== null) {
          b = S.child;
          for (var D = T.firstContext; D !== null; ) {
            if (D.context === a) {
              if (S.tag === g) {
                var N = Ni(p), $ = Sd(ir, N);
                $.tag = R0;
                var G = S.updateQueue;
                if (G !== null) {
                  var X = G.shared, fe = X.pending;
                  fe === null ? $.next = $ : ($.next = fe.next, fe.next = $), X.pending = $;
                }
              }
              S.lanes = nn(S.lanes, p);
              var ue = S.alternate;
              ue !== null && (ue.lanes = nn(ue.lanes, p)), dT(S.return, p, o), T.lanes = nn(T.lanes, p);
              break;
            }
            D = D.next;
          }
        } else if (S.tag === L)
          b = S.type === o.type ? null : S.child;
        else if (S.tag === J) {
          var _e = S.return;
          if (_e === null)
            throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
          _e.lanes = nn(_e.lanes, p);
          var Ie = _e.alternate;
          Ie !== null && (Ie.lanes = nn(Ie.lanes, p)), dT(_e, p, o), b = S.sibling;
        } else
          b = S.child;
        if (b !== null)
          b.return = S;
        else
          for (b = S; b !== null; ) {
            if (b === o) {
              b = null;
              break;
            }
            var Me = b.sibling;
            if (Me !== null) {
              Me.return = b.return, b = Me;
              break;
            }
            b = b.return;
          }
        S = b;
      }
    }
    function zm(o, a) {
      P0 = o, Fm = null, cT = null;
      var p = o.dependencies;
      if (p !== null) {
        var S = p.firstContext;
        S !== null && (ts(p.lanes, a) && LS(), p.firstContext = null);
      }
    }
    function Ui(o) {
      T0 && c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      var a = o._currentValue;
      if (cT !== o) {
        var p = {
          context: o,
          memoizedValue: a,
          next: null
        };
        if (Fm === null) {
          if (P0 === null)
            throw new Error("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
          Fm = p, P0.dependencies = {
            lanes: je,
            firstContext: p
          };
        } else
          Fm = Fm.next = p;
      }
      return a;
    }
    var Ap = null;
    function fT(o) {
      Ap === null ? Ap = [o] : Ap.push(o);
    }
    function jZ() {
      if (Ap !== null) {
        for (var o = 0; o < Ap.length; o++) {
          var a = Ap[o], p = a.interleaved;
          if (p !== null) {
            a.interleaved = null;
            var S = p.next, b = a.pending;
            if (b !== null) {
              var T = b.next;
              b.next = S, p.next = T;
            }
            a.pending = p;
          }
        }
        Ap = null;
      }
    }
    function b2(o, a, p, S) {
      var b = a.interleaved;
      return b === null ? (p.next = p, fT(a)) : (p.next = b.next, b.next = p), a.interleaved = p, k0(o, S);
    }
    function LZ(o, a, p, S) {
      var b = a.interleaved;
      b === null ? (p.next = p, fT(a)) : (p.next = b.next, b.next = p), a.interleaved = p;
    }
    function NZ(o, a, p, S) {
      var b = a.interleaved;
      return b === null ? (p.next = p, fT(a)) : (p.next = b.next, b.next = p), a.interleaved = p, k0(o, S);
    }
    function la(o, a) {
      return k0(o, a);
    }
    var FZ = k0;
    function k0(o, a) {
      o.lanes = nn(o.lanes, a);
      var p = o.alternate;
      p !== null && (p.lanes = nn(p.lanes, a)), p === null && (o.flags & (ci | di)) !== Rt && v3(o);
      for (var S = o, b = o.return; b !== null; )
        b.childLanes = nn(b.childLanes, a), p = b.alternate, p !== null ? p.childLanes = nn(p.childLanes, a) : (b.flags & (ci | di)) !== Rt && v3(o), S = b, b = b.return;
      if (S.tag === v) {
        var T = S.stateNode;
        return T;
      } else
        return null;
    }
    var C2 = 0, E2 = 1, R0 = 2, hT = 3, M0 = !1, pT, A0;
    pT = !1, A0 = null;
    function gT(o) {
      var a = {
        baseState: o.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
          pending: null,
          interleaved: null,
          lanes: je
        },
        effects: null
      };
      o.updateQueue = a;
    }
    function _2(o, a) {
      var p = a.updateQueue, S = o.updateQueue;
      if (p === S) {
        var b = {
          baseState: S.baseState,
          firstBaseUpdate: S.firstBaseUpdate,
          lastBaseUpdate: S.lastBaseUpdate,
          shared: S.shared,
          effects: S.effects
        };
        a.updateQueue = b;
      }
    }
    function Sd(o, a) {
      var p = {
        eventTime: o,
        lane: a,
        tag: C2,
        payload: null,
        callback: null,
        next: null
      };
      return p;
    }
    function $f(o, a, p) {
      var S = o.updateQueue;
      if (S === null)
        return null;
      var b = S.shared;
      if (A0 === b && !pT && (c("An update (setState, replaceState, or forceUpdate) was scheduled from inside an update function. Update functions should be pure, with zero side-effects. Consider using componentDidUpdate or a callback."), pT = !0), LJ()) {
        var T = b.pending;
        return T === null ? a.next = a : (a.next = T.next, T.next = a), b.pending = a, FZ(o, p);
      } else
        return NZ(o, b, a, p);
    }
    function D0(o, a, p) {
      var S = a.updateQueue;
      if (S !== null) {
        var b = S.shared;
        if (jv(p)) {
          var T = b.lanes;
          T = rm(T, o.pendingLanes);
          var D = nn(T, p);
          b.lanes = D, up(o, D);
        }
      }
    }
    function mT(o, a) {
      var p = o.updateQueue, S = o.alternate;
      if (S !== null) {
        var b = S.updateQueue;
        if (p === b) {
          var T = null, D = null, N = p.firstBaseUpdate;
          if (N !== null) {
            var $ = N;
            do {
              var G = {
                eventTime: $.eventTime,
                lane: $.lane,
                tag: $.tag,
                payload: $.payload,
                callback: $.callback,
                next: null
              };
              D === null ? T = D = G : (D.next = G, D = G), $ = $.next;
            } while ($ !== null);
            D === null ? T = D = a : (D.next = a, D = a);
          } else
            T = D = a;
          p = {
            baseState: b.baseState,
            firstBaseUpdate: T,
            lastBaseUpdate: D,
            shared: b.shared,
            effects: b.effects
          }, o.updateQueue = p;
          return;
        }
      }
      var X = p.lastBaseUpdate;
      X === null ? p.firstBaseUpdate = a : X.next = a, p.lastBaseUpdate = a;
    }
    function zZ(o, a, p, S, b, T) {
      switch (p.tag) {
        case E2: {
          var D = p.payload;
          if (typeof D == "function") {
            S2();
            var N = D.call(T, S, b);
            {
              if (o.mode & Jt) {
                rr(!0);
                try {
                  D.call(T, S, b);
                } finally {
                  rr(!1);
                }
              }
              x2();
            }
            return N;
          }
          return D;
        }
        case hT:
          o.flags = o.flags & -65537 | hn;
        // Intentional fallthrough
        case C2: {
          var $ = p.payload, G;
          if (typeof $ == "function") {
            S2(), G = $.call(T, S, b);
            {
              if (o.mode & Jt) {
                rr(!0);
                try {
                  $.call(T, S, b);
                } finally {
                  rr(!1);
                }
              }
              x2();
            }
          } else
            G = $;
          return G == null ? S : Gt({}, S, G);
        }
        case R0:
          return M0 = !0, S;
      }
      return S;
    }
    function O0(o, a, p, S) {
      var b = o.updateQueue;
      M0 = !1, A0 = b.shared;
      var T = b.firstBaseUpdate, D = b.lastBaseUpdate, N = b.shared.pending;
      if (N !== null) {
        b.shared.pending = null;
        var $ = N, G = $.next;
        $.next = null, D === null ? T = G : D.next = G, D = $;
        var X = o.alternate;
        if (X !== null) {
          var fe = X.updateQueue, ue = fe.lastBaseUpdate;
          ue !== D && (ue === null ? fe.firstBaseUpdate = G : ue.next = G, fe.lastBaseUpdate = $);
        }
      }
      if (T !== null) {
        var _e = b.baseState, Ie = je, Me = null, st = null, Dt = null, Tt = T;
        do {
          var Dn = Tt.lane, En = Tt.eventTime;
          if (rd(S, Dn)) {
            if (Dt !== null) {
              var Ae = {
                eventTime: En,
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: hi,
                tag: Tt.tag,
                payload: Tt.payload,
                callback: Tt.callback,
                next: null
              };
              Dt = Dt.next = Ae;
            }
            _e = zZ(o, b, Tt, _e, a, p);
            var we = Tt.callback;
            if (we !== null && // If the update was already committed, we should not queue its
            // callback again.
            Tt.lane !== hi) {
              o.flags |= gr;
              var Ge = b.effects;
              Ge === null ? b.effects = [Tt] : Ge.push(Tt);
            }
          } else {
            var xe = {
              eventTime: En,
              lane: Dn,
              tag: Tt.tag,
              payload: Tt.payload,
              callback: Tt.callback,
              next: null
            };
            Dt === null ? (st = Dt = xe, Me = _e) : Dt = Dt.next = xe, Ie = nn(Ie, Dn);
          }
          if (Tt = Tt.next, Tt === null) {
            if (N = b.shared.pending, N === null)
              break;
            var pt = N, ut = pt.next;
            pt.next = null, Tt = ut, b.lastBaseUpdate = pt, b.shared.pending = null;
          }
        } while (!0);
        Dt === null && (Me = _e), b.baseState = Me, b.firstBaseUpdate = st, b.lastBaseUpdate = Dt;
        var $t = b.shared.interleaved;
        if ($t !== null) {
          var Xt = $t;
          do
            Ie = nn(Ie, Xt.lane), Xt = Xt.next;
          while (Xt !== $t);
        } else T === null && (b.shared.lanes = je);
        qS(Ie), o.lanes = Ie, o.memoizedState = _e;
      }
      A0 = null;
    }
    function UZ(o, a) {
      if (typeof o != "function")
        throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + o));
      o.call(a);
    }
    function P2() {
      M0 = !1;
    }
    function j0() {
      return M0;
    }
    function T2(o, a, p) {
      var S = a.effects;
      if (a.effects = null, S !== null)
        for (var b = 0; b < S.length; b++) {
          var T = S[b], D = T.callback;
          D !== null && (T.callback = null, UZ(D, p));
        }
    }
    var bS = {}, Bf = Nf(bS), CS = Nf(bS), L0 = Nf(bS);
    function N0(o) {
      if (o === bS)
        throw new Error("Expected host context to exist. This error is likely caused by a bug in React. Please file an issue.");
      return o;
    }
    function I2() {
      var o = N0(L0.current);
      return o;
    }
    function yT(o, a) {
      os(L0, a, o), os(CS, o, o), os(Bf, bS, o);
      var p = rX(a);
      is(Bf, o), os(Bf, p, o);
    }
    function Um(o) {
      is(Bf, o), is(CS, o), is(L0, o);
    }
    function vT() {
      var o = N0(Bf.current);
      return o;
    }
    function k2(o) {
      N0(L0.current);
      var a = N0(Bf.current), p = iX(a, o.type);
      a !== p && (os(CS, o, o), os(Bf, p, o));
    }
    function ST(o) {
      CS.current === o && (is(Bf, o), is(CS, o));
    }
    var $Z = 0, R2 = 1, M2 = 1, ES = 2, sc = Nf($Z);
    function xT(o, a) {
      return (o & a) !== 0;
    }
    function $m(o) {
      return o & R2;
    }
    function wT(o, a) {
      return o & R2 | a;
    }
    function BZ(o, a) {
      return o | a;
    }
    function Hf(o, a) {
      os(sc, a, o);
    }
    function Bm(o) {
      is(sc, o);
    }
    function HZ(o, a) {
      var p = o.memoizedState;
      return p !== null ? p.dehydrated !== null : (o.memoizedProps, !0);
    }
    function F0(o) {
      for (var a = o; a !== null; ) {
        if (a.tag === F) {
          var p = a.memoizedState;
          if (p !== null) {
            var S = p.dehydrated;
            if (S === null || qL(S) || zP(S))
              return a;
          }
        } else if (a.tag === ie && // revealOrder undefined can't be trusted because it don't
        // keep track of whether it suspended or not.
        a.memoizedProps.revealOrder !== void 0) {
          var b = (a.flags & hn) !== Rt;
          if (b)
            return a;
        } else if (a.child !== null) {
          a.child.return = a, a = a.child;
          continue;
        }
        if (a === o)
          return null;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === o)
            return null;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return null;
    }
    var ca = (
      /*   */
      0
    ), Yi = (
      /* */
      1
    ), ou = (
      /*  */
      2
    ), Xi = (
      /*    */
      4
    ), Po = (
      /*   */
      8
    ), bT = [];
    function CT() {
      for (var o = 0; o < bT.length; o++) {
        var a = bT[o];
        a._workInProgressVersionPrimary = null;
      }
      bT.length = 0;
    }
    function VZ(o, a) {
      var p = a._getVersion, S = p(a._source);
      o.mutableSourceEagerHydrationData == null ? o.mutableSourceEagerHydrationData = [a, S] : o.mutableSourceEagerHydrationData.push(a, S);
    }
    var ft = r.ReactCurrentDispatcher, _S = r.ReactCurrentBatchConfig, ET, Hm;
    ET = /* @__PURE__ */ new Set();
    var Dp = je, dr = null, Zi = null, Qi = null, z0 = !1, PS = !1, TS = 0, KZ = 0, WZ = 25, Ne = null, bl = null, Vf = -1, _T = !1;
    function er() {
      {
        var o = Ne;
        bl === null ? bl = [o] : bl.push(o);
      }
    }
    function et() {
      {
        var o = Ne;
        bl !== null && (Vf++, bl[Vf] !== o && GZ(o));
      }
    }
    function Vm(o) {
      o != null && !tn(o) && c("%s received a final argument that is not an array (instead, received `%s`). When specified, the final argument must be an array.", Ne, typeof o);
    }
    function GZ(o) {
      {
        var a = Ut(dr);
        if (!ET.has(a) && (ET.add(a), bl !== null)) {
          for (var p = "", S = 30, b = 0; b <= Vf; b++) {
            for (var T = bl[b], D = b === Vf ? o : T, N = b + 1 + ". " + T; N.length < S; )
              N += " ";
            N += D + `
`, p += N;
          }
          c(`React has detected a change in the order of Hooks called by %s. This will lead to bugs and errors if not fixed. For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

   Previous render            Next render
   ------------------------------------------------------
%s   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, a, p);
        }
      }
    }
    function ss() {
      throw new Error(`Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for one of the following reasons:
1. You might have mismatching versions of React and the renderer (such as React DOM)
2. You might be breaking the Rules of Hooks
3. You might have more than one copy of React in the same app
See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.`);
    }
    function PT(o, a) {
      if (_T)
        return !1;
      if (a === null)
        return c("%s received a final argument during this render, but not during the previous render. Even though the final argument is optional, its type cannot change between renders.", Ne), !1;
      o.length !== a.length && c(`The final argument passed to %s changed size between renders. The order and size of this array must remain constant.

Previous: %s
Incoming: %s`, Ne, "[" + a.join(", ") + "]", "[" + o.join(", ") + "]");
      for (var p = 0; p < a.length && p < o.length; p++)
        if (!xt(o[p], a[p]))
          return !1;
      return !0;
    }
    function Km(o, a, p, S, b, T) {
      Dp = T, dr = a, bl = o !== null ? o._debugHookTypes : null, Vf = -1, _T = o !== null && o.type !== a.type, a.memoizedState = null, a.updateQueue = null, a.lanes = je, o !== null && o.memoizedState !== null ? ft.current = J2 : bl !== null ? ft.current = Q2 : ft.current = Z2;
      var D = p(S, b);
      if (PS) {
        var N = 0;
        do {
          if (PS = !1, TS = 0, N >= WZ)
            throw new Error("Too many re-renders. React limits the number of renders to prevent an infinite loop.");
          N += 1, _T = !1, Zi = null, Qi = null, a.updateQueue = null, Vf = -1, ft.current = eN, D = p(S, b);
        } while (PS);
      }
      ft.current = Q0, a._debugHookTypes = bl;
      var $ = Zi !== null && Zi.next !== null;
      if (Dp = je, dr = null, Zi = null, Qi = null, Ne = null, bl = null, Vf = -1, o !== null && (o.flags & fi) !== (a.flags & fi) && // Disable this warning in legacy mode, because legacy Suspense is weird
      // and creates false positives. To make this work in legacy mode, we'd
      // need to mark fibers that commit in an incomplete state, somehow. For
      // now I'll disable the warning that most of the bugs that would trigger
      // it are either exclusive to concurrent mode or exist in both.
      (o.mode & pn) !== Mt && c("Internal React error: Expected static flag was missing. Please notify the React team."), z0 = !1, $)
        throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental early return statement.");
      return D;
    }
    function Wm() {
      var o = TS !== 0;
      return TS = 0, o;
    }
    function A2(o, a, p) {
      a.updateQueue = o.updateQueue, (a.mode & ur) !== Mt ? a.flags &= -50333701 : a.flags &= -2053, o.lanes = cp(o.lanes, p);
    }
    function D2() {
      if (ft.current = Q0, z0) {
        for (var o = dr.memoizedState; o !== null; ) {
          var a = o.queue;
          a !== null && (a.pending = null), o = o.next;
        }
        z0 = !1;
      }
      Dp = je, dr = null, Zi = null, Qi = null, bl = null, Vf = -1, Ne = null, W2 = !1, PS = !1, TS = 0;
    }
    function su() {
      var o = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
      };
      return Qi === null ? dr.memoizedState = Qi = o : Qi = Qi.next = o, Qi;
    }
    function Cl() {
      var o;
      if (Zi === null) {
        var a = dr.alternate;
        a !== null ? o = a.memoizedState : o = null;
      } else
        o = Zi.next;
      var p;
      if (Qi === null ? p = dr.memoizedState : p = Qi.next, p !== null)
        Qi = p, p = Qi.next, Zi = o;
      else {
        if (o === null)
          throw new Error("Rendered more hooks than during the previous render.");
        Zi = o;
        var S = {
          memoizedState: Zi.memoizedState,
          baseState: Zi.baseState,
          baseQueue: Zi.baseQueue,
          queue: Zi.queue,
          next: null
        };
        Qi === null ? dr.memoizedState = Qi = S : Qi = Qi.next = S;
      }
      return Qi;
    }
    function O2() {
      return {
        lastEffect: null,
        stores: null
      };
    }
    function TT(o, a) {
      return typeof a == "function" ? a(o) : a;
    }
    function IT(o, a, p) {
      var S = su(), b;
      p !== void 0 ? b = p(a) : b = a, S.memoizedState = S.baseState = b;
      var T = {
        pending: null,
        interleaved: null,
        lanes: je,
        dispatch: null,
        lastRenderedReducer: o,
        lastRenderedState: b
      };
      S.queue = T;
      var D = T.dispatch = ZZ.bind(null, dr, T);
      return [S.memoizedState, D];
    }
    function kT(o, a, p) {
      var S = Cl(), b = S.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = o;
      var T = Zi, D = T.baseQueue, N = b.pending;
      if (N !== null) {
        if (D !== null) {
          var $ = D.next, G = N.next;
          D.next = G, N.next = $;
        }
        T.baseQueue !== D && c("Internal error: Expected work-in-progress queue to be a clone. This is a bug in React."), T.baseQueue = D = N, b.pending = null;
      }
      if (D !== null) {
        var X = D.next, fe = T.baseState, ue = null, _e = null, Ie = null, Me = X;
        do {
          var st = Me.lane;
          if (rd(Dp, st)) {
            if (Ie !== null) {
              var Tt = {
                // This update is going to be committed so we never want uncommit
                // it. Using NoLane works because 0 is a subset of all bitmasks, so
                // this will never be skipped by the check above.
                lane: hi,
                action: Me.action,
                hasEagerState: Me.hasEagerState,
                eagerState: Me.eagerState,
                next: null
              };
              Ie = Ie.next = Tt;
            }
            if (Me.hasEagerState)
              fe = Me.eagerState;
            else {
              var Dn = Me.action;
              fe = o(fe, Dn);
            }
          } else {
            var Dt = {
              lane: st,
              action: Me.action,
              hasEagerState: Me.hasEagerState,
              eagerState: Me.eagerState,
              next: null
            };
            Ie === null ? (_e = Ie = Dt, ue = fe) : Ie = Ie.next = Dt, dr.lanes = nn(dr.lanes, st), qS(st);
          }
          Me = Me.next;
        } while (Me !== null && Me !== X);
        Ie === null ? ue = fe : Ie.next = _e, xt(fe, S.memoizedState) || LS(), S.memoizedState = fe, S.baseState = ue, S.baseQueue = Ie, b.lastRenderedState = fe;
      }
      var En = b.interleaved;
      if (En !== null) {
        var xe = En;
        do {
          var Ae = xe.lane;
          dr.lanes = nn(dr.lanes, Ae), qS(Ae), xe = xe.next;
        } while (xe !== En);
      } else D === null && (b.lanes = je);
      var we = b.dispatch;
      return [S.memoizedState, we];
    }
    function RT(o, a, p) {
      var S = Cl(), b = S.queue;
      if (b === null)
        throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
      b.lastRenderedReducer = o;
      var T = b.dispatch, D = b.pending, N = S.memoizedState;
      if (D !== null) {
        b.pending = null;
        var $ = D.next, G = $;
        do {
          var X = G.action;
          N = o(N, X), G = G.next;
        } while (G !== $);
        xt(N, S.memoizedState) || LS(), S.memoizedState = N, S.baseQueue === null && (S.baseState = N), b.lastRenderedState = N;
      }
      return [N, T];
    }
    function sEe(o, a, p) {
    }
    function aEe(o, a, p) {
    }
    function MT(o, a, p) {
      var S = dr, b = su(), T, D = _o();
      if (D) {
        if (p === void 0)
          throw new Error("Missing getServerSnapshot, which is required for server-rendered content. Will revert to client rendering.");
        T = p(), Hm || T !== p() && (c("The result of getServerSnapshot should be cached to avoid an infinite loop"), Hm = !0);
      } else {
        if (T = a(), !Hm) {
          var N = a();
          xt(T, N) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), Hm = !0);
        }
        var $ = y1();
        if ($ === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        lp($, Dp) || j2(S, a, T);
      }
      b.memoizedState = T;
      var G = {
        value: T,
        getSnapshot: a
      };
      return b.queue = G, V0(N2.bind(null, S, G, o), [o]), S.flags |= Rs, IS(Yi | Po, L2.bind(null, S, G, T, a), void 0, null), T;
    }
    function U0(o, a, p) {
      var S = dr, b = Cl(), T = a();
      if (!Hm) {
        var D = a();
        xt(T, D) || (c("The result of getSnapshot should be cached to avoid an infinite loop"), Hm = !0);
      }
      var N = b.memoizedState, $ = !xt(N, T);
      $ && (b.memoizedState = T, LS());
      var G = b.queue;
      if (RS(N2.bind(null, S, G, o), [o]), G.getSnapshot !== a || $ || // Check if the susbcribe function changed. We can save some memory by
      // checking whether we scheduled a subscription effect above.
      Qi !== null && Qi.memoizedState.tag & Yi) {
        S.flags |= Rs, IS(Yi | Po, L2.bind(null, S, G, T, a), void 0, null);
        var X = y1();
        if (X === null)
          throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
        lp(X, Dp) || j2(S, a, T);
      }
      return T;
    }
    function j2(o, a, p) {
      o.flags |= Mg;
      var S = {
        getSnapshot: a,
        value: p
      }, b = dr.updateQueue;
      if (b === null)
        b = O2(), dr.updateQueue = b, b.stores = [S];
      else {
        var T = b.stores;
        T === null ? b.stores = [S] : T.push(S);
      }
    }
    function L2(o, a, p, S) {
      a.value = p, a.getSnapshot = S, F2(a) && z2(o);
    }
    function N2(o, a, p) {
      var S = function() {
        F2(a) && z2(o);
      };
      return p(S);
    }
    function F2(o) {
      var a = o.getSnapshot, p = o.value;
      try {
        var S = a();
        return !xt(p, S);
      } catch {
        return !0;
      }
    }
    function z2(o) {
      var a = la(o, Nt);
      a !== null && no(a, o, Nt, ir);
    }
    function $0(o) {
      var a = su();
      typeof o == "function" && (o = o()), a.memoizedState = a.baseState = o;
      var p = {
        pending: null,
        interleaved: null,
        lanes: je,
        dispatch: null,
        lastRenderedReducer: TT,
        lastRenderedState: o
      };
      a.queue = p;
      var S = p.dispatch = QZ.bind(null, dr, p);
      return [a.memoizedState, S];
    }
    function AT(o) {
      return kT(TT);
    }
    function DT(o) {
      return RT(TT);
    }
    function IS(o, a, p, S) {
      var b = {
        tag: o,
        create: a,
        destroy: p,
        deps: S,
        // Circular
        next: null
      }, T = dr.updateQueue;
      if (T === null)
        T = O2(), dr.updateQueue = T, T.lastEffect = b.next = b;
      else {
        var D = T.lastEffect;
        if (D === null)
          T.lastEffect = b.next = b;
        else {
          var N = D.next;
          D.next = b, b.next = N, T.lastEffect = b;
        }
      }
      return b;
    }
    function OT(o) {
      var a = su();
      {
        var p = {
          current: o
        };
        return a.memoizedState = p, p;
      }
    }
    function B0(o) {
      var a = Cl();
      return a.memoizedState;
    }
    function kS(o, a, p, S) {
      var b = su(), T = S === void 0 ? null : S;
      dr.flags |= o, b.memoizedState = IS(Yi | a, p, void 0, T);
    }
    function H0(o, a, p, S) {
      var b = Cl(), T = S === void 0 ? null : S, D = void 0;
      if (Zi !== null) {
        var N = Zi.memoizedState;
        if (D = N.destroy, T !== null) {
          var $ = N.deps;
          if (PT(T, $)) {
            b.memoizedState = IS(a, p, D, T);
            return;
          }
        }
      }
      dr.flags |= o, b.memoizedState = IS(Yi | a, p, D, T);
    }
    function V0(o, a) {
      return (dr.mode & ur) !== Mt ? kS(Uc | Rs | gv, Po, o, a) : kS(Rs | gv, Po, o, a);
    }
    function RS(o, a) {
      return H0(Rs, Po, o, a);
    }
    function jT(o, a) {
      return kS(Sn, ou, o, a);
    }
    function K0(o, a) {
      return H0(Sn, ou, o, a);
    }
    function LT(o, a) {
      var p = Sn;
      return p |= zc, (dr.mode & ur) !== Mt && (p |= wo), kS(p, Xi, o, a);
    }
    function W0(o, a) {
      return H0(Sn, Xi, o, a);
    }
    function U2(o, a) {
      if (typeof a == "function") {
        var p = a, S = o();
        return p(S), function() {
          p(null);
        };
      } else if (a != null) {
        var b = a;
        b.hasOwnProperty("current") || c("Expected useImperativeHandle() first argument to either be a ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(b).join(", ") + "}");
        var T = o();
        return b.current = T, function() {
          b.current = null;
        };
      }
    }
    function NT(o, a, p) {
      typeof a != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var S = p != null ? p.concat([o]) : null, b = Sn;
      return b |= zc, (dr.mode & ur) !== Mt && (b |= wo), kS(b, Xi, U2.bind(null, a, o), S);
    }
    function G0(o, a, p) {
      typeof a != "function" && c("Expected useImperativeHandle() second argument to be a function that creates a handle. Instead received: %s.", a !== null ? typeof a : "null");
      var S = p != null ? p.concat([o]) : null;
      return H0(Sn, Xi, U2.bind(null, a, o), S);
    }
    function qZ(o, a) {
    }
    var q0 = qZ;
    function FT(o, a) {
      var p = su(), S = a === void 0 ? null : a;
      return p.memoizedState = [o, S], o;
    }
    function Y0(o, a) {
      var p = Cl(), S = a === void 0 ? null : a, b = p.memoizedState;
      if (b !== null && S !== null) {
        var T = b[1];
        if (PT(S, T))
          return b[0];
      }
      return p.memoizedState = [o, S], o;
    }
    function zT(o, a) {
      var p = su(), S = a === void 0 ? null : a, b = o();
      return p.memoizedState = [b, S], b;
    }
    function X0(o, a) {
      var p = Cl(), S = a === void 0 ? null : a, b = p.memoizedState;
      if (b !== null && S !== null) {
        var T = b[1];
        if (PT(S, T))
          return b[0];
      }
      var D = o();
      return p.memoizedState = [D, S], D;
    }
    function UT(o) {
      var a = su();
      return a.memoizedState = o, o;
    }
    function $2(o) {
      var a = Cl(), p = Zi, S = p.memoizedState;
      return H2(a, S, o);
    }
    function B2(o) {
      var a = Cl();
      if (Zi === null)
        return a.memoizedState = o, o;
      var p = Zi.memoizedState;
      return H2(a, p, o);
    }
    function H2(o, a, p) {
      var S = !Ov(Dp);
      if (S) {
        if (!xt(p, a)) {
          var b = Lv();
          dr.lanes = nn(dr.lanes, b), qS(b), o.baseState = !0;
        }
        return a;
      } else
        return o.baseState && (o.baseState = !1, LS()), o.memoizedState = p, p;
    }
    function YZ(o, a, p) {
      var S = Ds();
      xi(dp(S, ra)), o(!0);
      var b = _S.transition;
      _S.transition = {};
      var T = _S.transition;
      _S.transition._updatedFibers = /* @__PURE__ */ new Set();
      try {
        o(!1), a();
      } finally {
        if (xi(S), _S.transition = b, b === null && T._updatedFibers) {
          var D = T._updatedFibers.size;
          D > 10 && l("Detected a large number of updates inside startTransition. If this is due to a subscription please re-write it to use React provided hooks. Otherwise concurrent mode guarantees are off the table."), T._updatedFibers.clear();
        }
      }
    }
    function $T() {
      var o = $0(!1), a = o[0], p = o[1], S = YZ.bind(null, p), b = su();
      return b.memoizedState = S, [a, S];
    }
    function V2() {
      var o = AT(), a = o[0], p = Cl(), S = p.memoizedState;
      return [a, S];
    }
    function K2() {
      var o = DT(), a = o[0], p = Cl(), S = p.memoizedState;
      return [a, S];
    }
    var W2 = !1;
    function XZ() {
      return W2;
    }
    function BT() {
      var o = su(), a = y1(), p = a.identifierPrefix, S;
      if (_o()) {
        var b = hZ();
        S = ":" + p + "R" + b;
        var T = TS++;
        T > 0 && (S += "H" + T.toString(32)), S += ":";
      } else {
        var D = KZ++;
        S = ":" + p + "r" + D.toString(32) + ":";
      }
      return o.memoizedState = S, S;
    }
    function Z0() {
      var o = Cl(), a = o.memoizedState;
      return a;
    }
    function ZZ(o, a, p) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = Yf(o), b = {
        lane: S,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (G2(o))
        q2(a, b);
      else {
        var T = b2(o, a, b, S);
        if (T !== null) {
          var D = zs();
          no(T, o, S, D), Y2(T, a, S);
        }
      }
      X2(o, S);
    }
    function QZ(o, a, p) {
      typeof arguments[3] == "function" && c("State updates from the useState() and useReducer() Hooks don't support the second callback argument. To execute a side effect after rendering, declare it in the component body with useEffect().");
      var S = Yf(o), b = {
        lane: S,
        action: p,
        hasEagerState: !1,
        eagerState: null,
        next: null
      };
      if (G2(o))
        q2(a, b);
      else {
        var T = o.alternate;
        if (o.lanes === je && (T === null || T.lanes === je)) {
          var D = a.lastRenderedReducer;
          if (D !== null) {
            var N;
            N = ft.current, ft.current = ac;
            try {
              var $ = a.lastRenderedState, G = D($, p);
              if (b.hasEagerState = !0, b.eagerState = G, xt(G, $)) {
                LZ(o, a, b, S);
                return;
              }
            } catch {
            } finally {
              ft.current = N;
            }
          }
        }
        var X = b2(o, a, b, S);
        if (X !== null) {
          var fe = zs();
          no(X, o, S, fe), Y2(X, a, S);
        }
      }
      X2(o, S);
    }
    function G2(o) {
      var a = o.alternate;
      return o === dr || a !== null && a === dr;
    }
    function q2(o, a) {
      PS = z0 = !0;
      var p = o.pending;
      p === null ? a.next = a : (a.next = p.next, p.next = a), o.pending = a;
    }
    function Y2(o, a, p) {
      if (jv(p)) {
        var S = a.lanes;
        S = rm(S, o.pendingLanes);
        var b = nn(S, p);
        a.lanes = b, up(o, b);
      }
    }
    function X2(o, a, p) {
      ep(o, a);
    }
    var Q0 = {
      readContext: Ui,
      useCallback: ss,
      useContext: ss,
      useEffect: ss,
      useImperativeHandle: ss,
      useInsertionEffect: ss,
      useLayoutEffect: ss,
      useMemo: ss,
      useReducer: ss,
      useRef: ss,
      useState: ss,
      useDebugValue: ss,
      useDeferredValue: ss,
      useTransition: ss,
      useMutableSource: ss,
      useSyncExternalStore: ss,
      useId: ss,
      unstable_isNewReconciler: he
    }, Z2 = null, Q2 = null, J2 = null, eN = null, au = null, ac = null, J0 = null;
    {
      var HT = function() {
        c("Context can only be read while React is rendering. In classes, you can read it in the render method or getDerivedStateFromProps. In function components, you can read it directly in the function body, but not inside Hooks like useReducer() or useMemo().");
      }, qt = function() {
        c("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. You can only call Hooks at the top level of your React function. For more information, see https://reactjs.org/link/rules-of-hooks");
      };
      Z2 = {
        readContext: function(o) {
          return Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", er(), Vm(a), FT(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", er(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", er(), Vm(a), V0(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", er(), Vm(p), NT(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", er(), Vm(a), jT(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", er(), Vm(a), LT(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", er(), Vm(a);
          var p = ft.current;
          ft.current = au;
          try {
            return zT(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", er();
          var S = ft.current;
          ft.current = au;
          try {
            return IT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", er(), OT(o);
        },
        useState: function(o) {
          Ne = "useState", er();
          var a = ft.current;
          ft.current = au;
          try {
            return $0(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", er(), void 0;
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", er(), UT(o);
        },
        useTransition: function() {
          return Ne = "useTransition", er(), $T();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", er(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", er(), MT(o, a, p);
        },
        useId: function() {
          return Ne = "useId", er(), BT();
        },
        unstable_isNewReconciler: he
      }, Q2 = {
        readContext: function(o) {
          return Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", et(), FT(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", et(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", et(), V0(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", et(), NT(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", et(), jT(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", et(), LT(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", et();
          var p = ft.current;
          ft.current = au;
          try {
            return zT(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", et();
          var S = ft.current;
          ft.current = au;
          try {
            return IT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", et(), OT(o);
        },
        useState: function(o) {
          Ne = "useState", et();
          var a = ft.current;
          ft.current = au;
          try {
            return $0(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", et(), void 0;
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", et(), UT(o);
        },
        useTransition: function() {
          return Ne = "useTransition", et(), $T();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", et(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", et(), MT(o, a, p);
        },
        useId: function() {
          return Ne = "useId", et(), BT();
        },
        unstable_isNewReconciler: he
      }, J2 = {
        readContext: function(o) {
          return Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", et(), Y0(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", et(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", et(), RS(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", et(), G0(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", et(), K0(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", et(), W0(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", et();
          var p = ft.current;
          ft.current = ac;
          try {
            return X0(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", et();
          var S = ft.current;
          ft.current = ac;
          try {
            return kT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", et(), B0();
        },
        useState: function(o) {
          Ne = "useState", et();
          var a = ft.current;
          ft.current = ac;
          try {
            return AT(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", et(), q0();
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", et(), $2(o);
        },
        useTransition: function() {
          return Ne = "useTransition", et(), V2();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", et(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", et(), U0(o, a);
        },
        useId: function() {
          return Ne = "useId", et(), Z0();
        },
        unstable_isNewReconciler: he
      }, eN = {
        readContext: function(o) {
          return Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", et(), Y0(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", et(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", et(), RS(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", et(), G0(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", et(), K0(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", et(), W0(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", et();
          var p = ft.current;
          ft.current = J0;
          try {
            return X0(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", et();
          var S = ft.current;
          ft.current = J0;
          try {
            return RT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", et(), B0();
        },
        useState: function(o) {
          Ne = "useState", et();
          var a = ft.current;
          ft.current = J0;
          try {
            return DT(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", et(), q0();
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", et(), B2(o);
        },
        useTransition: function() {
          return Ne = "useTransition", et(), K2();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", et(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", et(), U0(o, a);
        },
        useId: function() {
          return Ne = "useId", et(), Z0();
        },
        unstable_isNewReconciler: he
      }, au = {
        readContext: function(o) {
          return HT(), Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", qt(), er(), FT(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", qt(), er(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", qt(), er(), V0(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", qt(), er(), NT(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", qt(), er(), jT(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", qt(), er(), LT(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", qt(), er();
          var p = ft.current;
          ft.current = au;
          try {
            return zT(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", qt(), er();
          var S = ft.current;
          ft.current = au;
          try {
            return IT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", qt(), er(), OT(o);
        },
        useState: function(o) {
          Ne = "useState", qt(), er();
          var a = ft.current;
          ft.current = au;
          try {
            return $0(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", qt(), er(), void 0;
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", qt(), er(), UT(o);
        },
        useTransition: function() {
          return Ne = "useTransition", qt(), er(), $T();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", qt(), er(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", qt(), er(), MT(o, a, p);
        },
        useId: function() {
          return Ne = "useId", qt(), er(), BT();
        },
        unstable_isNewReconciler: he
      }, ac = {
        readContext: function(o) {
          return HT(), Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", qt(), et(), Y0(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", qt(), et(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", qt(), et(), RS(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", qt(), et(), G0(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", qt(), et(), K0(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", qt(), et(), W0(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", qt(), et();
          var p = ft.current;
          ft.current = ac;
          try {
            return X0(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", qt(), et();
          var S = ft.current;
          ft.current = ac;
          try {
            return kT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", qt(), et(), B0();
        },
        useState: function(o) {
          Ne = "useState", qt(), et();
          var a = ft.current;
          ft.current = ac;
          try {
            return AT(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", qt(), et(), q0();
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", qt(), et(), $2(o);
        },
        useTransition: function() {
          return Ne = "useTransition", qt(), et(), V2();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", qt(), et(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", qt(), et(), U0(o, a);
        },
        useId: function() {
          return Ne = "useId", qt(), et(), Z0();
        },
        unstable_isNewReconciler: he
      }, J0 = {
        readContext: function(o) {
          return HT(), Ui(o);
        },
        useCallback: function(o, a) {
          return Ne = "useCallback", qt(), et(), Y0(o, a);
        },
        useContext: function(o) {
          return Ne = "useContext", qt(), et(), Ui(o);
        },
        useEffect: function(o, a) {
          return Ne = "useEffect", qt(), et(), RS(o, a);
        },
        useImperativeHandle: function(o, a, p) {
          return Ne = "useImperativeHandle", qt(), et(), G0(o, a, p);
        },
        useInsertionEffect: function(o, a) {
          return Ne = "useInsertionEffect", qt(), et(), K0(o, a);
        },
        useLayoutEffect: function(o, a) {
          return Ne = "useLayoutEffect", qt(), et(), W0(o, a);
        },
        useMemo: function(o, a) {
          Ne = "useMemo", qt(), et();
          var p = ft.current;
          ft.current = ac;
          try {
            return X0(o, a);
          } finally {
            ft.current = p;
          }
        },
        useReducer: function(o, a, p) {
          Ne = "useReducer", qt(), et();
          var S = ft.current;
          ft.current = ac;
          try {
            return RT(o, a, p);
          } finally {
            ft.current = S;
          }
        },
        useRef: function(o) {
          return Ne = "useRef", qt(), et(), B0();
        },
        useState: function(o) {
          Ne = "useState", qt(), et();
          var a = ft.current;
          ft.current = ac;
          try {
            return DT(o);
          } finally {
            ft.current = a;
          }
        },
        useDebugValue: function(o, a) {
          return Ne = "useDebugValue", qt(), et(), q0();
        },
        useDeferredValue: function(o) {
          return Ne = "useDeferredValue", qt(), et(), B2(o);
        },
        useTransition: function() {
          return Ne = "useTransition", qt(), et(), K2();
        },
        useMutableSource: function(o, a, p) {
          return Ne = "useMutableSource", qt(), et(), void 0;
        },
        useSyncExternalStore: function(o, a, p) {
          return Ne = "useSyncExternalStore", qt(), et(), U0(o, a);
        },
        useId: function() {
          return Ne = "useId", qt(), et(), Z0();
        },
        unstable_isNewReconciler: he
      };
    }
    var Kf = t.unstable_now, tN = 0, e1 = -1, MS = -1, t1 = -1, VT = !1, n1 = !1;
    function nN() {
      return VT;
    }
    function JZ() {
      n1 = !0;
    }
    function eQ() {
      VT = !1, n1 = !1;
    }
    function tQ() {
      VT = n1, n1 = !1;
    }
    function rN() {
      return tN;
    }
    function iN() {
      tN = Kf();
    }
    function KT(o) {
      MS = Kf(), o.actualStartTime < 0 && (o.actualStartTime = Kf());
    }
    function oN(o) {
      MS = -1;
    }
    function r1(o, a) {
      if (MS >= 0) {
        var p = Kf() - MS;
        o.actualDuration += p, a && (o.selfBaseDuration = p), MS = -1;
      }
    }
    function lu(o) {
      if (e1 >= 0) {
        var a = Kf() - e1;
        e1 = -1;
        for (var p = o.return; p !== null; ) {
          switch (p.tag) {
            case v:
              var S = p.stateNode;
              S.effectDuration += a;
              return;
            case z:
              var b = p.stateNode;
              b.effectDuration += a;
              return;
          }
          p = p.return;
        }
      }
    }
    function WT(o) {
      if (t1 >= 0) {
        var a = Kf() - t1;
        t1 = -1;
        for (var p = o.return; p !== null; ) {
          switch (p.tag) {
            case v:
              var S = p.stateNode;
              S !== null && (S.passiveEffectDuration += a);
              return;
            case z:
              var b = p.stateNode;
              b !== null && (b.passiveEffectDuration += a);
              return;
          }
          p = p.return;
        }
      }
    }
    function cu() {
      e1 = Kf();
    }
    function GT() {
      t1 = Kf();
    }
    function qT(o) {
      for (var a = o.child; a; )
        o.actualDuration += a.actualDuration, a = a.sibling;
    }
    function lc(o, a) {
      if (o && o.defaultProps) {
        var p = Gt({}, a), S = o.defaultProps;
        for (var b in S)
          p[b] === void 0 && (p[b] = S[b]);
        return p;
      }
      return a;
    }
    var YT = {}, XT, ZT, QT, JT, eI, sN, i1, tI, nI, rI, AS;
    {
      XT = /* @__PURE__ */ new Set(), ZT = /* @__PURE__ */ new Set(), QT = /* @__PURE__ */ new Set(), JT = /* @__PURE__ */ new Set(), tI = /* @__PURE__ */ new Set(), eI = /* @__PURE__ */ new Set(), nI = /* @__PURE__ */ new Set(), rI = /* @__PURE__ */ new Set(), AS = /* @__PURE__ */ new Set();
      var aN = /* @__PURE__ */ new Set();
      i1 = function(o, a) {
        if (!(o === null || typeof o == "function")) {
          var p = a + "_" + o;
          aN.has(p) || (aN.add(p), c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, o));
        }
      }, sN = function(o, a) {
        if (a === void 0) {
          var p = Cn(o) || "Component";
          eI.has(p) || (eI.add(p), c("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. You have returned undefined.", p));
        }
      }, Object.defineProperty(YT, "_processChildContext", {
        enumerable: !1,
        value: function() {
          throw new Error("_processChildContext is not available in React 16+. This likely means you have multiple copies of React and are attempting to nest a React 15 tree inside a React 16 tree using unstable_renderSubtreeIntoContainer, which isn't supported. Try to make sure you have only one copy of React (and ideally, switch to ReactDOM.createPortal).");
        }
      }), Object.freeze(YT);
    }
    function iI(o, a, p, S) {
      var b = o.memoizedState, T = p(S, b);
      {
        if (o.mode & Jt) {
          rr(!0);
          try {
            T = p(S, b);
          } finally {
            rr(!1);
          }
        }
        sN(a, T);
      }
      var D = T == null ? b : Gt({}, b, T);
      if (o.memoizedState = D, o.lanes === je) {
        var N = o.updateQueue;
        N.baseState = D;
      }
    }
    var oI = {
      isMounted: mv,
      enqueueSetState: function(o, a, p) {
        var S = hf(o), b = zs(), T = Yf(S), D = Sd(b, T);
        D.payload = a, p != null && (i1(p, "setState"), D.callback = p);
        var N = $f(S, D, T);
        N !== null && (no(N, S, T, b), D0(N, S, T)), ep(S, T);
      },
      enqueueReplaceState: function(o, a, p) {
        var S = hf(o), b = zs(), T = Yf(S), D = Sd(b, T);
        D.tag = E2, D.payload = a, p != null && (i1(p, "replaceState"), D.callback = p);
        var N = $f(S, D, T);
        N !== null && (no(N, S, T, b), D0(N, S, T)), ep(S, T);
      },
      enqueueForceUpdate: function(o, a) {
        var p = hf(o), S = zs(), b = Yf(p), T = Sd(S, b);
        T.tag = R0, a != null && (i1(a, "forceUpdate"), T.callback = a);
        var D = $f(p, T, b);
        D !== null && (no(D, p, b, S), D0(D, p, b)), Rv(p, b);
      }
    };
    function lN(o, a, p, S, b, T, D) {
      var N = o.stateNode;
      if (typeof N.shouldComponentUpdate == "function") {
        var $ = N.shouldComponentUpdate(S, T, D);
        {
          if (o.mode & Jt) {
            rr(!0);
            try {
              $ = N.shouldComponentUpdate(S, T, D);
            } finally {
              rr(!1);
            }
          }
          $ === void 0 && c("%s.shouldComponentUpdate(): Returned undefined instead of a boolean value. Make sure to return true or false.", Cn(a) || "Component");
        }
        return $;
      }
      return a.prototype && a.prototype.isPureReactComponent ? !At(p, S) || !At(b, T) : !0;
    }
    function nQ(o, a, p) {
      var S = o.stateNode;
      {
        var b = Cn(a) || "Component", T = S.render;
        T || (a.prototype && typeof a.prototype.render == "function" ? c("%s(...): No `render` method found on the returned component instance: did you accidentally return an object from the constructor?", b) : c("%s(...): No `render` method found on the returned component instance: you may have forgotten to define `render`.", b)), S.getInitialState && !S.getInitialState.isReactClassApproved && !S.state && c("getInitialState was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Did you mean to define a state property instead?", b), S.getDefaultProps && !S.getDefaultProps.isReactClassApproved && c("getDefaultProps was defined on %s, a plain JavaScript class. This is only supported for classes created using React.createClass. Use a static property to define defaultProps instead.", b), S.propTypes && c("propTypes was defined as an instance property on %s. Use a static property to define propTypes instead.", b), S.contextType && c("contextType was defined as an instance property on %s. Use a static property to define contextType instead.", b), a.childContextTypes && !AS.has(a) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (o.mode & Jt) === Mt && (AS.add(a), c(`%s uses the legacy childContextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() instead

.Learn more about this warning here: https://reactjs.org/link/legacy-context`, b)), a.contextTypes && !AS.has(a) && // Strict Mode has its own warning for legacy context, so we can skip
        // this one.
        (o.mode & Jt) === Mt && (AS.add(a), c(`%s uses the legacy contextTypes API which is no longer supported and will be removed in the next major release. Use React.createContext() with static contextType instead.

Learn more about this warning here: https://reactjs.org/link/legacy-context`, b)), S.contextTypes && c("contextTypes was defined as an instance property on %s. Use a static property to define contextTypes instead.", b), a.contextType && a.contextTypes && !nI.has(a) && (nI.add(a), c("%s declares both contextTypes and contextType static properties. The legacy contextTypes property will be ignored.", b)), typeof S.componentShouldUpdate == "function" && c("%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.", b), a.prototype && a.prototype.isPureReactComponent && typeof S.shouldComponentUpdate < "u" && c("%s has a method called shouldComponentUpdate(). shouldComponentUpdate should not be used when extending React.PureComponent. Please extend React.Component if shouldComponentUpdate is used.", Cn(a) || "A pure component"), typeof S.componentDidUnmount == "function" && c("%s has a method called componentDidUnmount(). But there is no such lifecycle method. Did you mean componentWillUnmount()?", b), typeof S.componentDidReceiveProps == "function" && c("%s has a method called componentDidReceiveProps(). But there is no such lifecycle method. If you meant to update the state in response to changing props, use componentWillReceiveProps(). If you meant to fetch data or run side-effects or mutations after React has updated the UI, use componentDidUpdate().", b), typeof S.componentWillRecieveProps == "function" && c("%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", b), typeof S.UNSAFE_componentWillRecieveProps == "function" && c("%s has a method called UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", b);
        var D = S.props !== p;
        S.props !== void 0 && D && c("%s(...): When calling super() in `%s`, make sure to pass up the same props that your component's constructor was passed.", b, b), S.defaultProps && c("Setting defaultProps as an instance property on %s is not supported and will be ignored. Instead, define defaultProps as a static property on %s.", b, b), typeof S.getSnapshotBeforeUpdate == "function" && typeof S.componentDidUpdate != "function" && !QT.has(a) && (QT.add(a), c("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). This component defines getSnapshotBeforeUpdate() only.", Cn(a))), typeof S.getDerivedStateFromProps == "function" && c("%s: getDerivedStateFromProps() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof S.getDerivedStateFromError == "function" && c("%s: getDerivedStateFromError() is defined as an instance method and will be ignored. Instead, declare it as a static method.", b), typeof a.getSnapshotBeforeUpdate == "function" && c("%s: getSnapshotBeforeUpdate() is defined as a static method and will be ignored. Instead, declare it as an instance method.", b);
        var N = S.state;
        N && (typeof N != "object" || tn(N)) && c("%s.state: must be set to an object or null", b), typeof S.getChildContext == "function" && typeof a.childContextTypes != "object" && c("%s.getChildContext(): childContextTypes must be defined in order to use getChildContext().", b);
      }
    }
    function cN(o, a) {
      a.updater = oI, o.stateNode = a, Gh(a, o), a._reactInternalInstance = YT;
    }
    function uN(o, a, p) {
      var S = !1, b = Ha, T = Ha, D = a.contextType;
      if ("contextType" in a) {
        var N = (
          // Allow null for conditional declaration
          D === null || D !== void 0 && D.$$typeof === se && D._context === void 0
        );
        if (!N && !rI.has(a)) {
          rI.add(a);
          var $ = "";
          D === void 0 ? $ = " However, it is set to undefined. This can be caused by a typo or by mixing up named and default imports. This can also happen due to a circular dependency, so try moving the createContext() call to a separate file." : typeof D != "object" ? $ = " However, it is set to a " + typeof D + "." : D.$$typeof === Ma ? $ = " Did you accidentally pass the Context.Provider instead?" : D._context !== void 0 ? $ = " Did you accidentally pass the Context.Consumer instead?" : $ = " However, it is set to an object with keys {" + Object.keys(D).join(", ") + "}.", c("%s defines an invalid contextType. contextType should point to the Context object returned by React.createContext().%s", Cn(a) || "Component", $);
        }
      }
      if (typeof D == "object" && D !== null)
        T = Ui(D);
      else {
        b = Am(o, a, !0);
        var G = a.contextTypes;
        S = G != null, T = S ? Dm(o, b) : Ha;
      }
      var X = new a(p, T);
      if (o.mode & Jt) {
        rr(!0);
        try {
          X = new a(p, T);
        } finally {
          rr(!1);
        }
      }
      var fe = o.memoizedState = X.state !== null && X.state !== void 0 ? X.state : null;
      cN(o, X);
      {
        if (typeof a.getDerivedStateFromProps == "function" && fe === null) {
          var ue = Cn(a) || "Component";
          ZT.has(ue) || (ZT.add(ue), c("`%s` uses `getDerivedStateFromProps` but its initial state is %s. This is not recommended. Instead, define the initial state by assigning an object to `this.state` in the constructor of `%s`. This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", ue, X.state === null ? "null" : "undefined", ue));
        }
        if (typeof a.getDerivedStateFromProps == "function" || typeof X.getSnapshotBeforeUpdate == "function") {
          var _e = null, Ie = null, Me = null;
          if (typeof X.componentWillMount == "function" && X.componentWillMount.__suppressDeprecationWarning !== !0 ? _e = "componentWillMount" : typeof X.UNSAFE_componentWillMount == "function" && (_e = "UNSAFE_componentWillMount"), typeof X.componentWillReceiveProps == "function" && X.componentWillReceiveProps.__suppressDeprecationWarning !== !0 ? Ie = "componentWillReceiveProps" : typeof X.UNSAFE_componentWillReceiveProps == "function" && (Ie = "UNSAFE_componentWillReceiveProps"), typeof X.componentWillUpdate == "function" && X.componentWillUpdate.__suppressDeprecationWarning !== !0 ? Me = "componentWillUpdate" : typeof X.UNSAFE_componentWillUpdate == "function" && (Me = "UNSAFE_componentWillUpdate"), _e !== null || Ie !== null || Me !== null) {
            var st = Cn(a) || "Component", Dt = typeof a.getDerivedStateFromProps == "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
            JT.has(st) || (JT.add(st), c(`Unsafe legacy lifecycles will not be called for components using new component APIs.

%s uses %s but also contains the following legacy lifecycles:%s%s%s

The above lifecycles should be removed. Learn more about this warning here:
https://reactjs.org/link/unsafe-component-lifecycles`, st, Dt, _e !== null ? `
  ` + _e : "", Ie !== null ? `
  ` + Ie : "", Me !== null ? `
  ` + Me : ""));
          }
        }
      }
      return S && JL(o, b, T), X;
    }
    function rQ(o, a) {
      var p = a.state;
      typeof a.componentWillMount == "function" && a.componentWillMount(), typeof a.UNSAFE_componentWillMount == "function" && a.UNSAFE_componentWillMount(), p !== a.state && (c("%s.componentWillMount(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", Ut(o) || "Component"), oI.enqueueReplaceState(a, a.state, null));
    }
    function dN(o, a, p, S) {
      var b = a.state;
      if (typeof a.componentWillReceiveProps == "function" && a.componentWillReceiveProps(p, S), typeof a.UNSAFE_componentWillReceiveProps == "function" && a.UNSAFE_componentWillReceiveProps(p, S), a.state !== b) {
        {
          var T = Ut(o) || "Component";
          XT.has(T) || (XT.add(T), c("%s.componentWillReceiveProps(): Assigning directly to this.state is deprecated (except inside a component's constructor). Use setState instead.", T));
        }
        oI.enqueueReplaceState(a, a.state, null);
      }
    }
    function sI(o, a, p, S) {
      nQ(o, a, p);
      var b = o.stateNode;
      b.props = p, b.state = o.memoizedState, b.refs = {}, gT(o);
      var T = a.contextType;
      if (typeof T == "object" && T !== null)
        b.context = Ui(T);
      else {
        var D = Am(o, a, !0);
        b.context = Dm(o, D);
      }
      {
        if (b.state === p) {
          var N = Cn(a) || "Component";
          tI.has(N) || (tI.add(N), c("%s: It is not recommended to assign props directly to state because updates to props won't be reflected in state. In most cases, it is better to use props directly.", N));
        }
        o.mode & Jt && oc.recordLegacyContextWarning(o, b), oc.recordUnsafeLifecycleWarnings(o, b);
      }
      b.state = o.memoizedState;
      var $ = a.getDerivedStateFromProps;
      if (typeof $ == "function" && (iI(o, a, $, p), b.state = o.memoizedState), typeof a.getDerivedStateFromProps != "function" && typeof b.getSnapshotBeforeUpdate != "function" && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (rQ(o, b), O0(o, p, b, S), b.state = o.memoizedState), typeof b.componentDidMount == "function") {
        var G = Sn;
        G |= zc, (o.mode & ur) !== Mt && (G |= wo), o.flags |= G;
      }
    }
    function iQ(o, a, p, S) {
      var b = o.stateNode, T = o.memoizedProps;
      b.props = T;
      var D = b.context, N = a.contextType, $ = Ha;
      if (typeof N == "object" && N !== null)
        $ = Ui(N);
      else {
        var G = Am(o, a, !0);
        $ = Dm(o, G);
      }
      var X = a.getDerivedStateFromProps, fe = typeof X == "function" || typeof b.getSnapshotBeforeUpdate == "function";
      !fe && (typeof b.UNSAFE_componentWillReceiveProps == "function" || typeof b.componentWillReceiveProps == "function") && (T !== p || D !== $) && dN(o, b, p, $), P2();
      var ue = o.memoizedState, _e = b.state = ue;
      if (O0(o, p, b, S), _e = o.memoizedState, T === p && ue === _e && !g0() && !j0()) {
        if (typeof b.componentDidMount == "function") {
          var Ie = Sn;
          Ie |= zc, (o.mode & ur) !== Mt && (Ie |= wo), o.flags |= Ie;
        }
        return !1;
      }
      typeof X == "function" && (iI(o, a, X, p), _e = o.memoizedState);
      var Me = j0() || lN(o, a, T, p, ue, _e, $);
      if (Me) {
        if (!fe && (typeof b.UNSAFE_componentWillMount == "function" || typeof b.componentWillMount == "function") && (typeof b.componentWillMount == "function" && b.componentWillMount(), typeof b.UNSAFE_componentWillMount == "function" && b.UNSAFE_componentWillMount()), typeof b.componentDidMount == "function") {
          var st = Sn;
          st |= zc, (o.mode & ur) !== Mt && (st |= wo), o.flags |= st;
        }
      } else {
        if (typeof b.componentDidMount == "function") {
          var Dt = Sn;
          Dt |= zc, (o.mode & ur) !== Mt && (Dt |= wo), o.flags |= Dt;
        }
        o.memoizedProps = p, o.memoizedState = _e;
      }
      return b.props = p, b.state = _e, b.context = $, Me;
    }
    function oQ(o, a, p, S, b) {
      var T = a.stateNode;
      _2(o, a);
      var D = a.memoizedProps, N = a.type === a.elementType ? D : lc(a.type, D);
      T.props = N;
      var $ = a.pendingProps, G = T.context, X = p.contextType, fe = Ha;
      if (typeof X == "object" && X !== null)
        fe = Ui(X);
      else {
        var ue = Am(a, p, !0);
        fe = Dm(a, ue);
      }
      var _e = p.getDerivedStateFromProps, Ie = typeof _e == "function" || typeof T.getSnapshotBeforeUpdate == "function";
      !Ie && (typeof T.UNSAFE_componentWillReceiveProps == "function" || typeof T.componentWillReceiveProps == "function") && (D !== $ || G !== fe) && dN(a, T, S, fe), P2();
      var Me = a.memoizedState, st = T.state = Me;
      if (O0(a, S, T, b), st = a.memoizedState, D === $ && Me === st && !g0() && !j0())
        return typeof T.componentDidUpdate == "function" && (D !== o.memoizedProps || Me !== o.memoizedState) && (a.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && (D !== o.memoizedProps || Me !== o.memoizedState) && (a.flags |= ea), !1;
      typeof _e == "function" && (iI(a, p, _e, S), st = a.memoizedState);
      var Dt = j0() || lN(a, p, N, S, Me, st, fe) || // TODO: In some cases, we'll end up checking if context has changed twice,
      // both before and after `shouldComponentUpdate` has been called. Not ideal,
      // but I'm loath to refactor this function. This only happens for memoized
      // components so it's not that common.
      ke;
      return Dt ? (!Ie && (typeof T.UNSAFE_componentWillUpdate == "function" || typeof T.componentWillUpdate == "function") && (typeof T.componentWillUpdate == "function" && T.componentWillUpdate(S, st, fe), typeof T.UNSAFE_componentWillUpdate == "function" && T.UNSAFE_componentWillUpdate(S, st, fe)), typeof T.componentDidUpdate == "function" && (a.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && (a.flags |= ea)) : (typeof T.componentDidUpdate == "function" && (D !== o.memoizedProps || Me !== o.memoizedState) && (a.flags |= Sn), typeof T.getSnapshotBeforeUpdate == "function" && (D !== o.memoizedProps || Me !== o.memoizedState) && (a.flags |= ea), a.memoizedProps = S, a.memoizedState = st), T.props = S, T.state = st, T.context = fe, Dt;
    }
    function Op(o, a) {
      return {
        value: o,
        source: a,
        stack: dn(a),
        digest: null
      };
    }
    function aI(o, a, p) {
      return {
        value: o,
        source: null,
        stack: p ?? null,
        digest: a ?? null
      };
    }
    function sQ(o, a) {
      return !0;
    }
    function lI(o, a) {
      try {
        var p = sQ(o, a);
        if (p === !1)
          return;
        var S = a.value, b = a.source, T = a.stack, D = T !== null ? T : "";
        if (S != null && S._suppressLogging) {
          if (o.tag === g)
            return;
          console.error(S);
        }
        var N = b ? Ut(b) : null, $ = N ? "The above error occurred in the <" + N + "> component:" : "The above error occurred in one of your React components:", G;
        if (o.tag === v)
          G = `Consider adding an error boundary to your tree to customize error handling behavior.
Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.`;
        else {
          var X = Ut(o) || "Anonymous";
          G = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + X + ".");
        }
        var fe = $ + `
` + D + `

` + ("" + G);
        console.error(fe);
      } catch (ue) {
        setTimeout(function() {
          throw ue;
        });
      }
    }
    var aQ = typeof WeakMap == "function" ? WeakMap : Map;
    function fN(o, a, p) {
      var S = Sd(ir, p);
      S.tag = hT, S.payload = {
        element: null
      };
      var b = a.value;
      return S.callback = function() {
        JJ(b), lI(o, a);
      }, S;
    }
    function cI(o, a, p) {
      var S = Sd(ir, p);
      S.tag = hT;
      var b = o.type.getDerivedStateFromError;
      if (typeof b == "function") {
        var T = a.value;
        S.payload = function() {
          return b(T);
        }, S.callback = function() {
          C3(o), lI(o, a);
        };
      }
      var D = o.stateNode;
      return D !== null && typeof D.componentDidCatch == "function" && (S.callback = function() {
        C3(o), lI(o, a), typeof b != "function" && ZJ(this);
        var $ = a.value, G = a.stack;
        this.componentDidCatch($, {
          componentStack: G !== null ? G : ""
        }), typeof b != "function" && (ts(o.lanes, Nt) || c("%s: Error boundaries should implement getDerivedStateFromError(). In that method, return a state update to display an error message or fallback UI.", Ut(o) || "Unknown"));
      }), S;
    }
    function hN(o, a, p) {
      var S = o.pingCache, b;
      if (S === null ? (S = o.pingCache = new aQ(), b = /* @__PURE__ */ new Set(), S.set(a, b)) : (b = S.get(a), b === void 0 && (b = /* @__PURE__ */ new Set(), S.set(a, b))), !b.has(p)) {
        b.add(p);
        var T = eee.bind(null, o, a, p);
        uo && YS(o, p), a.then(T, T);
      }
    }
    function lQ(o, a, p, S) {
      var b = o.updateQueue;
      if (b === null) {
        var T = /* @__PURE__ */ new Set();
        T.add(p), o.updateQueue = T;
      } else
        b.add(p);
    }
    function cQ(o, a) {
      var p = o.tag;
      if ((o.mode & pn) === Mt && (p === h || p === O || p === V)) {
        var S = o.alternate;
        S ? (o.updateQueue = S.updateQueue, o.memoizedState = S.memoizedState, o.lanes = S.lanes) : (o.updateQueue = null, o.memoizedState = null);
      }
    }
    function pN(o) {
      var a = o;
      do {
        if (a.tag === F && HZ(a))
          return a;
        a = a.return;
      } while (a !== null);
      return null;
    }
    function gN(o, a, p, S, b) {
      if ((o.mode & pn) === Mt) {
        if (o === a)
          o.flags |= ta;
        else {
          if (o.flags |= hn, p.flags |= Fa, p.flags &= -52805, p.tag === g) {
            var T = p.alternate;
            if (T === null)
              p.tag = q;
            else {
              var D = Sd(ir, Nt);
              D.tag = R0, $f(p, D, Nt);
            }
          }
          p.lanes = nn(p.lanes, Nt);
        }
        return o;
      }
      return o.flags |= ta, o.lanes = b, o;
    }
    function uQ(o, a, p, S, b) {
      if (p.flags |= qu, uo && YS(o, b), S !== null && typeof S == "object" && typeof S.then == "function") {
        var T = S;
        cQ(p), _o() && p.mode & pn && s2();
        var D = pN(a);
        if (D !== null) {
          D.flags &= -257, gN(D, a, p, o, b), D.mode & pn && hN(o, T, b), lQ(D, o, T);
          return;
        } else {
          if (!Dv(b)) {
            hN(o, T, b), BI();
            return;
          }
          var N = new Error("A component suspended while responding to synchronous input. This will cause the UI to be replaced with a loading indicator. To fix, updates that suspend should be wrapped with startTransition.");
          S = N;
        }
      } else if (_o() && p.mode & pn) {
        s2();
        var $ = pN(a);
        if ($ !== null) {
          ($.flags & ta) === Rt && ($.flags |= Wr), gN($, a, p, o, b), tT(Op(S, p));
          return;
        }
      }
      S = Op(S, p), HJ(S);
      var G = a;
      do {
        switch (G.tag) {
          case v: {
            var X = S;
            G.flags |= ta;
            var fe = Ni(b);
            G.lanes = nn(G.lanes, fe);
            var ue = fN(G, X, fe);
            mT(G, ue);
            return;
          }
          case g:
            var _e = S, Ie = G.type, Me = G.stateNode;
            if ((G.flags & hn) === Rt && (typeof Ie.getDerivedStateFromError == "function" || Me !== null && typeof Me.componentDidCatch == "function" && !p3(Me))) {
              G.flags |= ta;
              var st = Ni(b);
              G.lanes = nn(G.lanes, st);
              var Dt = cI(G, _e, st);
              mT(G, Dt);
              return;
            }
            break;
        }
        G = G.return;
      } while (G !== null);
    }
    function dQ() {
      return null;
    }
    var DS = r.ReactCurrentOwner, cc = !1, uI, OS, dI, fI, hI, jp, pI, o1, jS;
    uI = {}, OS = {}, dI = {}, fI = {}, hI = {}, jp = !1, pI = {}, o1 = {}, jS = {};
    function Ns(o, a, p, S) {
      o === null ? a.child = v2(a, null, p, S) : a.child = Nm(a, o.child, p, S);
    }
    function fQ(o, a, p, S) {
      a.child = Nm(a, o.child, null, S), a.child = Nm(a, null, p, S);
    }
    function mN(o, a, p, S, b) {
      if (a.type !== a.elementType) {
        var T = p.propTypes;
        T && rc(
          T,
          S,
          // Resolved props
          "prop",
          Cn(p)
        );
      }
      var D = p.render, N = a.ref, $, G;
      zm(a, b), na(a);
      {
        if (DS.current = a, lo(!0), $ = Km(o, a, D, S, N, b), G = Wm(), a.mode & Jt) {
          rr(!0);
          try {
            $ = Km(o, a, D, S, N, b), G = Wm();
          } finally {
            rr(!1);
          }
        }
        lo(!1);
      }
      return Vc(), o !== null && !cc ? (A2(o, a, b), xd(o, a, b)) : (_o() && G && YP(a), a.flags |= Zl, Ns(o, a, $, b), a.child);
    }
    function yN(o, a, p, S, b) {
      if (o === null) {
        var T = p.type;
        if (yee(T) && p.compare === null && // SimpleMemoComponent codepath doesn't resolve outer props either.
        p.defaultProps === void 0) {
          var D = T;
          return D = ey(T), a.tag = V, a.type = D, yI(a, T), vN(o, a, D, S, b);
        }
        {
          var N = T.propTypes;
          if (N && rc(
            N,
            S,
            // Resolved props
            "prop",
            Cn(T)
          ), p.defaultProps !== void 0) {
            var $ = Cn(T) || "Unknown";
            jS[$] || (c("%s: Support for defaultProps will be removed from memo components in a future major release. Use JavaScript default parameters instead.", $), jS[$] = !0);
          }
        }
        var G = JI(p.type, null, S, a, a.mode, b);
        return G.ref = a.ref, G.return = a, a.child = G, G;
      }
      {
        var X = p.type, fe = X.propTypes;
        fe && rc(
          fe,
          S,
          // Resolved props
          "prop",
          Cn(X)
        );
      }
      var ue = o.child, _e = CI(o, b);
      if (!_e) {
        var Ie = ue.memoizedProps, Me = p.compare;
        if (Me = Me !== null ? Me : At, Me(Ie, S) && o.ref === a.ref)
          return xd(o, a, b);
      }
      a.flags |= Zl;
      var st = Up(ue, S);
      return st.ref = a.ref, st.return = a, a.child = st, st;
    }
    function vN(o, a, p, S, b) {
      if (a.type !== a.elementType) {
        var T = a.elementType;
        if (T.$$typeof === Vt) {
          var D = T, N = D._payload, $ = D._init;
          try {
            T = $(N);
          } catch {
            T = null;
          }
          var G = T && T.propTypes;
          G && rc(
            G,
            S,
            // Resolved (SimpleMemoComponent has no defaultProps)
            "prop",
            Cn(T)
          );
        }
      }
      if (o !== null) {
        var X = o.memoizedProps;
        if (At(X, S) && o.ref === a.ref && // Prevent bailout if the implementation changed due to hot reload.
        a.type === o.type)
          if (cc = !1, a.pendingProps = S = X, CI(o, b))
            (o.flags & Fa) !== Rt && (cc = !0);
          else return a.lanes = o.lanes, xd(o, a, b);
      }
      return gI(o, a, p, S, b);
    }
    function SN(o, a, p) {
      var S = a.pendingProps, b = S.children, T = o !== null ? o.memoizedState : null;
      if (S.mode === "hidden" || te)
        if ((a.mode & pn) === Mt) {
          var D = {
            baseLanes: je,
            cachePool: null,
            transitions: null
          };
          a.memoizedState = D, v1(a, p);
        } else if (ts(p, As)) {
          var fe = {
            baseLanes: je,
            cachePool: null,
            transitions: null
          };
          a.memoizedState = fe;
          var ue = T !== null ? T.baseLanes : p;
          v1(a, ue);
        } else {
          var N = null, $;
          if (T !== null) {
            var G = T.baseLanes;
            $ = nn(G, p);
          } else
            $ = p;
          a.lanes = a.childLanes = As;
          var X = {
            baseLanes: $,
            cachePool: N,
            transitions: null
          };
          return a.memoizedState = X, a.updateQueue = null, v1(a, $), null;
        }
      else {
        var _e;
        T !== null ? (_e = nn(T.baseLanes, p), a.memoizedState = null) : _e = p, v1(a, _e);
      }
      return Ns(o, a, b, p), a.child;
    }
    function hQ(o, a, p) {
      var S = a.pendingProps;
      return Ns(o, a, S, p), a.child;
    }
    function pQ(o, a, p) {
      var S = a.pendingProps.children;
      return Ns(o, a, S, p), a.child;
    }
    function gQ(o, a, p) {
      {
        a.flags |= Sn;
        {
          var S = a.stateNode;
          S.effectDuration = 0, S.passiveEffectDuration = 0;
        }
      }
      var b = a.pendingProps, T = b.children;
      return Ns(o, a, T, p), a.child;
    }
    function xN(o, a) {
      var p = a.ref;
      (o === null && p !== null || o !== null && o.ref !== p) && (a.flags |= ui, a.flags |= Yh);
    }
    function gI(o, a, p, S, b) {
      if (a.type !== a.elementType) {
        var T = p.propTypes;
        T && rc(
          T,
          S,
          // Resolved props
          "prop",
          Cn(p)
        );
      }
      var D;
      {
        var N = Am(a, p, !0);
        D = Dm(a, N);
      }
      var $, G;
      zm(a, b), na(a);
      {
        if (DS.current = a, lo(!0), $ = Km(o, a, p, S, D, b), G = Wm(), a.mode & Jt) {
          rr(!0);
          try {
            $ = Km(o, a, p, S, D, b), G = Wm();
          } finally {
            rr(!1);
          }
        }
        lo(!1);
      }
      return Vc(), o !== null && !cc ? (A2(o, a, b), xd(o, a, b)) : (_o() && G && YP(a), a.flags |= Zl, Ns(o, a, $, b), a.child);
    }
    function wN(o, a, p, S, b) {
      {
        switch (Aee(a)) {
          case !1: {
            var T = a.stateNode, D = a.type, N = new D(a.memoizedProps, T.context), $ = N.state;
            T.updater.enqueueSetState(T, $, null);
            break;
          }
          case !0: {
            a.flags |= hn, a.flags |= ta;
            var G = new Error("Simulated error coming from DevTools"), X = Ni(b);
            a.lanes = nn(a.lanes, X);
            var fe = cI(a, Op(G, a), X);
            mT(a, fe);
            break;
          }
        }
        if (a.type !== a.elementType) {
          var ue = p.propTypes;
          ue && rc(
            ue,
            S,
            // Resolved props
            "prop",
            Cn(p)
          );
        }
      }
      var _e;
      iu(p) ? (_e = !0, y0(a)) : _e = !1, zm(a, b);
      var Ie = a.stateNode, Me;
      Ie === null ? (a1(o, a), uN(a, p, S), sI(a, p, S, b), Me = !0) : o === null ? Me = iQ(a, p, S, b) : Me = oQ(o, a, p, S, b);
      var st = mI(o, a, p, Me, _e, b);
      {
        var Dt = a.stateNode;
        Me && Dt.props !== S && (jp || c("It looks like %s is reassigning its own `this.props` while rendering. This is not supported and can lead to confusing bugs.", Ut(a) || "a component"), jp = !0);
      }
      return st;
    }
    function mI(o, a, p, S, b, T) {
      xN(o, a);
      var D = (a.flags & hn) !== Rt;
      if (!S && !D)
        return b && n2(a, p, !1), xd(o, a, T);
      var N = a.stateNode;
      DS.current = a;
      var $;
      if (D && typeof p.getDerivedStateFromError != "function")
        $ = null, oN();
      else {
        na(a);
        {
          if (lo(!0), $ = N.render(), a.mode & Jt) {
            rr(!0);
            try {
              N.render();
            } finally {
              rr(!1);
            }
          }
          lo(!1);
        }
        Vc();
      }
      return a.flags |= Zl, o !== null && D ? fQ(o, a, $, T) : Ns(o, a, $, T), a.memoizedState = N.state, b && n2(a, p, !0), a.child;
    }
    function bN(o) {
      var a = o.stateNode;
      a.pendingContext ? e2(o, a.pendingContext, a.pendingContext !== a.context) : a.context && e2(o, a.context, !1), yT(o, a.containerInfo);
    }
    function mQ(o, a, p) {
      if (bN(a), o === null)
        throw new Error("Should have a current fiber. This is a bug in React.");
      var S = a.pendingProps, b = a.memoizedState, T = b.element;
      _2(o, a), O0(a, S, null, p);
      var D = a.memoizedState;
      a.stateNode;
      var N = D.element;
      if (b.isDehydrated) {
        var $ = {
          element: N,
          isDehydrated: !1,
          cache: D.cache,
          pendingSuspenseBoundaries: D.pendingSuspenseBoundaries,
          transitions: D.transitions
        }, G = a.updateQueue;
        if (G.baseState = $, a.memoizedState = $, a.flags & Wr) {
          var X = Op(new Error("There was an error while hydrating. Because the error happened outside of a Suspense boundary, the entire root will switch to client rendering."), a);
          return CN(o, a, N, p, X);
        } else if (N !== T) {
          var fe = Op(new Error("This root received an early update, before anything was able hydrate. Switched the entire root to client rendering."), a);
          return CN(o, a, N, p, fe);
        } else {
          SZ(a);
          var ue = v2(a, null, N, p);
          a.child = ue;
          for (var _e = ue; _e; )
            _e.flags = _e.flags & -3 | di, _e = _e.sibling;
        }
      } else {
        if (Lm(), N === T)
          return xd(o, a, p);
        Ns(o, a, N, p);
      }
      return a.child;
    }
    function CN(o, a, p, S, b) {
      return Lm(), tT(b), a.flags |= Wr, Ns(o, a, p, S), a.child;
    }
    function yQ(o, a, p) {
      k2(a), o === null && eT(a);
      var S = a.type, b = a.pendingProps, T = o !== null ? o.memoizedProps : null, D = b.children, N = jP(S, b);
      return N ? D = null : T !== null && jP(S, T) && (a.flags |= cr), xN(o, a), Ns(o, a, D, p), a.child;
    }
    function vQ(o, a) {
      return o === null && eT(a), null;
    }
    function SQ(o, a, p, S) {
      a1(o, a);
      var b = a.pendingProps, T = p, D = T._payload, N = T._init, $ = N(D);
      a.type = $;
      var G = a.tag = vee($), X = lc($, b), fe;
      switch (G) {
        case h:
          return yI(a, $), a.type = $ = ey($), fe = gI(null, a, $, X, S), fe;
        case g:
          return a.type = $ = GI($), fe = wN(null, a, $, X, S), fe;
        case O:
          return a.type = $ = qI($), fe = mN(null, a, $, X, S), fe;
        case H: {
          if (a.type !== a.elementType) {
            var ue = $.propTypes;
            ue && rc(
              ue,
              X,
              // Resolved for outer only
              "prop",
              Cn($)
            );
          }
          return fe = yN(
            null,
            a,
            $,
            lc($.type, X),
            // The inner type can have defaults too
            S
          ), fe;
        }
      }
      var _e = "";
      throw $ !== null && typeof $ == "object" && $.$$typeof === Vt && (_e = " Did you wrap a component in React.lazy() more than once?"), new Error("Element type is invalid. Received a promise that resolves to: " + $ + ". " + ("Lazy element type must resolve to a class or function." + _e));
    }
    function xQ(o, a, p, S, b) {
      a1(o, a), a.tag = g;
      var T;
      return iu(p) ? (T = !0, y0(a)) : T = !1, zm(a, b), uN(a, p, S), sI(a, p, S, b), mI(null, a, p, !0, T, b);
    }
    function wQ(o, a, p, S) {
      a1(o, a);
      var b = a.pendingProps, T;
      {
        var D = Am(a, p, !1);
        T = Dm(a, D);
      }
      zm(a, S);
      var N, $;
      na(a);
      {
        if (p.prototype && typeof p.prototype.render == "function") {
          var G = Cn(p) || "Unknown";
          uI[G] || (c("The <%s /> component appears to have a render method, but doesn't extend React.Component. This is likely to cause errors. Change %s to extend React.Component instead.", G, G), uI[G] = !0);
        }
        a.mode & Jt && oc.recordLegacyContextWarning(a, null), lo(!0), DS.current = a, N = Km(null, a, p, b, T, S), $ = Wm(), lo(!1);
      }
      if (Vc(), a.flags |= Zl, typeof N == "object" && N !== null && typeof N.render == "function" && N.$$typeof === void 0) {
        var X = Cn(p) || "Unknown";
        OS[X] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", X, X, X), OS[X] = !0);
      }
      if (
        // Run these checks in production only if the flag is off.
        // Eventually we'll delete this branch altogether.
        typeof N == "object" && N !== null && typeof N.render == "function" && N.$$typeof === void 0
      ) {
        {
          var fe = Cn(p) || "Unknown";
          OS[fe] || (c("The <%s /> component appears to be a function component that returns a class instance. Change %s to a class that extends React.Component instead. If you can't use a class try assigning the prototype on the function as a workaround. `%s.prototype = React.Component.prototype`. Don't use an arrow function since it cannot be called with `new` by React.", fe, fe, fe), OS[fe] = !0);
        }
        a.tag = g, a.memoizedState = null, a.updateQueue = null;
        var ue = !1;
        return iu(p) ? (ue = !0, y0(a)) : ue = !1, a.memoizedState = N.state !== null && N.state !== void 0 ? N.state : null, gT(a), cN(a, N), sI(a, p, b, S), mI(null, a, p, !0, ue, S);
      } else {
        if (a.tag = h, a.mode & Jt) {
          rr(!0);
          try {
            N = Km(null, a, p, b, T, S), $ = Wm();
          } finally {
            rr(!1);
          }
        }
        return _o() && $ && YP(a), Ns(null, a, N, S), yI(a, p), a.child;
      }
    }
    function yI(o, a) {
      {
        if (a && a.childContextTypes && c("%s(...): childContextTypes cannot be defined on a function component.", a.displayName || a.name || "Component"), o.ref !== null) {
          var p = "", S = Nr();
          S && (p += `

Check the render method of \`` + S + "`.");
          var b = S || "", T = o._debugSource;
          T && (b = T.fileName + ":" + T.lineNumber), hI[b] || (hI[b] = !0, c("Function components cannot be given refs. Attempts to access this ref will fail. Did you mean to use React.forwardRef()?%s", p));
        }
        if (a.defaultProps !== void 0) {
          var D = Cn(a) || "Unknown";
          jS[D] || (c("%s: Support for defaultProps will be removed from function components in a future major release. Use JavaScript default parameters instead.", D), jS[D] = !0);
        }
        if (typeof a.getDerivedStateFromProps == "function") {
          var N = Cn(a) || "Unknown";
          fI[N] || (c("%s: Function components do not support getDerivedStateFromProps.", N), fI[N] = !0);
        }
        if (typeof a.contextType == "object" && a.contextType !== null) {
          var $ = Cn(a) || "Unknown";
          dI[$] || (c("%s: Function components do not support contextType.", $), dI[$] = !0);
        }
      }
    }
    var vI = {
      dehydrated: null,
      treeContext: null,
      retryLane: hi
    };
    function SI(o) {
      return {
        baseLanes: o,
        cachePool: dQ(),
        transitions: null
      };
    }
    function bQ(o, a) {
      var p = null;
      return {
        baseLanes: nn(o.baseLanes, a),
        cachePool: p,
        transitions: o.transitions
      };
    }
    function CQ(o, a, p, S) {
      if (a !== null) {
        var b = a.memoizedState;
        if (b === null)
          return !1;
      }
      return xT(o, ES);
    }
    function EQ(o, a) {
      return cp(o.childLanes, a);
    }
    function EN(o, a, p) {
      var S = a.pendingProps;
      Dee(a) && (a.flags |= hn);
      var b = sc.current, T = !1, D = (a.flags & hn) !== Rt;
      if (D || CQ(b, o) ? (T = !0, a.flags &= -129) : (o === null || o.memoizedState !== null) && (b = BZ(b, M2)), b = $m(b), Hf(a, b), o === null) {
        eT(a);
        var N = a.memoizedState;
        if (N !== null) {
          var $ = N.dehydrated;
          if ($ !== null)
            return kQ(a, $);
        }
        var G = S.children, X = S.fallback;
        if (T) {
          var fe = _Q(a, G, X, p), ue = a.child;
          return ue.memoizedState = SI(p), a.memoizedState = vI, fe;
        } else
          return xI(a, G);
      } else {
        var _e = o.memoizedState;
        if (_e !== null) {
          var Ie = _e.dehydrated;
          if (Ie !== null)
            return RQ(o, a, D, S, Ie, _e, p);
        }
        if (T) {
          var Me = S.fallback, st = S.children, Dt = TQ(o, a, st, Me, p), Tt = a.child, Dn = o.child.memoizedState;
          return Tt.memoizedState = Dn === null ? SI(p) : bQ(Dn, p), Tt.childLanes = EQ(o, p), a.memoizedState = vI, Dt;
        } else {
          var En = S.children, xe = PQ(o, a, En, p);
          return a.memoizedState = null, xe;
        }
      }
    }
    function xI(o, a, p) {
      var S = o.mode, b = {
        mode: "visible",
        children: a
      }, T = wI(b, S);
      return T.return = o, o.child = T, T;
    }
    function _Q(o, a, p, S) {
      var b = o.mode, T = o.child, D = {
        mode: "hidden",
        children: a
      }, N, $;
      return (b & pn) === Mt && T !== null ? (N = T, N.childLanes = je, N.pendingProps = D, o.mode & _n && (N.actualDuration = 0, N.actualStartTime = -1, N.selfBaseDuration = 0, N.treeBaseDuration = 0), $ = Zf(p, b, S, null)) : (N = wI(D, b), $ = Zf(p, b, S, null)), N.return = o, $.return = o, N.sibling = $, o.child = N, $;
    }
    function wI(o, a, p) {
      return _3(o, a, je, null);
    }
    function _N(o, a) {
      return Up(o, a);
    }
    function PQ(o, a, p, S) {
      var b = o.child, T = b.sibling, D = _N(b, {
        mode: "visible",
        children: p
      });
      if ((a.mode & pn) === Mt && (D.lanes = S), D.return = a, D.sibling = null, T !== null) {
        var N = a.deletions;
        N === null ? (a.deletions = [T], a.flags |= Xo) : N.push(T);
      }
      return a.child = D, D;
    }
    function TQ(o, a, p, S, b) {
      var T = a.mode, D = o.child, N = D.sibling, $ = {
        mode: "hidden",
        children: p
      }, G;
      if (
        // In legacy mode, we commit the primary tree as if it successfully
        // completed, even though it's in an inconsistent state.
        (T & pn) === Mt && // Make sure we're on the second pass, i.e. the primary child fragment was
        // already cloned. In legacy mode, the only case where this isn't true is
        // when DevTools forces us to display a fallback; we skip the first render
        // pass entirely and go straight to rendering the fallback. (In Concurrent
        // Mode, SuspenseList can also trigger this scenario, but this is a legacy-
        // only codepath.)
        a.child !== D
      ) {
        var X = a.child;
        G = X, G.childLanes = je, G.pendingProps = $, a.mode & _n && (G.actualDuration = 0, G.actualStartTime = -1, G.selfBaseDuration = D.selfBaseDuration, G.treeBaseDuration = D.treeBaseDuration), a.deletions = null;
      } else
        G = _N(D, $), G.subtreeFlags = D.subtreeFlags & fi;
      var fe;
      return N !== null ? fe = Up(N, S) : (fe = Zf(S, T, b, null), fe.flags |= ci), fe.return = a, G.return = a, G.sibling = fe, a.child = G, fe;
    }
    function s1(o, a, p, S) {
      S !== null && tT(S), Nm(a, o.child, null, p);
      var b = a.pendingProps, T = b.children, D = xI(a, T);
      return D.flags |= ci, a.memoizedState = null, D;
    }
    function IQ(o, a, p, S, b) {
      var T = a.mode, D = {
        mode: "visible",
        children: p
      }, N = wI(D, T), $ = Zf(S, T, b, null);
      return $.flags |= ci, N.return = a, $.return = a, N.sibling = $, a.child = N, (a.mode & pn) !== Mt && Nm(a, o.child, null, b), $;
    }
    function kQ(o, a, p) {
      return (o.mode & pn) === Mt ? (c("Cannot hydrate Suspense in legacy mode. Switch from ReactDOM.hydrate(element, container) to ReactDOMClient.hydrateRoot(container, <App />).render(element) or remove the Suspense components from the server rendered components."), o.lanes = Nt) : zP(a) ? o.lanes = Li : o.lanes = As, null;
    }
    function RQ(o, a, p, S, b, T, D) {
      if (p)
        if (a.flags & Wr) {
          a.flags &= -257;
          var xe = aI(new Error("There was an error while hydrating this Suspense boundary. Switched to client rendering."));
          return s1(o, a, D, xe);
        } else {
          if (a.memoizedState !== null)
            return a.child = o.child, a.flags |= hn, null;
          var Ae = S.children, we = S.fallback, Ge = IQ(o, a, Ae, we, D), pt = a.child;
          return pt.memoizedState = SI(D), a.memoizedState = vI, Ge;
        }
      else {
        if (yZ(), (a.mode & pn) === Mt)
          return s1(
            o,
            a,
            D,
            // TODO: When we delete legacy mode, we should make this error argument
            // required — every concurrent mode path that causes hydration to
            // de-opt to client rendering should have an error message.
            null
          );
        if (zP(b)) {
          var N, $, G;
          {
            var X = OX(b);
            N = X.digest, $ = X.message, G = X.stack;
          }
          var fe;
          $ ? fe = new Error($) : fe = new Error("The server could not finish this Suspense boundary, likely due to an error during server rendering. Switched to client rendering.");
          var ue = aI(fe, N, G);
          return s1(o, a, D, ue);
        }
        var _e = ts(D, o.childLanes);
        if (cc || _e) {
          var Ie = y1();
          if (Ie !== null) {
            var Me = sm(Ie, D);
            if (Me !== hi && Me !== T.retryLane) {
              T.retryLane = Me;
              var st = ir;
              la(o, Me), no(Ie, o, Me, st);
            }
          }
          BI();
          var Dt = aI(new Error("This Suspense boundary received an update before it finished hydrating. This caused the boundary to switch to client rendering. The usual way to fix this is to wrap the original update in startTransition."));
          return s1(o, a, D, Dt);
        } else if (qL(b)) {
          a.flags |= hn, a.child = o.child;
          var Tt = tee.bind(null, o);
          return jX(b, Tt), null;
        } else {
          xZ(a, b, T.treeContext);
          var Dn = S.children, En = xI(a, Dn);
          return En.flags |= di, En;
        }
      }
    }
    function PN(o, a, p) {
      o.lanes = nn(o.lanes, a);
      var S = o.alternate;
      S !== null && (S.lanes = nn(S.lanes, a)), dT(o.return, a, p);
    }
    function MQ(o, a, p) {
      for (var S = a; S !== null; ) {
        if (S.tag === F) {
          var b = S.memoizedState;
          b !== null && PN(S, p, o);
        } else if (S.tag === ie)
          PN(S, p, o);
        else if (S.child !== null) {
          S.child.return = S, S = S.child;
          continue;
        }
        if (S === o)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === o)
            return;
          S = S.return;
        }
        S.sibling.return = S.return, S = S.sibling;
      }
    }
    function AQ(o) {
      for (var a = o, p = null; a !== null; ) {
        var S = a.alternate;
        S !== null && F0(S) === null && (p = a), a = a.sibling;
      }
      return p;
    }
    function DQ(o) {
      if (o !== void 0 && o !== "forwards" && o !== "backwards" && o !== "together" && !pI[o])
        if (pI[o] = !0, typeof o == "string")
          switch (o.toLowerCase()) {
            case "together":
            case "forwards":
            case "backwards": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. Use lowercase "%s" instead.', o, o.toLowerCase());
              break;
            }
            case "forward":
            case "backward": {
              c('"%s" is not a valid value for revealOrder on <SuspenseList />. React uses the -s suffix in the spelling. Use "%ss" instead.', o, o.toLowerCase());
              break;
            }
            default:
              c('"%s" is not a supported revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
              break;
          }
        else
          c('%s is not a supported value for revealOrder on <SuspenseList />. Did you mean "together", "forwards" or "backwards"?', o);
    }
    function OQ(o, a) {
      o !== void 0 && !o1[o] && (o !== "collapsed" && o !== "hidden" ? (o1[o] = !0, c('"%s" is not a supported value for tail on <SuspenseList />. Did you mean "collapsed" or "hidden"?', o)) : a !== "forwards" && a !== "backwards" && (o1[o] = !0, c('<SuspenseList tail="%s" /> is only valid if revealOrder is "forwards" or "backwards". Did you mean to specify revealOrder="forwards"?', o)));
    }
    function TN(o, a) {
      {
        var p = tn(o), S = !p && typeof yr(o) == "function";
        if (p || S) {
          var b = p ? "array" : "iterable";
          return c("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in an additional SuspenseList to configure its revealOrder: <SuspenseList revealOrder=...> ... <SuspenseList revealOrder=...>{%s}</SuspenseList> ... </SuspenseList>", b, a, b), !1;
        }
      }
      return !0;
    }
    function jQ(o, a) {
      if ((a === "forwards" || a === "backwards") && o !== void 0 && o !== null && o !== !1)
        if (tn(o)) {
          for (var p = 0; p < o.length; p++)
            if (!TN(o[p], p))
              return;
        } else {
          var S = yr(o);
          if (typeof S == "function") {
            var b = S.call(o);
            if (b)
              for (var T = b.next(), D = 0; !T.done; T = b.next()) {
                if (!TN(T.value, D))
                  return;
                D++;
              }
          } else
            c('A single row was passed to a <SuspenseList revealOrder="%s" />. This is not useful since it needs multiple rows. Did you mean to pass multiple children or an array?', a);
        }
    }
    function bI(o, a, p, S, b) {
      var T = o.memoizedState;
      T === null ? o.memoizedState = {
        isBackwards: a,
        rendering: null,
        renderingStartTime: 0,
        last: S,
        tail: p,
        tailMode: b
      } : (T.isBackwards = a, T.rendering = null, T.renderingStartTime = 0, T.last = S, T.tail = p, T.tailMode = b);
    }
    function IN(o, a, p) {
      var S = a.pendingProps, b = S.revealOrder, T = S.tail, D = S.children;
      DQ(b), OQ(T, b), jQ(D, b), Ns(o, a, D, p);
      var N = sc.current, $ = xT(N, ES);
      if ($)
        N = wT(N, ES), a.flags |= hn;
      else {
        var G = o !== null && (o.flags & hn) !== Rt;
        G && MQ(a, a.child, p), N = $m(N);
      }
      if (Hf(a, N), (a.mode & pn) === Mt)
        a.memoizedState = null;
      else
        switch (b) {
          case "forwards": {
            var X = AQ(a.child), fe;
            X === null ? (fe = a.child, a.child = null) : (fe = X.sibling, X.sibling = null), bI(
              a,
              !1,
              // isBackwards
              fe,
              X,
              T
            );
            break;
          }
          case "backwards": {
            var ue = null, _e = a.child;
            for (a.child = null; _e !== null; ) {
              var Ie = _e.alternate;
              if (Ie !== null && F0(Ie) === null) {
                a.child = _e;
                break;
              }
              var Me = _e.sibling;
              _e.sibling = ue, ue = _e, _e = Me;
            }
            bI(
              a,
              !0,
              // isBackwards
              ue,
              null,
              // last
              T
            );
            break;
          }
          case "together": {
            bI(
              a,
              !1,
              // isBackwards
              null,
              // tail
              null,
              // last
              void 0
            );
            break;
          }
          default:
            a.memoizedState = null;
        }
      return a.child;
    }
    function LQ(o, a, p) {
      yT(a, a.stateNode.containerInfo);
      var S = a.pendingProps;
      return o === null ? a.child = Nm(a, null, S, p) : Ns(o, a, S, p), a.child;
    }
    var kN = !1;
    function NQ(o, a, p) {
      var S = a.type, b = S._context, T = a.pendingProps, D = a.memoizedProps, N = T.value;
      {
        "value" in T || kN || (kN = !0, c("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?"));
        var $ = a.type.propTypes;
        $ && rc($, T, "prop", "Context.Provider");
      }
      if (w2(a, b, N), D !== null) {
        var G = D.value;
        if (xt(G, N)) {
          if (D.children === T.children && !g0())
            return xd(o, a, p);
        } else
          DZ(a, b, p);
      }
      var X = T.children;
      return Ns(o, a, X, p), a.child;
    }
    var RN = !1;
    function FQ(o, a, p) {
      var S = a.type;
      S._context === void 0 ? S !== S.Consumer && (RN || (RN = !0, c("Rendering <Context> directly is not supported and will be removed in a future major release. Did you mean to render <Context.Consumer> instead?"))) : S = S._context;
      var b = a.pendingProps, T = b.children;
      typeof T != "function" && c("A context consumer was rendered with multiple children, or a child that isn't a function. A context consumer expects a single child that is a function. If you did pass a function, make sure there is no trailing or leading whitespace around it."), zm(a, p);
      var D = Ui(S);
      na(a);
      var N;
      return DS.current = a, lo(!0), N = T(D), lo(!1), Vc(), a.flags |= Zl, Ns(o, a, N, p), a.child;
    }
    function LS() {
      cc = !0;
    }
    function a1(o, a) {
      (a.mode & pn) === Mt && o !== null && (o.alternate = null, a.alternate = null, a.flags |= ci);
    }
    function xd(o, a, p) {
      return o !== null && (a.dependencies = o.dependencies), oN(), qS(a.lanes), ts(p, a.childLanes) ? (MZ(o, a), a.child) : null;
    }
    function zQ(o, a, p) {
      {
        var S = a.return;
        if (S === null)
          throw new Error("Cannot swap the root fiber.");
        if (o.alternate = null, a.alternate = null, p.index = a.index, p.sibling = a.sibling, p.return = a.return, p.ref = a.ref, a === S.child)
          S.child = p;
        else {
          var b = S.child;
          if (b === null)
            throw new Error("Expected parent to have a child.");
          for (; b.sibling !== a; )
            if (b = b.sibling, b === null)
              throw new Error("Expected to find the previous sibling.");
          b.sibling = p;
        }
        var T = S.deletions;
        return T === null ? (S.deletions = [o], S.flags |= Xo) : T.push(o), p.flags |= ci, p;
      }
    }
    function CI(o, a) {
      var p = o.lanes;
      return !!ts(p, a);
    }
    function UQ(o, a, p) {
      switch (a.tag) {
        case v:
          bN(a), a.stateNode, Lm();
          break;
        case C:
          k2(a);
          break;
        case g: {
          var S = a.type;
          iu(S) && y0(a);
          break;
        }
        case w:
          yT(a, a.stateNode.containerInfo);
          break;
        case L: {
          var b = a.memoizedProps.value, T = a.type._context;
          w2(a, T, b);
          break;
        }
        case z:
          {
            var D = ts(p, a.childLanes);
            D && (a.flags |= Sn);
            {
              var N = a.stateNode;
              N.effectDuration = 0, N.passiveEffectDuration = 0;
            }
          }
          break;
        case F: {
          var $ = a.memoizedState;
          if ($ !== null) {
            if ($.dehydrated !== null)
              return Hf(a, $m(sc.current)), a.flags |= hn, null;
            var G = a.child, X = G.childLanes;
            if (ts(p, X))
              return EN(o, a, p);
            Hf(a, $m(sc.current));
            var fe = xd(o, a, p);
            return fe !== null ? fe.sibling : null;
          } else
            Hf(a, $m(sc.current));
          break;
        }
        case ie: {
          var ue = (o.flags & hn) !== Rt, _e = ts(p, a.childLanes);
          if (ue) {
            if (_e)
              return IN(o, a, p);
            a.flags |= hn;
          }
          var Ie = a.memoizedState;
          if (Ie !== null && (Ie.rendering = null, Ie.tail = null, Ie.lastEffect = null), Hf(a, sc.current), _e)
            break;
          return null;
        }
        case Y:
        case oe:
          return a.lanes = je, SN(o, a, p);
      }
      return xd(o, a, p);
    }
    function MN(o, a, p) {
      if (a._debugNeedsRemount && o !== null)
        return zQ(o, a, JI(a.type, a.key, a.pendingProps, a._debugOwner || null, a.mode, a.lanes));
      if (o !== null) {
        var S = o.memoizedProps, b = a.pendingProps;
        if (S !== b || g0() || // Force a re-render if the implementation changed due to hot reload:
        a.type !== o.type)
          cc = !0;
        else {
          var T = CI(o, p);
          if (!T && // If this is the second pass of an error or suspense boundary, there
          // may not be work scheduled on `current`, so we check for this flag.
          (a.flags & hn) === Rt)
            return cc = !1, UQ(o, a, p);
          (o.flags & Fa) !== Rt ? cc = !0 : cc = !1;
        }
      } else if (cc = !1, _o() && dZ(a)) {
        var D = a.index, N = fZ();
        o2(a, N, D);
      }
      switch (a.lanes = je, a.tag) {
        case y:
          return wQ(o, a, a.type, p);
        case re: {
          var $ = a.elementType;
          return SQ(o, a, $, p);
        }
        case h: {
          var G = a.type, X = a.pendingProps, fe = a.elementType === G ? X : lc(G, X);
          return gI(o, a, G, fe, p);
        }
        case g: {
          var ue = a.type, _e = a.pendingProps, Ie = a.elementType === ue ? _e : lc(ue, _e);
          return wN(o, a, ue, Ie, p);
        }
        case v:
          return mQ(o, a, p);
        case C:
          return yQ(o, a, p);
        case E:
          return vQ(o, a);
        case F:
          return EN(o, a, p);
        case w:
          return LQ(o, a, p);
        case O: {
          var Me = a.type, st = a.pendingProps, Dt = a.elementType === Me ? st : lc(Me, st);
          return mN(o, a, Me, Dt, p);
        }
        case P:
          return hQ(o, a, p);
        case I:
          return pQ(o, a, p);
        case z:
          return gQ(o, a, p);
        case L:
          return NQ(o, a, p);
        case k:
          return FQ(o, a, p);
        case H: {
          var Tt = a.type, Dn = a.pendingProps, En = lc(Tt, Dn);
          if (a.type !== a.elementType) {
            var xe = Tt.propTypes;
            xe && rc(
              xe,
              En,
              // Resolved for outer only
              "prop",
              Cn(Tt)
            );
          }
          return En = lc(Tt.type, En), yN(o, a, Tt, En, p);
        }
        case V:
          return vN(o, a, a.type, a.pendingProps, p);
        case q: {
          var Ae = a.type, we = a.pendingProps, Ge = a.elementType === Ae ? we : lc(Ae, we);
          return xQ(o, a, Ae, Ge, p);
        }
        case ie:
          return IN(o, a, p);
        case W:
          break;
        case Y:
          return SN(o, a, p);
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function Gm(o) {
      o.flags |= Sn;
    }
    function AN(o) {
      o.flags |= ui, o.flags |= Yh;
    }
    var DN, EI, ON, jN;
    DN = function(o, a, p, S) {
      for (var b = a.child; b !== null; ) {
        if (b.tag === C || b.tag === E)
          lX(o, b.stateNode);
        else if (b.tag !== w) {
          if (b.child !== null) {
            b.child.return = b, b = b.child;
            continue;
          }
        }
        if (b === a)
          return;
        for (; b.sibling === null; ) {
          if (b.return === null || b.return === a)
            return;
          b = b.return;
        }
        b.sibling.return = b.return, b = b.sibling;
      }
    }, EI = function(o, a) {
    }, ON = function(o, a, p, S, b) {
      var T = o.memoizedProps;
      if (T !== S) {
        var D = a.stateNode, N = vT(), $ = uX(D, p, T, S, b, N);
        a.updateQueue = $, $ && Gm(a);
      }
    }, jN = function(o, a, p, S) {
      p !== S && Gm(a);
    };
    function NS(o, a) {
      if (!_o())
        switch (o.tailMode) {
          case "hidden": {
            for (var p = o.tail, S = null; p !== null; )
              p.alternate !== null && (S = p), p = p.sibling;
            S === null ? o.tail = null : S.sibling = null;
            break;
          }
          case "collapsed": {
            for (var b = o.tail, T = null; b !== null; )
              b.alternate !== null && (T = b), b = b.sibling;
            T === null ? !a && o.tail !== null ? o.tail.sibling = null : o.tail = null : T.sibling = null;
            break;
          }
        }
    }
    function To(o) {
      var a = o.alternate !== null && o.alternate.child === o.child, p = je, S = Rt;
      if (a) {
        if ((o.mode & _n) !== Mt) {
          for (var $ = o.selfBaseDuration, G = o.child; G !== null; )
            p = nn(p, nn(G.lanes, G.childLanes)), S |= G.subtreeFlags & fi, S |= G.flags & fi, $ += G.treeBaseDuration, G = G.sibling;
          o.treeBaseDuration = $;
        } else
          for (var X = o.child; X !== null; )
            p = nn(p, nn(X.lanes, X.childLanes)), S |= X.subtreeFlags & fi, S |= X.flags & fi, X.return = o, X = X.sibling;
        o.subtreeFlags |= S;
      } else {
        if ((o.mode & _n) !== Mt) {
          for (var b = o.actualDuration, T = o.selfBaseDuration, D = o.child; D !== null; )
            p = nn(p, nn(D.lanes, D.childLanes)), S |= D.subtreeFlags, S |= D.flags, b += D.actualDuration, T += D.treeBaseDuration, D = D.sibling;
          o.actualDuration = b, o.treeBaseDuration = T;
        } else
          for (var N = o.child; N !== null; )
            p = nn(p, nn(N.lanes, N.childLanes)), S |= N.subtreeFlags, S |= N.flags, N.return = o, N = N.sibling;
        o.subtreeFlags |= S;
      }
      return o.childLanes = p, a;
    }
    function $Q(o, a, p) {
      if (_Z() && (a.mode & pn) !== Mt && (a.flags & hn) === Rt)
        return f2(a), Lm(), a.flags |= Wr | qu | ta, !1;
      var S = b0(a);
      if (p !== null && p.dehydrated !== null)
        if (o === null) {
          if (!S)
            throw new Error("A dehydrated suspense component was completed without a hydrated node. This is probably a bug in React.");
          if (CZ(a), To(a), (a.mode & _n) !== Mt) {
            var b = p !== null;
            if (b) {
              var T = a.child;
              T !== null && (a.treeBaseDuration -= T.treeBaseDuration);
            }
          }
          return !1;
        } else {
          if (Lm(), (a.flags & hn) === Rt && (a.memoizedState = null), a.flags |= Sn, To(a), (a.mode & _n) !== Mt) {
            var D = p !== null;
            if (D) {
              var N = a.child;
              N !== null && (a.treeBaseDuration -= N.treeBaseDuration);
            }
          }
          return !1;
        }
      else
        return h2(), !0;
    }
    function LN(o, a, p) {
      var S = a.pendingProps;
      switch (XP(a), a.tag) {
        case y:
        case re:
        case V:
        case h:
        case O:
        case P:
        case I:
        case z:
        case k:
        case H:
          return To(a), null;
        case g: {
          var b = a.type;
          return iu(b) && m0(a), To(a), null;
        }
        case v: {
          var T = a.stateNode;
          if (Um(a), WP(a), CT(), T.pendingContext && (T.context = T.pendingContext, T.pendingContext = null), o === null || o.child === null) {
            var D = b0(a);
            if (D)
              Gm(a);
            else if (o !== null) {
              var N = o.memoizedState;
              // Check if this is a client root
              (!N.isDehydrated || // Check if we reverted to client rendering (e.g. due to an error)
              (a.flags & Wr) !== Rt) && (a.flags |= ea, h2());
            }
          }
          return EI(o, a), To(a), null;
        }
        case C: {
          ST(a);
          var $ = I2(), G = a.type;
          if (o !== null && a.stateNode != null)
            ON(o, a, G, S, $), o.ref !== a.ref && AN(a);
          else {
            if (!S) {
              if (a.stateNode === null)
                throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
              return To(a), null;
            }
            var X = vT(), fe = b0(a);
            if (fe)
              wZ(a, $, X) && Gm(a);
            else {
              var ue = aX(G, S, $, X, a);
              DN(ue, a, !1, !1), a.stateNode = ue, cX(ue, G, S, $) && Gm(a);
            }
            a.ref !== null && AN(a);
          }
          return To(a), null;
        }
        case E: {
          var _e = S;
          if (o && a.stateNode != null) {
            var Ie = o.memoizedProps;
            jN(o, a, Ie, _e);
          } else {
            if (typeof _e != "string" && a.stateNode === null)
              throw new Error("We must have new props for new mounts. This error is likely caused by a bug in React. Please file an issue.");
            var Me = I2(), st = vT(), Dt = b0(a);
            Dt ? bZ(a) && Gm(a) : a.stateNode = dX(_e, Me, st, a);
          }
          return To(a), null;
        }
        case F: {
          Bm(a);
          var Tt = a.memoizedState;
          if (o === null || o.memoizedState !== null && o.memoizedState.dehydrated !== null) {
            var Dn = $Q(o, a, Tt);
            if (!Dn)
              return a.flags & ta ? a : null;
          }
          if ((a.flags & hn) !== Rt)
            return a.lanes = p, (a.mode & _n) !== Mt && qT(a), a;
          var En = Tt !== null, xe = o !== null && o.memoizedState !== null;
          if (En !== xe && En) {
            var Ae = a.child;
            if (Ae.flags |= hl, (a.mode & pn) !== Mt) {
              var we = o === null && (a.memoizedProps.unstable_avoidThisFallback !== !0 || !0);
              we || xT(sc.current, M2) ? BJ() : BI();
            }
          }
          var Ge = a.updateQueue;
          if (Ge !== null && (a.flags |= Sn), To(a), (a.mode & _n) !== Mt && En) {
            var pt = a.child;
            pt !== null && (a.treeBaseDuration -= pt.treeBaseDuration);
          }
          return null;
        }
        case w:
          return Um(a), EI(o, a), o === null && iZ(a.stateNode.containerInfo), To(a), null;
        case L:
          var ut = a.type._context;
          return uT(ut, a), To(a), null;
        case q: {
          var $t = a.type;
          return iu($t) && m0(a), To(a), null;
        }
        case ie: {
          Bm(a);
          var Xt = a.memoizedState;
          if (Xt === null)
            return To(a), null;
          var fr = (a.flags & hn) !== Rt, Vn = Xt.rendering;
          if (Vn === null)
            if (fr)
              NS(Xt, !1);
            else {
              var bi = VJ() && (o === null || (o.flags & hn) === Rt);
              if (!bi)
                for (var Kn = a.child; Kn !== null; ) {
                  var gi = F0(Kn);
                  if (gi !== null) {
                    fr = !0, a.flags |= hn, NS(Xt, !1);
                    var as = gi.updateQueue;
                    return as !== null && (a.updateQueue = as, a.flags |= Sn), a.subtreeFlags = Rt, AZ(a, p), Hf(a, wT(sc.current, ES)), a.child;
                  }
                  Kn = Kn.sibling;
                }
              Xt.tail !== null && Jr() > r3() && (a.flags |= hn, fr = !0, NS(Xt, !1), a.lanes = bb);
            }
          else {
            if (!fr) {
              var Ao = F0(Vn);
              if (Ao !== null) {
                a.flags |= hn, fr = !0;
                var Ka = Ao.updateQueue;
                if (Ka !== null && (a.updateQueue = Ka, a.flags |= Sn), NS(Xt, !0), Xt.tail === null && Xt.tailMode === "hidden" && !Vn.alternate && !_o())
                  return To(a), null;
              } else // The time it took to render last row is greater than the remaining
              // time we have to render. So rendering one more row would likely
              // exceed it.
              Jr() * 2 - Xt.renderingStartTime > r3() && p !== As && (a.flags |= hn, fr = !0, NS(Xt, !1), a.lanes = bb);
            }
            if (Xt.isBackwards)
              Vn.sibling = a.child, a.child = Vn;
            else {
              var Us = Xt.last;
              Us !== null ? Us.sibling = Vn : a.child = Vn, Xt.last = Vn;
            }
          }
          if (Xt.tail !== null) {
            var $s = Xt.tail;
            Xt.rendering = $s, Xt.tail = $s.sibling, Xt.renderingStartTime = Jr(), $s.sibling = null;
            var ls = sc.current;
            return fr ? ls = wT(ls, ES) : ls = $m(ls), Hf(a, ls), $s;
          }
          return To(a), null;
        }
        case W:
          break;
        case Y:
        case oe: {
          $I(a);
          var _d = a.memoizedState, ty = _d !== null;
          if (o !== null) {
            var JS = o.memoizedState, fu = JS !== null;
            fu !== ty && (a.flags |= hl);
          }
          return !ty || (a.mode & pn) === Mt ? To(a) : ts(du, As) && (To(a), a.subtreeFlags & (ci | Sn) && (a.flags |= hl)), null;
        }
        case le:
          return null;
        case ce:
          return null;
      }
      throw new Error("Unknown unit of work tag (" + a.tag + "). This error is likely caused by a bug in React. Please file an issue.");
    }
    function BQ(o, a, p) {
      switch (XP(a), a.tag) {
        case g: {
          var S = a.type;
          iu(S) && m0(a);
          var b = a.flags;
          return b & ta ? (a.flags = b & -65537 | hn, (a.mode & _n) !== Mt && qT(a), a) : null;
        }
        case v: {
          a.stateNode, Um(a), WP(a), CT();
          var T = a.flags;
          return (T & ta) !== Rt && (T & hn) === Rt ? (a.flags = T & -65537 | hn, a) : null;
        }
        case C:
          return ST(a), null;
        case F: {
          Bm(a);
          var D = a.memoizedState;
          if (D !== null && D.dehydrated !== null) {
            if (a.alternate === null)
              throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in React. Please file an issue.");
            Lm();
          }
          var N = a.flags;
          return N & ta ? (a.flags = N & -65537 | hn, (a.mode & _n) !== Mt && qT(a), a) : null;
        }
        case ie:
          return Bm(a), null;
        case w:
          return Um(a), null;
        case L:
          var $ = a.type._context;
          return uT($, a), null;
        case Y:
        case oe:
          return $I(a), null;
        case le:
          return null;
        default:
          return null;
      }
    }
    function NN(o, a, p) {
      switch (XP(a), a.tag) {
        case g: {
          var S = a.type.childContextTypes;
          S != null && m0(a);
          break;
        }
        case v: {
          a.stateNode, Um(a), WP(a), CT();
          break;
        }
        case C: {
          ST(a);
          break;
        }
        case w:
          Um(a);
          break;
        case F:
          Bm(a);
          break;
        case ie:
          Bm(a);
          break;
        case L:
          var b = a.type._context;
          uT(b, a);
          break;
        case Y:
        case oe:
          $I(a);
          break;
      }
    }
    var FN = null;
    FN = /* @__PURE__ */ new Set();
    var l1 = !1, Io = !1, HQ = typeof WeakSet == "function" ? WeakSet : Set, wt = null, qm = null, Ym = null;
    function VQ(o) {
      Js(null, function() {
        throw o;
      }), pv();
    }
    var KQ = function(o, a) {
      if (a.props = o.memoizedProps, a.state = o.memoizedState, o.mode & _n)
        try {
          cu(), a.componentWillUnmount();
        } finally {
          lu(o);
        }
      else
        a.componentWillUnmount();
    };
    function zN(o, a) {
      try {
        Wf(Xi, o);
      } catch (p) {
        Cr(o, a, p);
      }
    }
    function _I(o, a, p) {
      try {
        KQ(o, p);
      } catch (S) {
        Cr(o, a, S);
      }
    }
    function WQ(o, a, p) {
      try {
        p.componentDidMount();
      } catch (S) {
        Cr(o, a, S);
      }
    }
    function UN(o, a) {
      try {
        BN(o);
      } catch (p) {
        Cr(o, a, p);
      }
    }
    function Xm(o, a) {
      var p = o.ref;
      if (p !== null)
        if (typeof p == "function") {
          var S;
          try {
            if (De && yt && o.mode & _n)
              try {
                cu(), S = p(null);
              } finally {
                lu(o);
              }
            else
              S = p(null);
          } catch (b) {
            Cr(o, a, b);
          }
          typeof S == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ut(o));
        } else
          p.current = null;
    }
    function c1(o, a, p) {
      try {
        p();
      } catch (S) {
        Cr(o, a, S);
      }
    }
    var $N = !1;
    function GQ(o, a) {
      oX(o.containerInfo), wt = a, qQ();
      var p = $N;
      return $N = !1, p;
    }
    function qQ() {
      for (; wt !== null; ) {
        var o = wt, a = o.child;
        (o.subtreeFlags & $c) !== Rt && a !== null ? (a.return = o, wt = a) : YQ();
      }
    }
    function YQ() {
      for (; wt !== null; ) {
        var o = wt;
        $n(o);
        try {
          XQ(o);
        } catch (p) {
          Cr(o, o.return, p);
        }
        kr();
        var a = o.sibling;
        if (a !== null) {
          a.return = o.return, wt = a;
          return;
        }
        wt = o.return;
      }
    }
    function XQ(o) {
      var a = o.alternate, p = o.flags;
      if ((p & ea) !== Rt) {
        switch ($n(o), o.tag) {
          case h:
          case O:
          case V:
            break;
          case g: {
            if (a !== null) {
              var S = a.memoizedProps, b = a.memoizedState, T = o.stateNode;
              o.type === o.elementType && !jp && (T.props !== o.memoizedProps && c("Expected %s props to match memoized props before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(o) || "instance"), T.state !== o.memoizedState && c("Expected %s state to match memoized state before getSnapshotBeforeUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(o) || "instance"));
              var D = T.getSnapshotBeforeUpdate(o.elementType === o.type ? S : lc(o.type, S), b);
              {
                var N = FN;
                D === void 0 && !N.has(o.type) && (N.add(o.type), c("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) must be returned. You have returned undefined.", Ut(o)));
              }
              T.__reactInternalSnapshotBeforeUpdate = D;
            }
            break;
          }
          case v: {
            {
              var $ = o.stateNode;
              RX($.containerInfo);
            }
            break;
          }
          case C:
          case E:
          case w:
          case q:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
        kr();
      }
    }
    function uc(o, a, p) {
      var S = a.updateQueue, b = S !== null ? S.lastEffect : null;
      if (b !== null) {
        var T = b.next, D = T;
        do {
          if ((D.tag & o) === o) {
            var N = D.destroy;
            D.destroy = void 0, N !== void 0 && ((o & Po) !== ca ? Kc(a) : (o & Xi) !== ca && Pv(a), (o & ou) !== ca && XS(!0), c1(a, p, N), (o & ou) !== ca && XS(!1), (o & Po) !== ca ? Dg() : (o & Xi) !== ca && yf());
          }
          D = D.next;
        } while (D !== T);
      }
    }
    function Wf(o, a) {
      var p = a.updateQueue, S = p !== null ? p.lastEffect : null;
      if (S !== null) {
        var b = S.next, T = b;
        do {
          if ((T.tag & o) === o) {
            (o & Po) !== ca ? xb(a) : (o & Xi) !== ca && wb(a);
            var D = T.create;
            (o & ou) !== ca && XS(!0), T.destroy = D(), (o & ou) !== ca && XS(!1), (o & Po) !== ca ? Jl() : (o & Xi) !== ca && Og();
            {
              var N = T.destroy;
              if (N !== void 0 && typeof N != "function") {
                var $ = void 0;
                (T.tag & Xi) !== Rt ? $ = "useLayoutEffect" : (T.tag & ou) !== Rt ? $ = "useInsertionEffect" : $ = "useEffect";
                var G = void 0;
                N === null ? G = " You returned null. If your effect does not require clean up, return undefined (or nothing)." : typeof N.then == "function" ? G = `

It looks like you wrote ` + $ + `(async () => ...) or returned a Promise. Instead, write the async function inside your effect and call it immediately:

` + $ + `(() => {
  async function fetchData() {
    // You can await here
    const response = await MyAPI.getData(someId);
    // ...
  }
  fetchData();
}, [someId]); // Or [] if effect doesn't need props or state

Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching` : G = " You returned: " + N, c("%s must not return anything besides a function, which is used for clean-up.%s", $, G);
              }
            }
          }
          T = T.next;
        } while (T !== b);
      }
    }
    function ZQ(o, a) {
      if ((a.flags & Sn) !== Rt)
        switch (a.tag) {
          case z: {
            var p = a.stateNode.passiveEffectDuration, S = a.memoizedProps, b = S.id, T = S.onPostCommit, D = rN(), N = a.alternate === null ? "mount" : "update";
            nN() && (N = "nested-update"), typeof T == "function" && T(b, N, p, D);
            var $ = a.return;
            e: for (; $ !== null; ) {
              switch ($.tag) {
                case v:
                  var G = $.stateNode;
                  G.passiveEffectDuration += p;
                  break e;
                case z:
                  var X = $.stateNode;
                  X.passiveEffectDuration += p;
                  break e;
              }
              $ = $.return;
            }
            break;
          }
        }
    }
    function QQ(o, a, p, S) {
      if ((p.flags & Bc) !== Rt)
        switch (p.tag) {
          case h:
          case O:
          case V: {
            if (!Io)
              if (p.mode & _n)
                try {
                  cu(), Wf(Xi | Yi, p);
                } finally {
                  lu(p);
                }
              else
                Wf(Xi | Yi, p);
            break;
          }
          case g: {
            var b = p.stateNode;
            if (p.flags & Sn && !Io)
              if (a === null)
                if (p.type === p.elementType && !jp && (b.props !== p.memoizedProps && c("Expected %s props to match memoized props before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(p) || "instance"), b.state !== p.memoizedState && c("Expected %s state to match memoized state before componentDidMount. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(p) || "instance")), p.mode & _n)
                  try {
                    cu(), b.componentDidMount();
                  } finally {
                    lu(p);
                  }
                else
                  b.componentDidMount();
              else {
                var T = p.elementType === p.type ? a.memoizedProps : lc(p.type, a.memoizedProps), D = a.memoizedState;
                if (p.type === p.elementType && !jp && (b.props !== p.memoizedProps && c("Expected %s props to match memoized props before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(p) || "instance"), b.state !== p.memoizedState && c("Expected %s state to match memoized state before componentDidUpdate. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(p) || "instance")), p.mode & _n)
                  try {
                    cu(), b.componentDidUpdate(T, D, b.__reactInternalSnapshotBeforeUpdate);
                  } finally {
                    lu(p);
                  }
                else
                  b.componentDidUpdate(T, D, b.__reactInternalSnapshotBeforeUpdate);
              }
            var N = p.updateQueue;
            N !== null && (p.type === p.elementType && !jp && (b.props !== p.memoizedProps && c("Expected %s props to match memoized props before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.props`. Please file an issue.", Ut(p) || "instance"), b.state !== p.memoizedState && c("Expected %s state to match memoized state before processing the update queue. This might either be because of a bug in React, or because a component reassigns its own `this.state`. Please file an issue.", Ut(p) || "instance")), T2(p, N, b));
            break;
          }
          case v: {
            var $ = p.updateQueue;
            if ($ !== null) {
              var G = null;
              if (p.child !== null)
                switch (p.child.tag) {
                  case C:
                    G = p.child.stateNode;
                    break;
                  case g:
                    G = p.child.stateNode;
                    break;
                }
              T2(p, $, G);
            }
            break;
          }
          case C: {
            var X = p.stateNode;
            if (a === null && p.flags & Sn) {
              var fe = p.type, ue = p.memoizedProps;
              mX(X, fe, ue);
            }
            break;
          }
          case E:
            break;
          case w:
            break;
          case z: {
            {
              var _e = p.memoizedProps, Ie = _e.onCommit, Me = _e.onRender, st = p.stateNode.effectDuration, Dt = rN(), Tt = a === null ? "mount" : "update";
              nN() && (Tt = "nested-update"), typeof Me == "function" && Me(p.memoizedProps.id, Tt, p.actualDuration, p.treeBaseDuration, p.actualStartTime, Dt);
              {
                typeof Ie == "function" && Ie(p.memoizedProps.id, Tt, st, Dt), YJ(p);
                var Dn = p.return;
                e: for (; Dn !== null; ) {
                  switch (Dn.tag) {
                    case v:
                      var En = Dn.stateNode;
                      En.effectDuration += st;
                      break e;
                    case z:
                      var xe = Dn.stateNode;
                      xe.effectDuration += st;
                      break e;
                  }
                  Dn = Dn.return;
                }
              }
            }
            break;
          }
          case F: {
            sJ(o, p);
            break;
          }
          case ie:
          case q:
          case W:
          case Y:
          case oe:
          case ce:
            break;
          default:
            throw new Error("This unit of work tag should not have side-effects. This error is likely caused by a bug in React. Please file an issue.");
        }
      Io || p.flags & ui && BN(p);
    }
    function JQ(o) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          if (o.mode & _n)
            try {
              cu(), zN(o, o.return);
            } finally {
              lu(o);
            }
          else
            zN(o, o.return);
          break;
        }
        case g: {
          var a = o.stateNode;
          typeof a.componentDidMount == "function" && WQ(o, o.return, a), UN(o, o.return);
          break;
        }
        case C: {
          UN(o, o.return);
          break;
        }
      }
    }
    function eJ(o, a) {
      for (var p = null, S = o; ; ) {
        if (S.tag === C) {
          if (p === null) {
            p = S;
            try {
              var b = S.stateNode;
              a ? PX(b) : IX(S.stateNode, S.memoizedProps);
            } catch (D) {
              Cr(o, o.return, D);
            }
          }
        } else if (S.tag === E) {
          if (p === null)
            try {
              var T = S.stateNode;
              a ? TX(T) : kX(T, S.memoizedProps);
            } catch (D) {
              Cr(o, o.return, D);
            }
        } else if (!((S.tag === Y || S.tag === oe) && S.memoizedState !== null && S !== o)) {
          if (S.child !== null) {
            S.child.return = S, S = S.child;
            continue;
          }
        }
        if (S === o)
          return;
        for (; S.sibling === null; ) {
          if (S.return === null || S.return === o)
            return;
          p === S && (p = null), S = S.return;
        }
        p === S && (p = null), S.sibling.return = S.return, S = S.sibling;
      }
    }
    function BN(o) {
      var a = o.ref;
      if (a !== null) {
        var p = o.stateNode, S;
        switch (o.tag) {
          case C:
            S = p;
            break;
          default:
            S = p;
        }
        if (typeof a == "function") {
          var b;
          if (o.mode & _n)
            try {
              cu(), b = a(S);
            } finally {
              lu(o);
            }
          else
            b = a(S);
          typeof b == "function" && c("Unexpected return value from a callback ref in %s. A callback ref should not return a function.", Ut(o));
        } else
          a.hasOwnProperty("current") || c("Unexpected ref object provided for %s. Use either a ref-setter function or React.createRef().", Ut(o)), a.current = S;
      }
    }
    function tJ(o) {
      var a = o.alternate;
      a !== null && (a.return = null), o.return = null;
    }
    function HN(o) {
      var a = o.alternate;
      a !== null && (o.alternate = null, HN(a));
      {
        if (o.child = null, o.deletions = null, o.sibling = null, o.tag === C) {
          var p = o.stateNode;
          p !== null && aZ(p);
        }
        o.stateNode = null, o._debugOwner = null, o.return = null, o.dependencies = null, o.memoizedProps = null, o.memoizedState = null, o.pendingProps = null, o.stateNode = null, o.updateQueue = null;
      }
    }
    function nJ(o) {
      for (var a = o.return; a !== null; ) {
        if (VN(a))
          return a;
        a = a.return;
      }
      throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
    }
    function VN(o) {
      return o.tag === C || o.tag === v || o.tag === w;
    }
    function KN(o) {
      var a = o;
      e: for (; ; ) {
        for (; a.sibling === null; ) {
          if (a.return === null || VN(a.return))
            return null;
          a = a.return;
        }
        for (a.sibling.return = a.return, a = a.sibling; a.tag !== C && a.tag !== E && a.tag !== J; ) {
          if (a.flags & ci || a.child === null || a.tag === w)
            continue e;
          a.child.return = a, a = a.child;
        }
        if (!(a.flags & ci))
          return a.stateNode;
      }
    }
    function rJ(o) {
      var a = nJ(o);
      switch (a.tag) {
        case C: {
          var p = a.stateNode;
          a.flags & cr && (GL(p), a.flags &= -33);
          var S = KN(o);
          TI(o, S, p);
          break;
        }
        case v:
        case w: {
          var b = a.stateNode.containerInfo, T = KN(o);
          PI(o, T, b);
          break;
        }
        // eslint-disable-next-line-no-fallthrough
        default:
          throw new Error("Invalid host parent fiber. This error is likely caused by a bug in React. Please file an issue.");
      }
    }
    function PI(o, a, p) {
      var S = o.tag, b = S === C || S === E;
      if (b) {
        var T = o.stateNode;
        a ? bX(p, T, a) : xX(p, T);
      } else if (S !== w) {
        var D = o.child;
        if (D !== null) {
          PI(D, a, p);
          for (var N = D.sibling; N !== null; )
            PI(N, a, p), N = N.sibling;
        }
      }
    }
    function TI(o, a, p) {
      var S = o.tag, b = S === C || S === E;
      if (b) {
        var T = o.stateNode;
        a ? wX(p, T, a) : SX(p, T);
      } else if (S !== w) {
        var D = o.child;
        if (D !== null) {
          TI(D, a, p);
          for (var N = D.sibling; N !== null; )
            TI(N, a, p), N = N.sibling;
        }
      }
    }
    var ko = null, dc = !1;
    function iJ(o, a, p) {
      {
        var S = a;
        e: for (; S !== null; ) {
          switch (S.tag) {
            case C: {
              ko = S.stateNode, dc = !1;
              break e;
            }
            case v: {
              ko = S.stateNode.containerInfo, dc = !0;
              break e;
            }
            case w: {
              ko = S.stateNode.containerInfo, dc = !0;
              break e;
            }
          }
          S = S.return;
        }
        if (ko === null)
          throw new Error("Expected to find a host parent. This error is likely caused by a bug in React. Please file an issue.");
        WN(o, a, p), ko = null, dc = !1;
      }
      tJ(p);
    }
    function Gf(o, a, p) {
      for (var S = p.child; S !== null; )
        WN(o, a, S), S = S.sibling;
    }
    function WN(o, a, p) {
      switch (mf(p), p.tag) {
        case C:
          Io || Xm(p, a);
        // eslint-disable-next-line-no-fallthrough
        case E: {
          {
            var S = ko, b = dc;
            ko = null, Gf(o, a, p), ko = S, dc = b, ko !== null && (dc ? EX(ko, p.stateNode) : CX(ko, p.stateNode));
          }
          return;
        }
        case J: {
          ko !== null && (dc ? _X(ko, p.stateNode) : FP(ko, p.stateNode));
          return;
        }
        case w: {
          {
            var T = ko, D = dc;
            ko = p.stateNode.containerInfo, dc = !0, Gf(o, a, p), ko = T, dc = D;
          }
          return;
        }
        case h:
        case O:
        case H:
        case V: {
          if (!Io) {
            var N = p.updateQueue;
            if (N !== null) {
              var $ = N.lastEffect;
              if ($ !== null) {
                var G = $.next, X = G;
                do {
                  var fe = X, ue = fe.destroy, _e = fe.tag;
                  ue !== void 0 && ((_e & ou) !== ca ? c1(p, a, ue) : (_e & Xi) !== ca && (Pv(p), p.mode & _n ? (cu(), c1(p, a, ue), lu(p)) : c1(p, a, ue), yf())), X = X.next;
                } while (X !== G);
              }
            }
          }
          Gf(o, a, p);
          return;
        }
        case g: {
          if (!Io) {
            Xm(p, a);
            var Ie = p.stateNode;
            typeof Ie.componentWillUnmount == "function" && _I(p, a, Ie);
          }
          Gf(o, a, p);
          return;
        }
        case W: {
          Gf(o, a, p);
          return;
        }
        case Y: {
          if (
            // TODO: Remove this dead flag
            p.mode & pn
          ) {
            var Me = Io;
            Io = Me || p.memoizedState !== null, Gf(o, a, p), Io = Me;
          } else
            Gf(o, a, p);
          break;
        }
        default: {
          Gf(o, a, p);
          return;
        }
      }
    }
    function oJ(o) {
      o.memoizedState;
    }
    function sJ(o, a) {
      var p = a.memoizedState;
      if (p === null) {
        var S = a.alternate;
        if (S !== null) {
          var b = S.memoizedState;
          if (b !== null) {
            var T = b.dehydrated;
            T !== null && VX(T);
          }
        }
      }
    }
    function GN(o) {
      var a = o.updateQueue;
      if (a !== null) {
        o.updateQueue = null;
        var p = o.stateNode;
        p === null && (p = o.stateNode = new HQ()), a.forEach(function(S) {
          var b = nee.bind(null, o, S);
          if (!p.has(S)) {
            if (p.add(S), uo)
              if (qm !== null && Ym !== null)
                YS(Ym, qm);
              else
                throw Error("Expected finished root and lanes to be set. This is a bug in React.");
            S.then(b, b);
          }
        });
      }
    }
    function aJ(o, a, p) {
      qm = p, Ym = o, $n(a), qN(a, o), $n(a), qm = null, Ym = null;
    }
    function fc(o, a, p) {
      var S = a.deletions;
      if (S !== null)
        for (var b = 0; b < S.length; b++) {
          var T = S[b];
          try {
            iJ(o, a, T);
          } catch ($) {
            Cr(T, a, $);
          }
        }
      var D = Is();
      if (a.subtreeFlags & pf)
        for (var N = a.child; N !== null; )
          $n(N), qN(N, o), N = N.sibling;
      $n(D);
    }
    function qN(o, a, p) {
      var S = o.alternate, b = o.flags;
      switch (o.tag) {
        case h:
        case O:
        case H:
        case V: {
          if (fc(a, o), uu(o), b & Sn) {
            try {
              uc(ou | Yi, o, o.return), Wf(ou | Yi, o);
            } catch ($t) {
              Cr(o, o.return, $t);
            }
            if (o.mode & _n) {
              try {
                cu(), uc(Xi | Yi, o, o.return);
              } catch ($t) {
                Cr(o, o.return, $t);
              }
              lu(o);
            } else
              try {
                uc(Xi | Yi, o, o.return);
              } catch ($t) {
                Cr(o, o.return, $t);
              }
          }
          return;
        }
        case g: {
          fc(a, o), uu(o), b & ui && S !== null && Xm(S, S.return);
          return;
        }
        case C: {
          fc(a, o), uu(o), b & ui && S !== null && Xm(S, S.return);
          {
            if (o.flags & cr) {
              var T = o.stateNode;
              try {
                GL(T);
              } catch ($t) {
                Cr(o, o.return, $t);
              }
            }
            if (b & Sn) {
              var D = o.stateNode;
              if (D != null) {
                var N = o.memoizedProps, $ = S !== null ? S.memoizedProps : N, G = o.type, X = o.updateQueue;
                if (o.updateQueue = null, X !== null)
                  try {
                    yX(D, X, G, $, N, o);
                  } catch ($t) {
                    Cr(o, o.return, $t);
                  }
              }
            }
          }
          return;
        }
        case E: {
          if (fc(a, o), uu(o), b & Sn) {
            if (o.stateNode === null)
              throw new Error("This should have a text node initialized. This error is likely caused by a bug in React. Please file an issue.");
            var fe = o.stateNode, ue = o.memoizedProps, _e = S !== null ? S.memoizedProps : ue;
            try {
              vX(fe, _e, ue);
            } catch ($t) {
              Cr(o, o.return, $t);
            }
          }
          return;
        }
        case v: {
          if (fc(a, o), uu(o), b & Sn && S !== null) {
            var Ie = S.memoizedState;
            if (Ie.isDehydrated)
              try {
                HX(a.containerInfo);
              } catch ($t) {
                Cr(o, o.return, $t);
              }
          }
          return;
        }
        case w: {
          fc(a, o), uu(o);
          return;
        }
        case F: {
          fc(a, o), uu(o);
          var Me = o.child;
          if (Me.flags & hl) {
            var st = Me.stateNode, Dt = Me.memoizedState, Tt = Dt !== null;
            if (st.isHidden = Tt, Tt) {
              var Dn = Me.alternate !== null && Me.alternate.memoizedState !== null;
              Dn || $J();
            }
          }
          if (b & Sn) {
            try {
              oJ(o);
            } catch ($t) {
              Cr(o, o.return, $t);
            }
            GN(o);
          }
          return;
        }
        case Y: {
          var En = S !== null && S.memoizedState !== null;
          if (
            // TODO: Remove this dead flag
            o.mode & pn
          ) {
            var xe = Io;
            Io = xe || En, fc(a, o), Io = xe;
          } else
            fc(a, o);
          if (uu(o), b & hl) {
            var Ae = o.stateNode, we = o.memoizedState, Ge = we !== null, pt = o;
            if (Ae.isHidden = Ge, Ge && !En && (pt.mode & pn) !== Mt) {
              wt = pt;
              for (var ut = pt.child; ut !== null; )
                wt = ut, cJ(ut), ut = ut.sibling;
            }
            eJ(pt, Ge);
          }
          return;
        }
        case ie: {
          fc(a, o), uu(o), b & Sn && GN(o);
          return;
        }
        case W:
          return;
        default: {
          fc(a, o), uu(o);
          return;
        }
      }
    }
    function uu(o) {
      var a = o.flags;
      if (a & ci) {
        try {
          rJ(o);
        } catch (p) {
          Cr(o, o.return, p);
        }
        o.flags &= -3;
      }
      a & di && (o.flags &= -4097);
    }
    function lJ(o, a, p) {
      qm = p, Ym = a, wt = o, YN(o, a, p), qm = null, Ym = null;
    }
    function YN(o, a, p) {
      for (var S = (o.mode & pn) !== Mt; wt !== null; ) {
        var b = wt, T = b.child;
        if (b.tag === Y && S) {
          var D = b.memoizedState !== null, N = D || l1;
          if (N) {
            II(o, a, p);
            continue;
          } else {
            var $ = b.alternate, G = $ !== null && $.memoizedState !== null, X = G || Io, fe = l1, ue = Io;
            l1 = N, Io = X, Io && !ue && (wt = b, uJ(b));
            for (var _e = T; _e !== null; )
              wt = _e, YN(
                _e,
                // New root; bubble back up to here and stop.
                a,
                p
              ), _e = _e.sibling;
            wt = b, l1 = fe, Io = ue, II(o, a, p);
            continue;
          }
        }
        (b.subtreeFlags & Bc) !== Rt && T !== null ? (T.return = b, wt = T) : II(o, a, p);
      }
    }
    function II(o, a, p) {
      for (; wt !== null; ) {
        var S = wt;
        if ((S.flags & Bc) !== Rt) {
          var b = S.alternate;
          $n(S);
          try {
            QQ(a, b, S, p);
          } catch (D) {
            Cr(S, S.return, D);
          }
          kr();
        }
        if (S === o) {
          wt = null;
          return;
        }
        var T = S.sibling;
        if (T !== null) {
          T.return = S.return, wt = T;
          return;
        }
        wt = S.return;
      }
    }
    function cJ(o) {
      for (; wt !== null; ) {
        var a = wt, p = a.child;
        switch (a.tag) {
          case h:
          case O:
          case H:
          case V: {
            if (a.mode & _n)
              try {
                cu(), uc(Xi, a, a.return);
              } finally {
                lu(a);
              }
            else
              uc(Xi, a, a.return);
            break;
          }
          case g: {
            Xm(a, a.return);
            var S = a.stateNode;
            typeof S.componentWillUnmount == "function" && _I(a, a.return, S);
            break;
          }
          case C: {
            Xm(a, a.return);
            break;
          }
          case Y: {
            var b = a.memoizedState !== null;
            if (b) {
              XN(o);
              continue;
            }
            break;
          }
        }
        p !== null ? (p.return = a, wt = p) : XN(o);
      }
    }
    function XN(o) {
      for (; wt !== null; ) {
        var a = wt;
        if (a === o) {
          wt = null;
          return;
        }
        var p = a.sibling;
        if (p !== null) {
          p.return = a.return, wt = p;
          return;
        }
        wt = a.return;
      }
    }
    function uJ(o) {
      for (; wt !== null; ) {
        var a = wt, p = a.child;
        if (a.tag === Y) {
          var S = a.memoizedState !== null;
          if (S) {
            ZN(o);
            continue;
          }
        }
        p !== null ? (p.return = a, wt = p) : ZN(o);
      }
    }
    function ZN(o) {
      for (; wt !== null; ) {
        var a = wt;
        $n(a);
        try {
          JQ(a);
        } catch (S) {
          Cr(a, a.return, S);
        }
        if (kr(), a === o) {
          wt = null;
          return;
        }
        var p = a.sibling;
        if (p !== null) {
          p.return = a.return, wt = p;
          return;
        }
        wt = a.return;
      }
    }
    function dJ(o, a, p, S) {
      wt = a, fJ(a, o, p, S);
    }
    function fJ(o, a, p, S) {
      for (; wt !== null; ) {
        var b = wt, T = b.child;
        (b.subtreeFlags & Vi) !== Rt && T !== null ? (T.return = b, wt = T) : hJ(o, a, p, S);
      }
    }
    function hJ(o, a, p, S) {
      for (; wt !== null; ) {
        var b = wt;
        if ((b.flags & Rs) !== Rt) {
          $n(b);
          try {
            pJ(a, b, p, S);
          } catch (D) {
            Cr(b, b.return, D);
          }
          kr();
        }
        if (b === o) {
          wt = null;
          return;
        }
        var T = b.sibling;
        if (T !== null) {
          T.return = b.return, wt = T;
          return;
        }
        wt = b.return;
      }
    }
    function pJ(o, a, p, S) {
      switch (a.tag) {
        case h:
        case O:
        case V: {
          if (a.mode & _n) {
            GT();
            try {
              Wf(Po | Yi, a);
            } finally {
              WT(a);
            }
          } else
            Wf(Po | Yi, a);
          break;
        }
      }
    }
    function gJ(o) {
      wt = o, mJ();
    }
    function mJ() {
      for (; wt !== null; ) {
        var o = wt, a = o.child;
        if ((wt.flags & Xo) !== Rt) {
          var p = o.deletions;
          if (p !== null) {
            for (var S = 0; S < p.length; S++) {
              var b = p[S];
              wt = b, SJ(b, o);
            }
            {
              var T = o.alternate;
              if (T !== null) {
                var D = T.child;
                if (D !== null) {
                  T.child = null;
                  do {
                    var N = D.sibling;
                    D.sibling = null, D = N;
                  } while (D !== null);
                }
              }
            }
            wt = o;
          }
        }
        (o.subtreeFlags & Vi) !== Rt && a !== null ? (a.return = o, wt = a) : yJ();
      }
    }
    function yJ() {
      for (; wt !== null; ) {
        var o = wt;
        (o.flags & Rs) !== Rt && ($n(o), vJ(o), kr());
        var a = o.sibling;
        if (a !== null) {
          a.return = o.return, wt = a;
          return;
        }
        wt = o.return;
      }
    }
    function vJ(o) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          o.mode & _n ? (GT(), uc(Po | Yi, o, o.return), WT(o)) : uc(Po | Yi, o, o.return);
          break;
        }
      }
    }
    function SJ(o, a) {
      for (; wt !== null; ) {
        var p = wt;
        $n(p), wJ(p, a), kr();
        var S = p.child;
        S !== null ? (S.return = p, wt = S) : xJ(o);
      }
    }
    function xJ(o) {
      for (; wt !== null; ) {
        var a = wt, p = a.sibling, S = a.return;
        if (HN(a), a === o) {
          wt = null;
          return;
        }
        if (p !== null) {
          p.return = S, wt = p;
          return;
        }
        wt = S;
      }
    }
    function wJ(o, a) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          o.mode & _n ? (GT(), uc(Po, o, a), WT(o)) : uc(Po, o, a);
          break;
        }
      }
    }
    function bJ(o) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          try {
            Wf(Xi | Yi, o);
          } catch (p) {
            Cr(o, o.return, p);
          }
          break;
        }
        case g: {
          var a = o.stateNode;
          try {
            a.componentDidMount();
          } catch (p) {
            Cr(o, o.return, p);
          }
          break;
        }
      }
    }
    function CJ(o) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          try {
            Wf(Po | Yi, o);
          } catch (a) {
            Cr(o, o.return, a);
          }
          break;
        }
      }
    }
    function EJ(o) {
      switch (o.tag) {
        case h:
        case O:
        case V: {
          try {
            uc(Xi | Yi, o, o.return);
          } catch (p) {
            Cr(o, o.return, p);
          }
          break;
        }
        case g: {
          var a = o.stateNode;
          typeof a.componentWillUnmount == "function" && _I(o, o.return, a);
          break;
        }
      }
    }
    function _J(o) {
      switch (o.tag) {
        case h:
        case O:
        case V:
          try {
            uc(Po | Yi, o, o.return);
          } catch (a) {
            Cr(o, o.return, a);
          }
      }
    }
    if (typeof Symbol == "function" && Symbol.for) {
      var FS = Symbol.for;
      FS("selector.component"), FS("selector.has_pseudo_class"), FS("selector.role"), FS("selector.test_id"), FS("selector.text");
    }
    var PJ = [];
    function TJ() {
      PJ.forEach(function(o) {
        return o();
      });
    }
    var IJ = r.ReactCurrentActQueue;
    function kJ(o) {
      {
        var a = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        ), p = typeof jest < "u";
        return p && a !== !1;
      }
    }
    function QN() {
      {
        var o = (
          // $FlowExpectedError – Flow doesn't know about IS_REACT_ACT_ENVIRONMENT global
          typeof IS_REACT_ACT_ENVIRONMENT < "u" ? IS_REACT_ACT_ENVIRONMENT : void 0
        );
        return !o && IJ.current !== null && c("The current testing environment is not configured to support act(...)"), o;
      }
    }
    var RJ = Math.ceil, kI = r.ReactCurrentDispatcher, RI = r.ReactCurrentOwner, Ro = r.ReactCurrentBatchConfig, hc = r.ReactCurrentActQueue, Ji = (
      /*             */
      0
    ), JN = (
      /*               */
      1
    ), Mo = (
      /*                */
      2
    ), El = (
      /*                */
      4
    ), wd = 0, zS = 1, Lp = 2, u1 = 3, US = 4, e3 = 5, MI = 6, An = Ji, Fs = null, ri = null, eo = je, du = je, AI = Nf(je), to = wd, $S = null, d1 = je, BS = je, f1 = je, HS = null, ua = null, DI = 0, t3 = 500, n3 = 1 / 0, MJ = 500, bd = null;
    function VS() {
      n3 = Jr() + MJ;
    }
    function r3() {
      return n3;
    }
    var h1 = !1, OI = null, Zm = null, Np = !1, qf = null, KS = je, jI = [], LI = null, AJ = 50, WS = 0, NI = null, FI = !1, p1 = !1, DJ = 50, Qm = 0, g1 = null, GS = ir, m1 = je, i3 = !1;
    function y1() {
      return Fs;
    }
    function zs() {
      return (An & (Mo | El)) !== Ji ? Jr() : (GS !== ir || (GS = Jr()), GS);
    }
    function Yf(o) {
      var a = o.mode;
      if ((a & pn) === Mt)
        return Nt;
      if ((An & Mo) !== Ji && eo !== je)
        return Ni(eo);
      var p = IZ() !== TZ;
      if (p) {
        if (Ro.transition !== null) {
          var S = Ro.transition;
          S._updatedFibers || (S._updatedFibers = /* @__PURE__ */ new Set()), S._updatedFibers.add(o);
        }
        return m1 === hi && (m1 = Lv()), m1;
      }
      var b = Ds();
      if (b !== hi)
        return b;
      var T = fX();
      return T;
    }
    function OJ(o) {
      var a = o.mode;
      return (a & pn) === Mt ? Nt : Ib();
    }
    function no(o, a, p, S) {
      iee(), i3 && c("useInsertionEffect must not schedule updates."), FI && (p1 = !0), Cf(o, p, S), (An & Mo) !== je && o === Fs ? aee(a) : (uo && Rb(o, a, p), lee(a), o === Fs && ((An & Mo) === Ji && (BS = nn(BS, p)), to === US && Xf(o, eo)), da(o, S), p === Nt && An === Ji && (a.mode & pn) === Mt && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
      !hc.isBatchingLegacy && (VS(), i2()));
    }
    function jJ(o, a, p) {
      var S = o.current;
      S.lanes = a, Cf(o, a, p), da(o, p);
    }
    function LJ(o) {
      return (
        // TODO: Remove outdated deferRenderPhaseUpdateToNextBatch experiment. We
        // decided not to enable it.
        (An & Mo) !== Ji
      );
    }
    function da(o, a) {
      var p = o.callbackNode;
      _b(o, a);
      var S = es(o, o === Fs ? eo : je);
      if (S === je) {
        p !== null && x3(p), o.callbackNode = null, o.callbackPriority = hi;
        return;
      }
      var b = nd(S), T = o.callbackPriority;
      if (T === b && // Special case related to `act`. If the currently scheduled task is a
      // Scheduler task, rather than an `act` task, cancel it and re-scheduled
      // on the `act` queue.
      !(hc.current !== null && p !== KI)) {
        p == null && T !== Nt && c("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
        return;
      }
      p != null && x3(p);
      var D;
      if (b === Nt)
        o.tag === Ff ? (hc.isBatchingLegacy !== null && (hc.didScheduleLegacyUpdate = !0), uZ(a3.bind(null, o))) : r2(a3.bind(null, o)), hc.current !== null ? hc.current.push(zf) : pX(function() {
          (An & (Mo | El)) === Ji && zf();
        }), D = null;
      else {
        var N;
        switch (Ab(S)) {
          case ns:
            N = Ql;
            break;
          case ra:
            N = Xh;
            break;
          case Wi:
            N = Xu;
            break;
          case lm:
            N = gf;
            break;
          default:
            N = Xu;
            break;
        }
        D = WI(N, o3.bind(null, o));
      }
      o.callbackPriority = b, o.callbackNode = D;
    }
    function o3(o, a) {
      if (eQ(), GS = ir, m1 = je, (An & (Mo | El)) !== Ji)
        throw new Error("Should not already be working.");
      var p = o.callbackNode, S = Ed();
      if (S && o.callbackNode !== p)
        return null;
      var b = es(o, o === Fs ? eo : je);
      if (b === je)
        return null;
      var T = !lp(o, b) && !Tb(o, b) && !a, D = T ? WJ(o, b) : S1(o, b);
      if (D !== wd) {
        if (D === Lp) {
          var N = em(o);
          N !== je && (b = N, D = zI(o, N));
        }
        if (D === zS) {
          var $ = $S;
          throw Fp(o, je), Xf(o, b), da(o, Jr()), $;
        }
        if (D === MI)
          Xf(o, b);
        else {
          var G = !lp(o, b), X = o.current.alternate;
          if (G && !FJ(X)) {
            if (D = S1(o, b), D === Lp) {
              var fe = em(o);
              fe !== je && (b = fe, D = zI(o, fe));
            }
            if (D === zS) {
              var ue = $S;
              throw Fp(o, je), Xf(o, b), da(o, Jr()), ue;
            }
          }
          o.finishedWork = X, o.finishedLanes = b, NJ(o, D, b);
        }
      }
      return da(o, Jr()), o.callbackNode === p ? o3.bind(null, o) : null;
    }
    function zI(o, a) {
      var p = HS;
      if (id(o)) {
        var S = Fp(o, a);
        S.flags |= Wr, rZ(o.containerInfo);
      }
      var b = S1(o, a);
      if (b !== Lp) {
        var T = ua;
        ua = p, T !== null && s3(T);
      }
      return b;
    }
    function s3(o) {
      ua === null ? ua = o : ua.push.apply(ua, o);
    }
    function NJ(o, a, p) {
      switch (a) {
        case wd:
        case zS:
          throw new Error("Root did not complete. This is a bug in React.");
        // Flow knows about invariant, so it complains if I add a break
        // statement, but eslint doesn't know about invariant, so it complains
        // if I do. eslint-disable-next-line no-fallthrough
        case Lp: {
          zp(o, ua, bd);
          break;
        }
        case u1: {
          if (Xf(o, p), tm(p) && // do not delay if we're inside an act() scope
          !w3()) {
            var S = DI + t3 - Jr();
            if (S > 10) {
              var b = es(o, je);
              if (b !== je)
                break;
              var T = o.suspendedLanes;
              if (!rd(T, p)) {
                zs(), om(o, T);
                break;
              }
              o.timeoutHandle = LP(zp.bind(null, o, ua, bd), S);
              break;
            }
          }
          zp(o, ua, bd);
          break;
        }
        case US: {
          if (Xf(o, p), sP(p))
            break;
          if (!w3()) {
            var D = Av(o, p), N = D, $ = Jr() - N, G = ree($) - $;
            if (G > 10) {
              o.timeoutHandle = LP(zp.bind(null, o, ua, bd), G);
              break;
            }
          }
          zp(o, ua, bd);
          break;
        }
        case e3: {
          zp(o, ua, bd);
          break;
        }
        default:
          throw new Error("Unknown root exit status.");
      }
    }
    function FJ(o) {
      for (var a = o; ; ) {
        if (a.flags & Mg) {
          var p = a.updateQueue;
          if (p !== null) {
            var S = p.stores;
            if (S !== null)
              for (var b = 0; b < S.length; b++) {
                var T = S[b], D = T.getSnapshot, N = T.value;
                try {
                  if (!xt(D(), N))
                    return !1;
                } catch {
                  return !1;
                }
              }
          }
        }
        var $ = a.child;
        if (a.subtreeFlags & Mg && $ !== null) {
          $.return = a, a = $;
          continue;
        }
        if (a === o)
          return !0;
        for (; a.sibling === null; ) {
          if (a.return === null || a.return === o)
            return !0;
          a = a.return;
        }
        a.sibling.return = a.return, a = a.sibling;
      }
      return !0;
    }
    function Xf(o, a) {
      a = cp(a, f1), a = cp(a, BS), Fv(o, a);
    }
    function a3(o) {
      if (tQ(), (An & (Mo | El)) !== Ji)
        throw new Error("Should not already be working.");
      Ed();
      var a = es(o, je);
      if (!ts(a, Nt))
        return da(o, Jr()), null;
      var p = S1(o, a);
      if (o.tag !== Ff && p === Lp) {
        var S = em(o);
        S !== je && (a = S, p = zI(o, S));
      }
      if (p === zS) {
        var b = $S;
        throw Fp(o, je), Xf(o, a), da(o, Jr()), b;
      }
      if (p === MI)
        throw new Error("Root did not complete. This is a bug in React.");
      var T = o.current.alternate;
      return o.finishedWork = T, o.finishedLanes = a, zp(o, ua, bd), da(o, Jr()), null;
    }
    function zJ(o, a) {
      a !== je && (up(o, nn(a, Nt)), da(o, Jr()), (An & (Mo | El)) === Ji && (VS(), zf()));
    }
    function UI(o, a) {
      var p = An;
      An |= JN;
      try {
        return o(a);
      } finally {
        An = p, An === Ji && // Treat `act` as if it's inside `batchedUpdates`, even in legacy mode.
        !hc.isBatchingLegacy && (VS(), i2());
      }
    }
    function UJ(o, a, p, S, b) {
      var T = Ds(), D = Ro.transition;
      try {
        return Ro.transition = null, xi(ns), o(a, p, S, b);
      } finally {
        xi(T), Ro.transition = D, An === Ji && VS();
      }
    }
    function Cd(o) {
      qf !== null && qf.tag === Ff && (An & (Mo | El)) === Ji && Ed();
      var a = An;
      An |= JN;
      var p = Ro.transition, S = Ds();
      try {
        return Ro.transition = null, xi(ns), o ? o() : void 0;
      } finally {
        xi(S), Ro.transition = p, An = a, (An & (Mo | El)) === Ji && zf();
      }
    }
    function l3() {
      return (An & (Mo | El)) !== Ji;
    }
    function v1(o, a) {
      os(AI, du, o), du = nn(du, a);
    }
    function $I(o) {
      du = AI.current, is(AI, o);
    }
    function Fp(o, a) {
      o.finishedWork = null, o.finishedLanes = je;
      var p = o.timeoutHandle;
      if (p !== NP && (o.timeoutHandle = NP, hX(p)), ri !== null)
        for (var S = ri.return; S !== null; ) {
          var b = S.alternate;
          NN(b, S), S = S.return;
        }
      Fs = o;
      var T = Up(o.current, null);
      return ri = T, eo = du = a, to = wd, $S = null, d1 = je, BS = je, f1 = je, HS = null, ua = null, jZ(), oc.discardPendingWarnings(), T;
    }
    function c3(o, a) {
      do {
        var p = ri;
        try {
          if (I0(), D2(), kr(), RI.current = null, p === null || p.return === null) {
            to = zS, $S = a, ri = null;
            return;
          }
          if (De && p.mode & _n && r1(p, !0), Ze)
            if (Vc(), a !== null && typeof a == "object" && typeof a.then == "function") {
              var S = a;
              Qh(p, S, eo);
            } else
              ml(p, a, eo);
          uQ(o, p.return, p, a, eo), h3(p);
        } catch (b) {
          a = b, ri === p && p !== null ? (p = p.return, ri = p) : p = ri;
          continue;
        }
        return;
      } while (!0);
    }
    function u3() {
      var o = kI.current;
      return kI.current = Q0, o === null ? Q0 : o;
    }
    function d3(o) {
      kI.current = o;
    }
    function $J() {
      DI = Jr();
    }
    function qS(o) {
      d1 = nn(o, d1);
    }
    function BJ() {
      to === wd && (to = u1);
    }
    function BI() {
      (to === wd || to === u1 || to === Lp) && (to = US), Fs !== null && (Yc(d1) || Yc(BS)) && Xf(Fs, eo);
    }
    function HJ(o) {
      to !== US && (to = Lp), HS === null ? HS = [o] : HS.push(o);
    }
    function VJ() {
      return to === wd;
    }
    function S1(o, a) {
      var p = An;
      An |= Mo;
      var S = u3();
      if (Fs !== o || eo !== a) {
        if (uo) {
          var b = o.memoizedUpdaters;
          b.size > 0 && (YS(o, eo), b.clear()), zv(o, a);
        }
        bd = am(), Fp(o, a);
      }
      Iv(a);
      do
        try {
          KJ();
          break;
        } catch (T) {
          c3(o, T);
        }
      while (!0);
      if (I0(), An = p, d3(S), ri !== null)
        throw new Error("Cannot commit an incomplete root. This error is likely caused by a bug in React. Please file an issue.");
      return Mr(), Fs = null, eo = je, to;
    }
    function KJ() {
      for (; ri !== null; )
        f3(ri);
    }
    function WJ(o, a) {
      var p = An;
      An |= Mo;
      var S = u3();
      if (Fs !== o || eo !== a) {
        if (uo) {
          var b = o.memoizedUpdaters;
          b.size > 0 && (YS(o, eo), b.clear()), zv(o, a);
        }
        bd = am(), VS(), Fp(o, a);
      }
      Iv(a);
      do
        try {
          GJ();
          break;
        } catch (T) {
          c3(o, T);
        }
      while (!0);
      return I0(), d3(S), An = p, ri !== null ? (kv(), wd) : (Mr(), Fs = null, eo = je, to);
    }
    function GJ() {
      for (; ri !== null && !xv(); )
        f3(ri);
    }
    function f3(o) {
      var a = o.alternate;
      $n(o);
      var p;
      (o.mode & _n) !== Mt ? (KT(o), p = HI(a, o, du), r1(o, !0)) : p = HI(a, o, du), kr(), o.memoizedProps = o.pendingProps, p === null ? h3(o) : ri = p, RI.current = null;
    }
    function h3(o) {
      var a = o;
      do {
        var p = a.alternate, S = a.return;
        if ((a.flags & qu) === Rt) {
          $n(a);
          var b = void 0;
          if ((a.mode & _n) === Mt ? b = LN(p, a, du) : (KT(a), b = LN(p, a, du), r1(a, !1)), kr(), b !== null) {
            ri = b;
            return;
          }
        } else {
          var T = BQ(p, a);
          if (T !== null) {
            T.flags &= hb, ri = T;
            return;
          }
          if ((a.mode & _n) !== Mt) {
            r1(a, !1);
            for (var D = a.actualDuration, N = a.child; N !== null; )
              D += N.actualDuration, N = N.sibling;
            a.actualDuration = D;
          }
          if (S !== null)
            S.flags |= qu, S.subtreeFlags = Rt, S.deletions = null;
          else {
            to = MI, ri = null;
            return;
          }
        }
        var $ = a.sibling;
        if ($ !== null) {
          ri = $;
          return;
        }
        a = S, ri = a;
      } while (a !== null);
      to === wd && (to = e3);
    }
    function zp(o, a, p) {
      var S = Ds(), b = Ro.transition;
      try {
        Ro.transition = null, xi(ns), qJ(o, a, p, S);
      } finally {
        Ro.transition = b, xi(S);
      }
      return null;
    }
    function qJ(o, a, p, S) {
      do
        Ed();
      while (qf !== null);
      if (oee(), (An & (Mo | El)) !== Ji)
        throw new Error("Should not already be working.");
      var b = o.finishedWork, T = o.finishedLanes;
      if (Sb(T), b === null)
        return gl(), null;
      if (T === je && c("root.finishedLanes should not be empty during a commit. This is a bug in React."), o.finishedWork = null, o.finishedLanes = je, b === o.current)
        throw new Error("Cannot commit the same tree as before. This error is likely caused by a bug in React. Please file an issue.");
      o.callbackNode = null, o.callbackPriority = hi;
      var D = nn(b.lanes, b.childLanes);
      kb(o, D), o === Fs && (Fs = null, ri = null, eo = je), ((b.subtreeFlags & Vi) !== Rt || (b.flags & Vi) !== Rt) && (Np || (Np = !0, LI = p, WI(Xu, function() {
        return Ed(), null;
      })));
      var N = (b.subtreeFlags & ($c | pf | Bc | Vi)) !== Rt, $ = (b.flags & ($c | pf | Bc | Vi)) !== Rt;
      if (N || $) {
        var G = Ro.transition;
        Ro.transition = null;
        var X = Ds();
        xi(ns);
        var fe = An;
        An |= El, RI.current = null, GQ(o, b), iN(), aJ(o, b, T), sX(o.containerInfo), o.current = b, Jh(T), lJ(b, o, T), Qu(), gb(), An = fe, xi(X), Ro.transition = G;
      } else
        o.current = b, iN();
      var ue = Np;
      if (Np ? (Np = !1, qf = o, KS = T) : (Qm = 0, g1 = null), D = o.pendingLanes, D === je && (Zm = null), ue || y3(o.current, !1), Cv(b.stateNode, S), uo && o.memoizedUpdaters.clear(), TJ(), da(o, Jr()), a !== null)
        for (var _e = o.onRecoverableError, Ie = 0; Ie < a.length; Ie++) {
          var Me = a[Ie], st = Me.stack, Dt = Me.digest;
          _e(Me.value, {
            componentStack: st,
            digest: Dt
          });
        }
      if (h1) {
        h1 = !1;
        var Tt = OI;
        throw OI = null, Tt;
      }
      return ts(KS, Nt) && o.tag !== Ff && Ed(), D = o.pendingLanes, ts(D, Nt) ? (JZ(), o === NI ? WS++ : (WS = 0, NI = o)) : WS = 0, zf(), gl(), null;
    }
    function Ed() {
      if (qf !== null) {
        var o = Ab(KS), a = fo(Wi, o), p = Ro.transition, S = Ds();
        try {
          return Ro.transition = null, xi(a), XJ();
        } finally {
          xi(S), Ro.transition = p;
        }
      }
      return !1;
    }
    function YJ(o) {
      jI.push(o), Np || (Np = !0, WI(Xu, function() {
        return Ed(), null;
      }));
    }
    function XJ() {
      if (qf === null)
        return !1;
      var o = LI;
      LI = null;
      var a = qf, p = KS;
      if (qf = null, KS = je, (An & (Mo | El)) !== Ji)
        throw new Error("Cannot flush passive effects while already rendering.");
      FI = !0, p1 = !1, Tv(p);
      var S = An;
      An |= El, gJ(a.current), dJ(a, a.current, p, o);
      {
        var b = jI;
        jI = [];
        for (var T = 0; T < b.length; T++) {
          var D = b[T];
          ZQ(a, D);
        }
      }
      vf(), y3(a.current, !0), An = S, zf(), p1 ? a === g1 ? Qm++ : (Qm = 0, g1 = a) : Qm = 0, FI = !1, p1 = !1, Ev(a);
      {
        var N = a.current.stateNode;
        N.effectDuration = 0, N.passiveEffectDuration = 0;
      }
      return !0;
    }
    function p3(o) {
      return Zm !== null && Zm.has(o);
    }
    function ZJ(o) {
      Zm === null ? Zm = /* @__PURE__ */ new Set([o]) : Zm.add(o);
    }
    function QJ(o) {
      h1 || (h1 = !0, OI = o);
    }
    var JJ = QJ;
    function g3(o, a, p) {
      var S = Op(p, a), b = fN(o, S, Nt), T = $f(o, b, Nt), D = zs();
      T !== null && (Cf(T, Nt, D), da(T, D));
    }
    function Cr(o, a, p) {
      if (VQ(p), XS(!1), o.tag === v) {
        g3(o, o, p);
        return;
      }
      var S = null;
      for (S = a; S !== null; ) {
        if (S.tag === v) {
          g3(S, o, p);
          return;
        } else if (S.tag === g) {
          var b = S.type, T = S.stateNode;
          if (typeof b.getDerivedStateFromError == "function" || typeof T.componentDidCatch == "function" && !p3(T)) {
            var D = Op(p, o), N = cI(S, D, Nt), $ = $f(S, N, Nt), G = zs();
            $ !== null && (Cf($, Nt, G), da($, G));
            return;
          }
        }
        S = S.return;
      }
      c(`Internal React error: Attempted to capture a commit phase error inside a detached tree. This indicates a bug in React. Likely causes include deleting the same fiber more than once, committing an already-finished tree, or an inconsistent return pointer.

Error message:

%s`, p);
    }
    function eee(o, a, p) {
      var S = o.pingCache;
      S !== null && S.delete(a);
      var b = zs();
      om(o, p), cee(o), Fs === o && rd(eo, p) && (to === US || to === u1 && tm(eo) && Jr() - DI < t3 ? Fp(o, je) : f1 = nn(f1, p)), da(o, b);
    }
    function m3(o, a) {
      a === hi && (a = OJ(o));
      var p = zs(), S = la(o, a);
      S !== null && (Cf(S, a, p), da(S, p));
    }
    function tee(o) {
      var a = o.memoizedState, p = hi;
      a !== null && (p = a.retryLane), m3(o, p);
    }
    function nee(o, a) {
      var p = hi, S;
      switch (o.tag) {
        case F:
          S = o.stateNode;
          var b = o.memoizedState;
          b !== null && (p = b.retryLane);
          break;
        case ie:
          S = o.stateNode;
          break;
        default:
          throw new Error("Pinged unknown suspense boundary type. This is probably a bug in React.");
      }
      S !== null && S.delete(a), m3(o, p);
    }
    function ree(o) {
      return o < 120 ? 120 : o < 480 ? 480 : o < 1080 ? 1080 : o < 1920 ? 1920 : o < 3e3 ? 3e3 : o < 4320 ? 4320 : RJ(o / 1960) * 1960;
    }
    function iee() {
      if (WS > AJ)
        throw WS = 0, NI = null, new Error("Maximum update depth exceeded. This can happen when a component repeatedly calls setState inside componentWillUpdate or componentDidUpdate. React limits the number of nested updates to prevent infinite loops.");
      Qm > DJ && (Qm = 0, g1 = null, c("Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn't have a dependency array, or one of the dependencies changes on every render."));
    }
    function oee() {
      oc.flushLegacyContextWarning(), oc.flushPendingUnsafeLifecycleWarnings();
    }
    function y3(o, a) {
      $n(o), x1(o, wo, EJ), a && x1(o, Uc, _J), x1(o, wo, bJ), a && x1(o, Uc, CJ), kr();
    }
    function x1(o, a, p) {
      for (var S = o, b = null; S !== null; ) {
        var T = S.subtreeFlags & a;
        S !== b && S.child !== null && T !== Rt ? S = S.child : ((S.flags & a) !== Rt && p(S), S.sibling !== null ? S = S.sibling : S = b = S.return);
      }
    }
    var w1 = null;
    function v3(o) {
      {
        if ((An & Mo) !== Ji || !(o.mode & pn))
          return;
        var a = o.tag;
        if (a !== y && a !== v && a !== g && a !== h && a !== O && a !== H && a !== V)
          return;
        var p = Ut(o) || "ReactComponent";
        if (w1 !== null) {
          if (w1.has(p))
            return;
          w1.add(p);
        } else
          w1 = /* @__PURE__ */ new Set([p]);
        var S = ai;
        try {
          $n(o), c("Can't perform a React state update on a component that hasn't mounted yet. This indicates that you have a side-effect in your render function that asynchronously later calls tries to update the component. Move this work to useEffect instead.");
        } finally {
          S ? $n(o) : kr();
        }
      }
    }
    var HI;
    {
      var see = null;
      HI = function(o, a, p) {
        var S = P3(see, a);
        try {
          return MN(o, a, p);
        } catch (T) {
          if (vZ() || T !== null && typeof T == "object" && typeof T.then == "function")
            throw T;
          if (I0(), D2(), NN(o, a), P3(a, S), a.mode & _n && KT(a), Js(null, MN, null, o, a, p), hv()) {
            var b = pv();
            typeof b == "object" && b !== null && b._suppressLogging && typeof T == "object" && T !== null && !T._suppressLogging && (T._suppressLogging = !0);
          }
          throw T;
        }
      };
    }
    var S3 = !1, VI;
    VI = /* @__PURE__ */ new Set();
    function aee(o) {
      if (ao && !XZ())
        switch (o.tag) {
          case h:
          case O:
          case V: {
            var a = ri && Ut(ri) || "Unknown", p = a;
            if (!VI.has(p)) {
              VI.add(p);
              var S = Ut(o) || "Unknown";
              c("Cannot update a component (`%s`) while rendering a different component (`%s`). To locate the bad setState() call inside `%s`, follow the stack trace as described in https://reactjs.org/link/setstate-in-render", S, a, a);
            }
            break;
          }
          case g: {
            S3 || (c("Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state."), S3 = !0);
            break;
          }
        }
    }
    function YS(o, a) {
      if (uo) {
        var p = o.memoizedUpdaters;
        p.forEach(function(S) {
          Rb(o, S, a);
        });
      }
    }
    var KI = {};
    function WI(o, a) {
      {
        var p = hc.current;
        return p !== null ? (p.push(a), KI) : vv(o, a);
      }
    }
    function x3(o) {
      if (o !== KI)
        return Sv(o);
    }
    function w3() {
      return hc.current !== null;
    }
    function lee(o) {
      {
        if (o.mode & pn) {
          if (!QN())
            return;
        } else if (!kJ() || An !== Ji || o.tag !== h && o.tag !== O && o.tag !== V)
          return;
        if (hc.current === null) {
          var a = ai;
          try {
            $n(o), c(`An update to %s inside a test was not wrapped in act(...).

When testing, code that causes React state updates should be wrapped into act(...):

act(() => {
  /* fire events that update state */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`, Ut(o));
          } finally {
            a ? $n(o) : kr();
          }
        }
      }
    }
    function cee(o) {
      o.tag !== Ff && QN() && hc.current === null && c(`A suspended resource finished loading inside a test, but the event was not wrapped in act(...).

When testing, code that resolves suspended data should be wrapped into act(...):

act(() => {
  /* finish loading suspended data */
});
/* assert on the output */

This ensures that you're testing the behavior the user would see in the browser. Learn more at https://reactjs.org/link/wrap-tests-with-act`);
    }
    function XS(o) {
      i3 = o;
    }
    var _l = null, Jm = null, uee = function(o) {
      _l = o;
    };
    function ey(o) {
      {
        if (_l === null)
          return o;
        var a = _l(o);
        return a === void 0 ? o : a.current;
      }
    }
    function GI(o) {
      return ey(o);
    }
    function qI(o) {
      {
        if (_l === null)
          return o;
        var a = _l(o);
        if (a === void 0) {
          if (o != null && typeof o.render == "function") {
            var p = ey(o.render);
            if (o.render !== p) {
              var S = {
                $$typeof: Ue,
                render: p
              };
              return o.displayName !== void 0 && (S.displayName = o.displayName), S;
            }
          }
          return o;
        }
        return a.current;
      }
    }
    function b3(o, a) {
      {
        if (_l === null)
          return !1;
        var p = o.elementType, S = a.type, b = !1, T = typeof S == "object" && S !== null ? S.$$typeof : null;
        switch (o.tag) {
          case g: {
            typeof S == "function" && (b = !0);
            break;
          }
          case h: {
            (typeof S == "function" || T === Vt) && (b = !0);
            break;
          }
          case O: {
            (T === Ue || T === Vt) && (b = !0);
            break;
          }
          case H:
          case V: {
            (T === zt || T === Vt) && (b = !0);
            break;
          }
          default:
            return !1;
        }
        if (b) {
          var D = _l(p);
          if (D !== void 0 && D === _l(S))
            return !0;
        }
        return !1;
      }
    }
    function C3(o) {
      {
        if (_l === null || typeof WeakSet != "function")
          return;
        Jm === null && (Jm = /* @__PURE__ */ new WeakSet()), Jm.add(o);
      }
    }
    var dee = function(o, a) {
      {
        if (_l === null)
          return;
        var p = a.staleFamilies, S = a.updatedFamilies;
        Ed(), Cd(function() {
          YI(o.current, S, p);
        });
      }
    }, fee = function(o, a) {
      {
        if (o.context !== Ha)
          return;
        Ed(), Cd(function() {
          ZS(a, o, null, null);
        });
      }
    };
    function YI(o, a, p) {
      {
        var S = o.alternate, b = o.child, T = o.sibling, D = o.tag, N = o.type, $ = null;
        switch (D) {
          case h:
          case V:
          case g:
            $ = N;
            break;
          case O:
            $ = N.render;
            break;
        }
        if (_l === null)
          throw new Error("Expected resolveFamily to be set during hot reload.");
        var G = !1, X = !1;
        if ($ !== null) {
          var fe = _l($);
          fe !== void 0 && (p.has(fe) ? X = !0 : a.has(fe) && (D === g ? X = !0 : G = !0));
        }
        if (Jm !== null && (Jm.has(o) || S !== null && Jm.has(S)) && (X = !0), X && (o._debugNeedsRemount = !0), X || G) {
          var ue = la(o, Nt);
          ue !== null && no(ue, o, Nt, ir);
        }
        b !== null && !X && YI(b, a, p), T !== null && YI(T, a, p);
      }
    }
    var hee = function(o, a) {
      {
        var p = /* @__PURE__ */ new Set(), S = new Set(a.map(function(b) {
          return b.current;
        }));
        return XI(o.current, S, p), p;
      }
    };
    function XI(o, a, p) {
      {
        var S = o.child, b = o.sibling, T = o.tag, D = o.type, N = null;
        switch (T) {
          case h:
          case V:
          case g:
            N = D;
            break;
          case O:
            N = D.render;
            break;
        }
        var $ = !1;
        N !== null && a.has(N) && ($ = !0), $ ? pee(o, p) : S !== null && XI(S, a, p), b !== null && XI(b, a, p);
      }
    }
    function pee(o, a) {
      {
        var p = gee(o, a);
        if (p)
          return;
        for (var S = o; ; ) {
          switch (S.tag) {
            case C:
              a.add(S.stateNode);
              return;
            case w:
              a.add(S.stateNode.containerInfo);
              return;
            case v:
              a.add(S.stateNode.containerInfo);
              return;
          }
          if (S.return === null)
            throw new Error("Expected to reach root first.");
          S = S.return;
        }
      }
    }
    function gee(o, a) {
      for (var p = o, S = !1; ; ) {
        if (p.tag === C)
          S = !0, a.add(p.stateNode);
        else if (p.child !== null) {
          p.child.return = p, p = p.child;
          continue;
        }
        if (p === o)
          return S;
        for (; p.sibling === null; ) {
          if (p.return === null || p.return === o)
            return S;
          p = p.return;
        }
        p.sibling.return = p.return, p = p.sibling;
      }
      return !1;
    }
    var ZI;
    {
      ZI = !1;
      try {
        var E3 = Object.preventExtensions({});
      } catch {
        ZI = !0;
      }
    }
    function mee(o, a, p, S) {
      this.tag = o, this.key = p, this.elementType = null, this.type = null, this.stateNode = null, this.return = null, this.child = null, this.sibling = null, this.index = 0, this.ref = null, this.pendingProps = a, this.memoizedProps = null, this.updateQueue = null, this.memoizedState = null, this.dependencies = null, this.mode = S, this.flags = Rt, this.subtreeFlags = Rt, this.deletions = null, this.lanes = je, this.childLanes = je, this.alternate = null, this.actualDuration = Number.NaN, this.actualStartTime = Number.NaN, this.selfBaseDuration = Number.NaN, this.treeBaseDuration = Number.NaN, this.actualDuration = 0, this.actualStartTime = -1, this.selfBaseDuration = 0, this.treeBaseDuration = 0, this._debugSource = null, this._debugOwner = null, this._debugNeedsRemount = !1, this._debugHookTypes = null, !ZI && typeof Object.preventExtensions == "function" && Object.preventExtensions(this);
    }
    var Va = function(o, a, p, S) {
      return new mee(o, a, p, S);
    };
    function QI(o) {
      var a = o.prototype;
      return !!(a && a.isReactComponent);
    }
    function yee(o) {
      return typeof o == "function" && !QI(o) && o.defaultProps === void 0;
    }
    function vee(o) {
      if (typeof o == "function")
        return QI(o) ? g : h;
      if (o != null) {
        var a = o.$$typeof;
        if (a === Ue)
          return O;
        if (a === zt)
          return H;
      }
      return y;
    }
    function Up(o, a) {
      var p = o.alternate;
      p === null ? (p = Va(o.tag, a, o.key, o.mode), p.elementType = o.elementType, p.type = o.type, p.stateNode = o.stateNode, p._debugSource = o._debugSource, p._debugOwner = o._debugOwner, p._debugHookTypes = o._debugHookTypes, p.alternate = o, o.alternate = p) : (p.pendingProps = a, p.type = o.type, p.flags = Rt, p.subtreeFlags = Rt, p.deletions = null, p.actualDuration = 0, p.actualStartTime = -1), p.flags = o.flags & fi, p.childLanes = o.childLanes, p.lanes = o.lanes, p.child = o.child, p.memoizedProps = o.memoizedProps, p.memoizedState = o.memoizedState, p.updateQueue = o.updateQueue;
      var S = o.dependencies;
      switch (p.dependencies = S === null ? null : {
        lanes: S.lanes,
        firstContext: S.firstContext
      }, p.sibling = o.sibling, p.index = o.index, p.ref = o.ref, p.selfBaseDuration = o.selfBaseDuration, p.treeBaseDuration = o.treeBaseDuration, p._debugNeedsRemount = o._debugNeedsRemount, p.tag) {
        case y:
        case h:
        case V:
          p.type = ey(o.type);
          break;
        case g:
          p.type = GI(o.type);
          break;
        case O:
          p.type = qI(o.type);
          break;
      }
      return p;
    }
    function See(o, a) {
      o.flags &= fi | ci;
      var p = o.alternate;
      if (p === null)
        o.childLanes = je, o.lanes = a, o.child = null, o.subtreeFlags = Rt, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null, o.selfBaseDuration = 0, o.treeBaseDuration = 0;
      else {
        o.childLanes = p.childLanes, o.lanes = p.lanes, o.child = p.child, o.subtreeFlags = Rt, o.deletions = null, o.memoizedProps = p.memoizedProps, o.memoizedState = p.memoizedState, o.updateQueue = p.updateQueue, o.type = p.type;
        var S = p.dependencies;
        o.dependencies = S === null ? null : {
          lanes: S.lanes,
          firstContext: S.firstContext
        }, o.selfBaseDuration = p.selfBaseDuration, o.treeBaseDuration = p.treeBaseDuration;
      }
      return o;
    }
    function xee(o, a, p) {
      var S;
      return o === v0 ? (S = pn, a === !0 && (S |= Jt, S |= ur)) : S = Mt, uo && (S |= _n), Va(v, null, null, S);
    }
    function JI(o, a, p, S, b, T) {
      var D = y, N = o;
      if (typeof o == "function")
        QI(o) ? (D = g, N = GI(N)) : N = ey(N);
      else if (typeof o == "string")
        D = C;
      else
        e: switch (o) {
          case $i:
            return Zf(p.children, b, T, a);
          case Wo:
            D = I, b |= Jt, (b & pn) !== Mt && (b |= ur);
            break;
          case Ri:
            return wee(p, b, T, a);
          case tt:
            return bee(p, b, T, a);
          case rt:
            return Cee(p, b, T, a);
          case Lr:
            return _3(p, b, T, a);
          case ar:
          // eslint-disable-next-line no-fallthrough
          case un:
          // eslint-disable-next-line no-fallthrough
          case zn:
          // eslint-disable-next-line no-fallthrough
          case Mi:
          // eslint-disable-next-line no-fallthrough
          case en:
          // eslint-disable-next-line no-fallthrough
          default: {
            if (typeof o == "object" && o !== null)
              switch (o.$$typeof) {
                case Ma:
                  D = L;
                  break e;
                case se:
                  D = k;
                  break e;
                case Ue:
                  D = O, N = qI(N);
                  break e;
                case zt:
                  D = H;
                  break e;
                case Vt:
                  D = re, N = null;
                  break e;
              }
            var $ = "";
            {
              (o === void 0 || typeof o == "object" && o !== null && Object.keys(o).length === 0) && ($ += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
              var G = S ? Ut(S) : null;
              G && ($ += `

Check the render method of \`` + G + "`.");
            }
            throw new Error("Element type is invalid: expected a string (for built-in components) or a class/function (for composite components) " + ("but got: " + (o == null ? o : typeof o) + "." + $));
          }
        }
      var X = Va(D, p, a, b);
      return X.elementType = o, X.type = N, X.lanes = T, X._debugOwner = S, X;
    }
    function ek(o, a, p) {
      var S = null;
      S = o._owner;
      var b = o.type, T = o.key, D = o.props, N = JI(b, T, D, S, a, p);
      return N._debugSource = o._source, N._debugOwner = o._owner, N;
    }
    function Zf(o, a, p, S) {
      var b = Va(P, o, S, a);
      return b.lanes = p, b;
    }
    function wee(o, a, p, S) {
      typeof o.id != "string" && c('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof o.id);
      var b = Va(z, o, S, a | _n);
      return b.elementType = Ri, b.lanes = p, b.stateNode = {
        effectDuration: 0,
        passiveEffectDuration: 0
      }, b;
    }
    function bee(o, a, p, S) {
      var b = Va(F, o, S, a);
      return b.elementType = tt, b.lanes = p, b;
    }
    function Cee(o, a, p, S) {
      var b = Va(ie, o, S, a);
      return b.elementType = rt, b.lanes = p, b;
    }
    function _3(o, a, p, S) {
      var b = Va(Y, o, S, a);
      b.elementType = Lr, b.lanes = p;
      var T = {
        isHidden: !1
      };
      return b.stateNode = T, b;
    }
    function tk(o, a, p) {
      var S = Va(E, o, null, a);
      return S.lanes = p, S;
    }
    function Eee() {
      var o = Va(C, null, null, Mt);
      return o.elementType = "DELETED", o;
    }
    function _ee(o) {
      var a = Va(J, null, null, Mt);
      return a.stateNode = o, a;
    }
    function nk(o, a, p) {
      var S = o.children !== null ? o.children : [], b = Va(w, S, o.key, a);
      return b.lanes = p, b.stateNode = {
        containerInfo: o.containerInfo,
        pendingChildren: null,
        // Used by persistent updates
        implementation: o.implementation
      }, b;
    }
    function P3(o, a) {
      return o === null && (o = Va(y, null, null, Mt)), o.tag = a.tag, o.key = a.key, o.elementType = a.elementType, o.type = a.type, o.stateNode = a.stateNode, o.return = a.return, o.child = a.child, o.sibling = a.sibling, o.index = a.index, o.ref = a.ref, o.pendingProps = a.pendingProps, o.memoizedProps = a.memoizedProps, o.updateQueue = a.updateQueue, o.memoizedState = a.memoizedState, o.dependencies = a.dependencies, o.mode = a.mode, o.flags = a.flags, o.subtreeFlags = a.subtreeFlags, o.deletions = a.deletions, o.lanes = a.lanes, o.childLanes = a.childLanes, o.alternate = a.alternate, o.actualDuration = a.actualDuration, o.actualStartTime = a.actualStartTime, o.selfBaseDuration = a.selfBaseDuration, o.treeBaseDuration = a.treeBaseDuration, o._debugSource = a._debugSource, o._debugOwner = a._debugOwner, o._debugNeedsRemount = a._debugNeedsRemount, o._debugHookTypes = a._debugHookTypes, o;
    }
    function Pee(o, a, p, S, b) {
      this.tag = a, this.containerInfo = o, this.pendingChildren = null, this.current = null, this.pingCache = null, this.finishedWork = null, this.timeoutHandle = NP, this.context = null, this.pendingContext = null, this.callbackNode = null, this.callbackPriority = hi, this.eventTimes = im(je), this.expirationTimes = im(ir), this.pendingLanes = je, this.suspendedLanes = je, this.pingedLanes = je, this.expiredLanes = je, this.mutableReadLanes = je, this.finishedLanes = je, this.entangledLanes = je, this.entanglements = im(je), this.identifierPrefix = S, this.onRecoverableError = b, this.mutableSourceEagerHydrationData = null, this.effectDuration = 0, this.passiveEffectDuration = 0;
      {
        this.memoizedUpdaters = /* @__PURE__ */ new Set();
        for (var T = this.pendingUpdatersLaneMap = [], D = 0; D < Mv; D++)
          T.push(/* @__PURE__ */ new Set());
      }
      switch (a) {
        case v0:
          this._debugRootType = p ? "hydrateRoot()" : "createRoot()";
          break;
        case Ff:
          this._debugRootType = p ? "hydrate()" : "render()";
          break;
      }
    }
    function T3(o, a, p, S, b, T, D, N, $, G) {
      var X = new Pee(o, a, p, N, $), fe = xee(a, T);
      X.current = fe, fe.stateNode = X;
      {
        var ue = {
          element: S,
          isDehydrated: p,
          cache: null,
          // not enabled yet
          transitions: null,
          pendingSuspenseBoundaries: null
        };
        fe.memoizedState = ue;
      }
      return gT(fe), X;
    }
    var rk = "18.3.1";
    function Tee(o, a, p) {
      var S = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : null;
      return xr(S), {
        // This tag allow us to uniquely identify this as a React Portal
        $$typeof: So,
        key: S == null ? null : "" + S,
        children: o,
        containerInfo: a,
        implementation: p
      };
    }
    var ik, ok;
    ik = !1, ok = {};
    function I3(o) {
      if (!o)
        return Ha;
      var a = hf(o), p = cZ(a);
      if (a.tag === g) {
        var S = a.type;
        if (iu(S))
          return t2(a, S, p);
      }
      return p;
    }
    function Iee(o, a) {
      {
        var p = hf(o);
        if (p === void 0) {
          if (typeof o.render == "function")
            throw new Error("Unable to find node on an unmounted component.");
          var S = Object.keys(o).join(",");
          throw new Error("Argument appears to not be a ReactComponent. Keys: " + S);
        }
        var b = Qo(p);
        if (b === null)
          return null;
        if (b.mode & Jt) {
          var T = Ut(p) || "Component";
          if (!ok[T]) {
            ok[T] = !0;
            var D = ai;
            try {
              $n(b), p.mode & Jt ? c("%s is deprecated in StrictMode. %s was passed an instance of %s which is inside StrictMode. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, T) : c("%s is deprecated in StrictMode. %s was passed an instance of %s which renders StrictMode children. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node", a, a, T);
            } finally {
              D ? $n(D) : kr();
            }
          }
        }
        return b.stateNode;
      }
    }
    function k3(o, a, p, S, b, T, D, N) {
      var $ = !1, G = null;
      return T3(o, a, $, G, p, S, b, T, D);
    }
    function R3(o, a, p, S, b, T, D, N, $, G) {
      var X = !0, fe = T3(p, S, X, o, b, T, D, N, $);
      fe.context = I3(null);
      var ue = fe.current, _e = zs(), Ie = Yf(ue), Me = Sd(_e, Ie);
      return Me.callback = a ?? null, $f(ue, Me, Ie), jJ(fe, Ie, _e), fe;
    }
    function ZS(o, a, p, S) {
      bv(a, o);
      var b = a.current, T = zs(), D = Yf(b);
      jg(D);
      var N = I3(p);
      a.context === null ? a.context = N : a.pendingContext = N, ao && ai !== null && !ik && (ik = !0, c(`Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate.

Check the render method of %s.`, Ut(ai) || "Unknown"));
      var $ = Sd(T, D);
      $.payload = {
        element: o
      }, S = S === void 0 ? null : S, S !== null && (typeof S != "function" && c("render(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", S), $.callback = S);
      var G = $f(b, $, D);
      return G !== null && (no(G, b, D, T), D0(G, b, D)), D;
    }
    function b1(o) {
      var a = o.current;
      if (!a.child)
        return null;
      switch (a.child.tag) {
        case C:
          return a.child.stateNode;
        default:
          return a.child.stateNode;
      }
    }
    function kee(o) {
      switch (o.tag) {
        case v: {
          var a = o.stateNode;
          if (id(a)) {
            var p = Pb(a);
            zJ(a, p);
          }
          break;
        }
        case F: {
          Cd(function() {
            var b = la(o, Nt);
            if (b !== null) {
              var T = zs();
              no(b, o, Nt, T);
            }
          });
          var S = Nt;
          sk(o, S);
          break;
        }
      }
    }
    function M3(o, a) {
      var p = o.memoizedState;
      p !== null && p.dehydrated !== null && (p.retryLane = Nv(p.retryLane, a));
    }
    function sk(o, a) {
      M3(o, a);
      var p = o.alternate;
      p && M3(p, a);
    }
    function Ree(o) {
      if (o.tag === F) {
        var a = bf, p = la(o, a);
        if (p !== null) {
          var S = zs();
          no(p, o, a, S);
        }
        sk(o, a);
      }
    }
    function Mee(o) {
      if (o.tag === F) {
        var a = Yf(o), p = la(o, a);
        if (p !== null) {
          var S = zs();
          no(p, o, a, S);
        }
        sk(o, a);
      }
    }
    function A3(o) {
      var a = za(o);
      return a === null ? null : a.stateNode;
    }
    var D3 = function(o) {
      return null;
    };
    function Aee(o) {
      return D3(o);
    }
    var O3 = function(o) {
      return !1;
    };
    function Dee(o) {
      return O3(o);
    }
    var j3 = null, L3 = null, N3 = null, F3 = null, z3 = null, U3 = null, $3 = null, B3 = null, H3 = null;
    {
      var V3 = function(o, a, p) {
        var S = a[p], b = tn(o) ? o.slice() : Gt({}, o);
        return p + 1 === a.length ? (tn(b) ? b.splice(S, 1) : delete b[S], b) : (b[S] = V3(o[S], a, p + 1), b);
      }, K3 = function(o, a) {
        return V3(o, a, 0);
      }, W3 = function(o, a, p, S) {
        var b = a[S], T = tn(o) ? o.slice() : Gt({}, o);
        if (S + 1 === a.length) {
          var D = p[S];
          T[D] = T[b], tn(T) ? T.splice(b, 1) : delete T[b];
        } else
          T[b] = W3(
            // $FlowFixMe number or string is fine here
            o[b],
            a,
            p,
            S + 1
          );
        return T;
      }, G3 = function(o, a, p) {
        if (a.length !== p.length) {
          l("copyWithRename() expects paths of the same length");
          return;
        } else
          for (var S = 0; S < p.length - 1; S++)
            if (a[S] !== p[S]) {
              l("copyWithRename() expects paths to be the same except for the deepest key");
              return;
            }
        return W3(o, a, p, 0);
      }, q3 = function(o, a, p, S) {
        if (p >= a.length)
          return S;
        var b = a[p], T = tn(o) ? o.slice() : Gt({}, o);
        return T[b] = q3(o[b], a, p + 1, S), T;
      }, Y3 = function(o, a, p) {
        return q3(o, a, 0, p);
      }, ak = function(o, a) {
        for (var p = o.memoizedState; p !== null && a > 0; )
          p = p.next, a--;
        return p;
      };
      j3 = function(o, a, p, S) {
        var b = ak(o, a);
        if (b !== null) {
          var T = Y3(b.memoizedState, p, S);
          b.memoizedState = T, b.baseState = T, o.memoizedProps = Gt({}, o.memoizedProps);
          var D = la(o, Nt);
          D !== null && no(D, o, Nt, ir);
        }
      }, L3 = function(o, a, p) {
        var S = ak(o, a);
        if (S !== null) {
          var b = K3(S.memoizedState, p);
          S.memoizedState = b, S.baseState = b, o.memoizedProps = Gt({}, o.memoizedProps);
          var T = la(o, Nt);
          T !== null && no(T, o, Nt, ir);
        }
      }, N3 = function(o, a, p, S) {
        var b = ak(o, a);
        if (b !== null) {
          var T = G3(b.memoizedState, p, S);
          b.memoizedState = T, b.baseState = T, o.memoizedProps = Gt({}, o.memoizedProps);
          var D = la(o, Nt);
          D !== null && no(D, o, Nt, ir);
        }
      }, F3 = function(o, a, p) {
        o.pendingProps = Y3(o.memoizedProps, a, p), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var S = la(o, Nt);
        S !== null && no(S, o, Nt, ir);
      }, z3 = function(o, a) {
        o.pendingProps = K3(o.memoizedProps, a), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var p = la(o, Nt);
        p !== null && no(p, o, Nt, ir);
      }, U3 = function(o, a, p) {
        o.pendingProps = G3(o.memoizedProps, a, p), o.alternate && (o.alternate.pendingProps = o.pendingProps);
        var S = la(o, Nt);
        S !== null && no(S, o, Nt, ir);
      }, $3 = function(o) {
        var a = la(o, Nt);
        a !== null && no(a, o, Nt, ir);
      }, B3 = function(o) {
        D3 = o;
      }, H3 = function(o) {
        O3 = o;
      };
    }
    function Oee(o) {
      var a = Qo(o);
      return a === null ? null : a.stateNode;
    }
    function jee(o) {
      return null;
    }
    function Lee() {
      return ai;
    }
    function Nee(o) {
      var a = o.findFiberByHostInstance, p = r.ReactCurrentDispatcher;
      return wv({
        bundleType: o.bundleType,
        version: o.version,
        rendererPackageName: o.rendererPackageName,
        rendererConfig: o.rendererConfig,
        overrideHookState: j3,
        overrideHookStateDeletePath: L3,
        overrideHookStateRenamePath: N3,
        overrideProps: F3,
        overridePropsDeletePath: z3,
        overridePropsRenamePath: U3,
        setErrorHandler: B3,
        setSuspenseHandler: H3,
        scheduleUpdate: $3,
        currentDispatcherRef: p,
        findHostInstanceByFiber: Oee,
        findFiberByHostInstance: a || jee,
        // React Refresh
        findHostInstancesForRefresh: hee,
        scheduleRefresh: dee,
        scheduleRoot: fee,
        setRefreshHandler: uee,
        // Enables DevTools to append owner stacks to error messages in DEV mode.
        getCurrentFiber: Lee,
        // Enables DevTools to detect reconciler version rather than renderer version
        // which may not match for third party renderers.
        reconcilerVersion: rk
      });
    }
    var X3 = typeof reportError == "function" ? (
      // In modern browsers, reportError will dispatch an error event,
      // emulating an uncaught JavaScript error.
      reportError
    ) : function(o) {
      console.error(o);
    };
    function lk(o) {
      this._internalRoot = o;
    }
    C1.prototype.render = lk.prototype.render = function(o) {
      var a = this._internalRoot;
      if (a === null)
        throw new Error("Cannot update an unmounted root.");
      {
        typeof arguments[1] == "function" ? c("render(...): does not support the second callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().") : E1(arguments[1]) ? c("You passed a container to the second argument of root.render(...). You don't need to pass it again since you already passed it to create the root.") : typeof arguments[1] < "u" && c("You passed a second argument to root.render(...) but it only accepts one argument.");
        var p = a.containerInfo;
        if (p.nodeType !== li) {
          var S = A3(a.current);
          S && S.parentNode !== p && c("render(...): It looks like the React-rendered content of the root container was removed without using React. This is not supported and will cause errors. Instead, call root.unmount() to empty a root's container.");
        }
      }
      ZS(o, a, null, null);
    }, C1.prototype.unmount = lk.prototype.unmount = function() {
      typeof arguments[0] == "function" && c("unmount(...): does not support a callback argument. To execute a side effect after rendering, declare it in a component body with useEffect().");
      var o = this._internalRoot;
      if (o !== null) {
        this._internalRoot = null;
        var a = o.containerInfo;
        l3() && c("Attempted to synchronously unmount a root while React was already rendering. React cannot finish unmounting the root until the current render has completed, which may lead to a race condition."), Cd(function() {
          ZS(null, o, null, null);
        }), XL(a);
      }
    };
    function Fee(o, a) {
      if (!E1(o))
        throw new Error("createRoot(...): Target container is not a DOM element.");
      Z3(o);
      var p = !1, S = !1, b = "", T = X3;
      a != null && (a.hydrate ? l("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.") : typeof a == "object" && a !== null && a.$$typeof === vi && c(`You passed a JSX element to createRoot. You probably meant to call root.render instead. Example usage:

  let root = createRoot(domContainer);
  root.render(<App />);`), a.unstable_strictMode === !0 && (p = !0), a.identifierPrefix !== void 0 && (b = a.identifierPrefix), a.onRecoverableError !== void 0 && (T = a.onRecoverableError), a.transitionCallbacks !== void 0 && a.transitionCallbacks);
      var D = k3(o, v0, null, p, S, b, T);
      d0(D.current, o);
      var N = o.nodeType === li ? o.parentNode : o;
      return rS(N), new lk(D);
    }
    function C1(o) {
      this._internalRoot = o;
    }
    function zee(o) {
      o && Nb(o);
    }
    C1.prototype.unstable_scheduleHydration = zee;
    function Uee(o, a, p) {
      if (!E1(o))
        throw new Error("hydrateRoot(...): Target container is not a DOM element.");
      Z3(o), a === void 0 && c("Must provide initial children as second argument to hydrateRoot. Example usage: hydrateRoot(domContainer, <App />)");
      var S = p ?? null, b = p != null && p.hydratedSources || null, T = !1, D = !1, N = "", $ = X3;
      p != null && (p.unstable_strictMode === !0 && (T = !0), p.identifierPrefix !== void 0 && (N = p.identifierPrefix), p.onRecoverableError !== void 0 && ($ = p.onRecoverableError));
      var G = R3(a, null, o, v0, S, T, D, N, $);
      if (d0(G.current, o), rS(o), b)
        for (var X = 0; X < b.length; X++) {
          var fe = b[X];
          VZ(G, fe);
        }
      return new C1(G);
    }
    function E1(o) {
      return !!(o && (o.nodeType === Yo || o.nodeType === Yl || o.nodeType === Oh));
    }
    function QS(o) {
      return !!(o && (o.nodeType === Yo || o.nodeType === Yl || o.nodeType === Oh || o.nodeType === li && o.nodeValue === " react-mount-point-unstable "));
    }
    function Z3(o) {
      o.nodeType === Yo && o.tagName && o.tagName.toUpperCase() === "BODY" && c("createRoot(): Creating roots directly with document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try using a container element created for your app."), pS(o) && (o._reactRootContainer ? c("You are calling ReactDOMClient.createRoot() on a container that was previously passed to ReactDOM.render(). This is not supported.") : c("You are calling ReactDOMClient.createRoot() on a container that has already been passed to createRoot() before. Instead, call root.render() on the existing root instead if you want to update it."));
    }
    var $ee = r.ReactCurrentOwner, Q3;
    Q3 = function(o) {
      if (o._reactRootContainer && o.nodeType !== li) {
        var a = A3(o._reactRootContainer.current);
        a && a.parentNode !== o && c("render(...): It looks like the React-rendered content of this container was removed without using React. This is not supported and will cause errors. Instead, call ReactDOM.unmountComponentAtNode to empty a container.");
      }
      var p = !!o._reactRootContainer, S = ck(o), b = !!(S && Lf(S));
      b && !p && c("render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render."), o.nodeType === Yo && o.tagName && o.tagName.toUpperCase() === "BODY" && c("render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");
    };
    function ck(o) {
      return o ? o.nodeType === Yl ? o.documentElement : o.firstChild : null;
    }
    function J3() {
    }
    function Bee(o, a, p, S, b) {
      if (b) {
        if (typeof S == "function") {
          var T = S;
          S = function() {
            var ue = b1(D);
            T.call(ue);
          };
        }
        var D = R3(
          a,
          S,
          o,
          Ff,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          J3
        );
        o._reactRootContainer = D, d0(D.current, o);
        var N = o.nodeType === li ? o.parentNode : o;
        return rS(N), Cd(), D;
      } else {
        for (var $; $ = o.lastChild; )
          o.removeChild($);
        if (typeof S == "function") {
          var G = S;
          S = function() {
            var ue = b1(X);
            G.call(ue);
          };
        }
        var X = k3(
          o,
          Ff,
          null,
          // hydrationCallbacks
          !1,
          // isStrictMode
          !1,
          // concurrentUpdatesByDefaultOverride,
          "",
          // identifierPrefix
          J3
        );
        o._reactRootContainer = X, d0(X.current, o);
        var fe = o.nodeType === li ? o.parentNode : o;
        return rS(fe), Cd(function() {
          ZS(a, X, p, S);
        }), X;
      }
    }
    function Hee(o, a) {
      o !== null && typeof o != "function" && c("%s(...): Expected the last optional `callback` argument to be a function. Instead received: %s.", a, o);
    }
    function _1(o, a, p, S, b) {
      Q3(p), Hee(b === void 0 ? null : b, "render");
      var T = p._reactRootContainer, D;
      if (!T)
        D = Bee(p, a, o, b, S);
      else {
        if (D = T, typeof b == "function") {
          var N = b;
          b = function() {
            var $ = b1(D);
            N.call($);
          };
        }
        ZS(a, D, o, b);
      }
      return b1(D);
    }
    var eF = !1;
    function Vee(o) {
      {
        eF || (eF = !0, c("findDOMNode is deprecated and will be removed in the next major release. Instead, add a ref directly to the element you want to reference. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-find-node"));
        var a = $ee.current;
        if (a !== null && a.stateNode !== null) {
          var p = a.stateNode._warnedAboutRefsInRender;
          p || c("%s is accessing findDOMNode inside its render(). render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.", Cn(a.type) || "A component"), a.stateNode._warnedAboutRefsInRender = !0;
        }
      }
      return o == null ? null : o.nodeType === Yo ? o : Iee(o, "findDOMNode");
    }
    function Kee(o, a, p) {
      if (c("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QS(a))
        throw new Error("Target container is not a DOM element.");
      {
        var S = pS(a) && a._reactRootContainer === void 0;
        S && c("You are calling ReactDOM.hydrate() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call hydrateRoot(container, element)?");
      }
      return _1(null, o, a, !0, p);
    }
    function Wee(o, a, p) {
      if (c("ReactDOM.render is no longer supported in React 18. Use createRoot instead. Until you switch to the new API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QS(a))
        throw new Error("Target container is not a DOM element.");
      {
        var S = pS(a) && a._reactRootContainer === void 0;
        S && c("You are calling ReactDOM.render() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.render(element)?");
      }
      return _1(null, o, a, !1, p);
    }
    function Gee(o, a, p, S) {
      if (c("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported in React 18. Consider using a portal instead. Until you switch to the createRoot API, your app will behave as if it's running React 17. Learn more: https://reactjs.org/link/switch-to-createroot"), !QS(p))
        throw new Error("Target container is not a DOM element.");
      if (o == null || !Gu(o))
        throw new Error("parentComponent must be a valid React Component");
      return _1(o, a, p, !1, S);
    }
    var tF = !1;
    function qee(o) {
      if (tF || (tF = !0, c("unmountComponentAtNode is deprecated and will be removed in the next major release. Switch to the createRoot API. Learn more: https://reactjs.org/link/switch-to-createroot")), !QS(o))
        throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
      {
        var a = pS(o) && o._reactRootContainer === void 0;
        a && c("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
      }
      if (o._reactRootContainer) {
        {
          var p = ck(o), S = p && !Lf(p);
          S && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by another copy of React.");
        }
        return Cd(function() {
          _1(null, null, o, !1, function() {
            o._reactRootContainer = null, XL(o);
          });
        }), !0;
      } else {
        {
          var b = ck(o), T = !!(b && Lf(b)), D = o.nodeType === Yo && QS(o.parentNode) && !!o.parentNode._reactRootContainer;
          T && c("unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s", D ? "You may have accidentally passed in a React root node instead of its container." : "Instead, have the parent component update its state and rerender in order to remove this component.");
        }
        return !1;
      }
    }
    lP(kee), $v(Ree), cP(Mee), cm(Ds), Db(Mb), (typeof Map != "function" || // $FlowIssue Flow incorrectly thinks Map has no prototype
    Map.prototype == null || typeof Map.prototype.forEach != "function" || typeof Set != "function" || // $FlowIssue Flow incorrectly thinks Set has no prototype
    Set.prototype == null || typeof Set.prototype.clear != "function" || typeof Set.prototype.forEach != "function") && c("React depends on Map and Set built-in types. Make sure that you load a polyfill in older browsers. https://reactjs.org/link/react-polyfills"), Hh(XY), db(UI, UJ, Cd);
    function Yee(o, a) {
      var p = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : null;
      if (!E1(a))
        throw new Error("Target container is not a DOM element.");
      return Tee(o, a, null, p);
    }
    function Xee(o, a, p, S) {
      return Gee(o, a, p, S);
    }
    var uk = {
      usingClientEntryPoint: !1,
      // Keep in sync with ReactTestUtils.js.
      // This is an array for better minification.
      Events: [Lf, Mm, f0, dv, cf, UI]
    };
    function Zee(o, a) {
      return uk.usingClientEntryPoint || c('You are importing createRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Fee(o, a);
    }
    function Qee(o, a, p) {
      return uk.usingClientEntryPoint || c('You are importing hydrateRoot from "react-dom" which is not supported. You should instead import it from "react-dom/client".'), Uee(o, a, p);
    }
    function Jee(o) {
      return l3() && c("flushSync was called from inside a lifecycle method. React cannot flush when React is already rendering. Consider moving this call to a scheduler task or micro task."), Cd(o);
    }
    var ete = Nee({
      findFiberByHostInstance: _p,
      bundleType: 1,
      version: rk,
      rendererPackageName: "react-dom"
    });
    if (!ete && mn && window.top === window.self && (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1)) {
      var nF = window.location.protocol;
      /^(https?|file):$/.test(nF) && console.info("%cDownload the React DevTools for a better development experience: https://reactjs.org/link/react-devtools" + (nF === "file:" ? `
You might need to use a local HTTP server (instead of file://): https://reactjs.org/link/react-devtools-faq` : ""), "font-weight:bold");
    }
    ha.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = uk, ha.createPortal = Yee, ha.createRoot = Zee, ha.findDOMNode = Vee, ha.flushSync = Jee, ha.hydrate = Kee, ha.hydrateRoot = Qee, ha.render = Wee, ha.unmountComponentAtNode = qee, ha.unstable_batchedUpdates = UI, ha.unstable_renderSubtreeIntoContainer = Xee, ha.version = rk, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop == "function" && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());
  }(), ha;
}
var dF;
function j$() {
  if (dF) return T1.exports;
  dF = 1;
  var n = {};
  function e() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) {
      if (n.NODE_ENV !== "production")
        throw new Error("^_^");
      try {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e);
      } catch (t) {
        console.error(t);
      }
    }
  }
  return n.NODE_ENV === "production" ? (e(), T1.exports = dte()) : T1.exports = fte(), T1.exports;
}
var fF;
function hte() {
  if (fF) return ny;
  fF = 1;
  var n = {}, e = j$();
  if (n.NODE_ENV === "production")
    ny.createRoot = e.createRoot, ny.hydrateRoot = e.hydrateRoot;
  else {
    var t = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    ny.createRoot = function(r, i) {
      t.usingClientEntryPoint = !0;
      try {
        return e.createRoot(r, i);
      } finally {
        t.usingClientEntryPoint = !1;
      }
    }, ny.hydrateRoot = function(r, i, s) {
      t.usingClientEntryPoint = !0;
      try {
        return e.hydrateRoot(r, i, s);
      } finally {
        t.usingClientEntryPoint = !1;
      }
    };
  }
  return ny;
}
var L$ = hte(), pte = Object.defineProperty, gte = (n, e, t) => e in n ? pte(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, k1 = (n, e, t) => gte(n, typeof e != "symbol" ? e + "" : e, t);
const mte = {
  stringify: (n) => n ? "true" : "false",
  parse: (n) => /^[ty1-9]/i.test(n)
}, yte = {
  stringify: (n) => n.name,
  parse: (n, e, t) => {
    const r = (() => {
      if (typeof window < "u" && n in window)
        return window[n];
      if (typeof global < "u" && n in global)
        return global[n];
    })();
    return typeof r == "function" ? r.bind(t) : void 0;
  }
}, vte = {
  stringify: (n) => JSON.stringify(n),
  parse: (n) => JSON.parse(n)
}, Ste = {
  stringify: (n) => `${n}`,
  parse: (n) => parseFloat(n)
}, xte = {
  stringify: (n) => n,
  parse: (n) => n
}, hk = {
  string: xte,
  number: Ste,
  boolean: mte,
  function: yte,
  json: vte
};
function wte(n) {
  return n.replace(
    /([a-z0-9])([A-Z])/g,
    (e, t, r) => `${t}-${r.toLowerCase()}`
  );
}
const R1 = Symbol.for("r2wc.render"), M1 = Symbol.for("r2wc.connected"), $p = Symbol.for("r2wc.context"), Pd = Symbol.for("r2wc.props");
function bte(n, e, t) {
  var r, i, s;
  e.props || (e.props = n.propTypes ? Object.keys(n.propTypes) : []), e.events || (e.events = []);
  const l = Array.isArray(e.props) ? e.props.slice() : Object.keys(e.props), c = Array.isArray(e.events) ? e.events.slice() : Object.keys(e.events), d = {}, h = {}, g = {}, y = {};
  for (const w of l) {
    d[w] = Array.isArray(e.props) ? "string" : e.props[w];
    const C = wte(w);
    g[w] = C, y[C] = w;
  }
  for (const w of c)
    h[w] = Array.isArray(e.events) ? {} : e.events[w];
  class v extends HTMLElement {
    constructor() {
      super(), k1(this, s, !0), k1(this, i), k1(this, r, {}), k1(this, "container"), e.shadow ? this.container = this.attachShadow({
        mode: e.shadow
      }) : this.container = this, this[Pd].container = this.container;
      for (const C of l) {
        const E = g[C], P = this.getAttribute(E), I = d[C], k = I ? hk[I] : null;
        k != null && k.parse && P && (this[Pd][C] = k.parse(P, E, this));
      }
      for (const C of c)
        this[Pd][C] = (E) => {
          const P = C.replace(/^on/, "").toLowerCase();
          this.dispatchEvent(
            new CustomEvent(P, { detail: E, ...h[C] })
          );
        };
    }
    static get observedAttributes() {
      return Object.keys(y);
    }
    connectedCallback() {
      this[M1] = !0, this[R1]();
    }
    disconnectedCallback() {
      this[M1] = !1, this[$p] && t.unmount(this[$p]), delete this[$p];
    }
    attributeChangedCallback(C, E, P) {
      const I = y[C], k = d[I], L = k ? hk[k] : null;
      I in d && L != null && L.parse && P && (this[Pd][I] = L.parse(P, C, this), this[R1]());
    }
    [(s = M1, i = $p, r = Pd, R1)]() {
      this[M1] && (this[$p] ? t.update(this[$p], this[Pd]) : this[$p] = t.mount(
        this.container,
        n,
        this[Pd]
      ));
    }
  }
  for (const w of l) {
    const C = g[w], E = d[w];
    Object.defineProperty(v.prototype, w, {
      enumerable: !0,
      configurable: !0,
      get() {
        return this[Pd][w];
      },
      set(P) {
        this[Pd][w] = P;
        const I = E ? hk[E] : null;
        if (I != null && I.stringify) {
          const k = I.stringify(P, C, this);
          this.getAttribute(C) !== k && this.setAttribute(C, k);
        } else
          this[R1]();
      }
    });
  }
  return v;
}
function Cte(n, e, t) {
  const r = L$.createRoot(n), i = Bt.createElement(e, t);
  return r.render(i), {
    root: r,
    ReactComponent: e
  };
}
function Ete({ root: n, ReactComponent: e }, t) {
  const r = Bt.createElement(e, t);
  n.render(r);
}
function _te({ root: n }) {
  n.unmount();
}
function Pte(n, e = {}) {
  return bte(n, e, { mount: Cte, update: Ete, unmount: _te });
}
const pk = "__TLDRAW_LIBRARY_VERSIONS__";
function Tte() {
  if (globalThis[pk])
    return globalThis[pk];
  const n = {
    versions: [],
    didWarn: !1,
    scheduledNotice: null
  };
  return Object.defineProperty(globalThis, pk, {
    value: n,
    writable: !1,
    configurable: !1,
    enumerable: !1
  }), n;
}
function Au(n, e, t) {
  if (!n)
    throw new Error("Missing name/version/module system in built version of tldraw library");
  const r = Tte();
  if (r.versions.push({ name: n, version: e, modules: t }), !r.scheduledNotice)
    try {
      r.scheduledNotice = setTimeout(() => {
        r.scheduledNotice = null, hF(r);
      }, 100);
    } catch {
      hF(r);
    }
}
function hF(n) {
  if (!n.versions.length || n.didWarn) return;
  const e = n.versions.sort((c, d) => pF(c.version, d.version)), t = e[e.length - 1].version, r = /* @__PURE__ */ new Set(), i = /* @__PURE__ */ new Map();
  for (const c of e) {
    if (i.has(c.name)) {
      r.delete(c.name), gk(i, c.name, /* @__PURE__ */ new Set()).add(c.version);
      continue;
    }
    c.version === t ? r.add(c.name) : (r.delete(c.name), gk(i, c.name, /* @__PURE__ */ new Set()).add(c.version));
  }
  if (i.size > 0) {
    const c = [
      `${Td("[tldraw]", ["bold", "bgRed", "textWhite"])} ${Td("You have multiple versions of tldraw libraries installed. This can lead to bugs and unexpected behavior.", ["textRed", "bold"])}`,
      "",
      `The latest version you have installed is ${Td(`v${t}`, ["bold", "textBlue"])}. The following libraries are on the latest version:`,
      ...Array.from(r, (d) => `  • ✅ ${Td(d, ["bold"])}`),
      "",
      "The following libraries are not on the latest version, or have multiple versions installed:",
      ...Array.from(i, ([d, h]) => {
        const g = Array.from(h).sort(pF).map((y) => Td(`v${y}`, y === t ? ["textGreen"] : ["textRed"]));
        return `  • ❌ ${Td(d, ["bold"])} (${g.join(", ")})`;
      })
    ];
    console.log(c.join(`
`)), n.didWarn = !0;
    return;
  }
  const s = /* @__PURE__ */ new Map();
  for (const c of e)
    gk(s, c.name, { version: c.version, modules: [] }).modules.push(
      c.modules
    );
  const l = /* @__PURE__ */ new Map();
  for (const [c, d] of s)
    d.modules.length > 1 && l.set(c, d);
  if (l.size > 0) {
    const c = [
      `${Td("[tldraw]", ["bold", "bgRed", "textWhite"])} ${Td("You have multiple instances of some tldraw libraries active. This can lead to bugs and unexpected behavior. ", ["textRed", "bold"])}`,
      "",
      "This usually means that your bundler is misconfigured, and is importing the same library multiple times - usually once as an ES Module, and once as a CommonJS module.",
      "",
      "The following libraries have been imported multiple times:",
      ...Array.from(l, ([d, h]) => {
        const g = h.modules.map((y, v) => y === "esm" ? `      ${v + 1}. ES Modules` : `      ${v + 1}. CommonJS`).join(`
`);
        return `  • ❌ ${Td(d, ["bold"])} v${h.version}: 
${g}`;
      }),
      "",
      "You should configure your bundler to only import one version of each library."
    ];
    console.log(c.join(`
`)), n.didWarn = !0;
    return;
  }
}
function pF(n, e) {
  const t = n.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/), r = e.match(/^(\d+)\.(\d+)\.(\d+)(?:-(\w+))?$/);
  return !t || !r ? n.localeCompare(e) : t[1] !== r[1] ? Number(t[1]) - Number(r[1]) : t[2] !== r[2] ? Number(t[2]) - Number(r[2]) : t[3] !== r[3] ? Number(t[3]) - Number(r[3]) : t[4] && r[4] ? t[4].localeCompare(r[4]) : t[4] ? 1 : r[4] ? -1 : 0;
}
const Ite = {
  bold: "1",
  textBlue: "94",
  textRed: "31",
  textGreen: "32",
  bgRed: "41",
  textWhite: "97"
};
function Td(n, e = []) {
  return `\x1B[${e.map((t) => Ite[t]).join(";")}m${n}\x1B[m`;
}
function gk(n, e, t) {
  return n.has(e) ? n.get(e) : (n.set(e, t), t);
}
var mk, gF;
function kte() {
  if (gF) return mk;
  gF = 1;
  var n = "Expected a function", e = NaN, t = "[object Symbol]", r = /^\s+|\s+$/g, i = /^[-+]0x[0-9a-f]+$/i, s = /^0b[01]+$/i, l = /^0o[0-7]+$/i, c = parseInt, d = typeof ba == "object" && ba && ba.Object === Object && ba, h = typeof self == "object" && self && self.Object === Object && self, g = d || h || Function("return this")(), y = Object.prototype, v = y.toString, w = Math.max, C = Math.min, E = function() {
    return g.Date.now();
  };
  function P(F, H, V) {
    var re, q, J, ie, W, Y, oe = 0, le = !1, ce = !1, Q = !0;
    if (typeof F != "function")
      throw new TypeError(n);
    H = z(H) || 0, k(V) && (le = !!V.leading, ce = "maxWait" in V, J = ce ? w(z(V.maxWait) || 0, H) : J, Q = "trailing" in V ? !!V.trailing : Q);
    function he(We) {
      var Qe = re, gt = q;
      return re = q = void 0, oe = We, ie = F.apply(gt, Qe), ie;
    }
    function ke(We) {
      return oe = We, W = setTimeout(Oe, H), le ? he(We) : ie;
    }
    function te(We) {
      var Qe = We - Y, gt = We - oe, Pt = H - Qe;
      return ce ? C(Pt, J - gt) : Pt;
    }
    function me(We) {
      var Qe = We - Y, gt = We - oe;
      return Y === void 0 || Qe >= H || Qe < 0 || ce && gt >= J;
    }
    function Oe() {
      var We = E();
      if (me(We))
        return Ze(We);
      W = setTimeout(Oe, te(We));
    }
    function Ze(We) {
      return W = void 0, Q && re ? he(We) : (re = q = void 0, ie);
    }
    function De() {
      W !== void 0 && clearTimeout(W), oe = 0, re = Y = q = W = void 0;
    }
    function yt() {
      return W === void 0 ? ie : Ze(E());
    }
    function it() {
      var We = E(), Qe = me(We);
      if (re = arguments, q = this, Y = We, Qe) {
        if (W === void 0)
          return ke(Y);
        if (ce)
          return W = setTimeout(Oe, H), he(Y);
      }
      return W === void 0 && (W = setTimeout(Oe, H)), ie;
    }
    return it.cancel = De, it.flush = yt, it;
  }
  function I(F, H, V) {
    var re = !0, q = !0;
    if (typeof F != "function")
      throw new TypeError(n);
    return k(V) && (re = "leading" in V ? !!V.leading : re, q = "trailing" in V ? !!V.trailing : q), P(F, H, {
      leading: re,
      maxWait: H,
      trailing: q
    });
  }
  function k(F) {
    var H = typeof F;
    return !!F && (H == "object" || H == "function");
  }
  function L(F) {
    return !!F && typeof F == "object";
  }
  function O(F) {
    return typeof F == "symbol" || L(F) && v.call(F) == t;
  }
  function z(F) {
    if (typeof F == "number")
      return F;
    if (O(F))
      return e;
    if (k(F)) {
      var H = typeof F.valueOf == "function" ? F.valueOf() : F;
      F = k(H) ? H + "" : H;
    }
    if (typeof F != "string")
      return F === 0 ? F : +F;
    F = F.replace(r, "");
    var V = s.test(F);
    return V || l.test(F) ? c(F.slice(2), V ? 2 : 8) : i.test(F) ? e : +F;
  }
  return mk = I, mk;
}
var Rte = kte();
const N$ = /* @__PURE__ */ wh(Rte);
var yk, mF;
function Mte() {
  if (mF) return yk;
  mF = 1;
  var n = 200, e = "__lodash_hash_undefined__", t = 1 / 0, r = "[object Function]", i = "[object GeneratorFunction]", s = /[\\^$.*+?()[\]{}|]/g, l = /^\[object .+?Constructor\]$/, c = typeof ba == "object" && ba && ba.Object === Object && ba, d = typeof self == "object" && self && self.Object === Object && self, h = c || d || Function("return this")();
  function g(Ee, ve) {
    var $e = Ee ? Ee.length : 0;
    return !!$e && v(Ee, ve, 0) > -1;
  }
  function y(Ee, ve, $e, mt) {
    for (var cn = Ee.length, yn = $e + -1; ++yn < cn; )
      if (ve(Ee[yn], yn, Ee))
        return yn;
    return -1;
  }
  function v(Ee, ve, $e) {
    if (ve !== ve)
      return y(Ee, w, $e);
    for (var mt = $e - 1, cn = Ee.length; ++mt < cn; )
      if (Ee[mt] === ve)
        return mt;
    return -1;
  }
  function w(Ee) {
    return Ee !== Ee;
  }
  function C(Ee, ve) {
    return Ee.has(ve);
  }
  function E(Ee, ve) {
    return Ee == null ? void 0 : Ee[ve];
  }
  function P(Ee) {
    var ve = !1;
    if (Ee != null && typeof Ee.toString != "function")
      try {
        ve = !!(Ee + "");
      } catch {
      }
    return ve;
  }
  function I(Ee) {
    var ve = -1, $e = Array(Ee.size);
    return Ee.forEach(function(mt) {
      $e[++ve] = mt;
    }), $e;
  }
  var k = Array.prototype, L = Function.prototype, O = Object.prototype, z = h["__core-js_shared__"], F = function() {
    var Ee = /[^.]+$/.exec(z && z.keys && z.keys.IE_PROTO || "");
    return Ee ? "Symbol(src)_1." + Ee : "";
  }(), H = L.toString, V = O.hasOwnProperty, re = O.toString, q = RegExp(
    "^" + H.call(V).replace(s, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
  ), J = k.splice, ie = wr(h, "Map"), W = wr(h, "Set"), Y = wr(Object, "create");
  function oe(Ee) {
    var ve = -1, $e = Ee ? Ee.length : 0;
    for (this.clear(); ++ve < $e; ) {
      var mt = Ee[ve];
      this.set(mt[0], mt[1]);
    }
  }
  function le() {
    this.__data__ = Y ? Y(null) : {};
  }
  function ce(Ee) {
    return this.has(Ee) && delete this.__data__[Ee];
  }
  function Q(Ee) {
    var ve = this.__data__;
    if (Y) {
      var $e = ve[Ee];
      return $e === e ? void 0 : $e;
    }
    return V.call(ve, Ee) ? ve[Ee] : void 0;
  }
  function he(Ee) {
    var ve = this.__data__;
    return Y ? ve[Ee] !== void 0 : V.call(ve, Ee);
  }
  function ke(Ee, ve) {
    var $e = this.__data__;
    return $e[Ee] = Y && ve === void 0 ? e : ve, this;
  }
  oe.prototype.clear = le, oe.prototype.delete = ce, oe.prototype.get = Q, oe.prototype.has = he, oe.prototype.set = ke;
  function te(Ee) {
    var ve = -1, $e = Ee ? Ee.length : 0;
    for (this.clear(); ++ve < $e; ) {
      var mt = Ee[ve];
      this.set(mt[0], mt[1]);
    }
  }
  function me() {
    this.__data__ = [];
  }
  function Oe(Ee) {
    var ve = this.__data__, $e = Yt(ve, Ee);
    if ($e < 0)
      return !1;
    var mt = ve.length - 1;
    return $e == mt ? ve.pop() : J.call(ve, $e, 1), !0;
  }
  function Ze(Ee) {
    var ve = this.__data__, $e = Yt(ve, Ee);
    return $e < 0 ? void 0 : ve[$e][1];
  }
  function De(Ee) {
    return Yt(this.__data__, Ee) > -1;
  }
  function yt(Ee, ve) {
    var $e = this.__data__, mt = Yt($e, Ee);
    return mt < 0 ? $e.push([Ee, ve]) : $e[mt][1] = ve, this;
  }
  te.prototype.clear = me, te.prototype.delete = Oe, te.prototype.get = Ze, te.prototype.has = De, te.prototype.set = yt;
  function it(Ee) {
    var ve = -1, $e = Ee ? Ee.length : 0;
    for (this.clear(); ++ve < $e; ) {
      var mt = Ee[ve];
      this.set(mt[0], mt[1]);
    }
  }
  function We() {
    this.__data__ = {
      hash: new oe(),
      map: new (ie || te)(),
      string: new oe()
    };
  }
  function Qe(Ee) {
    return Pr(this, Ee).delete(Ee);
  }
  function gt(Ee) {
    return Pr(this, Ee).get(Ee);
  }
  function Pt(Ee) {
    return Pr(this, Ee).has(Ee);
  }
  function mn(Ee, ve) {
    return Pr(this, Ee).set(Ee, ve), this;
  }
  it.prototype.clear = We, it.prototype.delete = Qe, it.prototype.get = gt, it.prototype.has = Pt, it.prototype.set = mn;
  function Zt(Ee) {
    var ve = -1, $e = Ee ? Ee.length : 0;
    for (this.__data__ = new it(); ++ve < $e; )
      this.add(Ee[ve]);
  }
  function an(Ee) {
    return this.__data__.set(Ee, e), this;
  }
  function ln(Ee) {
    return this.__data__.has(Ee);
  }
  Zt.prototype.add = Zt.prototype.push = an, Zt.prototype.has = ln;
  function Yt(Ee, ve) {
    for (var $e = Ee.length; $e--; )
      if (Tr(Ee[$e][0], ve))
        return $e;
    return -1;
  }
  function Gn(Ee) {
    if (!Zr(Ee) || Kr(Ee))
      return !1;
    var ve = Ir(Ee) || P(Ee) ? q : l;
    return ve.test(si(Ee));
  }
  function xr(Ee, ve, $e) {
    var mt = -1, cn = g, yn = Ee.length, qn = !0, Rn = [], sr = Rn;
    if (yn >= n) {
      var bn = Hr(Ee);
      if (bn)
        return I(bn);
      qn = !1, cn = C, sr = new Zt();
    } else
      sr = Rn;
    e:
      for (; ++mt < yn; ) {
        var vn = Ee[mt], fn = vn;
        if (vn = vn !== 0 ? vn : 0, qn && fn === fn) {
          for (var Ii = sr.length; Ii--; )
            if (sr[Ii] === fn)
              continue e;
          Rn.push(vn);
        } else cn(sr, fn, $e) || (sr !== Rn && sr.push(fn), Rn.push(vn));
      }
    return Rn;
  }
  var Hr = W && 1 / I(new W([, -0]))[1] == t ? function(Ee) {
    return new W(Ee);
  } : Ko;
  function Pr(Ee, ve) {
    var $e = Ee.__data__;
    return Vr(ve) ? $e[typeof ve == "string" ? "string" : "hash"] : $e.map;
  }
  function wr(Ee, ve) {
    var $e = E(Ee, ve);
    return Gn($e) ? $e : void 0;
  }
  function Vr(Ee) {
    var ve = typeof Ee;
    return ve == "string" || ve == "number" || ve == "symbol" || ve == "boolean" ? Ee !== "__proto__" : Ee === null;
  }
  function Kr(Ee) {
    return !!F && F in Ee;
  }
  function si(Ee) {
    if (Ee != null) {
      try {
        return H.call(Ee);
      } catch {
      }
      try {
        return Ee + "";
      } catch {
      }
    }
    return "";
  }
  function mo(Ee) {
    return Ee && Ee.length ? xr(Ee) : [];
  }
  function Tr(Ee, ve) {
    return Ee === ve || Ee !== Ee && ve !== ve;
  }
  function Ir(Ee) {
    var ve = Zr(Ee) ? re.call(Ee) : "";
    return ve == r || ve == i;
  }
  function Zr(Ee) {
    var ve = typeof Ee;
    return !!Ee && (ve == "object" || ve == "function");
  }
  function Ko() {
  }
  return yk = mo, yk;
}
var Ate = Mte();
const Dte = /* @__PURE__ */ wh(Ate);
function F$(n) {
  const e = (...t) => {
    try {
      return n(...t);
    } catch (r) {
      throw r instanceof Error && Error.captureStackTrace && Error.captureStackTrace(r, e), r;
    }
  };
  return e;
}
const $x = () => {
}, uh = {
  ok(n) {
    return { ok: !0, value: n };
  },
  err(n) {
    return { ok: !1, error: n };
  }
};
function ro(n, e) {
  const t = e && n && typeof n == "object" && e in n ? n[e] : n;
  throw new Error(`Unknown switch case ${t}`);
}
const on = F$(
  (n, e) => {
    if (!n)
      throw new Error(e || "Assertion Error");
  }
), Sa = F$((n, e) => {
  if (n == null)
    throw new Error(e ?? "value must be defined");
  return n;
});
function WD() {
  let n, e;
  const t = new Promise((r, i) => {
    n = r, e = i;
  });
  return Object.assign(t, {
    resolve: n,
    reject: e
  });
}
function MA(n) {
  return new Promise((e) => setTimeout(e, n));
}
const vx = {
  Good: "#40C057",
  Mid: "#FFC078",
  Poor: "#E03131"
}, Ote = vx.Good;
class z$ {
  constructor() {
    U(this, "startTime", 0);
    U(this, "name", "");
    U(this, "frames", 0);
    U(this, "started", !1);
    U(this, "frame", null);
    // eslint-disable-next-line local/prefer-class-methods
    U(this, "recordFrame", () => {
      this.frames++, this.started && (this.frame = requestAnimationFrame(this.recordFrame));
    });
  }
  start(e) {
    this.name = e, this.frames = 0, this.started = !0, this.frame !== null && cancelAnimationFrame(this.frame), this.frame = requestAnimationFrame(this.recordFrame), this.startTime = performance.now();
  }
  stop() {
    this.started = !1, this.frame !== null && cancelAnimationFrame(this.frame);
    const e = (performance.now() - this.startTime) / 1e3, t = e === 0 ? 0 : Math.floor(this.frames / e), r = t > 55 ? vx.Good : t > 30 ? vx.Mid : vx.Poor, i = r === vx.Mid ? "black" : "white", s = this.name[0].toUpperCase() + this.name.slice(1);
    console.debug(
      `%cPerf%c ${s} %c${t}%c fps`,
      `color: white; background: ${Ote};padding: 2px;border-radius: 3px;`,
      "font-weight: normal",
      `font-weight: bold; padding: 2px; background: ${r};color: ${i};`,
      "font-weight: normal"
    );
  }
  isStarted() {
    return this.started;
  }
}
function GD(n, e) {
  const t = [];
  e: for (const r of n) {
    for (const i of t)
      if (e ? e(r, i) : r === i)
        continue e;
    t.push(r);
  }
  return t;
}
function rn(n) {
  return n.filter((e) => e != null);
}
function jo(n) {
  return n[n.length - 1];
}
function jte(n, e) {
  let t, r = 1 / 0;
  for (const i of n) {
    const s = e(i);
    s < r && (t = i, r = s);
  }
  return t;
}
function Lte(n, e) {
  let t, r = -1 / 0;
  for (const i of n) {
    const s = e(i);
    s > r && (t = i, r = s);
  }
  return t;
}
function U$(n, e) {
  if (n === e) return !0;
  if (n.length !== e.length) return !1;
  for (let t = 0; t < n.length; t++)
    if (!Object.is(n[t], e[t]))
      return !1;
  return !0;
}
function Ca(...n) {
  if (n.length === 2) {
    const [e, t] = n;
    t.addInitializer(function() {
      on(Reflect.isExtensible(this), "Cannot bind to a non-extensible class.");
      const i = e.bind(this), s = Reflect.defineProperty(this, t.name, {
        value: i,
        writable: !0,
        configurable: !0
      });
      on(s, "Cannot bind a non-configurable class method.");
    });
  } else {
    const [e, t, r] = n;
    if (!r || typeof r.value != "function")
      throw new TypeError(
        `Only methods can be decorated with @bind. <${t}> is not a method!`
      );
    return {
      configurable: !0,
      get() {
        const i = r.value.bind(this);
        return Object.defineProperty(this, t, {
          value: i,
          configurable: !0,
          writable: !0
        }), i;
      }
    };
  }
}
class Cu {
  constructor() {
    /** The map of items to their cached values. */
    U(this, "items", /* @__PURE__ */ new WeakMap());
  }
  /**
   * Get the cached value for a given record. If the record is not present in the map, the callback
   * will be used to create the value (with the result being stored in the cache for next time).
   *
   * @param item - The item to get.
   * @param cb - The callback to use to create the value when a cached value is not found.
   */
  get(e, t) {
    return this.items.has(e) || this.items.set(e, t(e)), this.items.get(e);
  }
}
function LE(n, e) {
  let t;
  const r = (...i) => (t || (t = {}, t.promise = new Promise((s, l) => {
    t.resolve = s, t.reject = l;
  })), clearTimeout(t.timeout), t.latestArgs = i, t.timeout = setTimeout(() => {
    const s = t;
    t = void 0;
    try {
      s.resolve(n(...s.latestArgs));
    } catch (l) {
      s.reject(l);
    }
  }, e), t.promise);
  return r.cancel = () => {
    t && clearTimeout(t.timeout);
  }, r;
}
const yF = /* @__PURE__ */ new WeakMap();
function qD(n, e) {
  if (typeof n != "object" || n === null) return;
  let t = yF.get(n);
  t || (t = { tags: {}, extras: {} }, yF.set(n, t)), e.tags && (t.tags = {
    ...t.tags,
    ...e.tags
  }), e.extras && (t.extras = {
    ...t.extras,
    ...e.extras
  });
}
async function Eu(n, e) {
  return window.fetch(n, {
    // We want to make sure that the referrer is not sent to other domains.
    referrerPolicy: "strict-origin-when-cross-origin",
    ...e
  });
}
const Bx = (n, e) => {
  const t = new window.Image(n, e);
  return t.referrerPolicy = "strict-origin-when-cross-origin", t;
};
class yc {
  /**
   * @param dataURL - The file as a string.
   *
   * from https://stackoverflow.com/a/53817185
   */
  static async dataUrlToArrayBuffer(e) {
    return Eu(e).then(function(t) {
      return t.arrayBuffer();
    });
  }
  /**
   * Convert a file to a base64 encoded data url.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.toDataUrl(myImageFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToDataUrl(e) {
    return await new Promise((t, r) => {
      if (e) {
        const i = new FileReader();
        i.onload = () => t(i.result), i.onerror = (s) => r(s), i.onabort = (s) => r(s), i.readAsDataURL(e);
      }
    });
  }
  /**
   * Convert a file to a unicode text string.
   *
   * @example
   *
   * ```ts
   * const A = FileHelpers.fileToDataUrl(myTextFile)
   * ```
   *
   * @param file - The file as a blob.
   */
  static async blobToText(e) {
    return await new Promise((t, r) => {
      if (e) {
        const i = new FileReader();
        i.onload = () => t(i.result), i.onerror = (s) => r(s), i.onabort = (s) => r(s), i.readAsText(e);
      }
    });
  }
  static rewriteMimeType(e, t) {
    return e.type === t ? e : e instanceof File ? new File([e], e.name, { type: t }) : new Blob([e], { type: t });
  }
}
function AA(n) {
  let e = 0;
  for (let t = 0; t < n.length; t++)
    e = (e << 5) - e + n.charCodeAt(t), e |= 0;
  return e + "";
}
function vF(n) {
  const e = new DataView(n);
  let t = 0;
  for (let r = 0; r < e.byteLength; r++)
    t = (t << 5) - t + e.getUint8(r), t |= 0;
  return t + "";
}
/*!
 * MIT License: https://github.com/ai/nanoid/blob/main/LICENSE
 * Modified code originally from <https://github.com/ai/nanoid>
 * Copyright 2017 Andrey Sitnik <andrey@sitnik.ru>
 *
 * `nanoid` is currently only distributed as an ES module. Some tools (jest, playwright) don't
 * properly support ESM-only code yet, and tldraw itself is distributed as both an ES module and a
 * CommonJS module. By including nanoid here, we can make sure it works well in every environment
 * where tldraw is used. We can also remove some unused features like custom alphabets.
 */
const SF = globalThis.crypto, Nte = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict", Fte = 128;
let Hp, yy;
function zte(n) {
  !Hp || Hp.length < n ? (Hp = new Uint8Array(n * Fte), SF.getRandomValues(Hp), yy = 0) : yy + n > Hp.length && (SF.getRandomValues(Hp), yy = 0), yy += n;
}
function Ute(n = 21) {
  zte(n -= 0);
  let e = "";
  for (let t = yy - n; t < yy; t++)
    e += Nte[Hp[t] & 63];
  return e;
}
let $te = Ute;
function or(n) {
  return $te(n);
}
/*!
 * MIT License: https://github.com/vHeemstra/is-apng/blob/main/license
 * Copyright (c) Philip van Heemstra
 */
function Bte(n) {
  const e = new Uint8Array(n);
  if (!e || !(typeof Buffer < "u" && Buffer.isBuffer(e) || e instanceof Uint8Array) || e.length < 16 || !(e[0] === 137 && e[1] === 80 && e[2] === 78 && e[3] === 71 && e[4] === 13 && e[5] === 10 && e[6] === 26 && e[7] === 10))
    return !1;
  function r(s, l, c, d, h = 1024) {
    if (!l)
      return -1;
    l = new RegExp(l, "g");
    const g = l.source.length, y = new TextDecoder(), v = s.length;
    if (typeof d > "u" && (d = v), c >= v || d <= 0 || c >= d)
      return -1;
    s = s.subarray(c, d);
    let w = -1, C = 0, E = 0, P = "";
    e: for (; C < s.length; ) {
      const I = C + h, k = s.subarray(C, I), L = y.decode(k, { stream: !0 }), O = P + L;
      let z, F = -1;
      for (; (z = l.exec(O)) !== null; ) {
        F = z.index - P.length, w = E + F;
        break e;
      }
      C = I, E += L.length;
      const H = F > -1 ? F + g : L.length - g;
      P = L.slice(H);
    }
    return w >= 0 && (w += c >= 0 ? c : v + c), w;
  }
  const i = r(e, "IDAT", 12);
  return i >= 12 ? r(e, "acTL", 8, i) >= 8 : !1;
}
const Hte = (n) => new Uint8Array(n)[3] === 44;
/*!
 * MIT License
 * Modified code originally from <https://github.com/qzb/is-animated>
 * Copyright (c) 2016 Józef Sokołowski <j.k.sokolowski@gmail.com>
 */
function xF(n, e) {
  let t = 0;
  for (; n[e + t]; )
    t += n[e + t] + 1;
  return t + 1;
}
function Vte(n) {
  return new TextDecoder("ascii").decode(n.slice(0, 3)) === "GIF";
}
function Kte(n) {
  const e = new Uint8Array(n);
  let t, r, i = 0, s = 0;
  if (!Vte(n))
    return !1;
  for (t = e[10] & 128, r = e[10] & 7, i += 6, i += 7, i += t ? 3 * Math.pow(2, r + 1) : 0; s < 2 && i < e.length; )
    switch (e[i]) {
      case 44:
        s += 1, t = e[i + 9] & 128, r = e[i + 9] & 7, i += 10, i += t ? 3 * Math.pow(2, r + 1) : 0, i += xF(e, i + 1) + 1;
        break;
      case 33:
        i += 2, i += xF(e, i);
        break;
      case 59:
        i = e.length;
        break;
      default:
        i = e.length;
        break;
    }
  return s > 1;
}
/*!
 * MIT License: https://github.com/alexgorbatchev/crc/blob/master/LICENSE
 * Copyright: 2014 Alex Gorbatchev
 * Code: crc32, https://github.com/alexgorbatchev/crc/blob/master/src/calculators/crc32.ts
 */
let DA = [
  0,
  1996959894,
  3993919788,
  2567524794,
  124634137,
  1886057615,
  3915621685,
  2657392035,
  249268274,
  2044508324,
  3772115230,
  2547177864,
  162941995,
  2125561021,
  3887607047,
  2428444049,
  498536548,
  1789927666,
  4089016648,
  2227061214,
  450548861,
  1843258603,
  4107580753,
  2211677639,
  325883990,
  1684777152,
  4251122042,
  2321926636,
  335633487,
  1661365465,
  4195302755,
  2366115317,
  997073096,
  1281953886,
  3579855332,
  2724688242,
  1006888145,
  1258607687,
  3524101629,
  2768942443,
  901097722,
  1119000684,
  3686517206,
  2898065728,
  853044451,
  1172266101,
  3705015759,
  2882616665,
  651767980,
  1373503546,
  3369554304,
  3218104598,
  565507253,
  1454621731,
  3485111705,
  3099436303,
  671266974,
  1594198024,
  3322730930,
  2970347812,
  795835527,
  1483230225,
  3244367275,
  3060149565,
  1994146192,
  31158534,
  2563907772,
  4023717930,
  1907459465,
  112637215,
  2680153253,
  3904427059,
  2013776290,
  251722036,
  2517215374,
  3775830040,
  2137656763,
  141376813,
  2439277719,
  3865271297,
  1802195444,
  476864866,
  2238001368,
  4066508878,
  1812370925,
  453092731,
  2181625025,
  4111451223,
  1706088902,
  314042704,
  2344532202,
  4240017532,
  1658658271,
  366619977,
  2362670323,
  4224994405,
  1303535960,
  984961486,
  2747007092,
  3569037538,
  1256170817,
  1037604311,
  2765210733,
  3554079995,
  1131014506,
  879679996,
  2909243462,
  3663771856,
  1141124467,
  855842277,
  2852801631,
  3708648649,
  1342533948,
  654459306,
  3188396048,
  3373015174,
  1466479909,
  544179635,
  3110523913,
  3462522015,
  1591671054,
  702138776,
  2966460450,
  3352799412,
  1504918807,
  783551873,
  3082640443,
  3233442989,
  3988292384,
  2596254646,
  62317068,
  1957810842,
  3939845945,
  2647816111,
  81470997,
  1943803523,
  3814918930,
  2489596804,
  225274430,
  2053790376,
  3826175755,
  2466906013,
  167816743,
  2097651377,
  4027552580,
  2265490386,
  503444072,
  1762050814,
  4150417245,
  2154129355,
  426522225,
  1852507879,
  4275313526,
  2312317920,
  282753626,
  1742555852,
  4189708143,
  2394877945,
  397917763,
  1622183637,
  3604390888,
  2714866558,
  953729732,
  1340076626,
  3518719985,
  2797360999,
  1068828381,
  1219638859,
  3624741850,
  2936675148,
  906185462,
  1090812512,
  3747672003,
  2825379669,
  829329135,
  1181335161,
  3412177804,
  3160834842,
  628085408,
  1382605366,
  3423369109,
  3138078467,
  570562233,
  1426400815,
  3317316542,
  2998733608,
  733239954,
  1555261956,
  3268935591,
  3050360625,
  752459403,
  1541320221,
  2607071920,
  3965973030,
  1969922972,
  40735498,
  2617837225,
  3943577151,
  1913087877,
  83908371,
  2512341634,
  3803740692,
  2075208622,
  213261112,
  2463272603,
  3855990285,
  2094854071,
  198958881,
  2262029012,
  4057260610,
  1759359992,
  534414190,
  2176718541,
  4139329115,
  1873836001,
  414664567,
  2282248934,
  4279200368,
  1711684554,
  285281116,
  2405801727,
  4167216745,
  1634467795,
  376229701,
  2685067896,
  3608007406,
  1308918612,
  956543938,
  2808555105,
  3495958263,
  1231636301,
  1047427035,
  2932959818,
  3654703836,
  1088359270,
  936918e3,
  2847714899,
  3736837829,
  1202900863,
  817233897,
  3183342108,
  3401237130,
  1404277552,
  615818150,
  3134207493,
  3453421203,
  1423857449,
  601450431,
  3009837614,
  3294710456,
  1567103746,
  711928724,
  3020668471,
  3272380065,
  1510334235,
  755167117
];
typeof Int32Array < "u" && (DA = new Int32Array(DA));
const Wte = (n, e) => {
  let t = -1;
  for (let r = 0; r < n.length; r++)
    t = DA[(t ^ n[r]) & 255] ^ t >>> 8;
  return t ^ -1;
}, wF = 4, bF = 4;
class mu {
  static isPng(e, t) {
    return e.getUint8(t + 0) === 137 && e.getUint8(t + 1) === 80 && e.getUint8(t + 2) === 78 && e.getUint8(t + 3) === 71 && e.getUint8(t + 4) === 13 && e.getUint8(t + 5) === 10 && e.getUint8(t + 6) === 26 && e.getUint8(t + 7) === 10;
  }
  static getChunkType(e, t) {
    return [
      String.fromCharCode(e.getUint8(t)),
      String.fromCharCode(e.getUint8(t + 1)),
      String.fromCharCode(e.getUint8(t + 2)),
      String.fromCharCode(e.getUint8(t + 3))
    ].join("");
  }
  static readChunks(e, t = 0) {
    const r = {};
    if (!mu.isPng(e, t))
      throw new Error("Not a PNG");
    for (t += 8; t <= e.buffer.byteLength; ) {
      const i = t, s = e.getInt32(t);
      t += 4;
      const l = mu.getChunkType(e, t);
      if (l === "IDAT" && r[l]) {
        t += s + wF + bF;
        continue;
      }
      if (l === "IEND")
        break;
      r[l] = {
        start: i,
        dataOffset: t + 4,
        size: s
      }, t += s + wF + bF;
    }
    return r;
  }
  static parsePhys(e, t) {
    return {
      ppux: e.getUint32(t),
      ppuy: e.getUint32(t + 4),
      unit: e.getUint8(t + 4)
    };
  }
  static findChunk(e, t) {
    return mu.readChunks(e)[t];
  }
  static setPhysChunk(e, t = 1, r) {
    let i = 46, s = 0;
    const l = mu.findChunk(e, "pHYs");
    l && (i = l.start, s = l.size);
    const c = mu.findChunk(e, "IDAT");
    c && (i = c.start, s = 0);
    const d = new ArrayBuffer(21), h = new DataView(d);
    h.setUint32(0, 9), h.setUint8(4, 112), h.setUint8(5, 72), h.setUint8(6, 89), h.setUint8(7, 115);
    const g = 2835.5;
    h.setInt32(8, g * t), h.setInt32(12, g * t), h.setInt8(16, 1);
    const y = new Uint8Array(d.slice(4, 17));
    h.setInt32(17, Wte(y));
    const v = e.buffer.slice(0, i), w = e.buffer.slice(i + s);
    return new Blob([v, d, w], r);
  }
}
/*!
 * MIT License: https://github.com/sindresorhus/is-webp/blob/main/license
 * Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)
 */
function Gte(n) {
  return !n || n.length < 12 ? !1 : n[8] === 87 && n[9] === 69 && n[10] === 66 && n[11] === 80;
}
function qte(n) {
  const e = new Uint8Array(n);
  return !Gte(e) || !e || e.length < 21 ? !1 : (e[20] >> 1 & 1) === 1;
}
const $$ = Object.freeze(["image/svg+xml"]), B$ = Object.freeze([
  "image/jpeg",
  "image/png",
  "image/webp"
]), H$ = Object.freeze([
  "image/gif",
  "image/apng",
  "image/avif"
]), NE = Object.freeze([
  ...B$,
  ...$$,
  ...H$
]), YD = Object.freeze([
  "video/mp4",
  "video/webm",
  "video/quicktime"
]), Yte = [
  ...NE,
  ...YD
].join(",");
class Ya {
  /**
   * Load a video from a url.
   * @public
   */
  static loadVideo(e) {
    return new Promise((t, r) => {
      const i = document.createElement("video");
      i.onloadeddata = () => t(i), i.onerror = (s) => {
        console.error(s), r(new Error("Could not load video"));
      }, i.crossOrigin = "anonymous", i.src = e;
    });
  }
  static async getVideoFrameAsDataUrl(e, t = 0) {
    const r = WD();
    let i = !1;
    const s = () => {
      if (!i)
        if (e.readyState >= e.HAVE_METADATA)
          i = !0, e.currentTime = t;
        else
          return;
      if (e.readyState >= e.HAVE_CURRENT_DATA) {
        const c = document.createElement("canvas");
        c.width = e.videoWidth, c.height = e.videoHeight;
        const d = c.getContext("2d");
        if (!d)
          throw new Error("Could not get 2d context");
        d.drawImage(e, 0, 0), r.resolve(c.toDataURL());
      }
    }, l = (c) => {
      console.error(c), r.reject(new Error("Could not get video frame"));
    };
    e.addEventListener("loadedmetadata", s), e.addEventListener("loadeddata", s), e.addEventListener("canplay", s), e.addEventListener("seeked", s), e.addEventListener("error", l), e.addEventListener("stalled", l), s();
    try {
      return await r;
    } finally {
      e.removeEventListener("loadedmetadata", s), e.removeEventListener("loadeddata", s), e.removeEventListener("canplay", s), e.removeEventListener("seeked", s), e.removeEventListener("error", l), e.removeEventListener("stalled", l);
    }
  }
  /**
   * Load an image from a url.
   * @public
   */
  static loadImage(e) {
    return new Promise((t, r) => {
      const i = Bx();
      i.onload = () => t(i), i.onerror = (s) => {
        console.error(s), r(new Error("Could not load image"));
      }, i.crossOrigin = "anonymous", i.referrerPolicy = "strict-origin-when-cross-origin", i.src = e;
    });
  }
  /**
   * Get the size of a video blob
   *
   * @param blob - A SharedBlob containing the video
   * @public
   */
  static async getVideoSize(e) {
    return Ya.usingObjectURL(e, async (t) => {
      const r = await Ya.loadVideo(t);
      return { w: r.videoWidth, h: r.videoHeight };
    });
  }
  /**
   * Get the size of an image blob
   *
   * @param blob - A Blob containing the image.
   * @public
   */
  static async getImageSize(e) {
    const t = await Ya.usingObjectURL(e, Ya.loadImage);
    try {
      if (e.type === "image/png") {
        const r = new DataView(await e.arrayBuffer());
        if (mu.isPng(r, 0)) {
          const i = mu.findChunk(r, "pHYs");
          if (i) {
            const s = mu.parsePhys(r, i.dataOffset);
            if (s.unit === 0 && s.ppux === s.ppuy) {
              const l = Math.max(s.ppux / 2834.5, 1);
              return {
                w: Math.round(t.naturalWidth / l),
                h: Math.round(t.naturalHeight / l)
              };
            }
          }
        }
      }
    } catch (r) {
      return console.error(r), { w: t.naturalWidth, h: t.naturalHeight };
    }
    return { w: t.naturalWidth, h: t.naturalHeight };
  }
  static async isAnimated(e) {
    return e.type === "image/gif" ? Kte(await e.arrayBuffer()) : e.type === "image/avif" ? Hte(await e.arrayBuffer()) : e.type === "image/webp" ? qte(await e.arrayBuffer()) : e.type === "image/apng" ? Bte(await e.arrayBuffer()) : !1;
  }
  static isAnimatedImageType(e) {
    return H$.includes(e || "");
  }
  static isStaticImageType(e) {
    return B$.includes(e || "");
  }
  static isVectorImageType(e) {
    return $$.includes(e || "");
  }
  static isImageType(e) {
    return NE.includes(e);
  }
  static async usingObjectURL(e, t) {
    const r = URL.createObjectURL(e);
    try {
      return await t(r);
    } finally {
      URL.revokeObjectURL(r);
    }
  }
}
function jn(n, e, t) {
  return n + (e - n) * t;
}
function Tc(n = "") {
  let e = 0, t = 0, r = 0, i = 0;
  function s() {
    const l = e ^ e << 11;
    return e = t, t = r, r = i, i ^= (i >>> 19 ^ l ^ l >>> 8) >>> 0, i / 4294967296 * 2;
  }
  for (let l = 0; l < n.length + 64; l++)
    e ^= n.charCodeAt(l) | 0, s();
  return s;
}
function Ry(n, e, t, r = !1) {
  const [i, s] = e, [l, c] = t, d = l + (n - i) / (s - i) * (c - l);
  return r ? l < c ? Math.max(Math.min(d, c), l) : Math.max(Math.min(d, l), c) : d;
}
function xc(n, e) {
  return Object.prototype.hasOwnProperty.call(n, e);
}
function ys(n, e) {
  if (xc(n, e))
    return n[e];
}
function CF(n) {
  return Object.keys(n);
}
function Xr(n) {
  return Object.values(n);
}
function Uo(n) {
  return Object.entries(n);
}
function XD(n) {
  return Object.fromEntries(n);
}
function Rx(n, e) {
  const t = {};
  let r = !1;
  for (const [i, s] of Uo(n))
    e(i, s) ? t[i] = s : r = !0;
  return r ? t : n;
}
function lw(n, e) {
  const t = {};
  for (const [r, i] of Uo(n)) {
    const s = e(r, i);
    t[r] = s;
  }
  return t;
}
function ZD(n, e) {
  if (n === e) return !0;
  const t = new Set(Object.keys(n)), r = new Set(Object.keys(e));
  if (t.size !== r.size) return !1;
  for (const i of t)
    if (!r.has(i) || !Object.is(n[i], e[i])) return !1;
  return !0;
}
function Xte(n) {
  const e = Zte(n.chars), t = Qte(
    e,
    n.firstPositive,
    n.mostPositive,
    n.mostNegative
  ), r = n.jitterRange ?? Math.floor(Math.pow(e.length, 3) / 5), i = Jte(r, e.length);
  return {
    chars: n.chars,
    byChar: e.byChar,
    byCode: e.byCode,
    length: e.length,
    first: e.byCode[0],
    last: e.byCode[e.length - 1],
    firstPositive: t.firstPositive,
    mostPositive: t.mostPositive,
    firstNegative: t.firstNegative,
    mostNegative: t.mostNegative,
    jitterRange: r,
    paddingDict: i
  };
}
function Zte(n) {
  const e = {}, t = {}, r = n.length;
  for (let i = 0; i < r; i++) {
    const s = n[i];
    e[i] = s, t[s] = i;
  }
  return {
    byCode: e,
    byChar: t,
    length: r
  };
}
function Qte(n, e, t, r) {
  const i = e ? n.byChar[e] : Math.ceil(n.length / 2), s = t ? n.byChar[t] : n.length - 1, l = r ? n.byChar[r] : 0;
  if (i === void 0 || s === void 0 || l === void 0)
    throw new Error("invalid charSet");
  if (s - i < 3)
    throw new Error(
      "mostPositive must be at least 3 characters away from neutral"
    );
  if (i - l < 3)
    throw new Error(
      "mostNegative must be at least 3 characters away from neutral"
    );
  return {
    firstPositive: n.byCode[i],
    mostPositive: n.byCode[s],
    firstNegative: n.byCode[i - 1],
    mostNegative: n.byCode[l]
  };
}
function Jte(n, e) {
  const t = {};
  for (let r = 0; r < 100 && (t[r] = Math.pow(e, r), !(t[r] > n)); r++)
    ;
  return t;
}
var vk = null;
function FE() {
  return vk || (vk = Xte({
    // Base62 are all the alphanumeric characters, database and user friendly
    // For shorter strings and more room you could opt for more characters
    chars: "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz",
    // This gives us nice human readable keys to start with a0 a1 etc
    firstPositive: "a",
    mostPositive: "z",
    mostNegative: "A"
  }));
}
function ah(n, e, t) {
  const r = t.byChar[n], i = t.byChar[e];
  return Math.abs(r - i);
}
function QD(n, e) {
  const t = n[0];
  if (t > e.mostPositive || t < e.mostNegative)
    throw new Error("invalid firstChar on key");
  return t === e.mostPositive ? ah(t, e.firstPositive, e) + 1 + ZC(n.slice(1), "positive", e) : t === e.mostNegative ? ah(t, e.firstNegative, e) + 1 + ZC(n.slice(1), "negative", e) : t >= e.firstPositive ? ah(t, e.firstPositive, e) + 2 : ah(t, e.firstNegative, e) + 2;
}
function ZC(n, e, t) {
  const r = n[0];
  if (r > t.mostPositive || r < t.mostNegative)
    throw new Error("invalid firstChar on key");
  return r === t.mostPositive && e === "positive" ? ah(r, t.mostNegative, t) + 1 + ZC(n.slice(1), e, t) : r === t.mostNegative && e === "negative" ? ah(r, t.mostPositive, t) + 1 + ZC(n.slice(1), e, t) : e === "positive" ? ah(r, t.mostNegative, t) + 2 : ah(r, t.mostPositive, t) + 2;
}
function zE(n, e, t, r, i) {
  const s = Math.max(n.length, e.length);
  return t === "start" ? [n.padStart(s, r), e.padStart(s, r)] : [n.padEnd(s, r), e.padEnd(s, r)];
}
function ene(n, e, t) {
  let [r, i] = zE(
    n,
    e,
    "end",
    t.first
  ), s = OA(r, i, t);
  s === 1 && (r = r.padEnd(r.length + 1, t.first), s = t.length);
  const l = W$(Math.floor(s / 2), t);
  return JD(r, l, t);
}
function OA(n, e, t) {
  const [r, i] = zE(n, e, "end", t.first).sort(), s = V$(i, r, t);
  return tne(s, t);
}
function JD(n, e, t) {
  const r = t.length, [i, s] = zE(n, e, "start", t.first), l = [];
  let c = 0;
  for (let d = i.length - 1; d >= 0; d--) {
    const h = t.byChar[i[d]], g = t.byChar[s[d]], y = h + g + c;
    c = Math.floor(y / r);
    const v = y % r;
    l.unshift(t.byCode[v]);
  }
  return c > 0 && l.unshift(t.byCode[c]), l.join("");
}
function V$(n, e, t) {
  const r = t.length, [i, s] = zE(n, e, "start", t.first), l = [];
  let c = 0;
  for (let d = i.length - 1; d >= 0; d--) {
    let h = t.byChar[i[d]];
    const g = t.byChar[s[d]] + c;
    h < g ? (c = 1, h += r) : c = 0;
    const y = h - g;
    l.unshift(t.byCode[y]);
  }
  if (c > 0)
    throw new Error(
      "Subtraction result is negative. Ensure a is greater than or equal to b."
    );
  for (; l.length > 1 && l[0] === t.byCode[0]; )
    l.shift();
  return l.join("");
}
function K$(n, e) {
  return JD(n, e.byCode[1], e);
}
function jA(n, e) {
  return V$(n, e.byCode[1], e);
}
function W$(n, e) {
  if (n === 0)
    return e.byCode[0];
  let t = "";
  const r = e.length;
  for (; n > 0; )
    t = e.byCode[n % r] + t, n = Math.floor(n / r);
  return t;
}
function tne(n, e) {
  let t = 0;
  const r = n.length, i = e.length;
  for (let s = 0; s < r; s++)
    t += e.byChar[n[s]] * Math.pow(i, r - s - 1);
  return t;
}
function nne(n) {
  return n.firstPositive + n.byCode[0];
}
function rne(n, e) {
  return QD(n, e) === n.length;
}
function EF(n, e) {
  QC(n, e);
}
function QC(n, e) {
  const t = Y$(n, e), r = QD(t, e);
  if (r > n.length)
    throw new Error("invalid order key length: " + n);
  return n.slice(0, r);
}
function G$(n, e) {
  if (!rne(n, e))
    throw new Error("invalid integer length: " + n);
}
function q$(n, e) {
  G$(n, e);
  const [t, r] = X$(n, e);
  if (r.split("").some((l) => l !== e.byCode[e.length - 1])) {
    const l = K$(r, e);
    return t + l;
  }
  const s = one(t, e);
  return Z$(s, "lower", e);
}
function ine(n, e) {
  G$(n, e);
  const [t, r] = X$(n, e);
  if (r.split("").some((l) => l !== e.byCode[0])) {
    const l = jA(r, e);
    return t + l;
  }
  const s = sne(t, e);
  return Z$(s, "upper", e);
}
function Y$(n, e) {
  let t = 0;
  if (n[0] === e.mostPositive)
    for (; n[t] === e.mostPositive; )
      t = t + 1;
  if (n[0] === e.mostNegative)
    for (; n[t] === e.mostNegative; )
      t = t + 1;
  return n.slice(0, t + 1);
}
function X$(n, e) {
  const t = Y$(n, e), r = n.slice(t.length);
  return [t, r];
}
function one(n, e) {
  const t = n >= e.firstPositive, r = K$(n, e), i = n[n.length - 1] === e.mostPositive, s = r[r.length - 1] === e.mostPositive;
  return t && s ? r + e.mostNegative : !t && i ? n.slice(0, n.length - 1) : r;
}
function sne(n, e) {
  const t = n >= e.firstPositive, r = n[n.length - 1] === e.mostNegative;
  if (t && r) {
    const i = n.slice(0, n.length - 1);
    return jA(i, e);
  }
  return !t && r ? n + e.mostPositive : jA(n, e);
}
function Z$(n, e, t) {
  const r = QD(n, t), i = e === "upper" ? t.byCode[t.length - 1] : t.byCode[0];
  return n + i.repeat(r - n.length);
}
function Q$(n, e) {
  const t = W$(
    Math.floor(Math.random() * e.jitterRange),
    e
  );
  return JD(n, t, e);
}
function ane(n, e, t) {
  const r = n.padEnd(
    n.length + e,
    t.first
  );
  return Q$(r, t);
}
function lne(n, e, t) {
  const r = QC(n, t), i = q$(r, t);
  let s = 0;
  if (e !== null) {
    const c = OA(n, e, t);
    c < t.jitterRange + 1 && (s = Math.max(s, _F(c, t)));
  }
  const l = OA(n, i, t);
  return l < t.jitterRange + 1 && (s = Math.max(
    s,
    _F(l, t)
  )), s;
}
function _F(n, e) {
  const t = e.jitterRange - n, r = Object.entries(e.paddingDict).find(
    ([i, s]) => s > t
  );
  return r ? parseInt(r[0]) : 0;
}
function J$(n, e, t = FE()) {
  if (n !== null && EF(n, t), e !== null && EF(e, t), n === null && e === null)
    return nne(t);
  if (n === null) {
    const r = QC(e, t);
    return ine(r, t);
  }
  if (e === null) {
    const r = QC(n, t);
    return q$(r, t);
  }
  if (n >= e)
    throw new Error(n + " >= " + e);
  return ene(n, e, t);
}
function e6(n, e, t, r = FE()) {
  return r6(
    n,
    e,
    t,
    r,
    J$,
    e6
  );
}
function t6(n, e, t = FE()) {
  const r = J$(n, e, t), i = lne(r, e, t);
  return i ? ane(r, i, t) : Q$(r, t);
}
function n6(n, e, t, r = FE()) {
  return r6(
    n,
    e,
    t,
    r,
    t6,
    n6
  );
}
function r6(n, e, t, r, i, s) {
  if (t === 0)
    return [];
  if (t === 1)
    return [i(n, e, r)];
  if (e == null) {
    let d = i(n, e, r);
    const h = [d];
    for (let g = 0; g < t - 1; g++)
      d = i(d, e, r), h.push(d);
    return h;
  }
  if (n == null) {
    let d = i(n, e, r);
    const h = [d];
    for (let g = 0; g < t - 1; g++)
      d = i(n, d, r), h.push(d);
    return h.reverse(), h;
  }
  const l = Math.floor(t / 2), c = i(n, e, r);
  return [
    ...s(n, c, l, r),
    c,
    ...s(c, e, t - l - 1, r)
  ];
}
var cne = {};
const zy = cne.NODE_ENV === "test" ? e6 : n6, i6 = "a0";
function une(n) {
  try {
    t6(n, null);
  } catch {
    throw new Error("invalid index: " + n);
  }
}
function My(n, e, t) {
  return zy(n ?? null, e ?? null, t);
}
function Sk(n, e) {
  return zy(n ?? null, null, e);
}
function Hx(n, e) {
  return zy(n ?? null, e ?? null, 1)[0];
}
function vu(n = null) {
  return zy(n, null, 1)[0];
}
function dne(n = null) {
  return zy(null, n, 1)[0];
}
function Vx(n, e = "a1") {
  return [e, ...zy(e, null, n)];
}
function gs(n, e) {
  return n.index < e.index ? -1 : n.index > e.index ? 1 : 0;
}
function fne(n, e) {
  return n.id > e.id ? 1 : -1;
}
function eO(n) {
  try {
    return localStorage.getItem(n);
  } catch {
    return null;
  }
}
function tO(n, e) {
  try {
    localStorage.setItem(n, e);
  } catch {
  }
}
function hne() {
  try {
    localStorage.clear();
  } catch {
  }
}
function o6(n) {
  try {
    return sessionStorage.getItem(n);
  } catch {
    return null;
  }
}
function nO(n, e) {
  try {
    sessionStorage.setItem(n, e);
  } catch {
  }
}
function s6(n) {
  try {
    sessionStorage.removeItem(n);
  } catch {
  }
}
function pne() {
  try {
    sessionStorage.clear();
  } catch {
  }
}
var gne = {};
const a6 = () => typeof process < "u" && gne.NODE_ENV === "test" && // @ts-expect-error
!globalThis.__FORCE_RAF_IN_TESTS__, Su = [], mne = 60, Mx = Math.ceil(1e3 / mne);
let Kp, xk = 0, JC = 0;
const yne = () => {
  const n = Su.splice(0, Su.length);
  for (const e of n)
    e();
};
function rO() {
  if (Kp)
    return;
  const n = Date.now(), e = n - JC;
  if (xk + e < Mx) {
    Kp = requestAnimationFrame(() => {
      Kp = void 0, rO();
    });
    return;
  }
  Kp = requestAnimationFrame(() => {
    Kp = void 0, JC = n, xk = Math.min(xk + e - Mx, Mx * 10), yne();
  });
}
let eE = !1;
function PF(n) {
  if (a6())
    return n.cancel = () => Kp && cancelAnimationFrame(Kp), n;
  const e = () => {
    Su.includes(n) || (Su.push(n), eE || (eE = !0, JC = Date.now() - Mx - 1), rO());
  };
  return e.cancel = () => {
    const t = Su.indexOf(n);
    t > -1 && Su.splice(t, 1);
  }, e;
}
function l6(n) {
  return a6() ? (n(), () => {
  }) : (Su.includes(n) || (Su.push(n), eE || (eE = !0, JC = Date.now() - Mx - 1), rO()), () => {
    const e = Su.indexOf(n);
    e > -1 && Su.splice(e, 1);
  });
}
class vne {
  constructor() {
    U(this, "timeouts", /* @__PURE__ */ new Map());
    U(this, "intervals", /* @__PURE__ */ new Map());
    U(this, "rafs", /* @__PURE__ */ new Map());
    this.setTimeout = this.setTimeout.bind(this), this.setInterval = this.setInterval.bind(this), this.requestAnimationFrame = this.requestAnimationFrame.bind(this), this.dispose = this.dispose.bind(this);
  }
  /** @public */
  setTimeout(e, t, r, ...i) {
    const s = window.setTimeout(t, r, i), l = this.timeouts.get(e) ?? [];
    return this.timeouts.set(e, [...l, s]), s;
  }
  /** @public */
  setInterval(e, t, r, ...i) {
    const s = window.setInterval(t, r, i), l = this.intervals.get(e) ?? [];
    return this.intervals.set(e, [...l, s]), s;
  }
  /** @public */
  requestAnimationFrame(e, t) {
    const r = window.requestAnimationFrame(t), i = this.rafs.get(e) ?? [];
    return this.rafs.set(e, [...i, r]), r;
  }
  /** @public */
  dispose(e) {
    var t, r, i;
    (t = this.timeouts.get(e)) == null || t.forEach((s) => clearTimeout(s)), (r = this.intervals.get(e)) == null || r.forEach((s) => clearInterval(s)), (i = this.rafs.get(e)) == null || i.forEach((s) => cancelAnimationFrame(s)), this.timeouts.delete(e), this.intervals.delete(e), this.rafs.delete(e);
  }
  disposeAll() {
    for (const e of this.timeouts.keys())
      this.dispose(e);
  }
  forContext(e) {
    return {
      setTimeout: (t, r, ...i) => this.setTimeout(e, t, r, i),
      setInterval: (t, r, ...i) => this.setInterval(e, t, r, i),
      requestAnimationFrame: (t) => this.requestAnimationFrame(e, t),
      dispose: () => this.dispose(e)
    };
  }
}
const Wt = (n, e) => {
  try {
    return new URL(n, e);
  } catch {
    return;
  }
};
function Sne(n) {
  return n !== void 0;
}
function xne() {
  return typeof globalThis < "u" && globalThis.structuredClone ? [globalThis.structuredClone, !0] : typeof global < "u" && global.structuredClone ? [global.structuredClone, !0] : typeof window < "u" && window.structuredClone ? [window.structuredClone, !0] : [(n) => n && JSON.parse(JSON.stringify(n)), !1];
}
const c6 = xne(), $r = c6[0];
c6[1];
const u6 = Object.getPrototypeOf($r({})), TF = /* @__PURE__ */ new Set();
function wne(n) {
  TF.has(n) || (TF.add(n), console.warn(`[tldraw] ${n}`));
}
Au(
  "@tldraw/utils",
  "3.7.0",
  "esm"
);
function d6(n) {
  return n && typeof n == "object" && "parents" in n;
}
function f6(n) {
  for (let e = 0, t = n.parents.length; e < t; e++)
    if (n.parents[e].__unsafe__getWithoutCapture(!0), n.parents[e].lastChangedEpoch !== n.parentEpochs[e])
      return !0;
  return !1;
}
function tE(n, e) {
  if (n.children.remove(e) && n.children.isEmpty && d6(n))
    for (let t = 0, r = n.parents.length; t < r; t++)
      tE(n.parents[t], n);
}
function iO(n, e) {
  if (n.children.add(e) && d6(n))
    for (let t = 0, r = n.parents.length; t < r; t++)
      iO(n.parents[t], n);
}
function h6(n, e) {
  return n === e || Object.is(n, e) || !!(n && e && typeof n.equals == "function" && n.equals(e));
}
function bh(n, e) {
  const t = Symbol.for(`com.tldraw.state/${n}`), r = globalThis;
  return r[t] ?? (r[t] = e()), r[t];
}
const Fd = bh("empty_array", () => Object.freeze([])), IF = 8;
class nE {
  constructor() {
    U(this, "arraySize", 0);
    U(this, "array", Array(IF));
    U(this, "set", null);
  }
  /**
   * Get whether this ArraySet has any elements.
   *
   * @returns True if this ArraySet has any elements, false otherwise.
   */
  // eslint-disable-next-line no-restricted-syntax
  get isEmpty() {
    if (this.array)
      return this.arraySize === 0;
    if (this.set)
      return this.set.size === 0;
    throw new Error("no set or array");
  }
  /**
   * Add an item to the ArraySet if it is not already present.
   *
   * @param elem - The element to add.
   */
  add(e) {
    if (this.array)
      return this.array.indexOf(e) !== -1 ? !1 : this.arraySize < IF ? (this.array[this.arraySize] = e, this.arraySize++, !0) : (this.set = new Set(this.array), this.array = null, this.set.add(e), !0);
    if (this.set)
      return this.set.has(e) ? !1 : (this.set.add(e), !0);
    throw new Error("no set or array");
  }
  /**
   * Remove an item from the ArraySet if it is present.
   *
   * @param elem - The element to remove
   */
  remove(e) {
    if (this.array) {
      const t = this.array.indexOf(e);
      return t === -1 ? !1 : (this.array[t] = void 0, this.arraySize--, t !== this.arraySize && (this.array[t] = this.array[this.arraySize], this.array[this.arraySize] = void 0), !0);
    }
    if (this.set)
      return this.set.has(e) ? (this.set.delete(e), !0) : !1;
    throw new Error("no set or array");
  }
  /**
   * Run a callback for each element in the ArraySet.
   *
   * @param visitor - The callback to run for each element.
   */
  visit(e) {
    if (this.array) {
      for (let t = 0; t < this.arraySize; t++) {
        const r = this.array[t];
        typeof r < "u" && e(r);
      }
      return;
    }
    if (this.set) {
      this.set.forEach(e);
      return;
    }
    throw new Error("no set or array");
  }
  has(e) {
    return this.array ? this.array.indexOf(e) !== -1 : this.set.has(e);
  }
  clear() {
    this.set ? this.set.clear() : (this.arraySize = 0, this.array = []);
  }
  size() {
    return this.set ? this.set.size : this.arraySize;
  }
}
const Za = Symbol.for("com.tldraw.state/RESET_VALUE");
class p6 {
  constructor(e) {
    U(this, "index", 0);
    // use a wrap around buffer to store the last N values
    U(this, "buffer");
    this.capacity = e, this.buffer = new Array(e);
  }
  /**
   * Add a diff to the history buffer.
   *
   * @param lastComputedEpoch - The epoch when the diff was computed.
   * @param currentEpoch - The current epoch.
   * @param diff - The diff to add, or else a reset value.
   */
  pushEntry(e, t, r) {
    if (r !== void 0) {
      if (r === Za) {
        this.clear();
        return;
      }
      this.buffer[this.index] = [e, t, r], this.index = (this.index + 1) % this.capacity;
    }
  }
  /**
   * Clear the history buffer.
   */
  clear() {
    this.index = 0, this.buffer.fill(void 0);
  }
  /**
   * Get the diffs since the given epoch.
   *
   * @param sinceEpoch - The epoch to get diffs since.
   * @returns An array of diffs or a flag to reset the history buffer.
   */
  getChangesSince(e) {
    const { index: t, capacity: r, buffer: i } = this;
    for (let s = 0; s < r; s++) {
      const l = (t - 1 + r - s) % r, c = i[l];
      if (!c)
        return Za;
      const [d, h] = c;
      if (s === 0 && e >= h)
        return [];
      if (d <= e && e < h) {
        const g = s + 1, y = new Array(g);
        for (let v = 0; v < g; v++)
          y[v] = i[(l + v) % r][2];
        return y;
      }
    }
    return Za;
  }
}
class bne {
  constructor(e, t) {
    U(this, "offset", 0);
    U(this, "maybeRemoved");
    this.below = e, this.child = t;
  }
}
const qr = bh("capture", () => ({ stack: null }));
function A1(n) {
  const e = qr.stack;
  qr.stack = null;
  try {
    return n();
  } finally {
    qr.stack = e;
  }
}
function g6(n) {
  qr.stack = new bne(qr.stack, n), n.parentSet.clear();
}
function m6() {
  const n = qr.stack;
  if (qr.stack = n.below, n.offset < n.child.parents.length) {
    for (let e = n.offset; e < n.child.parents.length; e++) {
      const t = n.child.parents[e];
      n.child.parentSet.has(t) || tE(t, n.child);
    }
    n.child.parents.length = n.offset, n.child.parentEpochs.length = n.offset;
  }
  if (n.maybeRemoved)
    for (let e = 0; e < n.maybeRemoved.length; e++) {
      const t = n.maybeRemoved[e];
      n.child.parentSet.has(t) || tE(t, n.child);
    }
}
function rE(n) {
  if (qr.stack) {
    if (qr.stack.child.parentSet.has(n))
      return;
    if (qr.stack.child.parentSet.add(n), qr.stack.child.isActivelyListening && iO(n, qr.stack.child), qr.stack.offset < qr.stack.child.parents.length) {
      const t = qr.stack.child.parents[qr.stack.offset];
      t !== n && (qr.stack.maybeRemoved ? qr.stack.maybeRemoved.push(t) : qr.stack.maybeRemoved = [t]);
    }
    qr.stack.child.parents[qr.stack.offset] = n, qr.stack.child.parentEpochs[qr.stack.offset] = n.lastChangedEpoch, qr.stack.offset++;
  }
}
const lh = -1;
class Cne {
  constructor(e, t, r) {
    U(this, "_isActivelyListening", !1);
    /** @internal */
    U(this, "lastTraversedEpoch", lh);
    U(this, "lastReactedEpoch", lh);
    U(this, "_scheduleCount", 0);
    /** @internal */
    U(this, "parentSet", new nE());
    /** @internal */
    U(this, "parentEpochs", []);
    /** @internal */
    U(this, "parents", []);
    U(this, "_scheduleEffect");
    /** @internal */
    // eslint-disable-next-line local/prefer-class-methods
    U(this, "maybeExecute", () => {
      this._isActivelyListening && this.execute();
    });
    this.name = e, this.runEffect = t, this._scheduleEffect = r == null ? void 0 : r.scheduleEffect;
  }
  /**
   * Whether this scheduler is attached and actively listening to its parents.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return this._isActivelyListening;
  }
  /**
   * The number of times this effect has been scheduled.
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get scheduleCount() {
    return this._scheduleCount;
  }
  /** @internal */
  maybeScheduleEffect() {
    if (this._isActivelyListening && this.lastReactedEpoch !== ya()) {
      if (this.parents.length && !f6(this)) {
        this.lastReactedEpoch = ya();
        return;
      }
      this.scheduleEffect();
    }
  }
  /** @internal */
  scheduleEffect() {
    this._scheduleCount++, this._scheduleEffect ? this._scheduleEffect(this.maybeExecute) : this.execute();
  }
  /**
   * Makes this scheduler become 'actively listening' to its parents.
   * If it has been executed before it will immediately become eligible to receive 'maybeScheduleEffect' calls.
   * If it has not executed before it will need to be manually executed once to become eligible for scheduling, i.e. by calling [[EffectScheduler.execute]].
   * @public
   */
  attach() {
    this._isActivelyListening = !0;
    for (let e = 0, t = this.parents.length; e < t; e++)
      iO(this.parents[e], this);
  }
  /**
   * Makes this scheduler stop 'actively listening' to its parents.
   * It will no longer be eligible to receive 'maybeScheduleEffect' calls until [[EffectScheduler.attach]] is called again.
   */
  detach() {
    this._isActivelyListening = !1;
    for (let e = 0, t = this.parents.length; e < t; e++)
      tE(this.parents[e], this);
  }
  /**
   * Executes the effect immediately and returns the result.
   * @returns The result of the effect.
   */
  execute() {
    try {
      g6(this);
      const e = ya(), t = this.runEffect(this.lastReactedEpoch);
      return this.lastReactedEpoch = e, t;
    } finally {
      m6();
    }
  }
}
const Uy = bh(
  "EffectScheduler",
  () => Cne
);
function wc(n, e, t) {
  const r = new Uy(n, e, t);
  return r.attach(), r.scheduleEffect(), () => {
    r.detach();
  };
}
function Ene(n, e, t) {
  const r = new Uy(n, e, t);
  return {
    scheduler: r,
    start: (i) => {
      const s = (i == null ? void 0 : i.force) ?? !1;
      r.attach(), s ? r.scheduleEffect() : r.maybeScheduleEffect();
    },
    stop: () => {
      r.detach();
    }
  };
}
class _ne {
  constructor(e) {
    U(this, "initialAtomValues", /* @__PURE__ */ new Map());
    this.parent = e;
  }
  /**
   * Get whether this transaction is a root (no parents).
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get isRoot() {
    return this.parent === null;
  }
  /**
   * Commit the transaction's changes.
   *
   * @public
   */
  commit() {
    if (tr.globalIsReacting)
      for (const e of this.initialAtomValues.keys())
        v6(e);
    else this.isRoot ? y6(this.initialAtomValues.keys()) : this.initialAtomValues.forEach((e, t) => {
      this.parent.initialAtomValues.has(t) || this.parent.initialAtomValues.set(t, e);
    });
  }
  /**
   * Abort the transaction.
   *
   * @public
   */
  abort() {
    tr.globalEpoch++, this.initialAtomValues.forEach((e, t) => {
      var r;
      t.set(e), (r = t.historyBuffer) == null || r.clear();
    }), this.commit();
  }
}
const tr = bh("transactions", () => ({
  // The current epoch (global to all atoms).
  globalEpoch: lh + 1,
  // Whether any transaction is reacting.
  globalIsReacting: !1,
  currentTransaction: null,
  cleanupReactors: null,
  reactionEpoch: lh + 1
}));
function Pne() {
  return tr.reactionEpoch;
}
function ya() {
  return tr.globalEpoch;
}
function Tne() {
  return tr.globalIsReacting;
}
function oO(n, e) {
  e.lastTraversedEpoch !== tr.globalEpoch && (e.lastTraversedEpoch = tr.globalEpoch, e instanceof Uy ? n.add(e) : e.children.visit((t) => oO(n, t)));
}
function y6(n) {
  var t;
  if (tr.globalIsReacting)
    throw new Error("flushChanges cannot be called during a reaction");
  const e = tr.currentTransaction;
  try {
    tr.currentTransaction = null, tr.globalIsReacting = !0, tr.reactionEpoch = tr.globalEpoch;
    const r = /* @__PURE__ */ new Set();
    for (const s of n)
      s.children.visit((l) => oO(r, l));
    for (const s of r)
      s.maybeScheduleEffect();
    let i = 0;
    for (; (t = tr.cleanupReactors) != null && t.size; ) {
      if (i++ > 1e3)
        throw new Error("Reaction update depth limit exceeded");
      const s = tr.cleanupReactors;
      tr.cleanupReactors = null;
      for (const l of s)
        l.maybeScheduleEffect();
    }
  } finally {
    tr.cleanupReactors = null, tr.globalIsReacting = !1, tr.currentTransaction = e;
  }
}
function Ine(n, e) {
  tr.currentTransaction ? tr.currentTransaction.initialAtomValues.has(n) || tr.currentTransaction.initialAtomValues.set(n, e) : tr.globalIsReacting ? v6(n) : y6([n]);
}
function v6(n) {
  const e = tr.cleanupReactors ?? (tr.cleanupReactors = /* @__PURE__ */ new Set());
  n.children.visit((t) => oO(e, t));
}
function kne() {
  tr.globalEpoch++;
}
function Rne(n) {
  const e = new _ne(tr.currentTransaction);
  tr.currentTransaction = e;
  try {
    let t, r = !1;
    try {
      t = n(() => r = !0);
    } catch (i) {
      throw e.abort(), i;
    }
    return r ? e.abort() : e.commit(), t;
  } finally {
    tr.currentTransaction = tr.currentTransaction.parent;
  }
}
function Dl(n) {
  return tr.currentTransaction ? n() : Rne(n);
}
class Mne {
  constructor(e, t, r) {
    U(this, "isEqual");
    U(this, "computeDiff");
    U(this, "lastChangedEpoch", ya());
    U(this, "children", new nE());
    U(this, "historyBuffer");
    this.name = e, this.current = t, this.isEqual = (r == null ? void 0 : r.isEqual) ?? null, r && (r.historyLength && (this.historyBuffer = new p6(r.historyLength)), this.computeDiff = r.computeDiff);
  }
  __unsafe__getWithoutCapture(e) {
    return this.current;
  }
  get() {
    return rE(this), this.current;
  }
  set(e, t) {
    var i, s;
    if (((i = this.isEqual) == null ? void 0 : i.call(this, this.current, e)) ?? h6(this.current, e))
      return this.current;
    kne(), this.historyBuffer && this.historyBuffer.pushEntry(
      this.lastChangedEpoch,
      ya(),
      t ?? ((s = this.computeDiff) == null ? void 0 : s.call(this, this.current, e, this.lastChangedEpoch, ya())) ?? Za
    ), this.lastChangedEpoch = ya();
    const r = this.current;
    return this.current = e, Ine(this, r), e;
  }
  update(e) {
    return this.set(e(this.current));
  }
  getDiffSince(e) {
    var t;
    return rE(this), e >= this.lastChangedEpoch ? Fd : ((t = this.historyBuffer) == null ? void 0 : t.getChangesSince(e)) ?? Za;
  }
}
const S6 = bh("Atom", () => Mne);
function mi(n, e, t) {
  return new S6(n, e, t);
}
let kF = !1;
function Ane() {
  kF || (kF = !0, console.warn(
    `Using \`@computed\` as a decorator for getters is deprecated and will be removed in the near future. Please refactor to use \`@computed\` as a decorator for methods.

// Before
@computed
get foo() {
	return 'foo'
}

// After
@computed
getFoo() {
	return 'foo'
}
`
  ));
}
const Sx = Symbol.for("com.tldraw.state/UNINITIALIZED");
function Gp(n) {
  return n === Sx;
}
const LA = bh(
  "WithDiff",
  () => class {
    constructor(e, t) {
      this.value = e, this.diff = t;
    }
  }
);
function xx(n, e) {
  return new LA(n, e);
}
class Dne {
  constructor(e, t, r) {
    U(this, "lastChangedEpoch", lh);
    U(this, "lastTraversedEpoch", lh);
    /**
     * The epoch when the reactor was last checked.
     */
    U(this, "lastCheckedEpoch", lh);
    U(this, "parentSet", new nE());
    U(this, "parents", []);
    U(this, "parentEpochs", []);
    U(this, "children", new nE());
    U(this, "historyBuffer");
    // The last-computed value of this signal.
    U(this, "state", Sx);
    // If the signal throws an error we stash it so we can rethrow it on the next get()
    U(this, "error", null);
    U(this, "computeDiff");
    U(this, "isEqual");
    this.name = e, this.derive = t, r != null && r.historyLength && (this.historyBuffer = new p6(r.historyLength)), this.computeDiff = r == null ? void 0 : r.computeDiff, this.isEqual = (r == null ? void 0 : r.isEqual) ?? h6;
  }
  // eslint-disable-next-line no-restricted-syntax
  get isActivelyListening() {
    return !this.children.isEmpty;
  }
  __unsafe__getWithoutCapture(e) {
    var i;
    const t = this.lastChangedEpoch === lh, r = ya();
    if (!t && (this.lastCheckedEpoch === r || this.isActivelyListening && Tne() && this.lastTraversedEpoch < Pne() || !f6(this)))
      if (this.lastCheckedEpoch = r, this.error) {
        if (e)
          return this.state;
        throw this.error.thrownValue;
      } else
        return this.state;
    try {
      g6(this);
      const s = this.derive(this.state, this.lastCheckedEpoch), l = s instanceof LA ? s.value : s, c = this.state === Sx;
      if (c || !this.isEqual(l, this.state)) {
        if (this.historyBuffer && !c) {
          const d = s instanceof LA ? s.diff : void 0;
          this.historyBuffer.pushEntry(
            this.lastChangedEpoch,
            ya(),
            d ?? ((i = this.computeDiff) == null ? void 0 : i.call(this, this.state, l, this.lastCheckedEpoch, ya())) ?? Za
          );
        }
        this.lastChangedEpoch = ya(), this.state = l;
      }
      return this.error = null, this.lastCheckedEpoch = ya(), this.state;
    } catch (s) {
      if (this.state !== Sx && (this.state = Sx, this.lastChangedEpoch = ya()), this.lastCheckedEpoch = ya(), this.historyBuffer && this.historyBuffer.clear(), this.error = { thrownValue: s }, !e) throw s;
      return this.state;
    } finally {
      m6();
    }
  }
  get() {
    try {
      return this.__unsafe__getWithoutCapture();
    } finally {
      rE(this);
    }
  }
  getDiffSince(e) {
    var t;
    return this.__unsafe__getWithoutCapture(!0), rE(this), e >= this.lastChangedEpoch ? Fd : ((t = this.historyBuffer) == null ? void 0 : t.getChangesSince(e)) ?? Za;
  }
}
const cw = bh("Computed", () => Dne);
function One(n = {}, e, t, r) {
  const i = r.value, s = Symbol.for("__@tldraw/state__computed__" + t);
  return r.value = function() {
    let l = this[s];
    return l || (l = new cw(t, i.bind(this), n), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: l
    })), l.get();
  }, r.value[x6] = !0, r;
}
function jne(n = {}, e, t, r) {
  const i = r.get, s = Symbol.for("__@tldraw/state__computed__" + t);
  return r.get = function() {
    let l = this[s];
    return l || (l = new cw(t, i.bind(this), n), Object.defineProperty(this, s, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: l
    })), l.get();
  }, r;
}
function Lne(n, e, t) {
  on(t.kind === "method", "@computed can only be used on methods");
  const r = Symbol.for("__@tldraw/state__computed__" + String(t.name)), i = function() {
    let s = this[r];
    return s || (s = new cw(String(t.name), e.bind(this), n), Object.defineProperty(this, r, {
      enumerable: !1,
      configurable: !1,
      writable: !1,
      value: s
    })), s.get();
  };
  return i[x6] = !0, i;
}
function RF(n = {}, e) {
  if (e.length === 2) {
    const [t, r] = e;
    return Lne(n, t, r);
  } else {
    const [t, r, i] = e;
    return i.get ? (Ane(), jne(n, t, r, i)) : One(n, t, r, i);
  }
}
const x6 = "@@__isComputedMethod__@@";
function Le() {
  if (arguments.length === 1) {
    const n = arguments[0];
    return (...e) => RF(n, e);
  } else return typeof arguments[0] == "string" ? new cw(arguments[0], arguments[1], arguments[2]) : RF(void 0, arguments);
}
function Nne(n) {
  return n instanceof S6 || n instanceof cw;
}
const w6 = 1, Fne = bh("apiVersion", () => w6);
if (Fne !== w6)
  throw new Error(
    "You have multiple incompatible versions of @tldraw/state in your app. Please deduplicate the package."
  );
Au(
  "@tldraw/state",
  "3.7.0",
  "esm"
);
const zne = 1024 * 1024, Une = 4, $ne = zne / Une;
function Bne(n, e = $ne) {
  if (n.length < e)
    return [n];
  {
    const t = [];
    let r = 0, i = n.length;
    for (; i > 0; ) {
      const s = `${r}_`, l = Math.max(Math.min(e - s.length, i), 1);
      t.unshift(s + n.slice(i - l, i)), i -= l, r++;
    }
    return t;
  }
}
class yC {
  constructor(e) {
    /**
     * The next value of the set.
     *
     * @internal
     */
    U(this, "nextValue");
    /**
     * The diff of the set.
     *
     * @internal
     */
    U(this, "diff");
    this.previousValue = e;
  }
  /**
   * Get the next value of the set.
   *
   * @public
   */
  get() {
    var r, i, s, l;
    const e = ((i = (r = this.diff) == null ? void 0 : r.removed) == null ? void 0 : i.size) ?? 0, t = ((l = (s = this.diff) == null ? void 0 : s.added) == null ? void 0 : l.size) ?? 0;
    if (!(e === 0 && t === 0))
      return { value: this.nextValue, diff: this.diff };
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _add(e, t) {
    var r, i;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.add(e), this.diff ?? (this.diff = {}), t ? (r = this.diff.removed) == null || r.delete(e) : ((i = this.diff).added ?? (i.added = /* @__PURE__ */ new Set()), this.diff.added.add(e));
  }
  /**
   * Add an item to the set.
   *
   * @param item - The item to add.
   * @public
   */
  add(e) {
    var i, s, l;
    const t = this.previousValue.has(e);
    if (t)
      return ((s = (i = this.diff) == null ? void 0 : i.removed) == null ? void 0 : s.has(e)) ? this._add(e, t) : void 0;
    (l = this.nextValue) != null && l.has(e) || this._add(e, t);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @param wasAlreadyPresent - Whether the item was already present in the set.
   * @internal
   */
  _remove(e, t) {
    var r, i;
    this.nextValue ?? (this.nextValue = new Set(this.previousValue)), this.nextValue.delete(e), this.diff ?? (this.diff = {}), t ? ((r = this.diff).removed ?? (r.removed = /* @__PURE__ */ new Set()), this.diff.removed.add(e)) : (i = this.diff.added) == null || i.delete(e);
  }
  /**
   * Remove an item from the set.
   *
   * @param item - The item to remove.
   * @public
   */
  remove(e) {
    var i, s, l, c;
    const t = this.previousValue.has(e);
    if (!t)
      return ((s = (i = this.diff) == null ? void 0 : i.added) == null ? void 0 : s.has(e)) ? this._remove(e, t) : void 0;
    (c = (l = this.diff) == null ? void 0 : l.removed) != null && c.has(e) || this._remove(e, t);
  }
}
class UE {
  constructor(e, t) {
    U(this, "createDefaultProperties");
    U(this, "validator");
    U(this, "ephemeralKeys");
    U(this, "ephemeralKeySet");
    U(this, "scope");
    this.typeName = e, this.createDefaultProperties = t.createDefaultProperties, this.validator = t.validator ?? { validate: (i) => i }, this.scope = t.scope ?? "document", this.ephemeralKeys = t.ephemeralKeys;
    const r = /* @__PURE__ */ new Set();
    if (t.ephemeralKeys)
      for (const [i, s] of Uo(t.ephemeralKeys))
        s && r.add(i);
    this.ephemeralKeySet = r;
  }
  /**
   * Create a new record of this type.
   *
   * @param properties - The properties of the record.
   * @returns The new record.
   */
  create(e) {
    const t = { ...this.createDefaultProperties(), id: this.createId() };
    for (const [r, i] of Object.entries(e))
      i !== void 0 && (t[r] = i);
    return t.typeName = this.typeName, t;
  }
  /**
   * Clone a record of this type.
   *
   * @param record - The record to clone.
   * @returns The cloned record.
   * @public
   */
  clone(e) {
    return { ...$r(e), id: this.createId() };
  }
  /**
   * Create a new ID for this record type.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createId()
   * ```
   *
   * @returns The new ID.
   * @public
   */
  createId(e) {
    return this.typeName + ":" + (e ?? or());
  }
  /**
   * Create a new ID for this record type based on the given ID.
   *
   * @example
   *
   * ```ts
   * const id = recordType.createCustomId('myId')
   * ```
   *
   * @deprecated - Use `createId` instead.
   * @param id - The ID to base the new ID on.
   * @returns The new ID.
   */
  createCustomId(e) {
    return this.typeName + ":" + e;
  }
  /**
   * Takes an id like `user:123` and returns the part after the colon `123`
   *
   * @param id - The id
   * @returns
   */
  parseId(e) {
    if (!this.isId(e))
      throw new Error(`ID "${e}" is not a valid ID for type "${this.typeName}"`);
    return e.slice(this.typeName.length + 1);
  }
  /**
   * Check whether a record is an instance of this record type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isInstance(someRecord)
   * ```
   *
   * @param record - The record to check.
   * @returns Whether the record is an instance of this record type.
   */
  isInstance(e) {
    return (e == null ? void 0 : e.typeName) === this.typeName;
  }
  /**
   * Check whether an id is an id of this type.
   *
   * @example
   *
   * ```ts
   * const result = recordType.isIn('someId')
   * ```
   *
   * @param id - The id to check.
   * @returns Whether the id is an id of this type.
   */
  isId(e) {
    if (!e) return !1;
    for (let t = 0; t < this.typeName.length; t++)
      if (e[t] !== this.typeName[t]) return !1;
    return e[this.typeName.length] === ":";
  }
  /**
   * Create a new RecordType that has the same type name as this RecordType and includes the given
   * default properties.
   *
   * @example
   *
   * ```ts
   * const authorType = createRecordType('author', () => ({ living: true }))
   * const deadAuthorType = authorType.withDefaultProperties({ living: false })
   * ```
   *
   * @param createDefaultProperties - A function that returns the default properties of the new RecordType.
   * @returns The new RecordType.
   */
  withDefaultProperties(e) {
    return new UE(this.typeName, {
      createDefaultProperties: e,
      validator: this.validator,
      scope: this.scope,
      ephemeralKeys: this.ephemeralKeys
    });
  }
  /**
   * Check that the passed in record passes the validations for this type. Returns its input
   * correctly typed if it does, but throws an error otherwise.
   */
  validate(e, t) {
    return t && this.validator.validateUsingKnownGoodVersion ? this.validator.validateUsingKnownGoodVersion(t, e) : this.validator.validate(e);
  }
}
function Du(n, e) {
  return new UE(n, {
    createDefaultProperties: () => ({}),
    validator: e.validator,
    scope: e.scope,
    ephemeralKeys: e.ephemeralKeys
  });
}
function iE() {
  return { added: {}, updated: {}, removed: {} };
}
function Kx(n) {
  const e = { added: n.removed, removed: n.added, updated: {} };
  for (const [t, r] of Object.values(n.updated))
    e.updated[t.id] = [r, t];
  return e;
}
function b6(n) {
  return Object.keys(n.added).length === 0 && Object.keys(n.updated).length === 0 && Object.keys(n.removed).length === 0;
}
function $E(n) {
  const e = { added: {}, removed: {}, updated: {} };
  return Ax(e, n), e;
}
function Ax(n, e) {
  for (const t of e) {
    for (const [r, i] of Uo(t.added))
      if (n.removed[r]) {
        const s = n.removed[r];
        delete n.removed[r], s !== i && (n.updated[r] = [s, i]);
      } else
        n.added[r] = i;
    for (const [r, [i, s]] of Uo(t.updated)) {
      if (n.added[r]) {
        n.added[r] = s, delete n.updated[r], delete n.removed[r];
        continue;
      }
      if (n.updated[r]) {
        n.updated[r] = [n.updated[r][0], s], delete n.removed[r];
        continue;
      }
      n.updated[r] = t.updated[r], delete n.removed[r];
    }
    for (const [r, i] of Uo(t.removed))
      n.added[r] ? delete n.added[r] : n.updated[r] ? (n.removed[r] = n.updated[r][0], delete n.updated[r]) : n.removed[r] = i;
  }
}
var wx = { exports: {} };
wx.exports;
var MF;
function Hne() {
  return MF || (MF = 1, function(n, e) {
    var t = 200, r = "__lodash_hash_undefined__", i = 1, s = 2, l = 9007199254740991, c = "[object Arguments]", d = "[object Array]", h = "[object AsyncFunction]", g = "[object Boolean]", y = "[object Date]", v = "[object Error]", w = "[object Function]", C = "[object GeneratorFunction]", E = "[object Map]", P = "[object Number]", I = "[object Null]", k = "[object Object]", L = "[object Promise]", O = "[object Proxy]", z = "[object RegExp]", F = "[object Set]", H = "[object String]", V = "[object Symbol]", re = "[object Undefined]", q = "[object WeakMap]", J = "[object ArrayBuffer]", ie = "[object DataView]", W = "[object Float32Array]", Y = "[object Float64Array]", oe = "[object Int8Array]", le = "[object Int16Array]", ce = "[object Int32Array]", Q = "[object Uint8Array]", he = "[object Uint8ClampedArray]", ke = "[object Uint16Array]", te = "[object Uint32Array]", me = /[\\^$.*+?()[\]{}|]/g, Oe = /^\[object .+?Constructor\]$/, Ze = /^(?:0|[1-9]\d*)$/, De = {};
    De[W] = De[Y] = De[oe] = De[le] = De[ce] = De[Q] = De[he] = De[ke] = De[te] = !0, De[c] = De[d] = De[J] = De[g] = De[ie] = De[y] = De[v] = De[w] = De[E] = De[P] = De[k] = De[z] = De[F] = De[H] = De[q] = !1;
    var yt = typeof ba == "object" && ba && ba.Object === Object && ba, it = typeof self == "object" && self && self.Object === Object && self, We = yt || it || Function("return this")(), Qe = e && !e.nodeType && e, gt = Qe && !0 && n && !n.nodeType && n, Pt = gt && gt.exports === Qe, mn = Pt && yt.process, Zt = function() {
      try {
        return mn && mn.binding && mn.binding("util");
      } catch {
      }
    }(), an = Zt && Zt.isTypedArray;
    function ln(Z, pe) {
      for (var ze = -1, lt = Z == null ? 0 : Z.length, Nn = 0, Lt = []; ++ze < lt; ) {
        var nr = Z[ze];
        pe(nr, ze, Z) && (Lt[Nn++] = nr);
      }
      return Lt;
    }
    function Yt(Z, pe) {
      for (var ze = -1, lt = pe.length, Nn = Z.length; ++ze < lt; )
        Z[Nn + ze] = pe[ze];
      return Z;
    }
    function Gn(Z, pe) {
      for (var ze = -1, lt = Z == null ? 0 : Z.length; ++ze < lt; )
        if (pe(Z[ze], ze, Z))
          return !0;
      return !1;
    }
    function xr(Z, pe) {
      for (var ze = -1, lt = Array(Z); ++ze < Z; )
        lt[ze] = pe(ze);
      return lt;
    }
    function Hr(Z) {
      return function(pe) {
        return Z(pe);
      };
    }
    function Pr(Z, pe) {
      return Z.has(pe);
    }
    function wr(Z, pe) {
      return Z == null ? void 0 : Z[pe];
    }
    function Vr(Z) {
      var pe = -1, ze = Array(Z.size);
      return Z.forEach(function(lt, Nn) {
        ze[++pe] = [Nn, lt];
      }), ze;
    }
    function Kr(Z, pe) {
      return function(ze) {
        return Z(pe(ze));
      };
    }
    function si(Z) {
      var pe = -1, ze = Array(Z.size);
      return Z.forEach(function(lt) {
        ze[++pe] = lt;
      }), ze;
    }
    var mo = Array.prototype, Tr = Function.prototype, Ir = Object.prototype, Zr = We["__core-js_shared__"], Ko = Tr.toString, Ee = Ir.hasOwnProperty, ve = function() {
      var Z = /[^.]+$/.exec(Zr && Zr.keys && Zr.keys.IE_PROTO || "");
      return Z ? "Symbol(src)_1." + Z : "";
    }(), $e = Ir.toString, mt = RegExp(
      "^" + Ko.call(Ee).replace(me, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    ), cn = Pt ? We.Buffer : void 0, yn = We.Symbol, qn = We.Uint8Array, Rn = Ir.propertyIsEnumerable, sr = mo.splice, bn = yn ? yn.toStringTag : void 0, vn = Object.getOwnPropertySymbols, fn = cn ? cn.isBuffer : void 0, Ii = Kr(Object.keys, Object), oo = Zs(We, "DataView"), ki = Zs(We, "Map"), Cs = Zs(We, "Promise"), ka = Zs(We, "Set"), Ra = Zs(We, "WeakMap"), yo = Zs(Object, "create"), Ul = Nr(oo), Xs = Nr(ki), vo = Nr(Cs), vi = Nr(ka), So = Nr(Ra), $i = yn ? yn.prototype : void 0, Wo = $i ? $i.valueOf : void 0;
    function Ri(Z) {
      var pe = -1, ze = Z == null ? 0 : Z.length;
      for (this.clear(); ++pe < ze; ) {
        var lt = Z[pe];
        this.set(lt[0], lt[1]);
      }
    }
    function Ma() {
      this.__data__ = yo ? yo(null) : {}, this.size = 0;
    }
    function se(Z) {
      var pe = this.has(Z) && delete this.__data__[Z];
      return this.size -= pe ? 1 : 0, pe;
    }
    function Ue(Z) {
      var pe = this.__data__;
      if (yo) {
        var ze = pe[Z];
        return ze === r ? void 0 : ze;
      }
      return Ee.call(pe, Z) ? pe[Z] : void 0;
    }
    function tt(Z) {
      var pe = this.__data__;
      return yo ? pe[Z] !== void 0 : Ee.call(pe, Z);
    }
    function rt(Z, pe) {
      var ze = this.__data__;
      return this.size += this.has(Z) ? 0 : 1, ze[Z] = yo && pe === void 0 ? r : pe, this;
    }
    Ri.prototype.clear = Ma, Ri.prototype.delete = se, Ri.prototype.get = Ue, Ri.prototype.has = tt, Ri.prototype.set = rt;
    function zt(Z) {
      var pe = -1, ze = Z == null ? 0 : Z.length;
      for (this.clear(); ++pe < ze; ) {
        var lt = Z[pe];
        this.set(lt[0], lt[1]);
      }
    }
    function Vt() {
      this.__data__ = [], this.size = 0;
    }
    function un(Z) {
      var pe = this.__data__, ze = $l(pe, Z);
      if (ze < 0)
        return !1;
      var lt = pe.length - 1;
      return ze == lt ? pe.pop() : sr.call(pe, ze, 1), --this.size, !0;
    }
    function en(Z) {
      var pe = this.__data__, ze = $l(pe, Z);
      return ze < 0 ? void 0 : pe[ze][1];
    }
    function Lr(Z) {
      return $l(this.__data__, Z) > -1;
    }
    function ar(Z, pe) {
      var ze = this.__data__, lt = $l(ze, Z);
      return lt < 0 ? (++this.size, ze.push([Z, pe])) : ze[lt][1] = pe, this;
    }
    zt.prototype.clear = Vt, zt.prototype.delete = un, zt.prototype.get = en, zt.prototype.has = Lr, zt.prototype.set = ar;
    function zn(Z) {
      var pe = -1, ze = Z == null ? 0 : Z.length;
      for (this.clear(); ++pe < ze; ) {
        var lt = Z[pe];
        this.set(lt[0], lt[1]);
      }
    }
    function Mi() {
      this.size = 0, this.__data__ = {
        hash: new Ri(),
        map: new (ki || zt)(),
        string: new Ri()
      };
    }
    function Es(Z) {
      var pe = dn(this, Z).delete(Z);
      return this.size -= pe ? 1 : 0, pe;
    }
    function Un(Z) {
      return dn(this, Z).get(Z);
    }
    function yr(Z) {
      return dn(this, Z).has(Z);
    }
    function Gt(Z, pe) {
      var ze = dn(this, Z), lt = ze.size;
      return ze.set(Z, pe), this.size += ze.size == lt ? 0 : 1, this;
    }
    zn.prototype.clear = Mi, zn.prototype.delete = Es, zn.prototype.get = Un, zn.prototype.has = yr, zn.prototype.set = Gt;
    function xo(Z) {
      var pe = -1, ze = Z == null ? 0 : Z.length;
      for (this.__data__ = new zn(); ++pe < ze; )
        this.add(Z[pe]);
    }
    function Aa(Z) {
      return this.__data__.set(Z, r), this;
    }
    function Qd(Z) {
      return this.__data__.has(Z);
    }
    xo.prototype.add = xo.prototype.push = Aa, xo.prototype.has = Qd;
    function Ai(Z) {
      var pe = this.__data__ = new zt(Z);
      this.size = pe.size;
    }
    function al() {
      this.__data__ = new zt(), this.size = 0;
    }
    function so(Z) {
      var pe = this.__data__, ze = pe.delete(Z);
      return this.size = pe.size, ze;
    }
    function Fu(Z) {
      return this.__data__.get(Z);
    }
    function Bi(Z) {
      return this.__data__.has(Z);
    }
    function zu(Z, pe) {
      var ze = this.__data__;
      if (ze instanceof zt) {
        var lt = ze.__data__;
        if (!ki || lt.length < t - 1)
          return lt.push([Z, pe]), this.size = ++ze.size, this;
        ze = this.__data__ = new zn(lt);
      }
      return ze.set(Z, pe), this.size = ze.size, this;
    }
    Ai.prototype.clear = al, Ai.prototype.delete = so, Ai.prototype.get = Fu, Ai.prototype.has = Bi, Ai.prototype.set = zu;
    function Jd(Z, pe) {
      var ze = $n(Z), lt = !ze && kr(Z), Nn = !ze && !lt && lo(Z), Lt = !ze && !lt && !Nn && Kl(Z), nr = ze || lt || Nn || Lt, Rr = nr ? xr(Z.length, String) : [], Zn = Rr.length;
      for (var Qn in Z)
        Ee.call(Z, Qn) && !(nr && // Safari 9 has enumerable `arguments.length` in strict mode.
        (Qn == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
        Nn && (Qn == "offset" || Qn == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
        Lt && (Qn == "buffer" || Qn == "byteLength" || Qn == "byteOffset") || // Skip index properties.
        Qs(Qn, Zn))) && Rr.push(Qn);
      return Rr;
    }
    function $l(Z, pe) {
      for (var ze = Z.length; ze--; )
        if (Ts(Z[ze][0], pe))
          return ze;
      return -1;
    }
    function Da(Z, pe, ze) {
      var lt = pe(Z);
      return $n(Z) ? lt : Yt(lt, ze(Z));
    }
    function Go(Z) {
      return Z == null ? Z === void 0 ? re : I : bn && bn in Object(Z) ? Oc(Z) : ao(Z);
    }
    function Hi(Z) {
      return ks(Z) && Go(Z) == c;
    }
    function _s(Z, pe, ze, lt, Nn) {
      return Z === pe ? !0 : Z == null || pe == null || !ks(Z) && !ks(pe) ? Z !== Z && pe !== pe : ll(Z, pe, ze, lt, _s, Nn);
    }
    function ll(Z, pe, ze, lt, Nn, Lt) {
      var nr = $n(Z), Rr = $n(pe), Zn = nr ? d : Ps(Z), Qn = Rr ? d : Ps(pe);
      Zn = Zn == c ? k : Zn, Qn = Qn == c ? k : Qn;
      var B = Zn == k, ne = Qn == k, ge = Zn == Qn;
      if (ge && lo(Z)) {
        if (!lo(pe))
          return !1;
        nr = !0, B = !1;
      }
      if (ge && !B)
        return Lt || (Lt = new Ai()), nr || Kl(Z) ? cl(Z, pe, ze, lt, Nn, Lt) : ul(Z, pe, Zn, ze, lt, Nn, Lt);
      if (!(ze & i)) {
        var Re = B && Ee.call(Z, "__wrapped__"), Ve = ne && Ee.call(pe, "__wrapped__");
        if (Re || Ve) {
          var ot = Re ? Z.value() : Z, Je = Ve ? pe.value() : pe;
          return Lt || (Lt = new Ai()), Nn(ot, Je, ze, lt, Lt);
        }
      }
      return ge ? (Lt || (Lt = new Ai()), Uu(Z, pe, ze, lt, Nn, Lt)) : !1;
    }
    function Ac(Z) {
      if (!Vl(Z) || Hl(Z))
        return !1;
      var pe = Oi(Z) ? mt : Oe;
      return pe.test(Nr(Z));
    }
    function Oa(Z) {
      return ks(Z) && ef(Z.length) && !!De[Go(Z)];
    }
    function Bl(Z) {
      if (!ai(Z))
        return Ii(Z);
      var pe = [];
      for (var ze in Object(Z))
        Ee.call(Z, ze) && ze != "constructor" && pe.push(ze);
      return pe;
    }
    function cl(Z, pe, ze, lt, Nn, Lt) {
      var nr = ze & i, Rr = Z.length, Zn = pe.length;
      if (Rr != Zn && !(nr && Zn > Rr))
        return !1;
      var Qn = Lt.get(Z);
      if (Qn && Lt.get(pe))
        return Qn == pe;
      var B = -1, ne = !0, ge = ze & s ? new xo() : void 0;
      for (Lt.set(Z, pe), Lt.set(pe, Z); ++B < Rr; ) {
        var Re = Z[B], Ve = pe[B];
        if (lt)
          var ot = nr ? lt(Ve, Re, B, pe, Z, Lt) : lt(Re, Ve, B, Z, pe, Lt);
        if (ot !== void 0) {
          if (ot)
            continue;
          ne = !1;
          break;
        }
        if (ge) {
          if (!Gn(pe, function(Je, kt) {
            if (!Pr(ge, kt) && (Re === Je || Nn(Re, Je, ze, lt, Lt)))
              return ge.push(kt);
          })) {
            ne = !1;
            break;
          }
        } else if (!(Re === Ve || Nn(Re, Ve, ze, lt, Lt))) {
          ne = !1;
          break;
        }
      }
      return Lt.delete(Z), Lt.delete(pe), ne;
    }
    function ul(Z, pe, ze, lt, Nn, Lt, nr) {
      switch (ze) {
        case ie:
          if (Z.byteLength != pe.byteLength || Z.byteOffset != pe.byteOffset)
            return !1;
          Z = Z.buffer, pe = pe.buffer;
        case J:
          return !(Z.byteLength != pe.byteLength || !Lt(new qn(Z), new qn(pe)));
        case g:
        case y:
        case P:
          return Ts(+Z, +pe);
        case v:
          return Z.name == pe.name && Z.message == pe.message;
        case z:
        case H:
          return Z == pe + "";
        case E:
          var Rr = Vr;
        case F:
          var Zn = lt & i;
          if (Rr || (Rr = si), Z.size != pe.size && !Zn)
            return !1;
          var Qn = nr.get(Z);
          if (Qn)
            return Qn == pe;
          lt |= s, nr.set(Z, pe);
          var B = cl(Rr(Z), Rr(pe), lt, Nn, Lt, nr);
          return nr.delete(Z), B;
        case V:
          if (Wo)
            return Wo.call(Z) == Wo.call(pe);
      }
      return !1;
    }
    function Uu(Z, pe, ze, lt, Nn, Lt) {
      var nr = ze & i, Rr = Dc(Z), Zn = Rr.length, Qn = Dc(pe), B = Qn.length;
      if (Zn != B && !nr)
        return !1;
      for (var ne = Zn; ne--; ) {
        var ge = Rr[ne];
        if (!(nr ? ge in pe : Ee.call(pe, ge)))
          return !1;
      }
      var Re = Lt.get(Z);
      if (Re && Lt.get(pe))
        return Re == pe;
      var Ve = !0;
      Lt.set(Z, pe), Lt.set(pe, Z);
      for (var ot = nr; ++ne < Zn; ) {
        ge = Rr[ne];
        var Je = Z[ge], kt = pe[ge];
        if (lt)
          var Qt = nr ? lt(kt, Je, ge, pe, Z, Lt) : lt(Je, kt, ge, Z, pe, Lt);
        if (!(Qt === void 0 ? Je === kt || Nn(Je, kt, ze, lt, Lt) : Qt)) {
          Ve = !1;
          break;
        }
        ot || (ot = ge == "constructor");
      }
      if (Ve && !ot) {
        var Mn = Z.constructor, Bn = pe.constructor;
        Mn != Bn && "constructor" in Z && "constructor" in pe && !(typeof Mn == "function" && Mn instanceof Mn && typeof Bn == "function" && Bn instanceof Bn) && (Ve = !1);
      }
      return Lt.delete(Z), Lt.delete(pe), Ve;
    }
    function Dc(Z) {
      return Da(Z, jc, Cn);
    }
    function dn(Z, pe) {
      var ze = Z.__data__;
      return Ut(pe) ? ze[typeof pe == "string" ? "string" : "hash"] : ze.map;
    }
    function Zs(Z, pe) {
      var ze = wr(Z, pe);
      return Ac(ze) ? ze : void 0;
    }
    function Oc(Z) {
      var pe = Ee.call(Z, bn), ze = Z[bn];
      try {
        Z[bn] = void 0;
        var lt = !0;
      } catch {
      }
      var Nn = $e.call(Z);
      return lt && (pe ? Z[bn] = ze : delete Z[bn]), Nn;
    }
    var Cn = vn ? function(Z) {
      return Z == null ? [] : (Z = Object(Z), ln(vn(Z), function(pe) {
        return Rn.call(Z, pe);
      }));
    } : Wl, Ps = Go;
    (oo && Ps(new oo(new ArrayBuffer(1))) != ie || ki && Ps(new ki()) != E || Cs && Ps(Cs.resolve()) != L || ka && Ps(new ka()) != F || Ra && Ps(new Ra()) != q) && (Ps = function(Z) {
      var pe = Go(Z), ze = pe == k ? Z.constructor : void 0, lt = ze ? Nr(ze) : "";
      if (lt)
        switch (lt) {
          case Ul:
            return ie;
          case Xs:
            return E;
          case vo:
            return L;
          case vi:
            return F;
          case So:
            return q;
        }
      return pe;
    });
    function Qs(Z, pe) {
      return pe = pe ?? l, !!pe && (typeof Z == "number" || Ze.test(Z)) && Z > -1 && Z % 1 == 0 && Z < pe;
    }
    function Ut(Z) {
      var pe = typeof Z;
      return pe == "string" || pe == "number" || pe == "symbol" || pe == "boolean" ? Z !== "__proto__" : Z === null;
    }
    function Hl(Z) {
      return !!ve && ve in Z;
    }
    function ai(Z) {
      var pe = Z && Z.constructor, ze = typeof pe == "function" && pe.prototype || Ir;
      return Z === ze;
    }
    function ao(Z) {
      return $e.call(Z);
    }
    function Nr(Z) {
      if (Z != null) {
        try {
          return Ko.call(Z);
        } catch {
        }
        try {
          return Z + "";
        } catch {
        }
      }
      return "";
    }
    function Ts(Z, pe) {
      return Z === pe || Z !== Z && pe !== pe;
    }
    var kr = Hi(/* @__PURE__ */ function() {
      return arguments;
    }()) ? Hi : function(Z) {
      return ks(Z) && Ee.call(Z, "callee") && !Rn.call(Z, "callee");
    }, $n = Array.isArray;
    function Is(Z) {
      return Z != null && ef(Z.length) && !Oi(Z);
    }
    var lo = fn || qo;
    function Di(Z, pe) {
      return _s(Z, pe);
    }
    function Oi(Z) {
      if (!Vl(Z))
        return !1;
      var pe = Go(Z);
      return pe == w || pe == C || pe == h || pe == O;
    }
    function ef(Z) {
      return typeof Z == "number" && Z > -1 && Z % 1 == 0 && Z <= l;
    }
    function Vl(Z) {
      var pe = typeof Z;
      return Z != null && (pe == "object" || pe == "function");
    }
    function ks(Z) {
      return Z != null && typeof Z == "object";
    }
    var Kl = an ? Hr(an) : Oa;
    function jc(Z) {
      return Is(Z) ? Jd(Z) : Bl(Z);
    }
    function Wl() {
      return [];
    }
    function qo() {
      return !1;
    }
    n.exports = Di;
  }(wx, wx.exports)), wx.exports;
}
var Vne = Hne();
const ph = /* @__PURE__ */ wh(Vne);
function Kne(n) {
  if (n.length === 0) return /* @__PURE__ */ new Set();
  const e = n[0], t = n.slice(1), r = /* @__PURE__ */ new Set();
  for (const i of e)
    t.every((s) => s.has(i)) && r.add(i);
  return r;
}
function Wne(n, e) {
  const t = {};
  for (const r of e)
    n.has(r) || (t.added ?? (t.added = /* @__PURE__ */ new Set()), t.added.add(r));
  for (const r of n)
    e.has(r) || (t.removed ?? (t.removed = /* @__PURE__ */ new Set()), t.removed.add(r));
  return t.added || t.removed ? t : void 0;
}
function AF(n, e) {
  for (const [t, r] of Object.entries(n)) {
    const i = r, s = e[t];
    if ("eq" in i && s !== i.eq || "neq" in i && s === i.neq || "gt" in i && (typeof s != "number" || s <= i.gt)) return !1;
  }
  return !0;
}
function DF(n, e, t) {
  const r = Object.fromEntries(Object.keys(t).map((i) => [i, /* @__PURE__ */ new Set()]));
  for (const [i, s] of Object.entries(t))
    if ("eq" in s) {
      const c = n.index(e, i).get().get(s.eq);
      if (c)
        for (const d of c)
          r[i].add(d);
    } else if ("neq" in s) {
      const l = n.index(e, i);
      for (const [c, d] of l.get())
        if (c !== s.neq)
          for (const h of d)
            r[i].add(h);
    } else if ("gt" in s) {
      const l = n.index(e, i);
      for (const [c, d] of l.get())
        if (c > s.gt)
          for (const h of d)
            r[i].add(h);
    }
  return Kne(Object.values(r));
}
class Gne {
  constructor(e, t) {
    /**
     * A cache of derivations (indexes).
     *
     * @internal
     */
    U(this, "indexCache", /* @__PURE__ */ new Map());
    /**
     * A cache of derivations (filtered histories).
     *
     * @internal
     */
    U(this, "historyCache", /* @__PURE__ */ new Map());
    this.atoms = e, this.history = t;
  }
  /**
   * Create a derivation that contains the history for a given type
   *
   * @param typeName - The name of the type to filter by.
   * @returns A derivation that returns the ids of all records of the given type.
   * @public
   */
  filterHistory(e) {
    if (this.historyCache.has(e))
      return this.historyCache.get(e);
    const t = Le(
      "filterHistory:" + e,
      (r, i) => {
        if (Gp(r))
          return this.history.get();
        const s = this.history.getDiffSince(i);
        if (s === Za) return this.history.get();
        const l = { added: {}, removed: {}, updated: {} };
        let c = 0, d = 0, h = 0;
        for (const g of s) {
          for (const y of Xr(g.added))
            if (y.typeName === e)
              if (l.removed[y.id]) {
                const v = l.removed[y.id];
                delete l.removed[y.id], d--, v !== y && (l.updated[y.id] = [v, y], h++);
              } else
                l.added[y.id] = y, c++;
          for (const [y, v] of Xr(g.updated))
            v.typeName === e && (l.added[v.id] ? l.added[v.id] = v : l.updated[v.id] ? l.updated[v.id] = [l.updated[v.id][0], v] : (l.updated[v.id] = [y, v], h++));
          for (const y of Xr(g.removed))
            y.typeName === e && (l.added[y.id] ? (delete l.added[y.id], c--) : l.updated[y.id] ? (l.removed[y.id] = l.updated[y.id][0], delete l.updated[y.id], h--, d++) : (l.removed[y.id] = y, d++));
        }
        return c || d || h ? xx(this.history.get(), l) : r;
      },
      { historyLength: 100 }
    );
    return this.historyCache.set(e, t), t;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type.
   * @param property - The name of the property.
   * @public
   */
  index(e, t) {
    const r = e + ":" + t;
    if (this.indexCache.has(r))
      return this.indexCache.get(r);
    const i = this.__uncached_createIndex(e, t);
    return this.indexCache.set(r, i), i;
  }
  /**
   * Create a derivation that returns an index on a property for the given type.
   *
   * @param typeName - The name of the type?.
   * @param property - The name of the property?.
   * @internal
   */
  __uncached_createIndex(e, t) {
    const r = this.filterHistory(e), i = () => {
      r.get();
      const s = /* @__PURE__ */ new Map();
      for (const l of Xr(this.atoms.get())) {
        const c = l.get();
        if (c.typeName === e) {
          const d = c[t];
          s.has(d) || s.set(d, /* @__PURE__ */ new Set()), s.get(d).add(c.id);
        }
      }
      return s;
    };
    return Le(
      "index:" + e + ":" + t,
      (s, l) => {
        if (Gp(s)) return i();
        const c = r.getDiffSince(l);
        if (c === Za)
          return i();
        const d = /* @__PURE__ */ new Map(), h = (w, C) => {
          let E = d.get(w);
          E || (E = new yC(
            s.get(w) ?? /* @__PURE__ */ new Set()
          )), E.add(C), d.set(w, E);
        }, g = (w, C) => {
          let E = d.get(w);
          E || (E = new yC(s.get(w) ?? /* @__PURE__ */ new Set())), E.remove(C), d.set(w, E);
        };
        for (const w of c) {
          for (const C of Xr(w.added))
            if (C.typeName === e) {
              const E = C[t];
              h(E, C.id);
            }
          for (const [C, E] of Xr(w.updated))
            if (E.typeName === e) {
              const P = C[t], I = E[t];
              P !== I && (g(P, E.id), h(I, E.id));
            }
          for (const C of Xr(w.removed))
            if (C.typeName === e) {
              const E = C[t];
              g(E, C.id);
            }
        }
        let y, v;
        for (const [w, C] of d) {
          const E = C.get();
          E && (y || (y = new Map(s)), v || (v = /* @__PURE__ */ new Map()), E.value.size === 0 ? y.delete(w) : y.set(w, E.value), v.set(w, E.diff));
        }
        return y && v ? xx(y, v) : s;
      },
      { historyLength: 100 }
    );
  }
  /**
   * Create a derivation that will return a signle record matching the given query.
   *
   * It will return undefined if there is no matching record
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  record(e, t = () => ({}), r = "record:" + e + (t ? ":" + t.toString() : "")) {
    const i = this.ids(e, t, r);
    return Le(r, () => {
      var s;
      for (const l of i.get())
        return (s = this.atoms.get()[l]) == null ? void 0 : s.get();
    });
  }
  /**
   * Create a derivation that will return an array of records matching the given query
   *
   * @param typeName - The name of the type?
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  records(e, t = () => ({}), r = "records:" + e + (t ? ":" + t.toString() : "")) {
    const i = this.ids(e, t, "ids:" + r);
    return Le(
      r,
      () => {
        const s = this.atoms.get();
        return [...i.get()].map((l) => {
          const c = s[l];
          if (!c)
            throw new Error("no atom found for record id: " + l);
          return c.get();
        });
      },
      {
        isEqual: U$
      }
    );
  }
  /**
   * Create a derivation that will return the ids of all records of the given type.
   *
   * @param typeName - The name of the type.
   * @param queryCreator - A function that returns the query expression.
   * @param name - (optinal) The name of the query.
   */
  ids(e, t = () => ({}), r = "ids:" + e + (t ? ":" + t.toString() : "")) {
    const i = this.filterHistory(e), s = () => {
      i.get();
      const d = t();
      return Object.keys(d).length === 0 ? new Set(
        Xr(this.atoms.get()).flatMap((h) => {
          const g = h.get();
          return g.typeName === e ? g.id : [];
        })
      ) : DF(this, e, d);
    }, l = (d) => {
      const h = s(), g = Wne(d, h);
      return g ? xx(h, g) : d;
    }, c = Le("ids_query:" + r, t, {
      isEqual: ph
    });
    return Le(
      "query:" + r,
      (d, h) => {
        const g = c.get();
        if (Gp(d))
          return s();
        if (h < c.lastChangedEpoch)
          return l(d);
        const y = i.getDiffSince(h);
        if (y === Za)
          return l(d);
        const v = new yC(
          d
        );
        for (const C of y) {
          for (const E of Xr(C.added))
            E.typeName === e && AF(g, E) && v.add(E.id);
          for (const [E, P] of Xr(C.updated))
            P.typeName === e && (AF(g, P) ? v.add(P.id) : v.remove(P.id));
          for (const E of Xr(C.removed))
            E.typeName === e && v.remove(E.id);
        }
        const w = v.get();
        return w ? xx(w.value, w.diff) : d;
      },
      { historyLength: 50 }
    );
  }
  exec(e, t) {
    const r = DF(this, e, t);
    if (r.size === 0)
      return Fd;
    const i = this.atoms.get();
    return [...r].map((s) => i[s].get());
  }
}
class qne {
  constructor(e) {
    U(this, "_beforeCreateHandlers", {});
    U(this, "_afterCreateHandlers", {});
    U(this, "_beforeChangeHandlers", {});
    U(this, "_afterChangeHandlers", {});
    U(this, "_beforeDeleteHandlers", {});
    U(this, "_afterDeleteHandlers", {});
    U(this, "_operationCompleteHandlers", []);
    U(this, "_isEnabled", !0);
    this.store = e;
  }
  /** @internal */
  isEnabled() {
    return this._isEnabled;
  }
  /** @internal */
  setIsEnabled(e) {
    this._isEnabled = e;
  }
  /** @internal */
  handleBeforeCreate(e, t) {
    if (!this._isEnabled) return e;
    const r = this._beforeCreateHandlers[e.typeName];
    if (r) {
      let i = e;
      for (const s of r)
        i = s(i, t);
      return i;
    }
    return e;
  }
  /** @internal */
  handleAfterCreate(e, t) {
    if (!this._isEnabled) return;
    const r = this._afterCreateHandlers[e.typeName];
    if (r)
      for (const i of r)
        i(e, t);
  }
  /** @internal */
  handleBeforeChange(e, t, r) {
    if (!this._isEnabled) return t;
    const i = this._beforeChangeHandlers[t.typeName];
    if (i) {
      let s = t;
      for (const l of i)
        s = l(e, s, r);
      return s;
    }
    return t;
  }
  /** @internal */
  handleAfterChange(e, t, r) {
    if (!this._isEnabled) return;
    const i = this._afterChangeHandlers[t.typeName];
    if (i)
      for (const s of i)
        s(e, t, r);
  }
  /** @internal */
  handleBeforeDelete(e, t) {
    if (!this._isEnabled) return !0;
    const r = this._beforeDeleteHandlers[e.typeName];
    if (r) {
      for (const i of r)
        if (i(e, t) === !1)
          return !1;
    }
    return !0;
  }
  /** @internal */
  handleAfterDelete(e, t) {
    if (!this._isEnabled) return;
    const r = this._afterDeleteHandlers[e.typeName];
    if (r)
      for (const i of r)
        i(e, t);
  }
  /** @internal */
  handleOperationComplete(e) {
    if (this._isEnabled)
      for (const t of this._operationCompleteHandlers)
        t(e);
  }
  /**
   * Internal helper for registering a bunch of side effects at once and keeping them organized.
   * @internal
   */
  register(e) {
    const t = [];
    for (const [r, i] of Object.entries(e))
      i != null && i.beforeCreate && t.push(this.registerBeforeCreateHandler(r, i.beforeCreate)), i != null && i.afterCreate && t.push(this.registerAfterCreateHandler(r, i.afterCreate)), i != null && i.beforeChange && t.push(this.registerBeforeChangeHandler(r, i.beforeChange)), i != null && i.afterChange && t.push(this.registerAfterChangeHandler(r, i.afterChange)), i != null && i.beforeDelete && t.push(this.registerBeforeDeleteHandler(r, i.beforeDelete)), i != null && i.afterDelete && t.push(this.registerAfterDeleteHandler(r, i.afterDelete));
    return () => {
      for (const r of t) r();
    };
  }
  /**
   * Register a handler to be called before a record of a certain type is created. Return a
   * modified record from the handler to change the record that will be created.
   *
   * Use this handle only to modify the creation of the record itself. If you want to trigger a
   * side-effect on a different record (for example, moving one shape when another is created),
   * use {@link StoreSideEffects.registerAfterCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeCreateHandler('shape', (shape, source) => {
   *     // only modify shapes created by the user
   *     if (source !== 'user') return shape
   *
   *     //by default, arrow shapes have no label. Let's make sure they always have a label.
   *     if (shape.type === 'arrow') {
   *         return {...shape, props: {...shape.props, text: 'an arrow'}}
   *     }
   *
   *     // other shapes get returned unmodified
   *     return shape
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeCreateHandler(e, t) {
    return this._beforeCreateHandlers[e] || (this._beforeCreateHandlers[e] = []), this._beforeCreateHandlers[e].push(t), () => Bp(this._beforeCreateHandlers[e], t);
  }
  /**
   * Register a handler to be called after a record is created. This is useful for side-effects
   * that would update _other_ records. If you want to modify the record being created use
   * {@link StoreSideEffects.registerBeforeCreateHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterCreateHandler('page', (page, source) => {
   *     // Automatically create a shape when a page is created
   *     editor.createShape({
   *         id: createShapeId(),
   *         type: 'text',
   *         props: { text: page.name },
   *     })
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterCreateHandler(e, t) {
    return this._afterCreateHandlers[e] || (this._afterCreateHandlers[e] = []), this._afterCreateHandlers[e].push(t), () => Bp(this._afterCreateHandlers[e], t);
  }
  /**
   * Register a handler to be called before a record is changed. The handler is given the old and
   * new record - you can return a modified record to apply a different update, or the old record
   * to block the update entirely.
   *
   * Use this handler only for intercepting updates to the record itself. If you want to update
   * other records in response to a change, use
   * {@link StoreSideEffects.registerAfterChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeChangeHandler('shape', (prev, next, source) => {
   *     if (next.isLocked && !prev.isLocked) {
   *         // prevent shapes from ever being locked:
   *         return prev
   *     }
   *     // other types of change are allowed
   *     return next
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeChangeHandler(e, t) {
    return this._beforeChangeHandlers[e] || (this._beforeChangeHandlers[e] = []), this._beforeChangeHandlers[e].push(t), () => Bp(this._beforeChangeHandlers[e], t);
  }
  /**
   * Register a handler to be called after a record is changed. This is useful for side-effects
   * that would update _other_ records - if you want to modify the record being changed, use
   * {@link StoreSideEffects.registerBeforeChangeHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterChangeHandler('shape', (prev, next, source) => {
   *     if (next.props.color === 'red') {
   *         // there can only be one red shape at a time:
   *         const otherRedShapes = editor.getCurrentPageShapes().filter(s => s.props.color === 'red' && s.id !== next.id)
   *         editor.updateShapes(otherRedShapes.map(s => ({...s, props: {...s.props, color: 'blue'}})))
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterChangeHandler(e, t) {
    return this._afterChangeHandlers[e] || (this._afterChangeHandlers[e] = []), this._afterChangeHandlers[e].push(t), () => Bp(this._afterChangeHandlers[e], t);
  }
  /**
   * Register a handler to be called before a record is deleted. The handler can return `false` to
   * prevent the deletion.
   *
   * Use this handler only for intercepting deletions of the record itself. If you want to do
   * something to other records in response to a deletion, use
   * {@link StoreSideEffects.registerAfterDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerBeforeDeleteHandler('shape', (shape, source) => {
   *     if (shape.props.color === 'red') {
   *         // prevent red shapes from being deleted
   * 	       return false
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerBeforeDeleteHandler(e, t) {
    return this._beforeDeleteHandlers[e] || (this._beforeDeleteHandlers[e] = []), this._beforeDeleteHandlers[e].push(t), () => Bp(this._beforeDeleteHandlers[e], t);
  }
  /**
   * Register a handler to be called after a record is deleted. This is useful for side-effects
   * that would update _other_ records - if you want to block the deletion of the record itself,
   * use {@link StoreSideEffects.registerBeforeDeleteHandler} instead.
   *
   * @example
   * ```ts
   * editor.sideEffects.registerAfterDeleteHandler('shape', (shape, source) => {
   *     // if the last shape in a frame is deleted, delete the frame too:
   *     const parentFrame = editor.getShape(shape.parentId)
   *     if (!parentFrame || parentFrame.type !== 'frame') return
   *
   *     const siblings = editor.getSortedChildIdsForParent(parentFrame)
   *     if (siblings.length === 0) {
   *         editor.deleteShape(parentFrame.id)
   *     }
   * })
   * ```
   *
   * @param typeName - The type of record to listen for
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   */
  registerAfterDeleteHandler(e, t) {
    return this._afterDeleteHandlers[e] || (this._afterDeleteHandlers[e] = []), this._afterDeleteHandlers[e].push(t), () => Bp(this._afterDeleteHandlers[e], t);
  }
  /**
   * Register a handler to be called when a store completes an atomic operation.
   *
   * @example
   * ```ts
   * let count = 0
   *
   * editor.sideEffects.registerOperationCompleteHandler(() => count++)
   *
   * editor.selectAll()
   * expect(count).toBe(1)
   *
   * editor.store.atomic(() => {
   *	editor.selectNone()
   * 	editor.selectAll()
   * })
   *
   * expect(count).toBe(2)
   * ```
   *
   * @param handler - The handler to call
   *
   * @returns A callback that removes the handler.
   *
   * @public
   */
  registerOperationCompleteHandler(e) {
    return this._operationCompleteHandlers.push(e), () => Bp(this._operationCompleteHandlers, e);
  }
}
function Bp(n, e) {
  const t = n.indexOf(e);
  t >= 0 && n.splice(t, 1);
}
var Yne = {};
function oE(n) {
  if (Yne.NODE_ENV === "production")
    return n;
  const e = Object.getPrototypeOf(n);
  if (e && !(Array.isArray(n) || e === Object.prototype || e === null || e === u6))
    throw console.error("cannot include non-js data in a record", n), new Error("cannot include non-js data in a record");
  const t = Object.getOwnPropertyNames(n);
  for (const r of t) {
    const i = n[r];
    i && typeof i == "object" && oE(i);
  }
  return Object.freeze(n);
}
class sO {
  constructor(e) {
    /**
     * The random id of the store.
     */
    U(this, "id");
    /**
     * An atom containing the store's atoms.
     *
     * @internal
     * @readonly
     */
    U(this, "atoms", mi("store_atoms", {}));
    /**
     * An atom containing the store's history.
     *
     * @public
     * @readonly
     */
    U(this, "history", mi("history", 0, {
      historyLength: 1e3
    }));
    /**
     * A StoreQueries instance for this store.
     *
     * @public
     * @readonly
     */
    U(this, "query", new Gne(this.atoms, this.history));
    /**
     * A set containing listeners that have been added to this store.
     *
     * @internal
     */
    U(this, "listeners", /* @__PURE__ */ new Set());
    /**
     * An array of history entries that have not yet been flushed.
     *
     * @internal
     */
    U(this, "historyAccumulator", new Zne());
    /**
     * A reactor that responds to changes to the history by squashing the accumulated history and
     * notifying listeners of the changes.
     *
     * @internal
     */
    U(this, "historyReactor");
    U(this, "schema");
    U(this, "props");
    U(this, "scopedTypes");
    U(this, "sideEffects", new qne(this));
    U(this, "isMergingRemoteChanges", !1);
    U(this, "_integrityChecker");
    U(this, "_isPossiblyCorrupted", !1);
    U(this, "pendingAfterEvents", null);
    U(this, "_isInAtomicOp", !1);
    const { initialData: t, schema: r, id: i } = e;
    this.id = i ?? or(), this.schema = r, this.props = e.props, t && this.atoms.set(
      XD(
        Uo(t).map(([s, l]) => [
          s,
          mi(
            "atom:" + s,
            oE(this.schema.validateRecord(this, l, "initialize", null))
          )
        ])
      )
    ), this.historyReactor = Ene(
      "Store.historyReactor",
      () => {
        this.history.get(), this._flushHistory();
      },
      { scheduleEffect: (s) => this.cancelHistoryReactor = l6(s) }
    ), this.scopedTypes = {
      document: new Set(
        Xr(this.schema.types).filter((s) => s.scope === "document").map((s) => s.typeName)
      ),
      session: new Set(
        Xr(this.schema.types).filter((s) => s.scope === "session").map((s) => s.typeName)
      ),
      presence: new Set(
        Xr(this.schema.types).filter((s) => s.scope === "presence").map((s) => s.typeName)
      )
    };
  }
  /**
   * Function to dispose of any in-flight timeouts.
   *
   * @internal
   */
  cancelHistoryReactor() {
  }
  _flushHistory() {
    if (this.historyAccumulator.hasChanges()) {
      const e = this.historyAccumulator.flush();
      for (const { changes: t, source: r } of e) {
        let i = null, s = null, l = null;
        for (const { onHistory: c, filters: d } of this.listeners)
          if (!(d.source !== "all" && d.source !== r))
            if (d.scope !== "all")
              if (d.scope === "document") {
                if (s ?? (s = this.filterChangesByScope(t, "document")), !s) continue;
                c({ changes: s, source: r });
              } else if (d.scope === "session") {
                if (i ?? (i = this.filterChangesByScope(t, "session")), !i) continue;
                c({ changes: i, source: r });
              } else {
                if (l ?? (l = this.filterChangesByScope(t, "presence")), !l) continue;
                c({ changes: l, source: r });
              }
            else
              c({ changes: t, source: r });
      }
    }
  }
  dispose() {
    this.cancelHistoryReactor();
  }
  /**
   * Filters out non-document changes from a diff. Returns null if there are no changes left.
   * @param change - the records diff
   * @param scope - the records scope
   * @returns
   */
  filterChangesByScope(e, t) {
    const r = {
      added: Rx(e.added, (i, s) => this.scopedTypes[t].has(s.typeName)),
      updated: Rx(e.updated, (i, s) => this.scopedTypes[t].has(s[1].typeName)),
      removed: Rx(e.removed, (i, s) => this.scopedTypes[t].has(s.typeName))
    };
    return Object.keys(r.added).length === 0 && Object.keys(r.updated).length === 0 && Object.keys(r.removed).length === 0 ? null : r;
  }
  /**
   * Update the history with a diff of changes.
   *
   * @param changes - The changes to add to the history.
   */
  updateHistory(e) {
    this.historyAccumulator.add({
      changes: e,
      source: this.isMergingRemoteChanges ? "remote" : "user"
    }), this.listeners.size === 0 && this.historyAccumulator.clear(), this.history.set(this.history.get() + 1, e);
  }
  validate(e) {
    this.allRecords().forEach((t) => this.schema.validateRecord(this, t, e, null));
  }
  /**
   * Add some records to the store. It's an error if they already exist.
   *
   * @param records - The records to add.
   * @param phaseOverride - The phase override.
   * @public
   */
  put(e, t) {
    this.atomic(() => {
      const r = {}, i = {}, s = this.atoms.__unsafe__getWithoutCapture();
      let l = null, c, d = !1;
      const h = this.isMergingRemoteChanges ? "remote" : "user";
      for (let g = 0, y = e.length; g < y; g++) {
        c = e[g];
        const v = (l ?? s)[c.id];
        if (v) {
          const w = v.__unsafe__getWithoutCapture();
          if (c = this.sideEffects.handleBeforeChange(w, c, h), this.schema.validateRecord(
            this,
            c,
            t ?? "updateRecord",
            w
          ) === w) continue;
          v.set(oE(c)), d = !0;
          const E = v.__unsafe__getWithoutCapture();
          r[c.id] = [w, E], this.addDiffForAfterEvent(w, E);
        } else
          c = this.sideEffects.handleBeforeCreate(c, h), d = !0, c = this.schema.validateRecord(
            this,
            c,
            t ?? "createRecord",
            null
          ), i[c.id] = c, this.addDiffForAfterEvent(null, c), l || (l = { ...s }), l[c.id] = mi("atom:" + c.id, c);
      }
      l && this.atoms.set(l), d && this.updateHistory({
        added: i,
        updated: r,
        removed: {}
      });
    });
  }
  /**
   * Remove some records from the store via their ids.
   *
   * @param ids - The ids of the records to remove.
   * @public
   */
  remove(e) {
    this.atomic(() => {
      const t = /* @__PURE__ */ new Set(), r = this.isMergingRemoteChanges ? "remote" : "user";
      if (this.sideEffects.isEnabled())
        for (const s of e) {
          const l = this.atoms.__unsafe__getWithoutCapture()[s];
          l && this.sideEffects.handleBeforeDelete(l.get(), r) === !1 && t.add(s);
        }
      let i;
      this.atoms.update((s) => {
        let l;
        for (const c of e) {
          if (t.has(c) || !(c in s)) continue;
          l || (l = { ...s }), i || (i = {}), delete l[c];
          const d = s[c].get();
          i[c] = d, this.addDiffForAfterEvent(d, null);
        }
        return l ?? s;
      }), i && this.updateHistory({ added: {}, updated: {}, removed: i });
    });
  }
  /**
   * Get the value of a store record by its id.
   *
   * @param id - The id of the record to get.
   * @public
   */
  get(e) {
    var t;
    return (t = this.atoms.get()[e]) == null ? void 0 : t.get();
  }
  /**
   * Get the value of a store record by its id without updating its epoch.
   *
   * @param id - The id of the record to get.
   * @public
   */
  unsafeGetWithoutCapture(e) {
    var t;
    return (t = this.atoms.__unsafe__getWithoutCapture()[e]) == null ? void 0 : t.__unsafe__getWithoutCapture();
  }
  /**
   * Creates a JSON payload from the record store.
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   * @returns The record store snapshot as a JSON payload.
   */
  serialize(e = "document") {
    const t = {};
    for (const [r, i] of Uo(this.atoms.get())) {
      const s = i.get();
      (e === "all" || this.scopedTypes[e].has(s.typeName)) && (t[r] = s);
    }
    return t;
  }
  /**
   * Get a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param scope - The scope of records to serialize. Defaults to 'document'.
   *
   * @public
   */
  getStoreSnapshot(e = "document") {
    return {
      store: this.serialize(e),
      schema: this.schema.serialize()
    };
  }
  /**
   * @deprecated use `getSnapshot` from the 'tldraw' package instead.
   */
  getSnapshot(e = "document") {
    return console.warn(
      "[tldraw] `Store.getSnapshot` is deprecated and will be removed in a future release. Use `getSnapshot` from the `tldraw` package instead."
    ), this.getStoreSnapshot(e);
  }
  /**
   * Migrate a serialized snapshot of the store and its schema.
   *
   * ```ts
   * const snapshot = store.getSnapshot()
   * store.migrateSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  migrateSnapshot(e) {
    const t = this.schema.migrateStoreSnapshot(e);
    if (t.type === "error")
      throw new Error(`Failed to migrate snapshot: ${t.reason}`);
    return {
      store: t.value,
      schema: this.schema.serialize()
    };
  }
  /**
   * Load a serialized snapshot.
   *
   * ```ts
   * const snapshot = store.getStoreSnapshot()
   * store.loadStoreSnapshot(snapshot)
   * ```
   *
   * @param snapshot - The snapshot to load.
   * @public
   */
  loadStoreSnapshot(e) {
    const t = this.schema.migrateStoreSnapshot(e);
    if (t.type === "error")
      throw new Error(`Failed to migrate snapshot: ${t.reason}`);
    const r = this.sideEffects.isEnabled();
    try {
      this.sideEffects.setIsEnabled(!1), this.atomic(() => {
        this.clear(), this.put(Object.values(t.value)), this.ensureStoreIsUsable();
      });
    } finally {
      this.sideEffects.setIsEnabled(r);
    }
  }
  /**
   * @public
   * @deprecated use `loadSnapshot` from the 'tldraw' package instead.
   */
  loadSnapshot(e) {
    console.warn(
      "[tldraw] `Store.loadSnapshot` is deprecated and will be removed in a future release. Use `loadSnapshot` from the 'tldraw' package instead."
    ), this.loadStoreSnapshot(e);
  }
  /**
   * Get an array of all values in the store.
   *
   * @returns An array of all values in the store.
   * @public
   */
  allRecords() {
    return Xr(this.atoms.get()).map((e) => e.get());
  }
  /**
   * Removes all records from the store.
   *
   * @public
   */
  clear() {
    this.remove(CF(this.atoms.get()));
  }
  /**
   * Update a record. To update multiple records at once, use the `update` method of the
   * `TypedStore` class.
   *
   * @param id - The id of the record to update.
   * @param updater - A function that updates the record.
   */
  update(e, t) {
    const r = this.atoms.get()[e];
    if (!r) {
      console.error(`Record ${e} not found. This is probably an error`);
      return;
    }
    this.put([t(r.__unsafe__getWithoutCapture())]);
  }
  /**
   * Get whether the record store has a id.
   *
   * @param id - The id of the record to check.
   * @public
   */
  has(e) {
    return !!this.atoms.get()[e];
  }
  /**
   * Add a new listener to the store.
   *
   * @param onHistory - The listener to call when the store updates.
   * @param filters - Filters to apply to the listener.
   * @returns A function to remove the listener.
   */
  listen(e, t) {
    this._flushHistory();
    const r = {
      onHistory: e,
      filters: {
        source: (t == null ? void 0 : t.source) ?? "all",
        scope: (t == null ? void 0 : t.scope) ?? "all"
      }
    };
    return this.historyReactor.scheduler.isActivelyListening || (this.historyReactor.start(), this.historyReactor.scheduler.execute()), this.listeners.add(r), () => {
      this.listeners.delete(r), this.listeners.size === 0 && this.historyReactor.stop();
    };
  }
  /**
   * Merge changes from a remote source without triggering listeners.
   *
   * @param fn - A function that merges the external changes.
   * @public
   */
  mergeRemoteChanges(e) {
    if (this.isMergingRemoteChanges)
      return e();
    if (this._isInAtomicOp)
      throw new Error("Cannot merge remote changes while in atomic operation");
    try {
      this.isMergingRemoteChanges = !0, Dl(e);
    } finally {
      this.isMergingRemoteChanges = !1, this.ensureStoreIsUsable();
    }
  }
  /**
   * Run `fn` and return a {@link RecordsDiff} of the changes that occurred as a result.
   */
  extractingChanges(e) {
    const t = [], r = this.historyAccumulator.addInterceptor((i) => t.push(i.changes));
    try {
      return Dl(e), $E(t);
    } finally {
      r();
    }
  }
  applyDiff(e, {
    runCallbacks: t = !0,
    ignoreEphemeralKeys: r = !1
  } = {}) {
    this.atomic(() => {
      const i = Xr(e.added);
      for (const [l, c] of Xr(e.updated)) {
        const d = this.schema.getType(c.typeName);
        if (r && d.ephemeralKeySet.size) {
          const h = this.get(c.id);
          if (!h) {
            i.push(c);
            continue;
          }
          let g = null;
          for (const [y, v] of Object.entries(c))
            d.ephemeralKeySet.has(y) || Object.is(v, ys(h, y)) || (g || (g = { ...h }), g[y] = v);
          g && i.push(g);
        } else
          i.push(c);
      }
      const s = CF(e.removed);
      i.length && this.put(i), s.length && this.remove(s);
    }, t);
  }
  /**
   * Create a computed cache.
   *
   * @param name - The name of the derivation cache.
   * @param derive - A function used to derive the value of the cache.
   * @param isEqual - A function that determines equality between two records.
   * @public
   */
  createComputedCache(e, t, r) {
    const i = new Cu();
    return {
      get: (s) => {
        const l = this.atoms.get()[s];
        if (l)
          return i.get(l, () => {
            const c = r ? Le(l.name + ":equals", () => l.get(), { isEqual: r }) : l;
            return Le(e + ":" + s, () => t(c.get()));
          }).get();
      }
    };
  }
  /**
   * Create a computed cache from a selector
   *
   * @param name - The name of the derivation cache.
   * @param selector - A function that returns a subset of the original shape
   * @param derive - A function used to derive the value of the cache.
   * @public
   */
  createSelectedComputedCache(e, t, r) {
    const i = new Cu();
    return {
      get: (s) => {
        const l = this.atoms.get()[s];
        if (l)
          return i.get(l, () => {
            const c = Le(
              e + ":" + s + ":selector",
              () => t(l.get())
            );
            return Le(e + ":" + s, () => r(c.get()));
          }).get();
      }
    };
  }
  /** @internal */
  ensureStoreIsUsable() {
    this.atomic(() => {
      var e;
      this._integrityChecker ?? (this._integrityChecker = this.schema.createIntegrityChecker(this)), (e = this._integrityChecker) == null || e.call(this);
    });
  }
  /** @internal */
  markAsPossiblyCorrupted() {
    this._isPossiblyCorrupted = !0;
  }
  /** @internal */
  isPossiblyCorrupted() {
    return this._isPossiblyCorrupted;
  }
  addDiffForAfterEvent(e, t) {
    if (on(this.pendingAfterEvents, "must be in event operation"), e === t || (e && t && on(e.id === t.id), !e && !t)) return;
    const r = (e || t).id, i = this.pendingAfterEvents.get(r);
    i ? i.after = t : this.pendingAfterEvents.set(r, { before: e, after: t });
  }
  flushAtomicCallbacks() {
    let e = 0;
    const t = this.isMergingRemoteChanges ? "remote" : "user";
    for (; this.pendingAfterEvents; ) {
      const r = this.pendingAfterEvents;
      if (this.pendingAfterEvents = null, !!this.sideEffects.isEnabled()) {
        if (e++, e > 100)
          throw new Error("Maximum store update depth exceeded, bailing out");
        for (const { before: i, after: s } of r.values())
          i && s ? this.sideEffects.handleAfterChange(i, s, t) : i && !s ? this.sideEffects.handleAfterDelete(i, t) : !i && s && this.sideEffects.handleAfterCreate(s, t);
        this.pendingAfterEvents || this.sideEffects.handleOperationComplete(t);
      }
    }
  }
  /** @internal */
  atomic(e, t = !0) {
    return Dl(() => {
      if (this._isInAtomicOp)
        return this.pendingAfterEvents || (this.pendingAfterEvents = /* @__PURE__ */ new Map()), e();
      this.pendingAfterEvents = /* @__PURE__ */ new Map();
      const r = this.sideEffects.isEnabled();
      this.sideEffects.setIsEnabled(t ?? r), this._isInAtomicOp = !0;
      try {
        const i = e();
        return this.flushAtomicCallbacks(), i;
      } finally {
        this.pendingAfterEvents = null, this.sideEffects.setIsEnabled(r), this._isInAtomicOp = !1;
      }
    });
  }
  /** @internal */
  addHistoryInterceptor(e) {
    return this.historyAccumulator.addInterceptor(
      (t) => e(t, this.isMergingRemoteChanges ? "remote" : "user")
    );
  }
}
function Xne(n) {
  if (n.length === 0) return [];
  const e = [];
  let t = [n[0]], r;
  for (let i = 1, s = n.length; i < s; i++)
    r = n[i], t[0].source !== r.source && (e.push(t), t = []), t.push(r);
  return e.push(t), oE(
    e.map((i) => ({
      source: i[0].source,
      changes: $E(i.map((s) => s.changes))
    }))
  );
}
class Zne {
  constructor() {
    U(this, "_history", []);
    U(this, "_interceptors", /* @__PURE__ */ new Set());
  }
  addInterceptor(e) {
    return this._interceptors.add(e), () => {
      this._interceptors.delete(e);
    };
  }
  add(e) {
    this._history.push(e);
    for (const t of this._interceptors)
      t(e);
  }
  flush() {
    const e = Xne(this._history);
    return this._history = [], e;
  }
  clear() {
    this._history = [];
  }
  hasChanges() {
    return this._history.length > 0;
  }
}
function Qne(n, e, t) {
  const r = new Cu();
  return {
    get(i, s) {
      return r.get(i, () => (i instanceof sO ? i : i.store).createComputedCache(n, (d) => e(i, d), t)).get(s);
    }
  };
}
function Jne(n) {
  const e = [];
  for (let t = n.length - 1; t >= 0; t--) {
    const r = n[t];
    if ("id" in r)
      e.unshift(r);
    else {
      const i = r.dependsOn, s = e[0];
      s && (e[0] = {
        ...s,
        dependsOn: i.concat(s.dependsOn ?? [])
      });
    }
  }
  return e;
}
function Cy({
  sequence: n,
  sequenceId: e,
  retroactive: t = !0
}) {
  const r = {
    sequenceId: e,
    retroactive: t,
    sequence: Jne(n)
  };
  return C6(r), r;
}
function Pa(n, e) {
  return Object.fromEntries(
    Uo(e).map(([t, r]) => [t, `${n}/${r}`])
  );
}
function il(n) {
  const e = n.sequenceId;
  return Cy({
    sequenceId: e,
    retroactive: n.retroactive ?? !0,
    sequence: n.sequence.map(
      (t) => "id" in t ? {
        ...t,
        scope: "record",
        filter: (r) => {
          var i, s;
          return r.typeName === n.recordType && (((i = t.filter) == null ? void 0 : i.call(t, r)) ?? !0) && (((s = n.filter) == null ? void 0 : s.call(n, r)) ?? !0);
        }
      } : t
    )
  });
}
function ere(n) {
  const e = new Map(n.map((s) => [s.id, s])), t = /* @__PURE__ */ new Set(), r = [];
  function i(s) {
    on(!t.has(s.id), `Circular dependency in migrations: ${s.id}`), t.add(s.id);
    const { version: l, sequenceId: c } = sE(s.id), d = e.get(`${c}/${l - 1}`);
    if (d && i(d), s.dependsOn)
      for (const h of s.dependsOn) {
        const g = e.get(h);
        g && i(g);
      }
    e.delete(s.id), r.push(s);
  }
  for (const s of e.values())
    i(s);
  return r;
}
function sE(n) {
  const [e, t] = n.split("/");
  return { sequenceId: e, version: parseInt(t) };
}
function OF(n, e) {
  e && on(
    n.startsWith(e + "/"),
    `Every migration in sequence '${e}' must have an id starting with '${e}/'. Got invalid id: '${n}'`
  ), on(n.match(/^(.*?)\/(0|[1-9]\d*)$/), `Invalid migration id: '${n}'`);
}
function C6(n) {
  if (on(
    !n.sequenceId.includes("/"),
    `sequenceId cannot contain a '/', got ${n.sequenceId}`
  ), on(n.sequenceId.length, "sequenceId must be a non-empty string"), n.sequence.length === 0)
    return;
  OF(n.sequence[0].id, n.sequenceId);
  let e = sE(n.sequence[0].id).version;
  on(
    e === 1,
    `Expected the first migrationId to be '${n.sequenceId}/1' but got '${n.sequence[0].id}'`
  );
  for (let t = 1; t < n.sequence.length; t++) {
    const r = n.sequence[t].id;
    OF(r, n.sequenceId);
    const i = sE(r).version;
    on(
      i === e + 1,
      `Migration id numbers must increase in increments of 1, expected ${n.sequenceId}/${e + 1} but got '${n.sequence[t].id}'`
    ), e = i;
  }
}
var th = /* @__PURE__ */ ((n) => (n.IncompatibleSubtype = "incompatible-subtype", n.UnknownType = "unknown-type", n.TargetVersionTooNew = "target-version-too-new", n.TargetVersionTooOld = "target-version-too-old", n.MigrationError = "migration-error", n.UnrecognizedSubtype = "unrecognized-subtype", n))(th || {});
function tre(n) {
  if (n.schemaVersion > 2 || n.schemaVersion < 1) return uh.err("Bad schema version");
  if (n.schemaVersion === 2) return uh.ok(n);
  const e = {
    schemaVersion: 2,
    sequences: {
      "com.tldraw.store": n.storeVersion
    }
  };
  for (const [t, r] of Object.entries(n.recordVersions))
    if (e.sequences[`com.tldraw.${t}`] = r.version, "subTypeKey" in r)
      for (const [i, s] of Object.entries(r.subTypeVersions))
        e.sequences[`com.tldraw.${t}.${i}`] = s;
  return uh.ok(e);
}
class aO {
  constructor(e, t) {
    U(this, "migrations", {});
    U(this, "sortedMigrations");
    var i;
    this.types = e, this.options = t;
    for (const s of t.migrations ?? [])
      on(!this.migrations[s.sequenceId], `Duplicate migration sequenceId ${s.sequenceId}`), C6(s), this.migrations[s.sequenceId] = s;
    const r = Object.values(this.migrations).flatMap((s) => s.sequence);
    this.sortedMigrations = ere(r);
    for (const s of this.sortedMigrations)
      if ((i = s.dependsOn) != null && i.length)
        for (const l of s.dependsOn) {
          const c = r.find((d) => d.id === l);
          on(c, `Migration '${s.id}' depends on missing migration '${l}'`);
        }
  }
  static create(e, t) {
    return new aO(e, t ?? {});
  }
  validateRecord(e, t, r, i) {
    try {
      const s = ys(this.types, t.typeName);
      if (!s)
        throw new Error(`Missing definition for record type ${t.typeName}`);
      return s.validate(t, i ?? void 0);
    } catch (s) {
      if (this.options.onValidationFailure)
        return this.options.onValidationFailure({
          store: e,
          record: t,
          phase: r,
          recordBefore: i,
          error: s
        });
      throw s;
    }
  }
  // TODO: use a weakmap to store the result of this function
  getMigrationsSince(e) {
    const t = tre(e);
    if (!t.ok)
      return t;
    const r = t.value, i = new Set(
      // start with any shared sequences
      Object.keys(r.sequences).filter((l) => this.migrations[l])
    );
    for (const l in this.migrations)
      r.sequences[l] === void 0 && this.migrations[l].retroactive && i.add(l);
    if (i.size === 0)
      return uh.ok([]);
    const s = /* @__PURE__ */ new Set();
    for (const l of i) {
      const c = r.sequences[l];
      if (typeof c != "number" && this.migrations[l].retroactive || c === 0) {
        for (const g of this.migrations[l].sequence)
          s.add(g.id);
        continue;
      }
      const d = `${l}/${c}`, h = this.migrations[l].sequence.findIndex((g) => g.id === d);
      if (h === -1)
        return uh.err("Incompatible schema?");
      for (const g of this.migrations[l].sequence.slice(h + 1))
        s.add(g.id);
    }
    return uh.ok(this.sortedMigrations.filter(({ id: l }) => s.has(l)));
  }
  migratePersistedRecord(e, t, r = "up") {
    const i = this.getMigrationsSince(t);
    if (!i.ok)
      return console.error("Error migrating record", i.error), { type: "error", reason: th.MigrationError };
    let s = i.value;
    if (s.length === 0)
      return { type: "success", value: e };
    if (s.some((l) => l.scope === "store"))
      return {
        type: "error",
        reason: r === "down" ? th.TargetVersionTooOld : th.TargetVersionTooNew
      };
    if (r === "down") {
      if (!s.every((l) => l.down))
        return {
          type: "error",
          reason: th.TargetVersionTooOld
        };
      s = s.slice().reverse();
    }
    e = $r(e);
    try {
      for (const l of s) {
        if (l.scope === "store") throw new Error(
          /* won't happen, just for TS */
        );
        if (!(l.filter ? l.filter(e) : !0)) continue;
        const d = l[r](e);
        d && (e = $r(d));
      }
    } catch (l) {
      return console.error("Error migrating record", l), { type: "error", reason: th.MigrationError };
    }
    return { type: "success", value: e };
  }
  migrateStoreSnapshot(e) {
    let { store: t } = e;
    const r = this.getMigrationsSince(e.schema);
    if (!r.ok)
      return console.error("Error migrating store", r.error), { type: "error", reason: th.MigrationError };
    const i = r.value;
    if (i.length === 0)
      return { type: "success", value: t };
    t = $r(t);
    try {
      for (const s of i)
        if (s.scope === "record")
          for (const [l, c] of Object.entries(t)) {
            if (!(s.filter ? s.filter(c) : !0)) continue;
            const h = s.up(c);
            h && (t[l] = $r(h));
          }
        else if (s.scope === "store") {
          const l = s.up(t);
          l && (t = $r(l));
        } else
          ro(s);
    } catch (s) {
      return console.error("Error migrating store", s), { type: "error", reason: th.MigrationError };
    }
    return { type: "success", value: t };
  }
  /** @internal */
  createIntegrityChecker(e) {
    var t, r;
    return ((r = (t = this.options).createIntegrityChecker) == null ? void 0 : r.call(t, e)) ?? void 0;
  }
  serialize() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: e, sequence: t }) => [
          e,
          t.length ? sE(t.at(-1).id).version : 0
        ])
      )
    };
  }
  /**
   * @deprecated This is only here for legacy reasons, don't use it unless you have david's blessing!
   */
  serializeEarliestVersion() {
    return {
      schemaVersion: 2,
      sequences: Object.fromEntries(
        Object.values(this.migrations).map(({ sequenceId: e }) => [e, 0])
      )
    };
  }
  /** @internal */
  getType(e) {
    const t = ys(this.types, e);
    return on(t, "record type does not exists"), t;
  }
}
Au(
  "@tldraw/store",
  "3.7.0",
  "esm"
);
const Od = {
  Put: "put",
  Patch: "patch",
  Remove: "remove"
};
function nre(n) {
  let e = null;
  for (const [t, r] of Uo(n.added))
    e || (e = {}), e[t] = [Od.Put, r];
  for (const [t, r] of Xr(n.updated)) {
    const i = E6(t, r);
    i && (e || (e = {}), e[r.id] = [Od.Patch, i]);
  }
  for (const t of Object.keys(n.removed))
    e || (e = {}), e[t] = [Od.Remove];
  return e;
}
const ps = {
  Put: "put",
  Delete: "delete",
  Append: "append",
  Patch: "patch"
};
function E6(n, e) {
  return lO(n, e, /* @__PURE__ */ new Set(["props"]));
}
function lO(n, e, t) {
  if (n === e)
    return null;
  let r = null;
  for (const i of Object.keys(n)) {
    if (!(i in e)) {
      r || (r = {}), r[i] = [ps.Delete];
      continue;
    }
    const s = n[i], l = e[i];
    if (!ph(s, l))
      if (t != null && t.has(i) && s && l) {
        const c = lO(s, l);
        c && (r || (r = {}), r[i] = [ps.Patch, c]);
      } else if (Array.isArray(l) && Array.isArray(s)) {
        const c = _6(s, l);
        c && (r || (r = {}), r[i] = c);
      } else
        r || (r = {}), r[i] = [ps.Put, l];
  }
  for (const i of Object.keys(e))
    i in n || (r || (r = {}), r[i] = [ps.Put, e[i]]);
  return r;
}
function rre(n, e) {
  if (Object.is(n, e)) return null;
  if (Array.isArray(n) && Array.isArray(e))
    return _6(n, e);
  if (!n || !e || typeof n != "object" || typeof e != "object")
    return ph(n, e) ? null : [ps.Put, e];
  {
    const t = lO(n, e);
    return t ? [ps.Patch, t] : null;
  }
}
function _6(n, e) {
  if (Object.is(n, e)) return null;
  if (n.length === e.length) {
    const t = Math.max(n.length / 5, 1), r = [];
    for (let s = 0; s < n.length; s++)
      if (!ph(n[s], e[s]) && (r.push(s), r.length > t))
        return [ps.Put, e];
    if (r.length === 0)
      return null;
    const i = {};
    for (const s of r) {
      const l = n[s], c = e[s];
      if (!l || !c)
        i[s] = [ps.Put, c];
      else if (typeof l == "object" && typeof c == "object") {
        const d = rre(l, c);
        d && (i[s] = d);
      } else
        i[s] = [ps.Put, c];
    }
    return [ps.Patch, i];
  }
  for (let t = 0; t < n.length; t++)
    if (!ph(n[t], e[t]))
      return [ps.Put, e];
  return [ps.Append, e.slice(n.length), n.length];
}
function P6(n, e) {
  if (!n || typeof n != "object") return n;
  const t = Array.isArray(n);
  let r;
  const i = (s, l) => {
    r || (t ? r = [...n] : r = { ...n }), t ? r[Number(s)] = l : r[s] = l;
  };
  for (const [s, l] of Object.entries(e))
    switch (l[0]) {
      case ps.Put: {
        const c = l[1];
        ph(n[s], c) || i(s, c);
        break;
      }
      case ps.Append: {
        const c = l[1], d = l[2], h = n[s];
        Array.isArray(h) && h.length === d && i(s, [...h, ...c]);
        break;
      }
      case ps.Patch: {
        if (n[s] && typeof n[s] == "object") {
          const c = l[1], d = P6(n[s], c);
          d !== n[s] && i(s, d);
        }
        break;
      }
      case ps.Delete:
        s in n && (r || (t ? (console.error("Can't delete array item yet (this should never happen)"), r = [...n]) : r = { ...n }), delete r[s]);
    }
  return r ?? n;
}
function jF(n, e) {
  const t = setInterval(n, e);
  return () => clearInterval(t);
}
const ire = 7;
function ore() {
  return ire;
}
const sre = 4099, bx = {
  NOT_FOUND: "NOT_FOUND",
  FORBIDDEN: "FORBIDDEN",
  NOT_AUTHENTICATED: "NOT_AUTHENTICATED",
  UNKNOWN_ERROR: "UNKNOWN_ERROR",
  CLIENT_TOO_OLD: "CLIENT_TOO_OLD",
  SERVER_TOO_OLD: "SERVER_TOO_OLD",
  INVALID_RECORD: "INVALID_RECORD",
  RATE_LIMITED: "RATE_LIMITED",
  ROOM_FULL: "ROOM_FULL"
}, NA = 5e3, are = NA * 2;
class lre {
  constructor(e) {
    /** The last clock time from the most recent server update */
    U(this, "lastServerClock", 0);
    U(this, "lastServerInteractionTimestamp", Date.now());
    /** The queue of in-flight push requests that have not yet been acknowledged by the server */
    U(this, "pendingPushRequests", []);
    /**
     * The diff of 'unconfirmed', 'optimistic' changes that have been made locally by the user if we
     * take this diff, reverse it, and apply that to the store, our store will match exactly the most
     * recent state of the server that we know about
     */
    U(this, "speculativeChanges", {
      added: {},
      updated: {},
      removed: {}
    });
    U(this, "disposables", []);
    U(this, "store");
    U(this, "socket");
    U(this, "presenceState");
    // isOnline is true when we have an open socket connection and we have
    // established a connection with the server room (i.e. we have received a 'connect' message)
    U(this, "isConnectedToRoom", !1);
    /**
     * The client clock is essentially a counter for push requests Each time a push request is created
     * the clock is incremented. This clock is sent with the push request to the server, and the
     * server returns it with the response so that we can match up the response with the request.
     *
     * The clock may also be used at one point in the future to allow the client to re-send push
     * requests idempotently (i.e. the server will keep track of each client's clock and not execute
     * requests it has already handled), but at the time of writing this is neither needed nor
     * implemented.
     */
    U(this, "clientClock", 0);
    /**
     * Called immediately after a connect acceptance has been received and processed Use this to make
     * any changes to the store that are required to keep it operational
     */
    U(this, "onAfterConnect");
    U(this, "isDebugging", !1);
    U(this, "presenceType");
    U(this, "didCancel");
    U(this, "latestConnectRequestId", null);
    U(this, "incomingDiffBuffer", []);
    U(this, "lastPushedPresenceState", null);
    /** Send any unsent push requests to the server */
    U(this, "flushPendingPushRequests", PF(() => {
      if (this.debug("flushing pending push requests", {
        isConnectedToRoom: this.isConnectedToRoom,
        pendingPushRequests: this.pendingPushRequests
      }), !(!this.isConnectedToRoom || this.store.isPossiblyCorrupted())) {
        for (const e of this.pendingPushRequests)
          if (!e.sent) {
            if (this.socket.connectionStatus !== "online")
              return;
            this.socket.sendMessage(e.request), e.sent = !0;
          }
      }
    }));
    // eslint-disable-next-line local/prefer-class-methods
    U(this, "rebase", () => {
      var t;
      if (this.store._flushHistory(), this.incomingDiffBuffer.length === 0) return;
      const e = this.incomingDiffBuffer;
      this.incomingDiffBuffer = [];
      try {
        this.store.mergeRemoteChanges(() => {
          this.store.applyDiff(Kx(this.speculativeChanges), { runCallbacks: !1 });
          for (const r of e) {
            if (r.type === "patch") {
              this.applyNetworkDiff(r.diff, !0);
              continue;
            }
            if (this.pendingPushRequests.length === 0)
              throw new Error("Received push_result but there are no pending push requests");
            if (this.pendingPushRequests[0].request.clientClock !== r.clientClock)
              throw new Error(
                "Received push_result for a push request that is not at the front of the queue"
              );
            if (r.action === "discard")
              this.pendingPushRequests.shift();
            else if (r.action === "commit") {
              const { request: i } = this.pendingPushRequests.shift();
              "diff" in i && i.diff && this.applyNetworkDiff(i.diff, !0);
            } else
              this.applyNetworkDiff(r.action.rebaseWithDiff, !0), this.pendingPushRequests.shift();
          }
          try {
            this.speculativeChanges = this.store.extractingChanges(() => {
              for (const { request: r } of this.pendingPushRequests)
                !("diff" in r) || !r.diff || this.applyNetworkDiff(r.diff, !0);
            });
          } catch (r) {
            console.error(r), this.speculativeChanges = { added: {}, updated: {}, removed: {} }, this.resetConnection();
          }
        }), this.lastServerClock = ((t = e.at(-1)) == null ? void 0 : t.serverClock) ?? this.lastServerClock;
      } catch (r) {
        console.error(r), this.store.ensureStoreIsUsable(), this.resetConnection();
      }
    });
    U(this, "scheduleRebase", PF(this.rebase));
    this.didCancel = e.didCancel, this.presenceType = e.store.scopedTypes.presence.values().next().value ?? null, typeof window < "u" && (window.tlsync = this), this.store = e.store, this.socket = e.socket, this.onAfterConnect = e.onAfterConnect;
    let t = !1;
    this.presenceState = e.presence, this.disposables.push(
      // when local 'user' changes are made, send them to the server
      // or stash them locally in offline mode
      this.store.listen(
        ({ changes: r }) => {
          var i;
          if ((i = this.didCancel) != null && i.call(this)) return this.close();
          this.debug("received store changes", { changes: r }), this.push(r);
        },
        { source: "user", scope: "document" }
      ),
      // when the server sends us events, handle them
      this.socket.onReceiveMessage((r) => {
        var i;
        if ((i = this.didCancel) != null && i.call(this)) return this.close();
        this.debug("received message from server", r), this.handleServerEvent(r), t || (t = !0, e.onLoad(this));
      }),
      // handle switching between online and offline
      this.socket.onStatusChange((r) => {
        var i;
        if ((i = this.didCancel) != null && i.call(this)) return this.close();
        this.debug("socket status changed", r.status), r.status === "online" ? this.sendConnectMessage() : (this.resetConnection(), r.status === "error" && (t = !0, e.onSyncError(r.reason), this.close()));
      }),
      // Send a ping every PING_INTERVAL ms while online
      jF(() => {
        var r;
        if ((r = this.didCancel) != null && r.call(this)) return this.close();
        if (this.debug("ping loop", { isConnectedToRoom: this.isConnectedToRoom }), !!this.isConnectedToRoom)
          try {
            this.socket.sendMessage({ type: "ping" });
          } catch (i) {
            console.warn("ping failed, resetting", i), this.resetConnection();
          }
      }, NA),
      // Check the server connection health, reset the connection if needed
      jF(() => {
        var i;
        if ((i = this.didCancel) != null && i.call(this)) return this.close();
        if (this.debug("health check loop", { isConnectedToRoom: this.isConnectedToRoom }), !this.isConnectedToRoom) return;
        const r = Date.now() - this.lastServerInteractionTimestamp;
        if (r < are) {
          this.debug("health check passed", { timeSinceLastServerInteraction: r });
          return;
        }
        console.warn("Haven't heard from the server in a while, resetting connection..."), this.resetConnection();
      }, NA * 2)
    ), this.presenceState && this.disposables.push(
      wc("pushPresence", () => {
        var r;
        if ((r = this.didCancel) != null && r.call(this)) return this.close();
        this.pushPresence(this.presenceState.get());
      })
    ), this.socket.connectionStatus === "online" && this.sendConnectMessage();
  }
  debug(...e) {
    this.isDebugging && console.debug(...e);
  }
  /**
   * This is the first message that is sent over a newly established socket connection. And we need
   * to wait for the response before this client can be used.
   */
  sendConnectMessage() {
    if (this.isConnectedToRoom) {
      console.error("sendConnectMessage called while already connected");
      return;
    }
    this.debug("sending connect message"), this.latestConnectRequestId = or(), this.socket.sendMessage({
      type: "connect",
      connectRequestId: this.latestConnectRequestId,
      schema: this.store.schema.serialize(),
      protocolVersion: ore(),
      lastServerClock: this.lastServerClock
    });
  }
  /** Switch to offline mode */
  resetConnection(e = !1) {
    this.debug("resetting connection"), e && (this.lastServerClock = 0), this.store.mergeRemoteChanges(() => {
      this.store.remove(Object.keys(this.store.serialize("presence")));
    }), this.lastPushedPresenceState = null, this.isConnectedToRoom = !1, this.pendingPushRequests = [], this.incomingDiffBuffer = [], this.socket.connectionStatus === "online" && this.socket.restart();
  }
  /**
   * Invoked when the socket connection comes online, either for the first time or as the result of
   * a reconnect. The goal is to rebase on the server's state and fire off a new push request for
   * any local changes that were made while offline.
   */
  didReconnect(e) {
    if (this.debug("did reconnect", e), e.connectRequestId === this.latestConnectRequestId) {
      if (this.latestConnectRequestId = null, this.isConnectedToRoom) {
        console.error("didReconnect called while already connected"), this.resetConnection(!0);
        return;
      }
      if (this.pendingPushRequests.length > 0) {
        console.error("pendingPushRequests should already be empty when we reconnect"), this.resetConnection(!0);
        return;
      }
      Dl(() => {
        var r;
        const t = this.speculativeChanges;
        this.speculativeChanges = { added: {}, updated: {}, removed: {} }, this.store.mergeRemoteChanges(() => {
          const i = {}, s = e.hydrationType === "wipe_all";
          s || this.store.applyDiff(Kx(t), { runCallbacks: !1 });
          for (const [c, d] of Uo(this.store.serialize("all")))
            (s && this.store.scopedTypes.document.has(d.typeName) || d.typeName === this.presenceType) && (i[c] = [Od.Remove]);
          this.applyNetworkDiff({ ...i, ...e.diff }, !0), this.isConnectedToRoom = !0;
          const l = this.store.filterChangesByScope(
            this.store.extractingChanges(() => {
              this.store.applyDiff(t);
            }),
            "document"
          );
          l && this.push(l);
        }), (r = this.onAfterConnect) == null || r.call(this, this, { isReadonly: e.isReadonly });
      }), this.lastServerClock = e.serverClock;
    }
  }
  /** Handle events received from the server */
  handleServerEvent(e) {
    switch (this.debug("received server event", e), this.lastServerInteractionTimestamp = Date.now(), e.type) {
      case "connect":
        this.didReconnect(e);
        break;
      case "patch":
      case "push_result":
        if (!this.isConnectedToRoom) break;
        this.incomingDiffBuffer.push(e), this.scheduleRebase();
        break;
      case "data":
        if (!this.isConnectedToRoom) break;
        this.incomingDiffBuffer.push(...e.data), this.scheduleRebase();
        break;
      case "incompatibility_error":
        console.error("incompatibility error is legacy and should no longer be sent by the server");
        break;
      case "pong":
        break;
      default:
        ro(e);
    }
  }
  close() {
    var e, t, r, i;
    this.debug("closing"), this.disposables.forEach((s) => s()), (t = (e = this.flushPendingPushRequests).cancel) == null || t.call(e), (i = (r = this.scheduleRebase).cancel) == null || i.call(r);
  }
  pushPresence(e) {
    if (this.store._flushHistory(), !this.isConnectedToRoom)
      return;
    let t;
    if (!this.lastPushedPresenceState && e)
      t = [Od.Put, e];
    else if (this.lastPushedPresenceState && e) {
      const s = E6(this.lastPushedPresenceState, e);
      s && (t = [Od.Patch, s]);
    }
    if (!t) return;
    this.lastPushedPresenceState = e;
    const r = this.pendingPushRequests.at(-1);
    if (r && !r.sent && !r.request.presence) {
      r.request.presence = t;
      return;
    }
    const i = {
      type: "push",
      clientClock: this.clientClock++,
      presence: t
    };
    this.pendingPushRequests.push({ request: i, sent: !1 }), this.flushPendingPushRequests();
  }
  /** Push a change to the server, or stash it locally if we're offline */
  push(e) {
    this.debug("push", e);
    const t = nre(e);
    if (!t || (this.speculativeChanges = $E([this.speculativeChanges, e]), !this.isConnectedToRoom))
      return;
    const r = {
      type: "push",
      diff: t,
      clientClock: this.clientClock++
    };
    this.pendingPushRequests.push({ request: r, sent: !1 }), this.flushPendingPushRequests();
  }
  /**
   * Applies a 'network' diff to the store this does value-based equality checking so that if the
   * data is the same (as opposed to merely identical with ===), then no change is made and no
   * changes will be propagated back to store listeners
   */
  applyNetworkDiff(e, t) {
    this.debug("applyNetworkDiff", e);
    const r = { added: {}, updated: {}, removed: {} };
    let i = !1;
    for (const [s, l] of Uo(e))
      if (l[0] === Od.Put) {
        const c = this.store.get(s);
        c && !ph(c, l[1]) ? (i = !0, r.updated[s] = [c, l[1]]) : (i = !0, r.added[s] = l[1]);
      } else if (l[0] === Od.Patch) {
        const c = this.store.get(s);
        if (!c)
          continue;
        const d = P6(c, l[1]);
        i = !0, r.updated[s] = [c, d];
      } else l[0] === Od.Remove && this.store.has(s) && (i = !0, r.removed[s] = this.store.get(s));
    i && this.store.applyDiff(r, { runCallbacks: t });
  }
}
function D1(n, e, t) {
  return n.addEventListener(e, t), () => {
    n.removeEventListener(e, t);
  };
}
function Ur(...n) {
  if (typeof window < "u" && window.__tldraw_socket_debug) {
    const e = /* @__PURE__ */ new Date();
    console.log(
      `${e.getHours()}:${e.getMinutes()}:${e.getSeconds()}.${e.getMilliseconds()}`,
      ...n
      //, new Error().stack
    );
  }
}
class cre {
  constructor(e) {
    U(this, "_ws", null);
    U(this, "isDisposed", !1);
    /** @internal */
    U(this, "_reconnectManager");
    // TLPersistentClientSocket stuff
    U(this, "_connectionStatus", mi(
      "websocket connection status",
      "initial"
    ));
    U(this, "messageListeners", /* @__PURE__ */ new Set());
    U(this, "statusListeners", /* @__PURE__ */ new Set());
    this._reconnectManager = new pre(this, e);
  }
  // TODO: .close should be a project-wide interface with a common contract (.close()d thing
  //       can only be garbage collected, and can't be used anymore)
  close() {
    var e;
    this.isDisposed = !0, this._reconnectManager.close(), (e = this._ws) == null || e.close();
  }
  _handleConnect() {
    Ur("handleConnect"), this._connectionStatus.set("online"), this.statusListeners.forEach((e) => e({ status: "online" })), this._reconnectManager.connected();
  }
  _handleDisconnect(e, t, r, i) {
    i = i || bx.UNKNOWN_ERROR, Ur("handleDisconnect", {
      currentStatus: this.connectionStatus,
      closeCode: t,
      reason: e
    });
    let s;
    switch (e) {
      case "closed":
        t === sre ? s = "error" : s = "offline";
        break;
      case "manual":
        s = "offline";
        break;
    }
    t === 1006 && !r && wne(
      "Could not open WebSocket connection. This might be because you're trying to load a URL that doesn't support websockets. Check the URL you're trying to connect to."
    ), // it the status changed
    this.connectionStatus !== s && // ignore errors if we're already in the offline state
    !(s === "error" && this.connectionStatus === "offline") && (this._connectionStatus.set(s), this.statusListeners.forEach(
      (l) => l(s === "error" ? { status: "error", reason: i } : { status: s })
    )), this._reconnectManager.disconnected();
  }
  _setNewSocket(e) {
    var r;
    on(!this.isDisposed, "Tried to set a new websocket on a disposed socket"), on(
      this._ws === null || this._ws.readyState === WebSocket.CLOSED || this._ws.readyState === WebSocket.CLOSING,
      `Tried to set a new websocket in when the existing one was ${(r = this._ws) == null ? void 0 : r.readyState}`
    );
    let t = !1;
    e.onopen = () => {
      Ur("ws.onopen"), on(
        this._ws === e,
        "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't open"
      ), t = !0, this._handleConnect();
    }, e.onclose = (i) => {
      Ur("ws.onclose", i), this._ws === e ? this._handleDisconnect("closed", i.code, t, i.reason) : Ur("ignoring onclose for an orphaned socket");
    }, e.onerror = (i) => {
      Ur("ws.onerror", i), this._ws === e ? this._handleDisconnect("closed") : Ur("ignoring onerror for an orphaned socket");
    }, e.onmessage = (i) => {
      on(
        this._ws === e,
        "sockets must only be orphaned when they are CLOSING or CLOSED, so they can't receive messages"
      );
      const s = JSON.parse(i.data.toString());
      this.messageListeners.forEach((l) => l(s));
    }, this._ws = e;
  }
  _closeSocket() {
    this._ws !== null && (this._ws.close(), this._ws = null, this._handleDisconnect("manual"));
  }
  // eslint-disable-next-line no-restricted-syntax
  get connectionStatus() {
    const e = this._connectionStatus.get();
    return e === "initial" ? "offline" : e;
  }
  sendMessage(e) {
    if (on(!this.isDisposed, "Tried to send message on a disposed socket"), !!this._ws)
      if (this.connectionStatus === "online") {
        const t = Bne(JSON.stringify(e));
        for (const r of t)
          this._ws.send(r);
      } else
        console.warn("Tried to send message while " + this.connectionStatus);
  }
  onReceiveMessage(e) {
    return on(!this.isDisposed, "Tried to add message listener on a disposed socket"), this.messageListeners.add(e), () => {
      this.messageListeners.delete(e);
    };
  }
  onStatusChange(e) {
    return on(!this.isDisposed, "Tried to add status listener on a disposed socket"), this.statusListeners.add(e), () => {
      this.statusListeners.delete(e);
    };
  }
  restart() {
    on(!this.isDisposed, "Tried to restart a disposed socket"), Ur("restarting"), this._closeSocket(), this._reconnectManager.maybeReconnected();
  }
}
const ex = 500, ure = 2e3, dre = 1e3, fre = 1e3 * 60 * 5, hre = 1.5, LF = 1e3;
class pre {
  constructor(e, t) {
    U(this, "isDisposed", !1);
    U(this, "disposables", [
      () => {
        this.reconnectTimeout && clearTimeout(this.reconnectTimeout), this.recheckConnectingTimeout && clearTimeout(this.recheckConnectingTimeout);
      }
    ]);
    U(this, "reconnectTimeout", null);
    U(this, "recheckConnectingTimeout", null);
    U(this, "lastAttemptStart", null);
    U(this, "intendedDelay", ex);
    U(this, "state");
    this.socketAdapter = e, this.getUri = t, this.subscribeToReconnectHints(), this.disposables.push(
      D1(window, "offline", () => {
        Ur("window went offline"), this.socketAdapter._closeSocket();
      })
    ), this.state = "pendingAttempt", this.intendedDelay = ex, this.scheduleAttempt();
  }
  subscribeToReconnectHints() {
    if (this.disposables.push(
      D1(window, "online", () => {
        Ur("window went online"), this.maybeReconnected();
      }),
      D1(document, "visibilitychange", () => {
        document.hidden || (Ur("document became visible"), this.maybeReconnected());
      })
    ), Object.prototype.hasOwnProperty.call(navigator, "connection")) {
      const e = navigator.connection;
      this.disposables.push(
        D1(e, "change", () => {
          Ur("navigator.connection change"), this.maybeReconnected();
        })
      );
    }
  }
  scheduleAttempt() {
    on(this.state === "pendingAttempt"), Ur("scheduling a connection attempt"), Promise.resolve(this.getUri()).then((e) => {
      var t;
      this.state !== "pendingAttempt" || this.isDisposed || (on(
        ((t = this.socketAdapter._ws) == null ? void 0 : t.readyState) !== WebSocket.OPEN,
        "There should be no connection attempts while already connected"
      ), this.lastAttemptStart = Date.now(), this.socketAdapter._setNewSocket(new WebSocket(gre(e))), this.state = "pendingAttemptResult");
    });
  }
  getMaxDelay() {
    return document.hidden ? fre : ure;
  }
  getMinDelay() {
    return document.hidden ? dre : ex;
  }
  clearReconnectTimeout() {
    this.reconnectTimeout && (clearTimeout(this.reconnectTimeout), this.reconnectTimeout = null);
  }
  clearRecheckConnectingTimeout() {
    this.recheckConnectingTimeout && (clearTimeout(this.recheckConnectingTimeout), this.recheckConnectingTimeout = null);
  }
  maybeReconnected() {
    var e, t;
    if (Ur("ReconnectManager.maybeReconnected"), this.clearRecheckConnectingTimeout(), ((e = this.socketAdapter._ws) == null ? void 0 : e.readyState) === WebSocket.OPEN) {
      Ur("ReconnectManager.maybeReconnected: already connected");
      return;
    }
    if (((t = this.socketAdapter._ws) == null ? void 0 : t.readyState) === WebSocket.CONNECTING) {
      Ur("ReconnectManager.maybeReconnected: connecting"), on(
        this.lastAttemptStart,
        "ReadyState=CONNECTING without lastAttemptStart should be impossible"
      );
      const r = Date.now() - this.lastAttemptStart;
      r < LF ? (Ur("ReconnectManager.maybeReconnected: connecting, rechecking later"), this.recheckConnectingTimeout = setTimeout(
        () => this.maybeReconnected(),
        LF - r
      )) : (Ur("ReconnectManager.maybeReconnected: connecting, but for too long, retry now"), this.clearRecheckConnectingTimeout(), this.socketAdapter._closeSocket());
      return;
    }
    Ur("ReconnectManager.maybeReconnected: closing/closed/null, retry now"), this.intendedDelay = ex, this.disconnected();
  }
  disconnected() {
    var e, t;
    if (Ur("ReconnectManager.disconnected"), ((e = this.socketAdapter._ws) == null ? void 0 : e.readyState) !== WebSocket.OPEN && ((t = this.socketAdapter._ws) == null ? void 0 : t.readyState) !== WebSocket.CONNECTING) {
      Ur("ReconnectManager.disconnected: websocket is not OPEN or CONNECTING"), this.clearReconnectTimeout();
      let r;
      this.state === "connected" ? (this.intendedDelay = this.getMinDelay(), r = this.intendedDelay) : r = this.lastAttemptStart !== null ? this.lastAttemptStart + this.intendedDelay - Date.now() : 0, r > 0 ? (Ur("ReconnectManager.disconnected: delaying, delayLeft", r), this.state = "delay", this.reconnectTimeout = setTimeout(() => this.disconnected(), r)) : (this.state = "pendingAttempt", this.intendedDelay = Math.min(
        this.getMaxDelay(),
        Math.max(this.getMinDelay(), this.intendedDelay) * hre
      ), Ur(
        "ReconnectManager.disconnected: attempting a connection, next delay",
        this.intendedDelay
      ), this.scheduleAttempt());
    }
  }
  connected() {
    var e;
    Ur("ReconnectManager.connected"), ((e = this.socketAdapter._ws) == null ? void 0 : e.readyState) === WebSocket.OPEN && (Ur("ReconnectManager.connected: websocket is OPEN"), this.state = "connected", this.clearReconnectTimeout(), this.intendedDelay = ex);
  }
  close() {
    this.disposables.forEach((e) => e()), this.isDisposed = !0;
  }
}
function gre(n) {
  return n.replace(/^http(s)?:/, "ws$1:");
}
class mre extends Error {
  constructor(t) {
    super(`sync error: ${t}`);
    U(this, "name", "RemoteSyncError");
    this.reason = t;
  }
}
var yre = {};
function vre(n) {
  if (!n.length)
    return null;
  let e = "";
  for (const t of n)
    typeof t == "number" ? e += `.${t}` : t.startsWith("(") ? e.endsWith(")") ? e = `${e.slice(0, -1)}, ${t.slice(1)}` : e += t : e += `.${t}`;
  return e = e.replace(/id = [^,]+, /, "").replace(/id = [^)]+/, ""), e.startsWith(".") ? e.slice(1) : e;
}
class Fn extends Error {
  constructor(t, r = []) {
    const i = vre(r), s = t.split(`
`).map((l, c) => c === 0 ? l : `  ${l}`).join(`
`);
    super(r ? `At ${i}: ${s}` : s);
    U(this, "name", "ValidationError");
    this.rawMessage = t, this.path = r;
  }
}
function _a(n, e) {
  try {
    return e();
  } catch (t) {
    throw t instanceof Fn ? new Fn(t.rawMessage, [n, ...t.path]) : new Fn(t.toString(), [n]);
  }
}
function gh(n) {
  if (n === null) return "null";
  if (Array.isArray(n)) return "an array";
  const e = typeof n;
  switch (e) {
    case "bigint":
    case "boolean":
    case "function":
    case "number":
    case "string":
    case "symbol":
      return `a ${e}`;
    case "object":
      return `an ${e}`;
    case "undefined":
      return "undefined";
    default:
      ro(e);
  }
}
class Hs {
  constructor(e, t) {
    this.validationFn = e, this.validateUsingKnownGoodVersionFn = t;
  }
  /**
   * Asserts that the passed value is of the correct type and returns it. The returned value is
   * guaranteed to be referentially equal to the passed value.
   */
  validate(e) {
    const t = this.validationFn(e);
    if (yre.NODE_ENV !== "production" && !Object.is(e, t))
      throw new Fn("Validator functions must return the same value they were passed");
    return t;
  }
  validateUsingKnownGoodVersion(e, t) {
    return Object.is(e, t) ? e : this.validateUsingKnownGoodVersionFn ? this.validateUsingKnownGoodVersionFn(e, t) : this.validate(t);
  }
  /** Checks that the passed value is of the correct type. */
  isValid(e) {
    try {
      return this.validate(e), !0;
    } catch {
      return !1;
    }
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  nullable() {
    return Ere(this);
  }
  /**
   * Returns a new validator that also accepts null or undefined. The resulting value will always be
   * null.
   */
  optional() {
    return I6(this);
  }
  /**
   * Refine this validation to a new type. The passed-in validation function should throw an error
   * if the value can't be converted to the new type, or return the new type otherwise.
   */
  refine(e) {
    return new Hs(
      (t) => e(this.validate(t)),
      (t, r) => {
        const i = this.validateUsingKnownGoodVersion(t, r);
        return Object.is(t, i) ? t : e(i);
      }
    );
  }
  check(e, t) {
    return typeof e == "string" ? this.refine((r) => (_a(`(check ${e})`, () => t(r)), r)) : this.refine((r) => (e(r), r));
  }
}
class Sre extends Hs {
  constructor(e) {
    super(
      (t) => {
        const r = NF.validate(t);
        for (let i = 0; i < r.length; i++)
          _a(i, () => e.validate(r[i]));
        return r;
      },
      (t, r) => {
        if (!e.validateUsingKnownGoodVersion) return this.validate(r);
        const i = NF.validate(r);
        let s = t.length !== i.length;
        for (let l = 0; l < i.length; l++) {
          const c = i[l];
          if (l >= t.length) {
            s = !0, _a(l, () => e.validate(c));
            continue;
          }
          if (Object.is(t[l], c))
            continue;
          const d = _a(
            l,
            () => e.validateUsingKnownGoodVersion(t[l], c)
          );
          Object.is(d, t[l]) || (s = !0);
        }
        return s ? r : t;
      }
    ), this.itemValidator = e;
  }
  nonEmpty() {
    return this.check((e) => {
      if (e.length === 0)
        throw new Fn("Expected a non-empty array");
    });
  }
  lengthGreaterThan1() {
    return this.check((e) => {
      if (e.length <= 1)
        throw new Fn("Expected an array with length greater than 1");
    });
  }
}
class aE extends Hs {
  constructor(e, t = !1) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new Fn(`Expected object, got ${gh(r)}`);
        for (const [i, s] of Object.entries(e))
          _a(i, () => {
            s.validate(ys(r, i));
          });
        if (!t) {
          for (const i of Object.keys(r))
            if (!xc(e, i))
              throw new Fn("Unexpected property", [i]);
        }
        return r;
      },
      (r, i) => {
        if (typeof i != "object" || i === null)
          throw new Fn(`Expected object, got ${gh(i)}`);
        let s = !1;
        for (const [l, c] of Object.entries(e)) {
          const d = ys(r, l), h = ys(i, l);
          if (Object.is(d, h))
            continue;
          const g = _a(l, () => {
            const y = c;
            return y.validateUsingKnownGoodVersion ? y.validateUsingKnownGoodVersion(d, h) : y.validate(h);
          });
          Object.is(g, d) || (s = !0);
        }
        if (!t) {
          for (const l of Object.keys(i))
            if (!xc(e, l))
              throw new Fn("Unexpected property", [l]);
        }
        for (const l of Object.keys(r))
          if (!xc(i, l)) {
            s = !0;
            break;
          }
        return s ? i : r;
      }
    ), this.config = e, this.shouldAllowUnknownProperties = t;
  }
  allowUnknownProperties() {
    return new aE(this.config, !0);
  }
  /**
   * Extend an object validator by adding additional properties.
   *
   * @example
   *
   * ```ts
   * const animalValidator = T.object({
   * 	name: T.string,
   * })
   * const catValidator = animalValidator.extend({
   * 	meowVolume: T.number,
   * })
   * ```
   */
  extend(e) {
    return new aE({ ...this.config, ...e });
  }
}
class BE extends Hs {
  constructor(e, t, r, i) {
    super(
      (s) => {
        this.expectObject(s);
        const { matchingSchema: l, variant: c } = this.getMatchingSchemaAndVariant(s);
        return l === void 0 ? this.unknownValueValidation(s, c) : _a(`(${e} = ${c})`, () => l.validate(s));
      },
      (s, l) => {
        this.expectObject(l), this.expectObject(s);
        const { matchingSchema: c, variant: d } = this.getMatchingSchemaAndVariant(l);
        return c === void 0 ? this.unknownValueValidation(l, d) : ys(s, e) !== ys(l, e) ? _a(`(${e} = ${d})`, () => c.validate(l)) : _a(`(${e} = ${d})`, () => c.validateUsingKnownGoodVersion ? c.validateUsingKnownGoodVersion(s, l) : c.validate(l));
      }
    ), this.key = e, this.config = t, this.unknownValueValidation = r, this.useNumberKeys = i;
  }
  expectObject(e) {
    if (typeof e != "object" || e === null)
      throw new Fn(`Expected an object, got ${gh(e)}`, []);
  }
  getMatchingSchemaAndVariant(e) {
    const t = ys(e, this.key);
    if (!this.useNumberKeys && typeof t != "string")
      throw new Fn(
        `Expected a string for key "${this.key}", got ${gh(t)}`
      );
    if (this.useNumberKeys && !Number.isFinite(Number(t)))
      throw new Fn(`Expected a number for key "${this.key}", got "${t}"`);
    return { matchingSchema: xc(this.config, t) ? this.config[t] : void 0, variant: t };
  }
  validateUnknownVariants(e) {
    return new BE(this.key, this.config, e, this.useNumberKeys);
  }
}
class xre extends Hs {
  constructor(e, t) {
    super(
      (r) => {
        if (typeof r != "object" || r === null)
          throw new Fn(`Expected object, got ${gh(r)}`);
        for (const [i, s] of Object.entries(r))
          _a(i, () => {
            e.validate(i), t.validate(s);
          });
        return r;
      },
      (r, i) => {
        if (typeof i != "object" || i === null)
          throw new Fn(`Expected object, got ${gh(i)}`);
        let s = !1;
        for (const [l, c] of Object.entries(i)) {
          if (!xc(r, l)) {
            s = !0, _a(l, () => {
              e.validate(l), t.validate(c);
            });
            continue;
          }
          const d = ys(r, l), h = c;
          if (Object.is(d, h))
            continue;
          const g = _a(l, () => t.validateUsingKnownGoodVersion ? t.validateUsingKnownGoodVersion(d, h) : t.validate(h));
          Object.is(g, d) || (s = !0);
        }
        for (const l of Object.keys(r))
          if (!xc(i, l)) {
            s = !0;
            break;
          }
        return s ? i : r;
      }
    ), this.keyValidator = e, this.valueValidator = t;
  }
}
function cO(n) {
  return new Hs((e) => {
    if (typeof e !== n)
      throw new Fn(`Expected ${n}, got ${gh(e)}`);
    return e;
  });
}
const wre = new Hs((n) => n), sn = cO("string"), Ht = cO("number").check((n) => {
  if (Number.isNaN(n))
    throw new Fn("Expected a number, got NaN");
  if (!Number.isFinite(n))
    throw new Fn(`Expected a finite number, got ${n}`);
}), lE = Ht.check((n) => {
  if (n < 0) throw new Fn(`Expected a positive number, got ${n}`);
}), Pi = Ht.check((n) => {
  if (n <= 0) throw new Fn(`Expected a non-zero positive number, got ${n}`);
}), T6 = Ht.check((n) => {
  if (!Number.isInteger(n)) throw new Fn(`Expected an integer, got ${n}`);
}), vC = T6.check((n) => {
  if (n < 0) throw new Fn(`Expected a positive integer, got ${n}`);
}), bre = T6.check((n) => {
  if (n <= 0) throw new Fn(`Expected a non-zero positive integer, got ${n}`);
}), Tn = cO("boolean");
function xs(n) {
  return new Hs((e) => {
    if (e !== n)
      throw new Fn(`Expected ${n}, got ${JSON.stringify(e)}`);
    return n;
  });
}
const NF = new Hs((n) => {
  if (!Array.isArray(n))
    throw new Fn(`Expected an array, got ${gh(n)}`);
  return n;
});
function No(n) {
  return new Sre(n);
}
function kn(n) {
  return new aE(n);
}
function FA(n) {
  return typeof n == "object" && n !== null && (Object.getPrototypeOf(n) === Object.prototype || Object.getPrototypeOf(n) === null || Object.getPrototypeOf(n) === u6);
}
function zA(n) {
  return n === null || typeof n == "number" || typeof n == "string" || typeof n == "boolean" ? !0 : Array.isArray(n) ? n.every(zA) : FA(n) ? Object.values(n).every(zA) : !1;
}
const Fo = new Hs(
  (n) => {
    if (zA(n))
      return n;
    throw new Fn(`Expected json serializable value, got ${typeof n}`);
  },
  (n, e) => {
    if (Array.isArray(n) && Array.isArray(e)) {
      let t = n.length !== e.length;
      for (let r = 0; r < e.length; r++) {
        if (r >= n.length) {
          t = !0, Fo.validate(e[r]);
          continue;
        }
        const i = n[r], s = e[r];
        if (Object.is(i, s))
          continue;
        const l = Fo.validateUsingKnownGoodVersion(i, s);
        Object.is(l, i) || (t = !0);
      }
      return t ? e : n;
    } else if (FA(n) && FA(e)) {
      let t = !1;
      for (const r of Object.keys(e)) {
        if (!xc(n, r)) {
          t = !0, Fo.validate(e[r]);
          continue;
        }
        const i = n[r], s = e[r];
        if (Object.is(i, s))
          continue;
        const l = Fo.validateUsingKnownGoodVersion(i, s);
        Object.is(l, i) || (t = !0);
      }
      for (const r of Object.keys(n))
        if (!xc(e, r)) {
          t = !0;
          break;
        }
      return t ? e : n;
    } else
      return Fo.validate(e);
  }
);
function cE(n, e) {
  return new xre(n, e);
}
function uO(n, e) {
  return new BE(
    n,
    e,
    (t, r) => {
      throw new Fn(
        `Expected one of ${Object.keys(e).map((i) => JSON.stringify(i)).join(" or ")}, got ${JSON.stringify(r)}`,
        [n]
      );
    },
    !1
  );
}
function Cre(n, e) {
  return new BE(
    n,
    e,
    (t, r) => {
      throw new Fn(
        `Expected one of ${Object.keys(e).map((i) => JSON.stringify(i)).join(" or ")}, got ${JSON.stringify(r)}`,
        [n]
      );
    },
    !0
  );
}
function Ou(n, e) {
  return new Hs(
    (t) => _a(n, () => e.validate(t)),
    (t, r) => _a(n, () => e.validateUsingKnownGoodVersion ? e.validateUsingKnownGoodVersion(t, r) : e.validate(r))
  );
}
function HE(n) {
  return new Hs((e) => {
    if (!n.has(e)) {
      const t = Array.from(n, (r) => JSON.stringify(r)).join(" or ");
      throw new Fn(`Expected ${t}, got ${e}`);
    }
    return e;
  });
}
function I6(n) {
  return new Hs(
    (e) => {
      if (e !== void 0)
        return n.validate(e);
    },
    (e, t) => {
      if (!(e === void 0 && t === void 0) && t !== void 0)
        return n.validateUsingKnownGoodVersion && e !== void 0 ? n.validateUsingKnownGoodVersion(e, t) : n.validate(t);
    }
  );
}
function Ere(n) {
  return new Hs(
    (e) => e === null ? null : n.validate(e),
    (e, t) => t === null ? null : n.validateUsingKnownGoodVersion && e !== null ? n.validateUsingKnownGoodVersion(e, t) : n.validate(t)
  );
}
function VE(...n) {
  return HE(new Set(n));
}
function dO(n) {
  try {
    return new URL(n);
  } catch {
    if (n.startsWith("/") || n.startsWith("./"))
      try {
        return new URL(n, "http://example.com");
      } catch {
        throw new Fn(`Expected a valid url, got ${JSON.stringify(n)}`);
      }
    throw new Fn(`Expected a valid url, got ${JSON.stringify(n)}`);
  }
}
const _re = /* @__PURE__ */ new Set(["http:", "https:", "mailto:"]), tl = sn.check((n) => {
  if (n === "") return;
  const e = dO(n);
  if (!_re.has(e.protocol.toLowerCase()))
    throw new Fn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
}), Pre = /* @__PURE__ */ new Set(["http:", "https:", "data:", "asset:"]), Zp = sn.check((n) => {
  if (n === "") return;
  const e = dO(n);
  if (!Pre.has(e.protocol.toLowerCase()))
    throw new Fn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
});
sn.check((n) => {
  if (n === "") return;
  if (!dO(n).protocol.toLowerCase().match(/^https?:$/))
    throw new Fn(
      `Expected a valid url, got ${JSON.stringify(n)} (invalid protocol)`
    );
});
const fO = sn.refine((n) => {
  try {
    return une(n), n;
  } catch {
    throw new Fn(`Expected an index key, got ${JSON.stringify(n)}`);
  }
});
Au(
  "@tldraw/validate",
  "3.7.0",
  "esm"
);
function Qa(n) {
  return sn.refine((e) => {
    if (!e.startsWith(`${n}:`))
      throw new Error(`${n} ID must start with "${n}:"`);
    return e;
  });
}
const KE = Qa("asset");
function hO(n, e) {
  return kn({
    id: KE,
    typeName: xs("asset"),
    type: xs(n),
    props: e,
    meta: Fo
  });
}
const Qp = kn({
  x: Ht,
  y: Ht,
  z: Ht.optional()
}), Dx = kn({
  x: Ht,
  y: Ht,
  w: Ht,
  h: Ht
}), k6 = Ht.check((n) => {
  if (n < 0 || n > 1)
    throw new Fn("Opacity must be between 0 and 1");
}), Tre = sn.refine((n) => {
  if (!n.startsWith("page:") && !n.startsWith("shape:"))
    throw new Error('Parent ID must start with "page:" or "shape:"');
  return n;
}), Il = Qa("shape");
function Ire(n, e, t) {
  return kn({
    id: Il,
    typeName: xs("shape"),
    x: Ht,
    y: Ht,
    rotation: Ht,
    index: fO,
    parentId: Tre,
    type: xs(n),
    isLocked: Tn,
    opacity: k6,
    props: e ? kn(e) : Fo,
    meta: t ? kn(t) : Fo
  });
}
const kre = Qa("binding");
function Rre(n, e, t) {
  return kn({
    id: kre,
    typeName: xs("binding"),
    type: xs(n),
    fromId: Il,
    toId: Il,
    props: e ? kn(e) : Fo,
    meta: t ? kn(t) : Fo
  });
}
Pa("com.tldraw.binding", {});
il({
  sequenceId: "com.tldraw.binding",
  recordType: "binding",
  sequence: []
});
function qp(n) {
  return `binding:${or()}`;
}
function Mre(n) {
  return Du("binding", {
    scope: "document",
    validator: Ou(
      "binding",
      uO(
        "type",
        lw(
          n,
          (e, { props: t, meta: r }) => Rre(e, t, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    meta: {}
  }));
}
class Bo {
  /** @internal */
  constructor(e, t, r) {
    this.id = e, this.defaultValue = t, this.type = r;
  }
  /**
   * Define a new {@link StyleProp}.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `type`: Optionally, describe what type of data you expect for this style prop.
   *
   * @example
   * ```ts
   * import {T} from '@tldraw/validate'
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MyLineWidthProp = StyleProp.define('myApp:lineWidth', {
   *   defaultValue: 1,
   *   type: T.number,
   * })
   * ```
   * @public
   */
  static define(e, t) {
    const { defaultValue: r, type: i = wre } = t;
    return new Bo(e, r, i);
  }
  /**
   * Define a new {@link StyleProp} as a list of possible values.
   *
   * @param uniqueId - Each StyleProp must have a unique ID. We recommend you prefix this with
   * your app/library name.
   * @param options -
   * - `defaultValue`: The default value for this style prop.
   *
   * - `values`: An array of possible values of this style prop.
   *
   * @example
   * ```ts
   * import {StyleProp} from '@tldraw/tlschema'
   *
   * const MySizeProp = StyleProp.defineEnum('myApp:size', {
   *   defaultValue: 'medium',
   *   values: ['small', 'medium', 'large'],
   * })
   * ```
   */
  static defineEnum(e, t) {
    const { defaultValue: r, values: i } = t;
    return new Are(e, r, i);
  }
  setDefaultValue(e) {
    this.defaultValue = e;
  }
  validate(e) {
    return this.type.validate(e);
  }
  validateUsingKnownGoodVersion(e, t) {
    return this.type.validateUsingKnownGoodVersion ? this.type.validateUsingKnownGoodVersion(e, t) : this.validate(t);
  }
}
class Are extends Bo {
  /** @internal */
  constructor(e, t, r) {
    super(e, t, VE(...r)), this.values = r;
  }
}
const O1 = Pa("com.tldraw.shape", {
  AddIsLocked: 1,
  HoistOpacity: 2,
  AddMeta: 3,
  AddWhite: 4
}), Dre = il({
  sequenceId: "com.tldraw.shape",
  recordType: "shape",
  sequence: [
    {
      id: O1.AddIsLocked,
      up: (n) => {
        n.isLocked = !1;
      },
      down: (n) => {
        delete n.isLocked;
      }
    },
    {
      id: O1.HoistOpacity,
      up: (n) => {
        n.opacity = Number(n.props.opacity ?? "1"), delete n.props.opacity;
      },
      down: (n) => {
        const e = n.opacity;
        delete n.opacity, n.props.opacity = e < 0.175 ? "0.1" : e < 0.375 ? "0.25" : e < 0.625 ? "0.5" : e < 0.875 ? "0.75" : "1";
      }
    },
    {
      id: O1.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: O1.AddWhite,
      up: (n) => {
      },
      down: (n) => {
        n.props.color === "white" && (n.props.color = "black");
      }
    }
  ]
});
function vy(n) {
  return n ? n.typeName === "shape" : !1;
}
function va(n) {
  return n ? n.startsWith("shape:") : !1;
}
function Sr(n) {
  return `shape:${n ?? or()}`;
}
function R6(n) {
  const e = /* @__PURE__ */ new Map();
  for (const [t, r] of Object.entries(n))
    if (r instanceof Bo) {
      if (e.has(r))
        throw new Error(
          `Duplicate style prop ${r.id}. Each style prop can only be used once within a shape.`
        );
      e.set(r, t);
    }
  return e;
}
function Ic(n, e) {
  return lw(e, (t, r) => `com.tldraw.shape.${n}/${r}`);
}
function Ore(n) {
  return Du("shape", {
    scope: "document",
    validator: Ou(
      "shape",
      uO(
        "type",
        lw(
          n,
          (e, { props: t, meta: r }) => Ire(e, t, r)
        )
      )
    )
  }).withDefaultProperties(() => ({
    x: 0,
    y: 0,
    rotation: 0,
    isLocked: !1,
    opacity: 1,
    meta: {}
  }));
}
function FF(n, e) {
  const t = [];
  for (const [r, { migrations: i }] of Object.entries(e)) {
    const s = `com.tldraw.${n}.${r}`;
    i ? "sequenceId" in i ? (on(
      s === i.sequenceId,
      `sequenceId mismatch for ${r} ${UE} migrations. Expected '${s}', got '${i.sequenceId}'`
    ), t.push(i)) : "sequence" in i ? t.push(
      Cy({
        sequenceId: s,
        retroactive: !1,
        sequence: i.sequence.map(
          (l) => "id" in l ? M6(n, r, l) : l
        )
      })
    ) : t.push(
      Cy({
        sequenceId: s,
        retroactive: !1,
        sequence: Object.keys(i.migrators).map((l) => Number(l)).sort((l, c) => l - c).map(
          (l) => ({
            id: `${s}/${l}`,
            scope: "record",
            filter: (c) => c.typeName === n && c.type === r,
            up: (c) => {
              const d = i.migrators[l].up(c);
              if (d)
                return d;
            },
            down: (c) => {
              const d = i.migrators[l].down(c);
              if (d)
                return d;
            }
          })
        )
      })
    ) : t.push(
      Cy({
        sequenceId: s,
        retroactive: !1,
        sequence: []
      })
    );
  }
  return t;
}
function M6(n, e, t) {
  return {
    id: t.id,
    dependsOn: t.dependsOn,
    scope: "record",
    filter: (r) => r.typeName === n && r.type === e,
    up: (r) => {
      const i = t.up(r.props);
      i && (r.props = i);
    },
    down: typeof t.down == "function" ? (r) => {
      const i = t.down(r.props);
      i && (r.props = i);
    } : void 0
  };
}
const A6 = [
  "black",
  "grey",
  "light-violet",
  "violet",
  "blue",
  "light-blue",
  "yellow",
  "orange",
  "green",
  "light-green",
  "light-red",
  "red",
  "white"
], uE = {
  lightMode: {
    id: "light",
    text: "#000000",
    background: "rgb(249, 250, 251)",
    solid: "#fcfffe",
    black: {
      solid: "#1d1d1d",
      fill: "#1d1d1d",
      note: {
        fill: "#FCE19C",
        text: "#000000"
      },
      semi: "#e8e8e8",
      pattern: "#494949",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    blue: {
      solid: "#4465e9",
      fill: "#4465e9",
      note: {
        fill: "#8AA3FF",
        text: "#000000"
      },
      semi: "#dce1f8",
      pattern: "#6681ee",
      highlight: {
        srgb: "#10acff",
        p3: "color(display-p3 0.308 0.6632 0.9996)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      note: {
        fill: "#6FC896",
        text: "#000000"
      },
      semi: "#d3e9e3",
      pattern: "#39a785",
      highlight: {
        srgb: "#00ffc8",
        p3: "color(display-p3 0.2536 0.984 0.7981)"
      }
    },
    grey: {
      solid: "#9fa8b2",
      fill: "#9fa8b2",
      note: {
        fill: "#C0CAD3",
        text: "#000000"
      },
      semi: "#eceef0",
      pattern: "#bcc3c9",
      highlight: {
        srgb: "#cbe7f1",
        p3: "color(display-p3 0.8163 0.9023 0.9416)"
      }
    },
    "light-blue": {
      solid: "#4ba1f1",
      fill: "#4ba1f1",
      note: {
        fill: "#9BC4FD",
        text: "#000000"
      },
      semi: "#ddedfa",
      pattern: "#6fbbf8",
      highlight: {
        srgb: "#00f4ff",
        p3: "color(display-p3 0.1512 0.9414 0.9996)"
      }
    },
    "light-green": {
      solid: "#4cb05e",
      fill: "#4cb05e",
      note: {
        fill: "#98D08A",
        text: "#000000"
      },
      semi: "#dbf0e0",
      pattern: "#65cb78",
      highlight: {
        srgb: "#65f641",
        p3: "color(display-p3 0.563 0.9495 0.3857)"
      }
    },
    "light-red": {
      solid: "#f87777",
      fill: "#f87777",
      note: {
        fill: "#F7A5A1",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#fe9e9e",
      highlight: {
        srgb: "#ff7fa3",
        p3: "color(display-p3 0.9988 0.5301 0.6397)"
      }
    },
    "light-violet": {
      solid: "#e085f4",
      fill: "#e085f4",
      note: {
        fill: "#DFB0F9",
        text: "#000000"
      },
      semi: "#f5eafa",
      pattern: "#e9acf8",
      highlight: {
        srgb: "#ff88ff",
        p3: "color(display-p3 0.9676 0.5652 0.9999)"
      }
    },
    orange: {
      solid: "#e16919",
      fill: "#e16919",
      note: {
        fill: "#FAA475",
        text: "#000000"
      },
      semi: "#f8e2d4",
      pattern: "#f78438",
      highlight: {
        srgb: "#ffa500",
        p3: "color(display-p3 0.9988 0.6905 0.266)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      note: {
        fill: "#FC8282",
        text: "#000000"
      },
      semi: "#f4dadb",
      pattern: "#e55959",
      highlight: {
        srgb: "#ff636e",
        p3: "color(display-p3 0.9992 0.4376 0.45)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      note: {
        fill: "#DB91FD",
        text: "#000000"
      },
      semi: "#ecdcf2",
      pattern: "#bd63d3",
      highlight: {
        srgb: "#c77cff",
        p3: "color(display-p3 0.7469 0.5089 0.9995)"
      }
    },
    yellow: {
      solid: "#f1ac4b",
      fill: "#f1ac4b",
      note: {
        fill: "#FED49A",
        text: "#000000"
      },
      semi: "#f9f0e6",
      pattern: "#fecb92",
      highlight: {
        srgb: "#fddd00",
        p3: "color(display-p3 0.972 0.8705 0.05)"
      }
    },
    white: {
      solid: "#FFFFFF",
      fill: "#FFFFFF",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      note: {
        fill: "#FFFFFF",
        text: "#000000"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  },
  darkMode: {
    id: "dark",
    text: "hsl(210, 17%, 98%)",
    background: "hsl(240, 5%, 6.5%)",
    solid: "#010403",
    black: {
      solid: "#f2f2f2",
      fill: "#f2f2f2",
      note: {
        fill: "#2c2c2c",
        text: "#f2f2f2"
      },
      semi: "#2c3036",
      pattern: "#989898",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    blue: {
      solid: "#4f72fc",
      // 3c60f0
      fill: "#4f72fc",
      note: {
        fill: "#2A3F98",
        text: "#f2f2f2"
      },
      semi: "#262d40",
      pattern: "#3a4b9e",
      highlight: {
        srgb: "#0079d2",
        p3: "color(display-p3 0.0032 0.4655 0.7991)"
      }
    },
    green: {
      solid: "#099268",
      fill: "#099268",
      note: {
        fill: "#014429",
        text: "#f2f2f2"
      },
      semi: "#253231",
      pattern: "#366a53",
      highlight: {
        srgb: "#009774",
        p3: "color(display-p3 0.0085 0.582 0.4604)"
      }
    },
    grey: {
      solid: "#9398b0",
      fill: "#9398b0",
      note: {
        fill: "#56595F",
        text: "#f2f2f2"
      },
      semi: "#33373c",
      pattern: "#7c8187",
      highlight: {
        srgb: "#9cb4cb",
        p3: "color(display-p3 0.6299 0.7012 0.7856)"
      }
    },
    "light-blue": {
      solid: "#4dabf7",
      fill: "#4dabf7",
      note: {
        fill: "#1F5495",
        text: "#f2f2f2"
      },
      semi: "#2a3642",
      pattern: "#4d7aa9",
      highlight: {
        srgb: "#00bdc8",
        p3: "color(display-p3 0.0023 0.7259 0.7735)"
      }
    },
    "light-green": {
      solid: "#40c057",
      fill: "#40c057",
      note: {
        fill: "#21581D",
        text: "#f2f2f2"
      },
      semi: "#2a3830",
      pattern: "#4e874e",
      highlight: {
        srgb: "#00a000",
        p3: "color(display-p3 0.2711 0.6172 0.0195)"
      }
    },
    "light-red": {
      solid: "#ff8787",
      fill: "#ff8787",
      note: {
        fill: "#923632",
        text: "#f2f2f2"
      },
      semi: "#3b3235",
      pattern: "#a56767",
      highlight: {
        srgb: "#db005b",
        p3: "color(display-p3 0.7849 0.0585 0.3589)"
      }
    },
    "light-violet": {
      solid: "#e599f7",
      fill: "#e599f7",
      note: {
        fill: "#762F8E",
        text: "#f2f2f2"
      },
      semi: "#383442",
      pattern: "#9770a9",
      highlight: {
        srgb: "#c400c7",
        p3: "color(display-p3 0.7024 0.0403 0.753)"
      }
    },
    orange: {
      solid: "#f76707",
      fill: "#f76707",
      note: {
        fill: "#843906",
        text: "#f2f2f2"
      },
      semi: "#3a2e2a",
      pattern: "#9f552d",
      highlight: {
        srgb: "#d07a00",
        p3: "color(display-p3 0.7699 0.4937 0.0085)"
      }
    },
    red: {
      solid: "#e03131",
      fill: "#e03131",
      note: {
        fill: "#89231A",
        text: "#f2f2f2"
      },
      semi: "#36292b",
      pattern: "#8f3734",
      highlight: {
        srgb: "#de002c",
        p3: "color(display-p3 0.7978 0.0509 0.2035)"
      }
    },
    violet: {
      solid: "#ae3ec9",
      fill: "#ae3ec9",
      note: {
        fill: "#681683",
        text: "#f2f2f2"
      },
      semi: "#31293c",
      pattern: "#763a8b",
      highlight: {
        srgb: "#9e00ee",
        p3: "color(display-p3 0.5651 0.0079 0.8986)"
      }
    },
    yellow: {
      solid: "#ffc034",
      fill: "#ffc034",
      note: {
        fill: "#98571B",
        text: "#f2f2f2"
      },
      semi: "#3c3934",
      pattern: "#fecb92",
      highlight: {
        srgb: "#d2b700",
        p3: "color(display-p3 0.8078 0.7225 0.0312)"
      }
    },
    white: {
      solid: "#f3f3f3",
      fill: "#f3f3f3",
      semi: "#f5f5f5",
      pattern: "#f9f9f9",
      note: {
        fill: "#eaeaea",
        text: "#1d1d1d"
      },
      highlight: {
        srgb: "#ffffff",
        p3: "color(display-p3 1 1 1)"
      }
    }
  }
};
function Wd(n) {
  return n.isDarkMode ? uE.darkMode : uE.lightMode;
}
const nl = Bo.defineEnum("tldraw:color", {
  defaultValue: "black",
  values: A6
}), pO = Bo.defineEnum("tldraw:labelColor", {
  defaultValue: "black",
  values: A6
}), Jp = Bo.defineEnum("tldraw:dash", {
  defaultValue: "draw",
  values: ["draw", "solid", "dashed", "dotted"]
}), eg = Bo.defineEnum("tldraw:fill", {
  defaultValue: "none",
  values: ["none", "semi", "solid", "pattern", "fill"]
}), _u = Bo.defineEnum("tldraw:font", {
  defaultValue: "draw",
  values: ["draw", "sans", "serif", "mono"]
}), D6 = {
  draw: "'tldraw_draw', sans-serif",
  sans: "'tldraw_sans', sans-serif",
  serif: "'tldraw_serif', serif",
  mono: "'tldraw_mono', monospace"
}, Pu = Bo.defineEnum("tldraw:size", {
  defaultValue: "m",
  values: ["s", "m", "l", "xl"]
}), O6 = [
  "arrow",
  "triangle",
  "square",
  "dot",
  "pipe",
  "diamond",
  "inverted",
  "bar",
  "none"
], dE = Bo.defineEnum("tldraw:arrowheadStart", {
  defaultValue: "none",
  values: O6
}), fE = Bo.defineEnum("tldraw:arrowheadEnd", {
  defaultValue: "arrow",
  values: O6
}), j6 = {
  labelColor: pO,
  color: nl,
  fill: eg,
  dash: Jp,
  size: Pu,
  arrowheadStart: dE,
  arrowheadEnd: fE,
  font: _u,
  start: Qp,
  end: Qp,
  bend: Ht,
  text: sn,
  labelPosition: Ht,
  scale: Pi
}, py = Ic("arrow", {
  AddLabelColor: 1,
  AddIsPrecise: 2,
  AddLabelPosition: 3,
  ExtractBindings: 4,
  AddScale: 5
});
function j1(n) {
  return M6("shape", "arrow", n);
}
const L6 = Cy({
  sequenceId: "com.tldraw.shape.arrow",
  retroactive: !1,
  sequence: [
    j1({
      id: py.AddLabelColor,
      up: (n) => {
        n.labelColor = "black";
      },
      down: "retired"
    }),
    j1({
      id: py.AddIsPrecise,
      up: ({ start: n, end: e }) => {
        n.type === "binding" && (n.isPrecise = !(n.normalizedAnchor.x === 0.5 && n.normalizedAnchor.y === 0.5)), e.type === "binding" && (e.isPrecise = !(e.normalizedAnchor.x === 0.5 && e.normalizedAnchor.y === 0.5));
      },
      down: ({ start: n, end: e }) => {
        n.type === "binding" && (n.isPrecise || (n.normalizedAnchor = { x: 0.5, y: 0.5 }), delete n.isPrecise), e.type === "binding" && (e.isPrecise || (e.normalizedAnchor = { x: 0.5, y: 0.5 }), delete e.isPrecise);
      }
    }),
    j1({
      id: py.AddLabelPosition,
      up: (n) => {
        n.labelPosition = 0.5;
      },
      down: (n) => {
        delete n.labelPosition;
      }
    }),
    {
      id: py.ExtractBindings,
      scope: "store",
      up: (n) => {
        const e = Object.values(n).filter(
          (t) => t.typeName === "shape" && t.type === "arrow"
        );
        for (const t of e) {
          const { start: r, end: i } = t.props;
          if (r.type === "binding") {
            const s = qp(), l = {
              typeName: "binding",
              id: s,
              type: "arrow",
              fromId: t.id,
              toId: r.boundShapeId,
              meta: {},
              props: {
                terminal: "start",
                normalizedAnchor: r.normalizedAnchor,
                isExact: r.isExact,
                isPrecise: r.isPrecise
              }
            };
            n[s] = l, t.props.start = { x: 0, y: 0 };
          } else
            delete t.props.start.type;
          if (i.type === "binding") {
            const s = qp(), l = {
              typeName: "binding",
              id: s,
              type: "arrow",
              fromId: t.id,
              toId: i.boundShapeId,
              meta: {},
              props: {
                terminal: "end",
                normalizedAnchor: i.normalizedAnchor,
                isExact: i.isExact,
                isPrecise: i.isPrecise
              }
            };
            n[s] = l, t.props.end = { x: 0, y: 0 };
          } else
            delete t.props.end.type;
        }
      }
    },
    j1({
      id: py.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    })
  ]
}), N6 = {
  terminal: VE("start", "end"),
  normalizedAnchor: Qp,
  isExact: Tn,
  isPrecise: Tn
}, F6 = {
  sequence: [{ dependsOn: [py.ExtractBindings] }]
}, jre = Ou(
  "camera",
  kn({
    typeName: xs("camera"),
    id: Qa("camera"),
    x: Ht,
    y: Ht,
    z: Ht,
    meta: Fo
  })
), Lre = Pa("com.tldraw.camera", {
  AddMeta: 1
}), Nre = il({
  sequenceId: "com.tldraw.camera",
  recordType: "camera",
  sequence: [
    {
      id: Lre.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), vc = Du("camera", {
  validator: jre,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    z: 1,
    meta: {}
  })
), Fre = /* @__PURE__ */ new Set([
  "none",
  "default",
  "pointer",
  "cross",
  "grab",
  "rotate",
  "grabbing",
  "resize-edge",
  "resize-corner",
  "text",
  "move",
  "ew-resize",
  "ns-resize",
  "nesw-resize",
  "nwse-resize",
  "nesw-rotate",
  "nwse-rotate",
  "swne-rotate",
  "senw-rotate",
  "zoom-in",
  "zoom-out"
]), z6 = HE(Fre), zre = kn({
  type: z6,
  rotation: Ht
}), Ure = /* @__PURE__ */ new Set([
  "accent",
  "white",
  "black",
  "selection-stroke",
  "selection-fill",
  "laser",
  "muted-1"
]), $re = HE(Ure), Bre = /* @__PURE__ */ new Set(["starting", "paused", "active", "stopping"]), U6 = kn({
  id: sn,
  points: No(Qp),
  size: lE,
  color: $re,
  opacity: Ht,
  state: HE(Bre),
  delay: Ht,
  shrink: Ht,
  taper: Tn
}), Wx = Qa("page"), Hre = Ou(
  "page",
  kn({
    typeName: xs("page"),
    id: Wx,
    name: sn,
    index: fO,
    meta: Fo
  })
), Vre = Pa("com.tldraw.page", {
  AddMeta: 1
}), Kre = il({
  sequenceId: "com.tldraw.page",
  recordType: "page",
  sequence: [
    {
      id: Vre.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), rl = Du("page", {
  validator: Hre,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
}));
function ga(n) {
  return rl.isId(n);
}
const Wre = {
  // This object defines keys that should be preserved across calls to loadSnapshot()
  id: !1,
  // meta
  typeName: !1,
  // meta
  currentPageId: !1,
  // does not preserve because who knows if the page still exists
  opacityForNextShape: !1,
  // does not preserve because it's a temporary state
  stylesForNextShape: !1,
  // does not preserve because it's a temporary state
  followingUserId: !1,
  // does not preserve because it's a temporary state
  highlightedUserIds: !1,
  // does not preserve because it's a temporary state
  brush: !1,
  // does not preserve because it's a temporary state
  cursor: !1,
  // does not preserve because it's a temporary state
  scribbles: !1,
  // does not preserve because it's a temporary state
  isFocusMode: !0,
  // preserves because it's a user preference
  isDebugMode: !0,
  // preserves because it's a user preference
  isToolLocked: !0,
  // preserves because it's a user preference
  exportBackground: !0,
  // preserves because it's a user preference
  screenBounds: !0,
  // preserves because it's capturing the user's screen state
  insets: !0,
  // preserves because it's capturing the user's screen state
  zoomBrush: !1,
  // does not preserve because it's a temporary state
  chatMessage: !1,
  // does not preserve because it's a temporary state
  isChatting: !1,
  // does not preserve because it's a temporary state
  isPenMode: !1,
  // does not preserve because it's a temporary state
  isGridMode: !0,
  // preserves because it's a user preference
  isFocused: !0,
  // preserves because obviously
  devicePixelRatio: !0,
  // preserves because it captures the user's screen state
  isCoarsePointer: !0,
  // preserves because it captures the user's screen state
  isHoveringCanvas: !1,
  // does not preserve because it's a temporary state
  openMenus: !1,
  // does not preserve because it's a temporary state
  isChangingStyle: !1,
  // does not preserve because it's a temporary state
  isReadonly: !0,
  // preserves because it's a config option
  meta: !1,
  // does not preserve because who knows what's in there, leave it up to sdk users to save and reinstate
  duplicateProps: !1
  //
};
function $6(n) {
  return n ? Rx(n, (e) => Wre[e]) : null;
}
Qa("instance");
function Gre(n) {
  const e = {};
  for (const [r, i] of n)
    e[r] = I6(i);
  const t = Ou(
    "instance",
    kn({
      typeName: xs("instance"),
      id: Qa("instance"),
      currentPageId: Wx,
      followingUserId: sn.nullable(),
      brush: Dx.nullable(),
      opacityForNextShape: k6,
      stylesForNextShape: kn(e),
      cursor: zre,
      scribbles: No(U6),
      isFocusMode: Tn,
      isDebugMode: Tn,
      isToolLocked: Tn,
      exportBackground: Tn,
      screenBounds: Dx,
      insets: No(Tn),
      zoomBrush: Dx.nullable(),
      isPenMode: Tn,
      isGridMode: Tn,
      chatMessage: sn,
      isChatting: Tn,
      highlightedUserIds: No(sn),
      isFocused: Tn,
      devicePixelRatio: Ht,
      isCoarsePointer: Tn,
      isHoveringCanvas: Tn.nullable(),
      openMenus: No(sn),
      isChangingStyle: Tn,
      isReadonly: Tn,
      meta: Fo,
      duplicateProps: kn({
        shapeIds: No(Qa("shape")),
        offset: kn({
          x: Ht,
          y: Ht
        })
      }).nullable()
    })
  );
  return Du("instance", {
    validator: t,
    scope: "session",
    ephemeralKeys: {
      currentPageId: !1,
      meta: !1,
      followingUserId: !0,
      opacityForNextShape: !0,
      stylesForNextShape: !0,
      brush: !0,
      cursor: !0,
      scribbles: !0,
      isFocusMode: !0,
      isDebugMode: !0,
      isToolLocked: !0,
      exportBackground: !0,
      screenBounds: !0,
      insets: !0,
      zoomBrush: !0,
      isPenMode: !0,
      isGridMode: !0,
      chatMessage: !0,
      isChatting: !0,
      highlightedUserIds: !0,
      isFocused: !0,
      devicePixelRatio: !0,
      isCoarsePointer: !0,
      isHoveringCanvas: !0,
      openMenus: !0,
      isChangingStyle: !0,
      isReadonly: !0,
      duplicateProps: !0
    }
  }).withDefaultProperties(
    () => ({
      followingUserId: null,
      opacityForNextShape: 1,
      stylesForNextShape: {},
      brush: null,
      scribbles: [],
      cursor: {
        type: "default",
        rotation: 0
      },
      isFocusMode: !1,
      exportBackground: !1,
      isDebugMode: !1,
      isToolLocked: !1,
      screenBounds: { x: 0, y: 0, w: 1080, h: 720 },
      insets: [!1, !1, !1, !1],
      zoomBrush: null,
      isGridMode: !1,
      isPenMode: !1,
      chatMessage: "",
      isChatting: !1,
      highlightedUserIds: [],
      isFocused: !1,
      devicePixelRatio: typeof window > "u" ? 1 : window.devicePixelRatio,
      isCoarsePointer: !1,
      isHoveringCanvas: null,
      openMenus: [],
      isChangingStyle: !1,
      isReadonly: !1,
      meta: {},
      duplicateProps: null
    })
  );
}
const zr = Pa("com.tldraw.instance", {
  AddTransparentExportBgs: 1,
  RemoveDialog: 2,
  AddToolLockMode: 3,
  RemoveExtraPropsForNextShape: 4,
  AddLabelColor: 5,
  AddFollowingUserId: 6,
  RemoveAlignJustify: 7,
  AddZoom: 8,
  AddVerticalAlign: 9,
  AddScribbleDelay: 10,
  RemoveUserId: 11,
  AddIsPenModeAndIsGridMode: 12,
  HoistOpacity: 13,
  AddChat: 14,
  AddHighlightedUserIds: 15,
  ReplacePropsForNextShapeWithStylesForNextShape: 16,
  AddMeta: 17,
  RemoveCursorColor: 18,
  AddLonelyProperties: 19,
  ReadOnlyReadonly: 20,
  AddHoveringCanvas: 21,
  AddScribbles: 22,
  AddInset: 23,
  AddDuplicateProps: 24,
  RemoveCanMoveCamera: 25
}), qre = il({
  sequenceId: "com.tldraw.instance",
  recordType: "instance",
  sequence: [
    {
      id: zr.AddTransparentExportBgs,
      up: (n) => ({ ...n, exportBackground: !0 })
    },
    {
      id: zr.RemoveDialog,
      up: ({ dialog: n, ...e }) => e
    },
    {
      id: zr.AddToolLockMode,
      up: (n) => ({ ...n, isToolLocked: !1 })
    },
    {
      id: zr.RemoveExtraPropsForNextShape,
      up: ({ propsForNextShape: n, ...e }) => ({
        ...e,
        propsForNextShape: Object.fromEntries(
          Object.entries(n).filter(
            ([t]) => [
              "color",
              "labelColor",
              "dash",
              "fill",
              "size",
              "font",
              "align",
              "verticalAlign",
              "icon",
              "geo",
              "arrowheadStart",
              "arrowheadEnd",
              "spline"
            ].includes(t)
          )
        )
      })
    },
    {
      id: zr.AddLabelColor,
      up: ({ propsForNextShape: n, ...e }) => ({
        ...e,
        propsForNextShape: {
          ...n,
          labelColor: "black"
        }
      })
    },
    {
      id: zr.AddFollowingUserId,
      up: (n) => ({ ...n, followingUserId: null })
    },
    {
      id: zr.RemoveAlignJustify,
      up: (n) => {
        let e = n.propsForNextShape.align;
        return e === "justify" && (e = "start"), {
          ...n,
          propsForNextShape: {
            ...n.propsForNextShape,
            align: e
          }
        };
      }
    },
    {
      id: zr.AddZoom,
      up: (n) => ({ ...n, zoomBrush: null })
    },
    {
      id: zr.AddVerticalAlign,
      up: (n) => ({
        ...n,
        propsForNextShape: {
          ...n.propsForNextShape,
          verticalAlign: "middle"
        }
      })
    },
    {
      id: zr.AddScribbleDelay,
      up: (n) => n.scribble !== null ? { ...n, scribble: { ...n.scribble, delay: 0 } } : { ...n }
    },
    {
      id: zr.RemoveUserId,
      up: ({ userId: n, ...e }) => e
    },
    {
      id: zr.AddIsPenModeAndIsGridMode,
      up: (n) => ({ ...n, isPenMode: !1, isGridMode: !1 })
    },
    {
      id: zr.HoistOpacity,
      up: ({ propsForNextShape: { opacity: n, ...e }, ...t }) => ({ ...t, opacityForNextShape: Number(n ?? "1"), propsForNextShape: e })
    },
    {
      id: zr.AddChat,
      up: (n) => ({ ...n, chatMessage: "", isChatting: !1 })
    },
    {
      id: zr.AddHighlightedUserIds,
      up: (n) => ({ ...n, highlightedUserIds: [] })
    },
    {
      id: zr.ReplacePropsForNextShapeWithStylesForNextShape,
      up: ({ propsForNextShape: n, ...e }) => ({ ...e, stylesForNextShape: {} })
    },
    {
      id: zr.AddMeta,
      up: (n) => ({
        ...n,
        meta: {}
      })
    },
    {
      id: zr.RemoveCursorColor,
      up: (n) => {
        const { color: e, ...t } = n.cursor;
        return {
          ...n,
          cursor: t
        };
      }
    },
    {
      id: zr.AddLonelyProperties,
      up: (n) => ({
        ...n,
        canMoveCamera: !0,
        isFocused: !1,
        devicePixelRatio: 1,
        isCoarsePointer: !1,
        openMenus: [],
        isChangingStyle: !1,
        isReadOnly: !1
      })
    },
    {
      id: zr.ReadOnlyReadonly,
      up: ({ isReadOnly: n, ...e }) => ({
        ...e,
        isReadonly: n
      })
    },
    {
      id: zr.AddHoveringCanvas,
      up: (n) => ({
        ...n,
        isHoveringCanvas: null
      })
    },
    {
      id: zr.AddScribbles,
      up: ({ scribble: n, ...e }) => ({
        ...e,
        scribbles: []
      })
    },
    {
      id: zr.AddInset,
      up: (n) => ({
        ...n,
        insets: [!1, !1, !1, !1]
      }),
      down: ({ insets: n, ...e }) => ({
        ...e
      })
    },
    {
      id: zr.AddDuplicateProps,
      up: (n) => ({
        ...n,
        duplicateProps: null
      }),
      down: ({ duplicateProps: n, ...e }) => ({
        ...e
      })
    },
    {
      id: zr.RemoveCanMoveCamera,
      up: ({ canMoveCamera: n, ...e }) => ({
        ...e
      }),
      down: (n) => ({ ...n, canMoveCamera: !0 })
    }
  ]
}), hs = "instance:instance", Yre = Ou(
  "instance_page_state",
  kn({
    typeName: xs("instance_page_state"),
    id: Qa("instance_page_state"),
    pageId: Wx,
    selectedShapeIds: No(Il),
    hintingShapeIds: No(Il),
    erasingShapeIds: No(Il),
    hoveredShapeId: Il.nullable(),
    editingShapeId: Il.nullable(),
    croppingShapeId: Il.nullable(),
    focusedGroupId: Il.nullable(),
    meta: Fo
  })
), tx = Pa("com.tldraw.instance_page_state", {
  AddCroppingId: 1,
  RemoveInstanceIdAndCameraId: 2,
  AddMeta: 3,
  RenameProperties: 4,
  RenamePropertiesAgain: 5
}), Xre = il({
  sequenceId: "com.tldraw.instance_page_state",
  recordType: "instance_page_state",
  sequence: [
    {
      id: tx.AddCroppingId,
      up(n) {
        n.croppingShapeId = null;
      }
    },
    {
      id: tx.RemoveInstanceIdAndCameraId,
      up(n) {
        delete n.instanceId, delete n.cameraId;
      }
    },
    {
      id: tx.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: tx.RenameProperties,
      // this migration is cursed: it was written wrong and doesn't do anything.
      // rather than replace it, I've added another migration below that fixes it.
      up: (n) => {
      },
      down: (n) => {
      }
    },
    {
      id: tx.RenamePropertiesAgain,
      up: (n) => {
        n.selectedShapeIds = n.selectedIds, delete n.selectedIds, n.hintingShapeIds = n.hintingIds, delete n.hintingIds, n.erasingShapeIds = n.erasingIds, delete n.erasingIds, n.hoveredShapeId = n.hoveredId, delete n.hoveredId, n.editingShapeId = n.editingId, delete n.editingId, n.croppingShapeId = n.croppingShapeId ?? n.croppingId ?? null, delete n.croppingId, n.focusedGroupId = n.focusLayerId, delete n.focusLayerId;
      },
      down: (n) => {
        n.selectedIds = n.selectedShapeIds, delete n.selectedShapeIds, n.hintingIds = n.hintingShapeIds, delete n.hintingShapeIds, n.erasingIds = n.erasingShapeIds, delete n.erasingShapeIds, n.hoveredId = n.hoveredShapeId, delete n.hoveredShapeId, n.editingId = n.editingShapeId, delete n.editingShapeId, n.croppingId = n.croppingShapeId, delete n.croppingShapeId, n.focusLayerId = n.focusedGroupId, delete n.focusedGroupId;
      }
    }
  ]
}), Ml = Du(
  "instance_page_state",
  {
    validator: Yre,
    scope: "session",
    ephemeralKeys: {
      pageId: !1,
      selectedShapeIds: !1,
      editingShapeId: !1,
      croppingShapeId: !1,
      meta: !1,
      hintingShapeIds: !0,
      erasingShapeIds: !0,
      hoveredShapeId: !0,
      focusedGroupId: !0
    }
  }
).withDefaultProperties(
  () => ({
    editingShapeId: null,
    croppingShapeId: null,
    selectedShapeIds: [],
    hoveredShapeId: null,
    erasingShapeIds: [],
    hintingShapeIds: [],
    focusedGroupId: null,
    meta: {}
  })
), Zre = Ou(
  "pointer",
  kn({
    typeName: xs("pointer"),
    id: Qa("pointer"),
    x: Ht,
    y: Ht,
    lastActivityTimestamp: Ht,
    meta: Fo
  })
), Qre = Pa("com.tldraw.pointer", {
  AddMeta: 1
}), Jre = il({
  sequenceId: "com.tldraw.pointer",
  recordType: "pointer",
  sequence: [
    {
      id: Qre.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), gO = Du("pointer", {
  validator: Zre,
  scope: "session"
}).withDefaultProperties(
  () => ({
    x: 0,
    y: 0,
    lastActivityTimestamp: 0,
    meta: {}
  })
), Gx = gO.createId("pointer"), eie = Ou(
  "instance_presence",
  kn({
    typeName: xs("instance_presence"),
    id: Qa("instance_presence"),
    userId: sn,
    userName: sn,
    lastActivityTimestamp: Ht.nullable(),
    followingUserId: sn.nullable(),
    cursor: kn({
      x: Ht,
      y: Ht,
      type: z6,
      rotation: Ht
    }).nullable(),
    color: sn,
    camera: kn({
      x: Ht,
      y: Ht,
      z: Ht
    }).nullable(),
    screenBounds: Dx.nullable(),
    selectedShapeIds: No(Qa("shape")),
    currentPageId: Qa("page"),
    brush: Dx.nullable(),
    scribbles: No(U6),
    chatMessage: sn,
    meta: Fo
  })
), ry = Pa("com.tldraw.instance_presence", {
  AddScribbleDelay: 1,
  RemoveInstanceId: 2,
  AddChatMessage: 3,
  AddMeta: 4,
  RenameSelectedShapeIds: 5,
  NullableCameraCursor: 6
}), tie = il({
  sequenceId: "com.tldraw.instance_presence",
  recordType: "instance_presence",
  sequence: [
    {
      id: ry.AddScribbleDelay,
      up: (n) => {
        n.scribble !== null && (n.scribble.delay = 0);
      }
    },
    {
      id: ry.RemoveInstanceId,
      up: (n) => {
        delete n.instanceId;
      }
    },
    {
      id: ry.AddChatMessage,
      up: (n) => {
        n.chatMessage = "";
      }
    },
    {
      id: ry.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    },
    {
      id: ry.RenameSelectedShapeIds,
      up: (n) => {
      }
    },
    {
      id: ry.NullableCameraCursor,
      up: (n) => {
      },
      down: (n) => {
        n.camera === null && (n.camera = { x: 0, y: 0, z: 1 }), n.lastActivityTimestamp === null && (n.lastActivityTimestamp = 0), n.cursor === null && (n.cursor = { type: "default", x: 0, y: 0, rotation: 0 }), n.screenBounds === null && (n.screenBounds = { x: 0, y: 0, w: 1, h: 1 });
      }
    }
  ]
}), UA = Du(
  "instance_presence",
  {
    validator: eie,
    scope: "presence"
  }
).withDefaultProperties(() => ({
  lastActivityTimestamp: null,
  followingUserId: null,
  color: "#FF0000",
  camera: null,
  cursor: null,
  screenBounds: null,
  selectedShapeIds: [],
  brush: null,
  scribbles: [],
  chatMessage: "",
  meta: {}
}));
function nie(n, e) {
  const t = n.get(hs), r = n.get(Ml.createId(t == null ? void 0 : t.currentPageId)), i = n.get(vc.createId(t == null ? void 0 : t.currentPageId)), s = n.get(Gx);
  return !r || !t || !i || !s ? null : {
    selectedShapeIds: r.selectedShapeIds,
    brush: t.brush,
    scribbles: t.scribbles,
    userId: e.id,
    userName: e.name ?? "",
    followingUserId: t.followingUserId,
    camera: {
      x: i.x,
      y: i.y,
      z: i.z
    },
    color: e.color ?? "#FF0000",
    currentPageId: t.currentPageId,
    cursor: {
      x: s.x,
      y: s.y,
      rotation: t.cursor.rotation,
      type: t.cursor.type
    },
    lastActivityTimestamp: s.lastActivityTimestamp,
    screenBounds: t.screenBounds,
    chatMessage: t.chatMessage,
    meta: {}
  };
}
const rie = Ou(
  "document",
  kn({
    typeName: xs("document"),
    id: xs("document:document"),
    gridSize: Ht,
    name: sn,
    meta: Fo
  })
), zF = Pa("com.tldraw.document", {
  AddName: 1,
  AddMeta: 2
}), iie = il({
  sequenceId: "com.tldraw.document",
  recordType: "document",
  sequence: [
    {
      id: zF.AddName,
      up: (n) => {
        n.name = "";
      },
      down: (n) => {
        delete n.name;
      }
    },
    {
      id: zF.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), mO = Du("document", {
  validator: rie,
  scope: "document"
}).withDefaultProperties(
  () => ({
    gridSize: 10,
    name: "",
    meta: {}
  })
), $A = mO.createId("document");
function oie(n, e) {
  return n.index < e.index ? -1 : n.index > e.index ? 1 : 0;
}
function UF(n) {
  n.typeName === "asset" && ("src" in n && (n.src = "<redacted>"), "src" in n.props && (n.props.src = "<redacted>"));
}
function sie({
  error: n,
  phase: e,
  record: t,
  recordBefore: r
}) {
  throw qD(n, {
    tags: {
      origin: "store.validateRecord",
      storePhase: e,
      isExistingValidationIssue: (
        // if we're initializing the store for the first time, we should
        // allow invalid records so people can load old buggy data:
        e === "initialize"
      )
    },
    extras: {
      recordBefore: r ? UF($r(r)) : void 0,
      recordAfter: UF($r(t))
    }
  }), n;
}
function aie() {
  return [
    rl.create({
      id: "page:page",
      name: "Page 1",
      index: "a1",
      meta: {}
    })
  ];
}
function lie(n) {
  const e = n.query.ids("page"), t = n.query.records("instance_page_state"), r = () => {
    if (!n.has($A))
      return n.put([mO.create({ id: $A, name: n.props.defaultName })]), r();
    if (!n.has(Gx))
      return n.put([gO.create({ id: Gx })]), r();
    const i = e.get();
    if (i.size === 0)
      return n.put(aie()), r();
    const s = () => [...i].map((g) => n.get(g)).sort(oie)[0].id, l = n.get(hs);
    if (l) {
      if (!i.has(l.currentPageId))
        return n.put([{ ...l, currentPageId: s() }]), r();
    } else return n.put([
      n.schema.types.instance.create({
        id: hs,
        currentPageId: s(),
        exportBackground: !0
      })
    ]), r();
    const c = /* @__PURE__ */ new Set(), d = /* @__PURE__ */ new Set();
    for (const g of i) {
      const y = Ml.createId(g);
      n.get(y) || c.add(y);
      const w = vc.createId(g);
      n.has(w) || d.add(w);
    }
    c.size > 0 && n.put(
      [...c].map(
        (g) => Ml.create({
          id: g,
          pageId: Ml.parseId(g)
        })
      )
    ), d.size > 0 && n.put([...d].map((g) => vc.create({ id: g })));
    const h = t.get();
    for (const g of h) {
      if (!i.has(g.pageId)) {
        n.remove([g.id]);
        continue;
      }
      if (g.croppingShapeId && !n.has(g.croppingShapeId))
        return n.put([{ ...g, croppingShapeId: null }]), r();
      if (g.focusedGroupId && !n.has(g.focusedGroupId))
        return n.put([{ ...g, focusedGroupId: null }]), r();
      if (g.hoveredShapeId && !n.has(g.hoveredShapeId))
        return n.put([{ ...g, hoveredShapeId: null }]), r();
      const y = g.selectedShapeIds.filter((C) => n.has(C));
      if (y.length !== g.selectedShapeIds.length)
        return n.put([{ ...g, selectedShapeIds: y }]), r();
      const v = g.hintingShapeIds.filter((C) => n.has(C));
      if (v.length !== g.hintingShapeIds.length)
        return n.put([{ ...g, hintingShapeIds: v }]), r();
      const w = g.erasingShapeIds.filter((C) => n.has(C));
      if (w.length !== g.erasingShapeIds.length)
        return n.put([{ ...g, erasingShapeIds: w }]), r();
    }
  };
  return r;
}
const cie = hO(
  "bookmark",
  kn({
    title: sn,
    description: sn,
    image: sn,
    favicon: sn,
    src: Zp.nullable()
  })
), $F = Pa("com.tldraw.asset.bookmark", {
  MakeUrlsValid: 1,
  AddFavicon: 2
}), uie = il({
  sequenceId: "com.tldraw.asset.bookmark",
  recordType: "asset",
  filter: (n) => n.type === "bookmark",
  sequence: [
    {
      id: $F.MakeUrlsValid,
      up: (n) => {
        Zp.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: $F.AddFavicon,
      up: (n) => {
        Zp.isValid(n.props.favicon) || (n.props.favicon = "");
      },
      down: (n) => {
        delete n.props.favicon;
      }
    }
  ]
}), die = hO(
  "image",
  kn({
    w: Ht,
    h: Ht,
    name: sn,
    isAnimated: Tn,
    mimeType: sn.nullable(),
    src: Zp.nullable(),
    fileSize: Pi.optional()
  })
), nx = Pa("com.tldraw.asset.image", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), fie = il({
  sequenceId: "com.tldraw.asset.image",
  recordType: "asset",
  filter: (n) => n.type === "image",
  sequence: [
    {
      id: nx.AddIsAnimated,
      up: (n) => {
        n.props.isAnimated = !1;
      },
      down: (n) => {
        delete n.props.isAnimated;
      }
    },
    {
      id: nx.RenameWidthHeight,
      up: (n) => {
        n.props.w = n.props.width, n.props.h = n.props.height, delete n.props.width, delete n.props.height;
      },
      down: (n) => {
        n.props.width = n.props.w, n.props.height = n.props.h, delete n.props.w, delete n.props.h;
      }
    },
    {
      id: nx.MakeUrlsValid,
      up: (n) => {
        Zp.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: nx.AddFileSize,
      up: (n) => {
        n.props.fileSize = -1;
      },
      down: (n) => {
        delete n.props.fileSize;
      }
    },
    {
      id: nx.MakeFileSizeOptional,
      up: (n) => {
        n.props.fileSize === -1 && (n.props.fileSize = void 0);
      },
      down: (n) => {
        n.props.fileSize === void 0 && (n.props.fileSize = -1);
      }
    }
  ]
}), hie = hO(
  "video",
  kn({
    w: Ht,
    h: Ht,
    name: sn,
    isAnimated: Tn,
    mimeType: sn.nullable(),
    src: Zp.nullable(),
    fileSize: Ht.optional()
  })
), rx = Pa("com.tldraw.asset.video", {
  AddIsAnimated: 1,
  RenameWidthHeight: 2,
  MakeUrlsValid: 3,
  AddFileSize: 4,
  MakeFileSizeOptional: 5
}), pie = il({
  sequenceId: "com.tldraw.asset.video",
  recordType: "asset",
  filter: (n) => n.type === "video",
  sequence: [
    {
      id: rx.AddIsAnimated,
      up: (n) => {
        n.props.isAnimated = !1;
      },
      down: (n) => {
        delete n.props.isAnimated;
      }
    },
    {
      id: rx.RenameWidthHeight,
      up: (n) => {
        n.props.w = n.props.width, n.props.h = n.props.height, delete n.props.width, delete n.props.height;
      },
      down: (n) => {
        n.props.width = n.props.w, n.props.height = n.props.h, delete n.props.w, delete n.props.h;
      }
    },
    {
      id: rx.MakeUrlsValid,
      up: (n) => {
        Zp.isValid(n.props.src) || (n.props.src = "");
      },
      down: (n) => {
      }
    },
    {
      id: rx.AddFileSize,
      up: (n) => {
        n.props.fileSize = -1;
      },
      down: (n) => {
        delete n.props.fileSize;
      }
    },
    {
      id: rx.MakeFileSizeOptional,
      up: (n) => {
        n.props.fileSize === -1 && (n.props.fileSize = void 0);
      },
      down: (n) => {
        n.props.fileSize === void 0 && (n.props.fileSize = -1);
      }
    }
  ]
}), gie = Ou(
  "asset",
  uO("type", {
    image: die,
    video: hie,
    bookmark: cie
  })
), mie = Pa("com.tldraw.asset", {
  AddMeta: 1
}), yie = il({
  sequenceId: "com.tldraw.asset",
  recordType: "asset",
  sequence: [
    {
      id: mie.AddMeta,
      up: (n) => {
        n.meta = {};
      }
    }
  ]
}), ih = Du("asset", {
  validator: gie,
  scope: "document"
}).withDefaultProperties(() => ({
  meta: {}
})), B6 = {
  w: Pi,
  h: Pi,
  assetId: KE.nullable(),
  url: tl
}, BF = Ic("bookmark", {
  NullAssetId: 1,
  MakeUrlsValid: 2
}), H6 = {
  sequence: [
    {
      id: BF.NullAssetId,
      up: (n) => {
        n.assetId === void 0 && (n.assetId = null);
      },
      down: "retired"
    },
    {
      id: BF.MakeUrlsValid,
      up: (n) => {
        tl.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    }
  ]
}, V6 = kn({
  type: VE("free", "straight"),
  points: No(Qp)
}), K6 = {
  color: nl,
  fill: eg,
  dash: Jp,
  size: Pu,
  segments: No(V6),
  isComplete: Tn,
  isClosed: Tn,
  isPen: Tn,
  scale: Pi
}, HF = Ic("draw", {
  AddInPen: 1,
  AddScale: 2
}), W6 = {
  sequence: [
    {
      id: HF.AddInPen,
      up: (n) => {
        const { points: e } = n.segments[0];
        if (e.length === 0) {
          n.isPen = !1;
          return;
        }
        let t = !(e[0].z === 0 || e[0].z === 0.5);
        e[1] && (t = t && !(e[1].z === 0 || e[1].z === 0.5)), n.isPen = t;
      },
      down: "retired"
    },
    {
      id: HF.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, vie = /(^\/r\/[^/]+\/?$)/, Sie = [
  {
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(vie))
        return n;
    }
  },
  {
    hostnames: ["figma.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const t = e.searchParams.get("url");
        if (t)
          return t;
      }
    }
  },
  {
    hostnames: ["google.*"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (!e) return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"), [i, s] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${i},${s},${r}z`;
      }
    }
  },
  {
    hostnames: ["val.town"],
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/embed\/(.+)\/?/);
      if (t)
        return `https://www.val.town/v/${t[1]}`;
    }
  },
  {
    hostnames: ["codesandbox.io"],
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (t)
        return `https://codesandbox.io/s/${t[1]}`;
    }
  },
  {
    hostnames: ["codepen.io"],
    fromEmbedUrl: (n) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i, s] = t;
        return `https://codepen.io/${i}/pen/${s}`;
      }
    }
  },
  {
    hostnames: ["scratch.mit.edu"],
    fromEmbedUrl: (n) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i] = t;
        return `https://scratch.mit.edu/projects/${i}`;
      }
    }
  },
  {
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (!e) return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    hostnames: ["calendar.google.*"],
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e == null ? void 0 : e.searchParams.get("src");
      if (e != null && e.pathname.match(/\/calendar\/embed/) && t) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const i of r)
          e.searchParams.delete(i);
        return e.searchParams.set("cid", t), e.href;
      }
    }
  },
  {
    hostnames: ["docs.google.*"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/embed\/?$/))) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const t = Array.from(e.searchParams.keys());
        for (const r of t)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    hostnames: ["gist.github.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/([^/]+)\/([^/]+)/))
        return n.split("/").pop() ? n : void 0;
    }
  },
  {
    hostnames: ["replit.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    hostnames: ["felt.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    hostnames: ["open.spotify.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    hostnames: ["vimeo.com", "player.vimeo.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "player.vimeo.com") {
        const t = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (t)
          return "https://vimeo.com/" + t[1];
      }
    }
  },
  {
    hostnames: ["excalidraw.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hash.match(/#room=/))
        return n;
    }
  },
  {
    hostnames: ["observablehq.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  },
  {
    hostnames: ["desmos.com"],
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "?embed" && e.hash === "")
        return n.replace("?embed", "");
    }
  }
], G6 = {
  w: Pi,
  h: Pi,
  url: sn
}, L1 = Ic("embed", {
  GenOriginalUrlInEmbed: 1,
  RemoveDoesResize: 2,
  RemoveTmpOldUrl: 3,
  RemovePermissionOverrides: 4
}), q6 = {
  sequence: [
    {
      id: L1.GenOriginalUrlInEmbed,
      // add tmpOldUrl property
      up: (n) => {
        try {
          const e = n.url, t = new URL(e).host.replace("www.", "");
          let r;
          for (const i of Sie)
            if (i.hostnames.includes(t))
              try {
                r = i.fromEmbedUrl(e);
              } catch (s) {
                console.warn(s);
              }
          n.tmpOldUrl = n.url, n.url = r ?? "";
        } catch {
          n.url = "", n.tmpOldUrl = n.url;
        }
      },
      down: "retired"
    },
    {
      id: L1.RemoveDoesResize,
      up: (n) => {
        delete n.doesResize;
      },
      down: "retired"
    },
    {
      id: L1.RemoveTmpOldUrl,
      up: (n) => {
        delete n.tmpOldUrl;
      },
      down: "retired"
    },
    {
      id: L1.RemovePermissionOverrides,
      up: (n) => {
        delete n.overridePermissions;
      },
      down: "retired"
    }
  ]
}, Y6 = {
  w: Pi,
  h: Pi,
  name: sn
}, X6 = {
  sequence: []
}, hE = Bo.defineEnum("tldraw:horizontalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end", "start-legacy", "end-legacy", "middle-legacy"]
}), pE = Bo.defineEnum("tldraw:verticalAlign", {
  defaultValue: "middle",
  values: ["start", "middle", "end"]
}), Sc = Bo.defineEnum("tldraw:geo", {
  defaultValue: "rectangle",
  values: [
    "cloud",
    "rectangle",
    "ellipse",
    "triangle",
    "diamond",
    "pentagon",
    "hexagon",
    "octagon",
    "star",
    "rhombus",
    "rhombus-2",
    "oval",
    "trapezoid",
    "arrow-right",
    "arrow-left",
    "arrow-up",
    "arrow-down",
    "x-box",
    "check-box",
    "heart"
  ]
}), Z6 = {
  geo: Sc,
  labelColor: pO,
  color: nl,
  fill: eg,
  dash: Jp,
  size: Pu,
  font: _u,
  align: hE,
  verticalAlign: pE,
  url: tl,
  w: Pi,
  h: Pi,
  growY: lE,
  text: sn,
  scale: Pi
}, Id = Ic("geo", {
  AddUrlProp: 1,
  AddLabelColor: 2,
  RemoveJustify: 3,
  AddCheckBox: 4,
  AddVerticalAlign: 5,
  MigrateLegacyAlign: 6,
  AddCloud: 7,
  MakeUrlsValid: 8,
  AddScale: 9
}), Q6 = {
  sequence: [
    {
      id: Id.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: Id.AddLabelColor,
      up: (n) => {
        n.labelColor = "black";
      },
      down: "retired"
    },
    {
      id: Id.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: Id.AddCheckBox,
      up: (n) => {
      },
      down: "retired"
    },
    {
      id: Id.AddVerticalAlign,
      up: (n) => {
        n.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Id.MigrateLegacyAlign,
      up: (n) => {
        let e;
        switch (n.align) {
          case "start":
            e = "start-legacy";
            break;
          case "end":
            e = "end-legacy";
            break;
          default:
            e = "middle-legacy";
            break;
        }
        n.align = e;
      },
      down: "retired"
    },
    {
      id: Id.AddCloud,
      up: (n) => {
      },
      down: "retired"
    },
    {
      id: Id.MakeUrlsValid,
      up: (n) => {
        tl.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: Id.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, J6 = {}, e8 = { sequence: [] }, t8 = {
  color: nl,
  size: Pu,
  segments: No(V6),
  isComplete: Tn,
  isPen: Tn,
  scale: Pi
}, xie = Ic("highlight", {
  AddScale: 1
}), n8 = {
  sequence: [
    {
      id: xie.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, wie = kn({
  topLeft: Qp,
  bottomRight: Qp
}), r8 = {
  w: Pi,
  h: Pi,
  playing: Tn,
  url: tl,
  assetId: KE.nullable(),
  crop: wie.nullable(),
  flipX: Tn,
  flipY: Tn
}, N1 = Ic("image", {
  AddUrlProp: 1,
  AddCropProp: 2,
  MakeUrlsValid: 3,
  AddFlipProps: 4
}), i8 = {
  sequence: [
    {
      id: N1.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: N1.AddCropProp,
      up: (n) => {
        n.crop = null;
      },
      down: (n) => {
        delete n.crop;
      }
    },
    {
      id: N1.MakeUrlsValid,
      up: (n) => {
        tl.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: N1.AddFlipProps,
      up: (n) => {
        n.flipX = !1, n.flipY = !1;
      },
      down: (n) => {
        delete n.flipX, delete n.flipY;
      }
    }
  ]
}, gE = Bo.defineEnum("tldraw:spline", {
  defaultValue: "line",
  values: ["cubic", "line"]
}), bie = kn({
  id: sn,
  index: fO,
  x: Ht,
  y: Ht
}), o8 = {
  color: nl,
  dash: Jp,
  size: Pu,
  spline: gE,
  points: cE(sn, bie),
  scale: Pi
}, ix = Ic("line", {
  AddSnapHandles: 1,
  RemoveExtraHandleProps: 2,
  HandlesToPoints: 3,
  PointIndexIds: 4,
  AddScale: 5
}), s8 = {
  sequence: [
    {
      id: ix.AddSnapHandles,
      up: (n) => {
        for (const e of Object.values(n.handles))
          e.canSnap = !0;
      },
      down: "retired"
    },
    {
      id: ix.RemoveExtraHandleProps,
      up: (n) => {
        n.handles = XD(
          Object.values(n.handles).map((e) => [
            e.index,
            {
              x: e.x,
              y: e.y
            }
          ])
        );
      },
      down: (n) => {
        const e = Object.entries(n.handles).map(([t, r]) => ({ index: t, ...r })).sort(gs);
        n.handles = Object.fromEntries(
          e.map((t, r) => {
            const i = r === 0 ? "start" : r === e.length - 1 ? "end" : `handle:${t.index}`;
            return [
              i,
              {
                id: i,
                type: "vertex",
                canBind: !1,
                canSnap: !0,
                index: t.index,
                x: t.x,
                y: t.y
              }
            ];
          })
        );
      }
    },
    {
      id: ix.HandlesToPoints,
      up: (n) => {
        const e = Object.entries(n.handles).map(([t, { x: r, y: i }]) => ({ x: r, y: i, index: t })).sort(gs);
        n.points = e.map(({ x: t, y: r }) => ({ x: t, y: r })), delete n.handles;
      },
      down: (n) => {
        const e = Vx(n.points.length);
        n.handles = Object.fromEntries(
          n.points.map((t, r) => [
            e[r],
            {
              x: t.x,
              y: t.y
            }
          ])
        ), delete n.points;
      }
    },
    {
      id: ix.PointIndexIds,
      up: (n) => {
        const e = Vx(n.points.length);
        n.points = Object.fromEntries(
          n.points.map((t, r) => {
            const i = e[r];
            return [
              i,
              {
                id: i,
                index: i,
                x: t.x,
                y: t.y
              }
            ];
          })
        );
      },
      down: (n) => {
        const e = Object.values(n.points).sort(gs);
        n.points = e.map(({ x: t, y: r }) => ({ x: t, y: r }));
      }
    },
    {
      id: ix.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    }
  ]
}, a8 = {
  color: nl,
  labelColor: pO,
  size: Pu,
  font: _u,
  fontSizeAdjustment: lE,
  align: hE,
  verticalAlign: pE,
  growY: lE,
  url: tl,
  text: sn,
  scale: Pi
}, Qf = Ic("note", {
  AddUrlProp: 1,
  RemoveJustify: 2,
  MigrateLegacyAlign: 3,
  AddVerticalAlign: 4,
  MakeUrlsValid: 5,
  AddFontSizeAdjustment: 6,
  AddScale: 7,
  AddLabelColor: 8
}), l8 = {
  sequence: [
    {
      id: Qf.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: Qf.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: Qf.MigrateLegacyAlign,
      up: (n) => {
        switch (n.align) {
          case "start":
            n.align = "start-legacy";
            return;
          case "end":
            n.align = "end-legacy";
            return;
          default:
            n.align = "middle-legacy";
            return;
        }
      },
      down: "retired"
    },
    {
      id: Qf.AddVerticalAlign,
      up: (n) => {
        n.verticalAlign = "middle";
      },
      down: "retired"
    },
    {
      id: Qf.MakeUrlsValid,
      up: (n) => {
        tl.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    },
    {
      id: Qf.AddFontSizeAdjustment,
      up: (n) => {
        n.fontSizeAdjustment = 0;
      },
      down: (n) => {
        delete n.fontSizeAdjustment;
      }
    },
    {
      id: Qf.AddScale,
      up: (n) => {
        n.scale = 1;
      },
      down: (n) => {
        delete n.scale;
      }
    },
    {
      id: Qf.AddLabelColor,
      up: (n) => {
        n.labelColor = "black";
      },
      down: (n) => {
        delete n.labelColor;
      }
    }
  ]
}, BA = Bo.defineEnum("tldraw:textAlign", {
  defaultValue: "start",
  values: ["start", "middle", "end"]
}), c8 = {
  color: nl,
  size: Pu,
  font: _u,
  textAlign: BA,
  w: Pi,
  text: sn,
  scale: Pi,
  autoSize: Tn
}, VF = Ic("text", {
  RemoveJustify: 1,
  AddTextAlign: 2
}), u8 = {
  sequence: [
    {
      id: VF.RemoveJustify,
      up: (n) => {
        n.align === "justify" && (n.align = "start");
      },
      down: "retired"
    },
    {
      id: VF.AddTextAlign,
      up: (n) => {
        n.textAlign = n.align, delete n.align;
      },
      down: (n) => {
        n.align = n.textAlign, delete n.textAlign;
      }
    }
  ]
}, d8 = {
  w: Pi,
  h: Pi,
  time: Ht,
  playing: Tn,
  url: tl,
  assetId: KE.nullable()
}, KF = Ic("video", {
  AddUrlProp: 1,
  MakeUrlsValid: 2
}), f8 = {
  sequence: [
    {
      id: KF.AddUrlProp,
      up: (n) => {
        n.url = "";
      },
      down: "retired"
    },
    {
      id: KF.MakeUrlsValid,
      up: (n) => {
        tl.isValid(n.url) || (n.url = "");
      },
      down: (n) => {
      }
    }
  ]
}, F1 = Pa("com.tldraw.store", {
  RemoveCodeAndIconShapeTypes: 1,
  AddInstancePresenceType: 2,
  RemoveTLUserAndPresenceAndAddPointer: 3,
  RemoveUserDocument: 4
}), Cie = Cy({
  sequenceId: "com.tldraw.store",
  retroactive: !1,
  sequence: [
    {
      id: F1.RemoveCodeAndIconShapeTypes,
      scope: "store",
      up: (n) => {
        for (const [e, t] of Uo(n))
          t.typeName === "shape" && (t.type === "icon" || t.type === "code") && delete n[e];
      }
    },
    {
      id: F1.AddInstancePresenceType,
      scope: "store",
      up(n) {
      }
    },
    {
      // remove user and presence records and add pointer records
      id: F1.RemoveTLUserAndPresenceAndAddPointer,
      scope: "store",
      up: (n) => {
        for (const [e, t] of Uo(n))
          t.typeName.match(/^(user|user_presence)$/) && delete n[e];
      }
    },
    {
      // remove user document records
      id: F1.RemoveUserDocument,
      scope: "store",
      up: (n) => {
        for (const [e, t] of Uo(n))
          t.typeName.match("user_document") && delete n[e];
      }
    }
  ]
}), Eie = {
  arrow: { migrations: L6, props: j6 },
  bookmark: { migrations: H6, props: B6 },
  draw: { migrations: W6, props: K6 },
  embed: { migrations: q6, props: G6 },
  frame: { migrations: X6, props: Y6 },
  geo: { migrations: Q6, props: Z6 },
  group: { migrations: e8, props: J6 },
  highlight: { migrations: n8, props: t8 },
  image: { migrations: i8, props: r8 },
  line: { migrations: s8, props: o8 },
  note: { migrations: l8, props: a8 },
  text: { migrations: u8, props: c8 },
  video: { migrations: f8, props: d8 }
}, _ie = {
  arrow: { migrations: F6, props: N6 }
};
function Pie({
  shapes: n = Eie,
  bindings: e = _ie,
  migrations: t
} = {}) {
  const r = /* @__PURE__ */ new Map();
  for (const c of Xr(n))
    for (const d of R6(c.props ?? {}).keys()) {
      if (r.has(d.id) && r.get(d.id) !== d)
        throw new Error(`Multiple StyleProp instances with the same id: ${d.id}`);
      r.set(d.id, d);
    }
  const i = Ore(n), s = Mre(e), l = Gre(r);
  return aO.create(
    {
      asset: ih,
      binding: s,
      camera: vc,
      document: mO,
      instance: l,
      instance_page_state: Ml,
      page: rl,
      instance_presence: UA,
      pointer: gO,
      shape: i
    },
    {
      migrations: [
        Cie,
        yie,
        Nre,
        iie,
        qre,
        Xre,
        Kre,
        tie,
        Jre,
        Dre,
        uie,
        fie,
        pie,
        ...FF("shape", n),
        ...FF("binding", e),
        ...t ?? []
      ],
      onValidationFailure: sie,
      createIntegrityChecker: lie
    }
  );
}
const qx = [
  { locale: "id", label: "Bahasa Indonesia" },
  { locale: "ca", label: "Català" },
  { locale: "cs", label: "Čeština" },
  { locale: "da", label: "Danish" },
  { locale: "de", label: "Deutsch" },
  { locale: "en", label: "English" },
  { locale: "es", label: "Español" },
  { locale: "fr", label: "Français" },
  { locale: "gl", label: "Galego" },
  { locale: "hr", label: "Hrvatski" },
  { locale: "it", label: "Italiano" },
  { locale: "hu", label: "Magyar" },
  { locale: "no", label: "Norwegian" },
  { locale: "pl", label: "Polski" },
  { locale: "pt-br", label: "Português - Brasil" },
  { locale: "pt-pt", label: "Português - Europeu" },
  { locale: "ro", label: "Română" },
  { locale: "ru", label: "Russian" },
  { locale: "sl", label: "Slovenščina" },
  { locale: "so", label: "Somali" },
  { locale: "fi", label: "Suomi" },
  { locale: "sv", label: "Svenska" },
  { locale: "vi", label: "Tiếng Việt" },
  { locale: "tr", label: "Türkçe" },
  { locale: "uk", label: "Ukrainian" },
  { locale: "he", label: "עברית" },
  { locale: "ar", label: "عربي" },
  { locale: "fa", label: "فارسی" },
  { locale: "ku", label: "کوردی" },
  { locale: "ne", label: "नेपाली" },
  { locale: "hi-in", label: "हिन्दी" },
  { locale: "te", label: "తెలుగు" },
  { locale: "th", label: "ภาษาไทย" },
  { locale: "my", label: "မြန်မာစာ" },
  { locale: "ko-kr", label: "한국어" },
  { locale: "ja", label: "日本語" },
  { locale: "zh-cn", label: "简体中文" },
  { locale: "zh-tw", label: "繁體中文 (台灣)" }
];
function Tie() {
  const n = typeof window < "u" ? window.navigator.languages ?? ["en"] : ["en"];
  return Iie(n);
}
function Iie(n) {
  for (const e of n) {
    const t = kie(e);
    if (t)
      return t;
  }
  return "en";
}
const WF = {
  zh: "zh-cn",
  pt: "pt-br",
  ko: "ko-kr",
  hi: "hi-in"
};
function kie(n) {
  const e = qx.find((i) => i.locale === n.toLowerCase());
  if (e)
    return e.locale;
  const [t, r] = n.split(/[-_]/).map((i) => i.toLowerCase());
  if (r) {
    const i = qx.find((s) => s.locale === t);
    if (i)
      return i.locale;
  }
  return t in WF ? WF[t] : null;
}
Au(
  "@tldraw/tlschema",
  "3.7.0",
  "esm"
);
Au(
  "@tldraw/sync-core",
  "3.7.0",
  "esm"
);
function WE(n, e, t = []) {
  const r = Bt.useRef(e);
  r.current = e;
  const [i, s, l] = Bt.useMemo(() => {
    let c = null;
    const d = (y) => (c = y, () => {
      c = null;
    }), h = new Uy(
      `useStateTracking(${n})`,
      // this is what `scheduler.execute()` will call
      () => {
        var y;
        return (y = r.current) == null ? void 0 : y.call(r);
      },
      // this is what will be invoked when @tldraw/state detects a change in an upstream reactive value
      {
        scheduleEffect() {
          c == null || c();
        }
      }
    );
    return [h, d, () => h.scheduleCount];
  }, [n, ...t]);
  return Bt.useSyncExternalStore(s, l, l), Bt.useEffect(() => (i.attach(), i.maybeScheduleEffect(), () => {
    i.detach();
  }), [i]), i.execute();
}
const GF = {
  /**
   * This is a function call trap for functional components. When this is called, we know it means
   * React did run 'Component()', that means we can use any hooks here to setup our effect and
   * store.
   *
   * With the native Proxy, all other calls such as access/setting to/of properties will be
   * forwarded to the target Component, so we don't need to copy the Component's own or inherited
   * properties.
   *
   * @see https://github.com/facebook/react/blob/2d80a0cd690bb5650b6c8a6c079a87b5dc42bd15/packages/react-reconciler/src/ReactFiberHooks.old.js#L460
   */
  apply(n, e, t) {
    return WE(
      n.displayName ?? n.name ?? "tracked(???)",
      () => n.apply(e, t)
    );
  }
}, Rie = Symbol.for("react.memo"), Mie = Symbol.for("react.forward_ref");
function Ho(n) {
  let e = null;
  const t = n.$$typeof;
  return t === Rie && (n = n.type, e = n.compare), t === Mie ? M.memo(M.forwardRef(new Proxy(n.render, GF))) : M.memo(new Proxy(n, GF), e);
}
function uw(n, e, t) {
  return M.useState(() => {
    const r = typeof e == "function" ? e() : e;
    return mi(`useAtom(${n})`, r, t);
  })[0];
}
function Aie() {
  const n = arguments[0], e = arguments[1], t = arguments.length === 3 ? void 0 : arguments[2], r = arguments.length === 3 ? arguments[2] : arguments[3];
  return M.useMemo(() => Le(`useComputed(${n})`, e, t), r);
}
function dh(n, e, t = Fd) {
  M.useEffect(() => {
    const r = new Uy(n, e);
    return r.attach(), r.execute(), () => {
      r.detach();
    };
  }, t);
}
function Pe() {
  const n = arguments, e = n.length === 3 ? n[2] : [n[0]], t = n.length === 3 ? n[0] : `useValue(${n[0].name})`, r = M.useRef(!0);
  r.current = !0;
  const i = M.useMemo(() => n.length === 1 ? n[0] : Le(t, () => {
    if (r.current)
      return n[1]();
    try {
      return n[1]();
    } catch {
      return {};
    }
  }), e);
  try {
    const { subscribe: s, getSnapshot: l } = M.useMemo(() => ({
      subscribe: (c) => wc(`useValue(${t})`, () => {
        i.get(), c();
      }),
      getSnapshot: () => i.get()
    }), [i]);
    return M.useSyncExternalStore(s, l, l);
  } finally {
    r.current = !1;
  }
}
Au(
  "@tldraw/state-react",
  "3.7.0",
  "esm"
);
var qF = {}, ox, YF;
function Vs() {
  if (YF) return ox;
  YF = 1;
  var n = function(e) {
    return e && e.Math === Math && e;
  };
  return ox = // eslint-disable-next-line es/no-global-this -- safe
  n(typeof globalThis == "object" && globalThis) || n(typeof window == "object" && window) || // eslint-disable-next-line no-restricted-globals -- safe
  n(typeof self == "object" && self) || n(typeof ba == "object" && ba) || n(typeof ox == "object" && ox) || // eslint-disable-next-line no-new-func -- fallback
  /* @__PURE__ */ function() {
    return this;
  }() || Function("return this")(), ox;
}
var wk = {}, bk, XF;
function Ks() {
  return XF || (XF = 1, bk = function(n) {
    try {
      return !!n();
    } catch {
      return !0;
    }
  }), bk;
}
var Ck, ZF;
function Ch() {
  if (ZF) return Ck;
  ZF = 1;
  var n = Ks();
  return Ck = !n(function() {
    return Object.defineProperty({}, 1, { get: function() {
      return 7;
    } })[1] !== 7;
  }), Ck;
}
var Ek, QF;
function GE() {
  if (QF) return Ek;
  QF = 1;
  var n = Ks();
  return Ek = !n(function() {
    var e = (function() {
    }).bind();
    return typeof e != "function" || e.hasOwnProperty("prototype");
  }), Ek;
}
var _k, JF;
function Gd() {
  if (JF) return _k;
  JF = 1;
  var n = GE(), e = Function.prototype.call;
  return _k = n ? e.bind(e) : function() {
    return e.apply(e, arguments);
  }, _k;
}
var Pk = {}, e5;
function Die() {
  if (e5) return Pk;
  e5 = 1;
  var n = {}.propertyIsEnumerable, e = Object.getOwnPropertyDescriptor, t = e && !n.call({ 1: 2 }, 1);
  return Pk.f = t ? function(i) {
    var s = e(this, i);
    return !!s && s.enumerable;
  } : n, Pk;
}
var Tk, t5;
function h8() {
  return t5 || (t5 = 1, Tk = function(n, e) {
    return {
      enumerable: !(n & 1),
      configurable: !(n & 2),
      writable: !(n & 4),
      value: e
    };
  }), Tk;
}
var Ik, n5;
function go() {
  if (n5) return Ik;
  n5 = 1;
  var n = GE(), e = Function.prototype, t = e.call, r = n && e.bind.bind(t, t);
  return Ik = n ? r : function(i) {
    return function() {
      return t.apply(i, arguments);
    };
  }, Ik;
}
var kk, r5;
function $y() {
  if (r5) return kk;
  r5 = 1;
  var n = go(), e = n({}.toString), t = n("".slice);
  return kk = function(r) {
    return t(e(r), 8, -1);
  }, kk;
}
var Rk, i5;
function Oie() {
  if (i5) return Rk;
  i5 = 1;
  var n = go(), e = Ks(), t = $y(), r = Object, i = n("".split);
  return Rk = e(function() {
    return !r("z").propertyIsEnumerable(0);
  }) ? function(s) {
    return t(s) === "String" ? i(s, "") : r(s);
  } : r, Rk;
}
var Mk, o5;
function qE() {
  return o5 || (o5 = 1, Mk = function(n) {
    return n == null;
  }), Mk;
}
var Ak, s5;
function By() {
  if (s5) return Ak;
  s5 = 1;
  var n = qE(), e = TypeError;
  return Ak = function(t) {
    if (n(t)) throw new e("Can't call method on " + t);
    return t;
  }, Ak;
}
var Dk, a5;
function YE() {
  if (a5) return Dk;
  a5 = 1;
  var n = Oie(), e = By();
  return Dk = function(t) {
    return n(e(t));
  }, Dk;
}
var Ok, l5;
function Ws() {
  if (l5) return Ok;
  l5 = 1;
  var n = typeof document == "object" && document.all;
  return Ok = typeof n > "u" && n !== void 0 ? function(e) {
    return typeof e == "function" || e === n;
  } : function(e) {
    return typeof e == "function";
  }, Ok;
}
var jk, c5;
function cg() {
  if (c5) return jk;
  c5 = 1;
  var n = Ws();
  return jk = function(e) {
    return typeof e == "object" ? e !== null : n(e);
  }, jk;
}
var Lk, u5;
function XE() {
  if (u5) return Lk;
  u5 = 1;
  var n = Vs(), e = Ws(), t = function(r) {
    return e(r) ? r : void 0;
  };
  return Lk = function(r, i) {
    return arguments.length < 2 ? t(n[r]) : n[r] && n[r][i];
  }, Lk;
}
var Nk, d5;
function p8() {
  if (d5) return Nk;
  d5 = 1;
  var n = go();
  return Nk = n({}.isPrototypeOf), Nk;
}
var Fk, f5;
function jie() {
  if (f5) return Fk;
  f5 = 1;
  var n = Vs(), e = n.navigator, t = e && e.userAgent;
  return Fk = t ? String(t) : "", Fk;
}
var zk, h5;
function Lie() {
  if (h5) return zk;
  h5 = 1;
  var n = Vs(), e = jie(), t = n.process, r = n.Deno, i = t && t.versions || r && r.version, s = i && i.v8, l, c;
  return s && (l = s.split("."), c = l[0] > 0 && l[0] < 4 ? 1 : +(l[0] + l[1])), !c && e && (l = e.match(/Edge\/(\d+)/), (!l || l[1] >= 74) && (l = e.match(/Chrome\/(\d+)/), l && (c = +l[1]))), zk = c, zk;
}
var Uk, p5;
function g8() {
  if (p5) return Uk;
  p5 = 1;
  var n = Lie(), e = Ks(), t = Vs(), r = t.String;
  return Uk = !!Object.getOwnPropertySymbols && !e(function() {
    var i = Symbol("symbol detection");
    return !r(i) || !(Object(i) instanceof Symbol) || // Chrome 38-40 symbols are not inherited from DOM collections prototypes to instances
    !Symbol.sham && n && n < 41;
  }), Uk;
}
var $k, g5;
function m8() {
  if (g5) return $k;
  g5 = 1;
  var n = g8();
  return $k = n && !Symbol.sham && typeof Symbol.iterator == "symbol", $k;
}
var Bk, m5;
function y8() {
  if (m5) return Bk;
  m5 = 1;
  var n = XE(), e = Ws(), t = p8(), r = m8(), i = Object;
  return Bk = r ? function(s) {
    return typeof s == "symbol";
  } : function(s) {
    var l = n("Symbol");
    return e(l) && t(l.prototype, i(s));
  }, Bk;
}
var Hk, y5;
function Nie() {
  if (y5) return Hk;
  y5 = 1;
  var n = String;
  return Hk = function(e) {
    try {
      return n(e);
    } catch {
      return "Object";
    }
  }, Hk;
}
var Vk, v5;
function yO() {
  if (v5) return Vk;
  v5 = 1;
  var n = Ws(), e = Nie(), t = TypeError;
  return Vk = function(r) {
    if (n(r)) return r;
    throw new t(e(r) + " is not a function");
  }, Vk;
}
var Kk, S5;
function vO() {
  if (S5) return Kk;
  S5 = 1;
  var n = yO(), e = qE();
  return Kk = function(t, r) {
    var i = t[r];
    return e(i) ? void 0 : n(i);
  }, Kk;
}
var Wk, x5;
function Fie() {
  if (x5) return Wk;
  x5 = 1;
  var n = Gd(), e = Ws(), t = cg(), r = TypeError;
  return Wk = function(i, s) {
    var l, c;
    if (s === "string" && e(l = i.toString) && !t(c = n(l, i)) || e(l = i.valueOf) && !t(c = n(l, i)) || s !== "string" && e(l = i.toString) && !t(c = n(l, i))) return c;
    throw new r("Can't convert object to primitive value");
  }, Wk;
}
var Gk = { exports: {} }, qk, w5;
function v8() {
  return w5 || (w5 = 1, qk = !1), qk;
}
var Yk, b5;
function SO() {
  if (b5) return Yk;
  b5 = 1;
  var n = Vs(), e = Object.defineProperty;
  return Yk = function(t, r) {
    try {
      e(n, t, { value: r, configurable: !0, writable: !0 });
    } catch {
      n[t] = r;
    }
    return r;
  }, Yk;
}
var C5;
function xO() {
  if (C5) return Gk.exports;
  C5 = 1;
  var n = v8(), e = Vs(), t = SO(), r = "__core-js_shared__", i = Gk.exports = e[r] || t(r, {});
  return (i.versions || (i.versions = [])).push({
    version: "3.40.0",
    mode: n ? "pure" : "global",
    copyright: "© 2014-2025 Denis Pushkarev (zloirock.ru)",
    license: "https://github.com/zloirock/core-js/blob/v3.40.0/LICENSE",
    source: "https://github.com/zloirock/core-js"
  }), Gk.exports;
}
var Xk, E5;
function wO() {
  if (E5) return Xk;
  E5 = 1;
  var n = xO();
  return Xk = function(e, t) {
    return n[e] || (n[e] = t || {});
  }, Xk;
}
var Zk, _5;
function dw() {
  if (_5) return Zk;
  _5 = 1;
  var n = By(), e = Object;
  return Zk = function(t) {
    return e(n(t));
  }, Zk;
}
var Qk, P5;
function Eh() {
  if (P5) return Qk;
  P5 = 1;
  var n = go(), e = dw(), t = n({}.hasOwnProperty);
  return Qk = Object.hasOwn || function(i, s) {
    return t(e(i), s);
  }, Qk;
}
var Jk, T5;
function S8() {
  if (T5) return Jk;
  T5 = 1;
  var n = go(), e = 0, t = Math.random(), r = n(1 .toString);
  return Jk = function(i) {
    return "Symbol(" + (i === void 0 ? "" : i) + ")_" + r(++e + t, 36);
  }, Jk;
}
var eR, I5;
function qd() {
  if (I5) return eR;
  I5 = 1;
  var n = Vs(), e = wO(), t = Eh(), r = S8(), i = g8(), s = m8(), l = n.Symbol, c = e("wks"), d = s ? l.for || l : l && l.withoutSetter || r;
  return eR = function(h) {
    return t(c, h) || (c[h] = i && t(l, h) ? l[h] : d("Symbol." + h)), c[h];
  }, eR;
}
var tR, k5;
function zie() {
  if (k5) return tR;
  k5 = 1;
  var n = Gd(), e = cg(), t = y8(), r = vO(), i = Fie(), s = qd(), l = TypeError, c = s("toPrimitive");
  return tR = function(d, h) {
    if (!e(d) || t(d)) return d;
    var g = r(d, c), y;
    if (g) {
      if (h === void 0 && (h = "default"), y = n(g, d, h), !e(y) || t(y)) return y;
      throw new l("Can't convert object to primitive value");
    }
    return h === void 0 && (h = "number"), i(d, h);
  }, tR;
}
var nR, R5;
function x8() {
  if (R5) return nR;
  R5 = 1;
  var n = zie(), e = y8();
  return nR = function(t) {
    var r = n(t, "string");
    return e(r) ? r : r + "";
  }, nR;
}
var rR, M5;
function w8() {
  if (M5) return rR;
  M5 = 1;
  var n = Vs(), e = cg(), t = n.document, r = e(t) && e(t.createElement);
  return rR = function(i) {
    return r ? t.createElement(i) : {};
  }, rR;
}
var iR, A5;
function b8() {
  if (A5) return iR;
  A5 = 1;
  var n = Ch(), e = Ks(), t = w8();
  return iR = !n && !e(function() {
    return Object.defineProperty(t("div"), "a", {
      get: function() {
        return 7;
      }
    }).a !== 7;
  }), iR;
}
var D5;
function C8() {
  if (D5) return wk;
  D5 = 1;
  var n = Ch(), e = Gd(), t = Die(), r = h8(), i = YE(), s = x8(), l = Eh(), c = b8(), d = Object.getOwnPropertyDescriptor;
  return wk.f = n ? d : function(g, y) {
    if (g = i(g), y = s(y), c) try {
      return d(g, y);
    } catch {
    }
    if (l(g, y)) return r(!e(t.f, g, y), g[y]);
  }, wk;
}
var oR = {}, sR, O5;
function E8() {
  if (O5) return sR;
  O5 = 1;
  var n = Ch(), e = Ks();
  return sR = n && e(function() {
    return Object.defineProperty(function() {
    }, "prototype", {
      value: 42,
      writable: !1
    }).prototype !== 42;
  }), sR;
}
var aR, j5;
function ug() {
  if (j5) return aR;
  j5 = 1;
  var n = cg(), e = String, t = TypeError;
  return aR = function(r) {
    if (n(r)) return r;
    throw new t(e(r) + " is not an object");
  }, aR;
}
var L5;
function fw() {
  if (L5) return oR;
  L5 = 1;
  var n = Ch(), e = b8(), t = E8(), r = ug(), i = x8(), s = TypeError, l = Object.defineProperty, c = Object.getOwnPropertyDescriptor, d = "enumerable", h = "configurable", g = "writable";
  return oR.f = n ? t ? function(v, w, C) {
    if (r(v), w = i(w), r(C), typeof v == "function" && w === "prototype" && "value" in C && g in C && !C[g]) {
      var E = c(v, w);
      E && E[g] && (v[w] = C.value, C = {
        configurable: h in C ? C[h] : E[h],
        enumerable: d in C ? C[d] : E[d],
        writable: !1
      });
    }
    return l(v, w, C);
  } : l : function(v, w, C) {
    if (r(v), w = i(w), r(C), e) try {
      return l(v, w, C);
    } catch {
    }
    if ("get" in C || "set" in C) throw new s("Accessors not supported");
    return "value" in C && (v[w] = C.value), v;
  }, oR;
}
var lR, N5;
function bO() {
  if (N5) return lR;
  N5 = 1;
  var n = Ch(), e = fw(), t = h8();
  return lR = n ? function(r, i, s) {
    return e.f(r, i, t(1, s));
  } : function(r, i, s) {
    return r[i] = s, r;
  }, lR;
}
var cR = { exports: {} }, uR, F5;
function Uie() {
  if (F5) return uR;
  F5 = 1;
  var n = Ch(), e = Eh(), t = Function.prototype, r = n && Object.getOwnPropertyDescriptor, i = e(t, "name"), s = i && (function() {
  }).name === "something", l = i && (!n || n && r(t, "name").configurable);
  return uR = {
    EXISTS: i,
    PROPER: s,
    CONFIGURABLE: l
  }, uR;
}
var dR, z5;
function _8() {
  if (z5) return dR;
  z5 = 1;
  var n = go(), e = Ws(), t = xO(), r = n(Function.toString);
  return e(t.inspectSource) || (t.inspectSource = function(i) {
    return r(i);
  }), dR = t.inspectSource, dR;
}
var fR, U5;
function $ie() {
  if (U5) return fR;
  U5 = 1;
  var n = Vs(), e = Ws(), t = n.WeakMap;
  return fR = e(t) && /native code/.test(String(t)), fR;
}
var hR, $5;
function P8() {
  if ($5) return hR;
  $5 = 1;
  var n = wO(), e = S8(), t = n("keys");
  return hR = function(r) {
    return t[r] || (t[r] = e(r));
  }, hR;
}
var pR, B5;
function CO() {
  return B5 || (B5 = 1, pR = {}), pR;
}
var gR, H5;
function T8() {
  if (H5) return gR;
  H5 = 1;
  var n = $ie(), e = Vs(), t = cg(), r = bO(), i = Eh(), s = xO(), l = P8(), c = CO(), d = "Object already initialized", h = e.TypeError, g = e.WeakMap, y, v, w, C = function(k) {
    return w(k) ? v(k) : y(k, {});
  }, E = function(k) {
    return function(L) {
      var O;
      if (!t(L) || (O = v(L)).type !== k)
        throw new h("Incompatible receiver, " + k + " required");
      return O;
    };
  };
  if (n || s.state) {
    var P = s.state || (s.state = new g());
    P.get = P.get, P.has = P.has, P.set = P.set, y = function(k, L) {
      if (P.has(k)) throw new h(d);
      return L.facade = k, P.set(k, L), L;
    }, v = function(k) {
      return P.get(k) || {};
    }, w = function(k) {
      return P.has(k);
    };
  } else {
    var I = l("state");
    c[I] = !0, y = function(k, L) {
      if (i(k, I)) throw new h(d);
      return L.facade = k, r(k, I, L), L;
    }, v = function(k) {
      return i(k, I) ? k[I] : {};
    }, w = function(k) {
      return i(k, I);
    };
  }
  return gR = {
    set: y,
    get: v,
    has: w,
    enforce: C,
    getterFor: E
  }, gR;
}
var V5;
function Bie() {
  if (V5) return cR.exports;
  V5 = 1;
  var n = go(), e = Ks(), t = Ws(), r = Eh(), i = Ch(), s = Uie().CONFIGURABLE, l = _8(), c = T8(), d = c.enforce, h = c.get, g = String, y = Object.defineProperty, v = n("".slice), w = n("".replace), C = n([].join), E = i && !e(function() {
    return y(function() {
    }, "length", { value: 8 }).length !== 8;
  }), P = String(String).split("String"), I = cR.exports = function(k, L, O) {
    v(g(L), 0, 7) === "Symbol(" && (L = "[" + w(g(L), /^Symbol\(([^)]*)\).*$/, "$1") + "]"), O && O.getter && (L = "get " + L), O && O.setter && (L = "set " + L), (!r(k, "name") || s && k.name !== L) && (i ? y(k, "name", { value: L, configurable: !0 }) : k.name = L), E && O && r(O, "arity") && k.length !== O.arity && y(k, "length", { value: O.arity });
    try {
      O && r(O, "constructor") && O.constructor ? i && y(k, "prototype", { writable: !1 }) : k.prototype && (k.prototype = void 0);
    } catch {
    }
    var z = d(k);
    return r(z, "source") || (z.source = C(P, typeof L == "string" ? L : "")), k;
  };
  return Function.prototype.toString = I(function() {
    return t(this) && h(this).source || l(this);
  }, "toString"), cR.exports;
}
var mR, K5;
function I8() {
  if (K5) return mR;
  K5 = 1;
  var n = Ws(), e = fw(), t = Bie(), r = SO();
  return mR = function(i, s, l, c) {
    c || (c = {});
    var d = c.enumerable, h = c.name !== void 0 ? c.name : s;
    if (n(l) && t(l, h, c), c.global)
      d ? i[s] = l : r(s, l);
    else {
      try {
        c.unsafe ? i[s] && (d = !0) : delete i[s];
      } catch {
      }
      d ? i[s] = l : e.f(i, s, {
        value: l,
        enumerable: !1,
        configurable: !c.nonConfigurable,
        writable: !c.nonWritable
      });
    }
    return i;
  }, mR;
}
var yR = {}, vR, W5;
function Hie() {
  if (W5) return vR;
  W5 = 1;
  var n = Math.ceil, e = Math.floor;
  return vR = Math.trunc || function(r) {
    var i = +r;
    return (i > 0 ? e : n)(i);
  }, vR;
}
var SR, G5;
function dg() {
  if (G5) return SR;
  G5 = 1;
  var n = Hie();
  return SR = function(e) {
    var t = +e;
    return t !== t || t === 0 ? 0 : n(t);
  }, SR;
}
var xR, q5;
function Vie() {
  if (q5) return xR;
  q5 = 1;
  var n = dg(), e = Math.max, t = Math.min;
  return xR = function(r, i) {
    var s = n(r);
    return s < 0 ? e(s + i, 0) : t(s, i);
  }, xR;
}
var wR, Y5;
function k8() {
  if (Y5) return wR;
  Y5 = 1;
  var n = dg(), e = Math.min;
  return wR = function(t) {
    var r = n(t);
    return r > 0 ? e(r, 9007199254740991) : 0;
  }, wR;
}
var bR, X5;
function hw() {
  if (X5) return bR;
  X5 = 1;
  var n = k8();
  return bR = function(e) {
    return n(e.length);
  }, bR;
}
var CR, Z5;
function Kie() {
  if (Z5) return CR;
  Z5 = 1;
  var n = YE(), e = Vie(), t = hw(), r = function(i) {
    return function(s, l, c) {
      var d = n(s), h = t(d);
      if (h === 0) return !i && -1;
      var g = e(c, h), y;
      if (i && l !== l) {
        for (; h > g; )
          if (y = d[g++], y !== y) return !0;
      } else for (; h > g; g++)
        if ((i || g in d) && d[g] === l) return i || g || 0;
      return !i && -1;
    };
  };
  return CR = {
    // `Array.prototype.includes` method
    // https://tc39.es/ecma262/#sec-array.prototype.includes
    includes: r(!0),
    // `Array.prototype.indexOf` method
    // https://tc39.es/ecma262/#sec-array.prototype.indexof
    indexOf: r(!1)
  }, CR;
}
var ER, Q5;
function R8() {
  if (Q5) return ER;
  Q5 = 1;
  var n = go(), e = Eh(), t = YE(), r = Kie().indexOf, i = CO(), s = n([].push);
  return ER = function(l, c) {
    var d = t(l), h = 0, g = [], y;
    for (y in d) !e(i, y) && e(d, y) && s(g, y);
    for (; c.length > h; ) e(d, y = c[h++]) && (~r(g, y) || s(g, y));
    return g;
  }, ER;
}
var _R, J5;
function EO() {
  return J5 || (J5 = 1, _R = [
    "constructor",
    "hasOwnProperty",
    "isPrototypeOf",
    "propertyIsEnumerable",
    "toLocaleString",
    "toString",
    "valueOf"
  ]), _R;
}
var ez;
function Wie() {
  if (ez) return yR;
  ez = 1;
  var n = R8(), e = EO(), t = e.concat("length", "prototype");
  return yR.f = Object.getOwnPropertyNames || function(i) {
    return n(i, t);
  }, yR;
}
var PR = {}, tz;
function Gie() {
  return tz || (tz = 1, PR.f = Object.getOwnPropertySymbols), PR;
}
var TR, nz;
function qie() {
  if (nz) return TR;
  nz = 1;
  var n = XE(), e = go(), t = Wie(), r = Gie(), i = ug(), s = e([].concat);
  return TR = n("Reflect", "ownKeys") || function(c) {
    var d = t.f(i(c)), h = r.f;
    return h ? s(d, h(c)) : d;
  }, TR;
}
var IR, rz;
function Yie() {
  if (rz) return IR;
  rz = 1;
  var n = Eh(), e = qie(), t = C8(), r = fw();
  return IR = function(i, s, l) {
    for (var c = e(s), d = r.f, h = t.f, g = 0; g < c.length; g++) {
      var y = c[g];
      !n(i, y) && !(l && n(l, y)) && d(i, y, h(s, y));
    }
  }, IR;
}
var kR, iz;
function Xie() {
  if (iz) return kR;
  iz = 1;
  var n = Ks(), e = Ws(), t = /#|\.prototype\./, r = function(d, h) {
    var g = s[i(d)];
    return g === c ? !0 : g === l ? !1 : e(h) ? n(h) : !!h;
  }, i = r.normalize = function(d) {
    return String(d).replace(t, ".").toLowerCase();
  }, s = r.data = {}, l = r.NATIVE = "N", c = r.POLYFILL = "P";
  return kR = r, kR;
}
var RR, oz;
function Hy() {
  if (oz) return RR;
  oz = 1;
  var n = Vs(), e = C8().f, t = bO(), r = I8(), i = SO(), s = Yie(), l = Xie();
  return RR = function(c, d) {
    var h = c.target, g = c.global, y = c.stat, v, w, C, E, P, I;
    if (g ? w = n : y ? w = n[h] || i(h, {}) : w = n[h] && n[h].prototype, w) for (C in d) {
      if (P = d[C], c.dontCallGetSet ? (I = e(w, C), E = I && I.value) : E = w[C], v = l(g ? C : h + (y ? "." : "#") + C, c.forced), !v && E !== void 0) {
        if (typeof P == typeof E) continue;
        s(P, E);
      }
      (c.sham || E && E.sham) && t(P, "sham", !0), r(w, C, P, c);
    }
  }, RR;
}
var MR = {}, AR, sz;
function Zie() {
  if (sz) return AR;
  sz = 1;
  var n = R8(), e = EO();
  return AR = Object.keys || function(r) {
    return n(r, e);
  }, AR;
}
var az;
function Qie() {
  if (az) return MR;
  az = 1;
  var n = Ch(), e = E8(), t = fw(), r = ug(), i = YE(), s = Zie();
  return MR.f = n && !e ? Object.defineProperties : function(c, d) {
    r(c);
    for (var h = i(d), g = s(d), y = g.length, v = 0, w; y > v; ) t.f(c, w = g[v++], h[w]);
    return c;
  }, MR;
}
var DR, lz;
function Jie() {
  if (lz) return DR;
  lz = 1;
  var n = XE();
  return DR = n("document", "documentElement"), DR;
}
var OR, cz;
function M8() {
  if (cz) return OR;
  cz = 1;
  var n = ug(), e = Qie(), t = EO(), r = CO(), i = Jie(), s = w8(), l = P8(), c = ">", d = "<", h = "prototype", g = "script", y = l("IE_PROTO"), v = function() {
  }, w = function(k) {
    return d + g + c + k + d + "/" + g + c;
  }, C = function(k) {
    k.write(w("")), k.close();
    var L = k.parentWindow.Object;
    return k = null, L;
  }, E = function() {
    var k = s("iframe"), L = "java" + g + ":", O;
    return k.style.display = "none", i.appendChild(k), k.src = String(L), O = k.contentWindow.document, O.open(), O.write(w("document.F=Object")), O.close(), O.F;
  }, P, I = function() {
    try {
      P = new ActiveXObject("htmlfile");
    } catch {
    }
    I = typeof document < "u" ? document.domain && P ? C(P) : E() : C(P);
    for (var k = t.length; k--; ) delete I[h][t[k]];
    return I();
  };
  return r[y] = !0, OR = Object.create || function(L, O) {
    var z;
    return L !== null ? (v[h] = n(L), z = new v(), v[h] = null, z[y] = L) : z = I(), O === void 0 ? z : e.f(z, O);
  }, OR;
}
var jR, uz;
function _O() {
  if (uz) return jR;
  uz = 1;
  var n = qd(), e = M8(), t = fw().f, r = n("unscopables"), i = Array.prototype;
  return i[r] === void 0 && t(i, r, {
    configurable: !0,
    value: e(null)
  }), jR = function(s) {
    i[r][s] = !0;
  }, jR;
}
var dz;
function eoe() {
  if (dz) return qF;
  dz = 1;
  var n = Hy(), e = dw(), t = hw(), r = dg(), i = _O();
  return n({ target: "Array", proto: !0 }, {
    at: function(l) {
      var c = e(this), d = t(c), h = r(l), g = h >= 0 ? h : d + h;
      return g < 0 || g >= d ? void 0 : c[g];
    }
  }), i("at"), qF;
}
var LR, fz;
function pw() {
  if (fz) return LR;
  fz = 1;
  var n = Vs(), e = go();
  return LR = function(t, r) {
    return e(n[t].prototype[r]);
  }, LR;
}
var NR, hz;
function toe() {
  if (hz) return NR;
  hz = 1, eoe();
  var n = pw();
  return NR = n("Array", "at"), NR;
}
var FR, pz;
function noe() {
  if (pz) return FR;
  pz = 1;
  var n = toe();
  return FR = n, FR;
}
noe();
var gz = {}, zR, mz;
function A8() {
  if (mz) return zR;
  mz = 1;
  var n = $y();
  return zR = Array.isArray || function(t) {
    return n(t) === "Array";
  }, zR;
}
var UR, yz;
function roe() {
  if (yz) return UR;
  yz = 1;
  var n = TypeError, e = 9007199254740991;
  return UR = function(t) {
    if (t > e) throw n("Maximum allowed index exceeded");
    return t;
  }, UR;
}
var $R, vz;
function ioe() {
  if (vz) return $R;
  vz = 1;
  var n = $y(), e = go();
  return $R = function(t) {
    if (n(t) === "Function") return e(t);
  }, $R;
}
var BR, Sz;
function ooe() {
  if (Sz) return BR;
  Sz = 1;
  var n = ioe(), e = yO(), t = GE(), r = n(n.bind);
  return BR = function(i, s) {
    return e(i), s === void 0 ? i : t ? r(i, s) : function() {
      return i.apply(s, arguments);
    };
  }, BR;
}
var HR, xz;
function D8() {
  if (xz) return HR;
  xz = 1;
  var n = A8(), e = hw(), t = roe(), r = ooe(), i = function(s, l, c, d, h, g, y, v) {
    for (var w = h, C = 0, E = y ? r(y, v) : !1, P, I; C < d; )
      C in c && (P = E ? E(c[C], C, l) : c[C], g > 0 && n(P) ? (I = e(P), w = i(s, l, P, I, w, g - 1) - 1) : (t(w + 1), s[w] = P), w++), C++;
    return w;
  };
  return HR = i, HR;
}
var VR, wz;
function soe() {
  if (wz) return VR;
  wz = 1;
  var n = qd(), e = n("toStringTag"), t = {};
  return t[e] = "z", VR = String(t) === "[object z]", VR;
}
var KR, bz;
function O8() {
  if (bz) return KR;
  bz = 1;
  var n = soe(), e = Ws(), t = $y(), r = qd(), i = r("toStringTag"), s = Object, l = t(/* @__PURE__ */ function() {
    return arguments;
  }()) === "Arguments", c = function(d, h) {
    try {
      return d[h];
    } catch {
    }
  };
  return KR = n ? t : function(d) {
    var h, g, y;
    return d === void 0 ? "Undefined" : d === null ? "Null" : typeof (g = c(h = s(d), i)) == "string" ? g : l ? t(h) : (y = t(h)) === "Object" && e(h.callee) ? "Arguments" : y;
  }, KR;
}
var WR, Cz;
function aoe() {
  if (Cz) return WR;
  Cz = 1;
  var n = go(), e = Ks(), t = Ws(), r = O8(), i = XE(), s = _8(), l = function() {
  }, c = i("Reflect", "construct"), d = /^\s*(?:class|function)\b/, h = n(d.exec), g = !d.test(l), y = function(C) {
    if (!t(C)) return !1;
    try {
      return c(l, [], C), !0;
    } catch {
      return !1;
    }
  }, v = function(C) {
    if (!t(C)) return !1;
    switch (r(C)) {
      case "AsyncFunction":
      case "GeneratorFunction":
      case "AsyncGeneratorFunction":
        return !1;
    }
    try {
      return g || !!h(d, s(C));
    } catch {
      return !0;
    }
  };
  return v.sham = !0, WR = !c || e(function() {
    var w;
    return y(y.call) || !y(Object) || !y(function() {
      w = !0;
    }) || w;
  }) ? v : y, WR;
}
var GR, Ez;
function loe() {
  if (Ez) return GR;
  Ez = 1;
  var n = A8(), e = aoe(), t = cg(), r = qd(), i = r("species"), s = Array;
  return GR = function(l) {
    var c;
    return n(l) && (c = l.constructor, e(c) && (c === s || n(c.prototype)) ? c = void 0 : t(c) && (c = c[i], c === null && (c = void 0))), c === void 0 ? s : c;
  }, GR;
}
var qR, _z;
function j8() {
  if (_z) return qR;
  _z = 1;
  var n = loe();
  return qR = function(e, t) {
    return new (n(e))(t === 0 ? 0 : t);
  }, qR;
}
var Pz;
function coe() {
  if (Pz) return gz;
  Pz = 1;
  var n = Hy(), e = D8(), t = yO(), r = dw(), i = hw(), s = j8();
  return n({ target: "Array", proto: !0 }, {
    flatMap: function(c) {
      var d = r(this), h = i(d), g;
      return t(c), g = s(d, 0), g.length = e(g, d, d, h, 0, 1, c, arguments.length > 1 ? arguments[1] : void 0), g;
    }
  }), gz;
}
var Tz = {}, Iz;
function uoe() {
  if (Iz) return Tz;
  Iz = 1;
  var n = _O();
  return n("flatMap"), Tz;
}
var YR, kz;
function doe() {
  if (kz) return YR;
  kz = 1, coe(), uoe();
  var n = pw();
  return YR = n("Array", "flatMap"), YR;
}
var XR, Rz;
function foe() {
  if (Rz) return XR;
  Rz = 1;
  var n = doe();
  return XR = n, XR;
}
foe();
var Mz = {}, Az;
function hoe() {
  if (Az) return Mz;
  Az = 1;
  var n = Hy(), e = D8(), t = dw(), r = hw(), i = dg(), s = j8();
  return n({ target: "Array", proto: !0 }, {
    flat: function() {
      var c = arguments.length ? arguments[0] : void 0, d = t(this), h = r(d), g = s(d, 0);
      return g.length = e(g, d, d, h, 0, c === void 0 ? 1 : i(c)), g;
    }
  }), Mz;
}
var Dz = {}, Oz;
function poe() {
  if (Oz) return Dz;
  Oz = 1;
  var n = _O();
  return n("flat"), Dz;
}
var ZR, jz;
function goe() {
  if (jz) return ZR;
  jz = 1, hoe(), poe();
  var n = pw();
  return ZR = n("Array", "flat"), ZR;
}
var QR, Lz;
function moe() {
  if (Lz) return QR;
  Lz = 1;
  var n = goe();
  return QR = n, QR;
}
moe();
var Nz = {}, JR, Fz;
function gw() {
  if (Fz) return JR;
  Fz = 1;
  var n = O8(), e = String;
  return JR = function(t) {
    if (n(t) === "Symbol") throw new TypeError("Cannot convert a Symbol value to a string");
    return e(t);
  }, JR;
}
var zz;
function yoe() {
  if (zz) return Nz;
  zz = 1;
  var n = Hy(), e = go(), t = By(), r = dg(), i = gw(), s = Ks(), l = e("".charAt), c = s(function() {
    return "𠮷".at(-2) !== "\uD842";
  });
  return n({ target: "String", proto: !0, forced: c }, {
    at: function(h) {
      var g = i(t(this)), y = g.length, v = r(h), w = v >= 0 ? v : y + v;
      return w < 0 || w >= y ? void 0 : l(g, w);
    }
  }), Nz;
}
var eM, Uz;
function voe() {
  if (Uz) return eM;
  Uz = 1, yoe();
  var n = pw();
  return eM = n("String", "at"), eM;
}
var tM, $z;
function Soe() {
  if ($z) return tM;
  $z = 1;
  var n = voe();
  return tM = n, tM;
}
Soe();
var Bz = {}, nM, Hz;
function L8() {
  if (Hz) return nM;
  Hz = 1;
  var n = ug();
  return nM = function() {
    var e = n(this), t = "";
    return e.hasIndices && (t += "d"), e.global && (t += "g"), e.ignoreCase && (t += "i"), e.multiline && (t += "m"), e.dotAll && (t += "s"), e.unicode && (t += "u"), e.unicodeSets && (t += "v"), e.sticky && (t += "y"), t;
  }, nM;
}
var rM, Vz;
function xoe() {
  if (Vz) return rM;
  Vz = 1;
  var n = Ks(), e = Vs(), t = e.RegExp, r = n(function() {
    var l = t("a", "y");
    return l.lastIndex = 2, l.exec("abcd") !== null;
  }), i = r || n(function() {
    return !t("a", "y").sticky;
  }), s = r || n(function() {
    var l = t("^r", "gy");
    return l.lastIndex = 2, l.exec("str") !== null;
  });
  return rM = {
    BROKEN_CARET: s,
    MISSED_STICKY: i,
    UNSUPPORTED_Y: r
  }, rM;
}
var iM, Kz;
function woe() {
  if (Kz) return iM;
  Kz = 1;
  var n = Ks(), e = Vs(), t = e.RegExp;
  return iM = n(function() {
    var r = t(".", "s");
    return !(r.dotAll && r.test(`
`) && r.flags === "s");
  }), iM;
}
var oM, Wz;
function boe() {
  if (Wz) return oM;
  Wz = 1;
  var n = Ks(), e = Vs(), t = e.RegExp;
  return oM = n(function() {
    var r = t("(?<a>b)", "g");
    return r.exec("b").groups.a !== "b" || "b".replace(r, "$<a>c") !== "bc";
  }), oM;
}
var sM, Gz;
function PO() {
  if (Gz) return sM;
  Gz = 1;
  var n = Gd(), e = go(), t = gw(), r = L8(), i = xoe(), s = wO(), l = M8(), c = T8().get, d = woe(), h = boe(), g = s("native-string-replace", String.prototype.replace), y = RegExp.prototype.exec, v = y, w = e("".charAt), C = e("".indexOf), E = e("".replace), P = e("".slice), I = function() {
    var z = /a/, F = /b*/g;
    return n(y, z, "a"), n(y, F, "a"), z.lastIndex !== 0 || F.lastIndex !== 0;
  }(), k = i.BROKEN_CARET, L = /()??/.exec("")[1] !== void 0, O = I || L || k || d || h;
  return O && (v = function(F) {
    var H = this, V = c(H), re = t(F), q = V.raw, J, ie, W, Y, oe, le, ce;
    if (q)
      return q.lastIndex = H.lastIndex, J = n(v, q, re), H.lastIndex = q.lastIndex, J;
    var Q = V.groups, he = k && H.sticky, ke = n(r, H), te = H.source, me = 0, Oe = re;
    if (he && (ke = E(ke, "y", ""), C(ke, "g") === -1 && (ke += "g"), Oe = P(re, H.lastIndex), H.lastIndex > 0 && (!H.multiline || H.multiline && w(re, H.lastIndex - 1) !== `
`) && (te = "(?: " + te + ")", Oe = " " + Oe, me++), ie = new RegExp("^(?:" + te + ")", ke)), L && (ie = new RegExp("^" + te + "$(?!\\s)", ke)), I && (W = H.lastIndex), Y = n(y, he ? ie : H, Oe), he ? Y ? (Y.input = P(Y.input, me), Y[0] = P(Y[0], me), Y.index = H.lastIndex, H.lastIndex += Y[0].length) : H.lastIndex = 0 : I && Y && (H.lastIndex = H.global ? Y.index + Y[0].length : W), L && Y && Y.length > 1 && n(g, Y[0], ie, function() {
      for (oe = 1; oe < arguments.length - 2; oe++)
        arguments[oe] === void 0 && (Y[oe] = void 0);
    }), Y && Q)
      for (Y.groups = le = l(null), oe = 0; oe < Q.length; oe++)
        ce = Q[oe], le[ce[0]] = Y[ce[1]];
    return Y;
  }), sM = v, sM;
}
var qz;
function N8() {
  if (qz) return Bz;
  qz = 1;
  var n = Hy(), e = PO();
  return n({ target: "RegExp", proto: !0, forced: /./.exec !== e }, {
    exec: e
  }), Bz;
}
var Yz = {}, aM, Xz;
function Coe() {
  if (Xz) return aM;
  Xz = 1;
  var n = GE(), e = Function.prototype, t = e.apply, r = e.call;
  return aM = typeof Reflect == "object" && Reflect.apply || (n ? r.bind(t) : function() {
    return r.apply(t, arguments);
  }), aM;
}
var lM, Zz;
function Eoe() {
  if (Zz) return lM;
  Zz = 1, N8();
  var n = Gd(), e = I8(), t = PO(), r = Ks(), i = qd(), s = bO(), l = i("species"), c = RegExp.prototype;
  return lM = function(d, h, g, y) {
    var v = i(d), w = !r(function() {
      var I = {};
      return I[v] = function() {
        return 7;
      }, ""[d](I) !== 7;
    }), C = w && !r(function() {
      var I = !1, k = /a/;
      return d === "split" && (k = {}, k.constructor = {}, k.constructor[l] = function() {
        return k;
      }, k.flags = "", k[v] = /./[v]), k.exec = function() {
        return I = !0, null;
      }, k[v](""), !I;
    });
    if (!w || !C || g) {
      var E = /./[v], P = h(v, ""[d], function(I, k, L, O, z) {
        var F = k.exec;
        return F === t || F === c.exec ? w && !z ? { done: !0, value: n(E, k, L, O) } : { done: !0, value: n(I, L, k, O) } : { done: !1 };
      });
      e(String.prototype, d, P[0]), e(c, v, P[1]);
    }
    y && s(c[v], "sham", !0);
  }, lM;
}
var cM, Qz;
function _oe() {
  if (Qz) return cM;
  Qz = 1;
  var n = go(), e = dg(), t = gw(), r = By(), i = n("".charAt), s = n("".charCodeAt), l = n("".slice), c = function(d) {
    return function(h, g) {
      var y = t(r(h)), v = e(g), w = y.length, C, E;
      return v < 0 || v >= w ? d ? "" : void 0 : (C = s(y, v), C < 55296 || C > 56319 || v + 1 === w || (E = s(y, v + 1)) < 56320 || E > 57343 ? d ? i(y, v) : C : d ? l(y, v, v + 2) : (C - 55296 << 10) + (E - 56320) + 65536);
    };
  };
  return cM = {
    // `String.prototype.codePointAt` method
    // https://tc39.es/ecma262/#sec-string.prototype.codepointat
    codeAt: c(!1),
    // `String.prototype.at` method
    // https://github.com/mathiasbynens/String.prototype.at
    charAt: c(!0)
  }, cM;
}
var uM, Jz;
function Poe() {
  if (Jz) return uM;
  Jz = 1;
  var n = _oe().charAt;
  return uM = function(e, t, r) {
    return t + (r ? n(e, t).length : 1);
  }, uM;
}
var dM, e4;
function F8() {
  if (e4) return dM;
  e4 = 1;
  var n = go(), e = dw(), t = Math.floor, r = n("".charAt), i = n("".replace), s = n("".slice), l = /\$([$&'`]|\d{1,2}|<[^>]*>)/g, c = /\$([$&'`]|\d{1,2})/g;
  return dM = function(d, h, g, y, v, w) {
    var C = g + d.length, E = y.length, P = c;
    return v !== void 0 && (v = e(v), P = l), i(w, P, function(I, k) {
      var L;
      switch (r(k, 0)) {
        case "$":
          return "$";
        case "&":
          return d;
        case "`":
          return s(h, 0, g);
        case "'":
          return s(h, C);
        case "<":
          L = v[s(k, 1, -1)];
          break;
        default:
          var O = +k;
          if (O === 0) return I;
          if (O > E) {
            var z = t(O / 10);
            return z === 0 ? I : z <= E ? y[z - 1] === void 0 ? r(k, 1) : y[z - 1] + r(k, 1) : I;
          }
          L = y[O - 1];
      }
      return L === void 0 ? "" : L;
    });
  }, dM;
}
var fM, t4;
function Toe() {
  if (t4) return fM;
  t4 = 1;
  var n = Gd(), e = ug(), t = Ws(), r = $y(), i = PO(), s = TypeError;
  return fM = function(l, c) {
    var d = l.exec;
    if (t(d)) {
      var h = n(d, l, c);
      return h !== null && e(h), h;
    }
    if (r(l) === "RegExp") return n(i, l, c);
    throw new s("RegExp#exec called on incompatible receiver");
  }, fM;
}
var n4;
function Ioe() {
  if (n4) return Yz;
  n4 = 1;
  var n = Coe(), e = Gd(), t = go(), r = Eoe(), i = Ks(), s = ug(), l = Ws(), c = qE(), d = dg(), h = k8(), g = gw(), y = By(), v = Poe(), w = vO(), C = F8(), E = Toe(), P = qd(), I = P("replace"), k = Math.max, L = Math.min, O = t([].concat), z = t([].push), F = t("".indexOf), H = t("".slice), V = function(ie) {
    return ie === void 0 ? ie : String(ie);
  }, re = function() {
    return "a".replace(/./, "$0") === "$0";
  }(), q = function() {
    return /./[I] ? /./[I]("a", "$0") === "" : !1;
  }(), J = !i(function() {
    var ie = /./;
    return ie.exec = function() {
      var W = [];
      return W.groups = { a: "7" }, W;
    }, "".replace(ie, "$<a>") !== "7";
  });
  return r("replace", function(ie, W, Y) {
    var oe = q ? "$" : "$0";
    return [
      // `String.prototype.replace` method
      // https://tc39.es/ecma262/#sec-string.prototype.replace
      function(ce, Q) {
        var he = y(this), ke = c(ce) ? void 0 : w(ce, I);
        return ke ? e(ke, ce, he, Q) : e(W, g(he), ce, Q);
      },
      // `RegExp.prototype[@@replace]` method
      // https://tc39.es/ecma262/#sec-regexp.prototype-@@replace
      function(le, ce) {
        var Q = s(this), he = g(le);
        if (typeof ce == "string" && F(ce, oe) === -1 && F(ce, "$<") === -1) {
          var ke = Y(W, Q, he, ce);
          if (ke.done) return ke.value;
        }
        var te = l(ce);
        te || (ce = g(ce));
        var me = Q.global, Oe;
        me && (Oe = Q.unicode, Q.lastIndex = 0);
        for (var Ze = [], De; De = E(Q, he), !(De === null || (z(Ze, De), !me)); ) {
          var yt = g(De[0]);
          yt === "" && (Q.lastIndex = v(he, h(Q.lastIndex), Oe));
        }
        for (var it = "", We = 0, Qe = 0; Qe < Ze.length; Qe++) {
          De = Ze[Qe];
          for (var gt = g(De[0]), Pt = k(L(d(De.index), he.length), 0), mn = [], Zt, an = 1; an < De.length; an++) z(mn, V(De[an]));
          var ln = De.groups;
          if (te) {
            var Yt = O([gt], mn, Pt, he);
            ln !== void 0 && z(Yt, ln), Zt = g(n(ce, void 0, Yt));
          } else
            Zt = C(gt, he, Pt, mn, ln, ce);
          Pt >= We && (it += H(he, We, Pt) + Zt, We = Pt + gt.length);
        }
        return it + H(he, We);
      }
    ];
  }, !J || !re || q), Yz;
}
var r4 = {}, hM, i4;
function koe() {
  if (i4) return hM;
  i4 = 1;
  var n = cg(), e = $y(), t = qd(), r = t("match");
  return hM = function(i) {
    var s;
    return n(i) && ((s = i[r]) !== void 0 ? !!s : e(i) === "RegExp");
  }, hM;
}
var pM, o4;
function Roe() {
  if (o4) return pM;
  o4 = 1;
  var n = Gd(), e = Eh(), t = p8(), r = L8(), i = RegExp.prototype;
  return pM = function(s) {
    var l = s.flags;
    return l === void 0 && !("flags" in i) && !e(s, "flags") && t(i, s) ? n(r, s) : l;
  }, pM;
}
var s4;
function Moe() {
  if (s4) return r4;
  s4 = 1;
  var n = Hy(), e = Gd(), t = go(), r = By(), i = Ws(), s = qE(), l = koe(), c = gw(), d = vO(), h = Roe(), g = F8(), y = qd(), v = v8(), w = y("replace"), C = TypeError, E = t("".indexOf), P = t("".replace), I = t("".slice), k = Math.max;
  return n({ target: "String", proto: !0 }, {
    replaceAll: function(O, z) {
      var F = r(this), H, V, re, q, J, ie, W, Y, oe, le, ce = 0, Q = "";
      if (!s(O)) {
        if (H = l(O), H && (V = c(r(h(O))), !~E(V, "g")))
          throw new C("`.replaceAll` does not allow non-global regexes");
        if (re = d(O, w), re) return e(re, O, F, z);
        if (v && H) return P(c(F), O, z);
      }
      for (q = c(F), J = c(O), ie = i(z), ie || (z = c(z)), W = J.length, Y = k(1, W), oe = E(q, J); oe !== -1; )
        le = ie ? c(z(J, oe, q)) : g(J, q, oe, [], void 0, z), Q += I(q, ce, oe) + le, ce = oe + W, oe = oe + Y > q.length ? -1 : E(q, J, oe + Y);
      return ce < q.length && (Q += I(q, ce)), Q;
    }
  }), r4;
}
var gM, a4;
function Aoe() {
  if (a4) return gM;
  a4 = 1, N8(), Ioe(), Moe();
  var n = pw();
  return gM = n("String", "replaceAll"), gM;
}
var mM, l4;
function Doe() {
  if (l4) return mM;
  l4 = 1;
  var n = Aoe();
  return mM = n, mM;
}
Doe();
const Ooe = (n, e) => e.some((t) => n instanceof t);
let c4, u4;
function joe() {
  return c4 || (c4 = [
    IDBDatabase,
    IDBObjectStore,
    IDBIndex,
    IDBCursor,
    IDBTransaction
  ]);
}
function Loe() {
  return u4 || (u4 = [
    IDBCursor.prototype.advance,
    IDBCursor.prototype.continue,
    IDBCursor.prototype.continuePrimaryKey
  ]);
}
const z8 = /* @__PURE__ */ new WeakMap(), HA = /* @__PURE__ */ new WeakMap(), U8 = /* @__PURE__ */ new WeakMap(), yM = /* @__PURE__ */ new WeakMap(), TO = /* @__PURE__ */ new WeakMap();
function Noe(n) {
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("success", s), n.removeEventListener("error", l);
    }, s = () => {
      t(zd(n.result)), i();
    }, l = () => {
      r(n.error), i();
    };
    n.addEventListener("success", s), n.addEventListener("error", l);
  });
  return e.then((t) => {
    t instanceof IDBCursor && z8.set(t, n);
  }).catch(() => {
  }), TO.set(e, n), e;
}
function Foe(n) {
  if (HA.has(n))
    return;
  const e = new Promise((t, r) => {
    const i = () => {
      n.removeEventListener("complete", s), n.removeEventListener("error", l), n.removeEventListener("abort", l);
    }, s = () => {
      t(), i();
    }, l = () => {
      r(n.error || new DOMException("AbortError", "AbortError")), i();
    };
    n.addEventListener("complete", s), n.addEventListener("error", l), n.addEventListener("abort", l);
  });
  HA.set(n, e);
}
let VA = {
  get(n, e, t) {
    if (n instanceof IDBTransaction) {
      if (e === "done")
        return HA.get(n);
      if (e === "objectStoreNames")
        return n.objectStoreNames || U8.get(n);
      if (e === "store")
        return t.objectStoreNames[1] ? void 0 : t.objectStore(t.objectStoreNames[0]);
    }
    return zd(n[e]);
  },
  set(n, e, t) {
    return n[e] = t, !0;
  },
  has(n, e) {
    return n instanceof IDBTransaction && (e === "done" || e === "store") ? !0 : e in n;
  }
};
function zoe(n) {
  VA = n(VA);
}
function Uoe(n) {
  return n === IDBDatabase.prototype.transaction && !("objectStoreNames" in IDBTransaction.prototype) ? function(e, ...t) {
    const r = n.call(vM(this), e, ...t);
    return U8.set(r, e.sort ? e.sort() : [e]), zd(r);
  } : Loe().includes(n) ? function(...e) {
    return n.apply(vM(this), e), zd(z8.get(this));
  } : function(...e) {
    return zd(n.apply(vM(this), e));
  };
}
function $oe(n) {
  return typeof n == "function" ? Uoe(n) : (n instanceof IDBTransaction && Foe(n), Ooe(n, joe()) ? new Proxy(n, VA) : n);
}
function zd(n) {
  if (n instanceof IDBRequest)
    return Noe(n);
  if (yM.has(n))
    return yM.get(n);
  const e = $oe(n);
  return e !== n && (yM.set(n, e), TO.set(e, n)), e;
}
const vM = (n) => TO.get(n);
function $8(n, e, { blocked: t, upgrade: r, blocking: i, terminated: s } = {}) {
  const l = indexedDB.open(n, e), c = zd(l);
  return r && l.addEventListener("upgradeneeded", (d) => {
    r(zd(l.result), d.oldVersion, d.newVersion, zd(l.transaction), d);
  }), t && l.addEventListener("blocked", (d) => t(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    d.oldVersion,
    d.newVersion,
    d
  )), c.then((d) => {
    s && d.addEventListener("close", () => s()), i && d.addEventListener("versionchange", (h) => i(h.oldVersion, h.newVersion, h));
  }).catch(() => {
  }), c;
}
function B8(n, { blocked: e } = {}) {
  const t = indexedDB.deleteDatabase(n);
  return e && t.addEventListener("blocked", (r) => e(
    // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405
    r.oldVersion,
    r
  )), zd(t).then(() => {
  });
}
const Boe = ["get", "getKey", "getAll", "getAllKeys", "count"], Hoe = ["put", "add", "delete", "clear"], SM = /* @__PURE__ */ new Map();
function d4(n, e) {
  if (!(n instanceof IDBDatabase && !(e in n) && typeof e == "string"))
    return;
  if (SM.get(e))
    return SM.get(e);
  const t = e.replace(/FromIndex$/, ""), r = e !== t, i = Hoe.includes(t);
  if (
    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.
    !(t in (r ? IDBIndex : IDBObjectStore).prototype) || !(i || Boe.includes(t))
  )
    return;
  const s = async function(l, ...c) {
    const d = this.transaction(l, i ? "readwrite" : "readonly");
    let h = d.store;
    return r && (h = h.index(c.shift())), (await Promise.all([
      h[t](...c),
      i && d.done
    ]))[0];
  };
  return SM.set(e, s), s;
}
zoe((n) => ({
  ...n,
  get: (e, t, r) => d4(e, t) || n.get(e, t, r),
  has: (e, t) => !!d4(e, t) || n.has(e, t)
}));
const Voe = "TLDRAW_DOCUMENT_v2", Koe = "TLDRAW_ASSET_STORE_v1", H8 = "TLDRAW_DB_NAME_INDEX_v2", On = {
  Records: "records",
  Schema: "schema",
  SessionState: "session_state",
  Assets: "assets"
};
async function V8(n) {
  const e = Voe + n;
  return Goe(e), await $8(e, 4, {
    upgrade(t) {
      t.objectStoreNames.contains(On.Records) || t.createObjectStore(On.Records), t.objectStoreNames.contains(On.Schema) || t.createObjectStore(On.Schema), t.objectStoreNames.contains(On.SessionState) || t.createObjectStore(On.SessionState), t.objectStoreNames.contains(On.Assets) || t.createObjectStore(On.Assets);
    }
  });
}
async function Woe(n) {
  const e = window.indexedDB.databases ? (await window.indexedDB.databases()).map((v) => v.name) : IO(), t = Koe + n;
  if (!e.find((v) => v === t)) return;
  const i = await $8(t, 1, {
    upgrade(v) {
      v.objectStoreNames.contains("assets") || v.createObjectStore("assets");
    }
  });
  if (!i.objectStoreNames.contains("assets")) return;
  const s = i.transaction(["assets"], "readonly"), l = s.objectStore("assets"), c = await l.getAllKeys(), d = await Promise.all(
    c.map(async (v) => [v, await l.get(v)])
  );
  await s.done;
  const h = await V8(n), g = h.transaction([On.Assets], "readwrite"), y = g.objectStore(On.Assets);
  for (const [v, w] of d)
    y.put(w, v);
  await g.done, i.close(), h.close(), await B8(t);
}
const Ux = class Ux {
  constructor(e) {
    U(this, "getDbPromise");
    U(this, "isClosed", !1);
    U(this, "pendingTransactionSet", /* @__PURE__ */ new Set());
    Ux.connectedInstances.add(this), this.getDbPromise = (async () => (await Woe(e), await V8(e)))();
  }
  getDb() {
    return this.getDbPromise;
  }
  /**
   * Wait for any pending transactions to be completed. Useful for tests.
   *
   * @internal
   */
  pending() {
    return Promise.allSettled([this.getDbPromise, ...this.pendingTransactionSet]).then($x);
  }
  async close() {
    this.isClosed || (this.isClosed = !0, await this.pending(), (await this.getDb()).close(), Ux.connectedInstances.delete(this));
  }
  tx(e, t, r) {
    const i = (async () => {
      on(!this.isClosed, "db is closed");
      const l = (await this.getDb()).transaction(t, e), c = l.done.catch((d) => {
        if (!this.isClosed)
          throw d;
      });
      try {
        return await r(l);
      } finally {
        this.isClosed ? l.abort() : await c;
      }
    })();
    return this.pendingTransactionSet.add(i), i.finally(() => this.pendingTransactionSet.delete(i)), i;
  }
  async load({ sessionId: e } = {}) {
    return await this.tx(
      "readonly",
      [On.Records, On.Schema, On.SessionState],
      async (t) => {
        var d, h;
        const r = t.objectStore(On.Records), i = t.objectStore(On.Schema), s = t.objectStore(On.SessionState);
        let l = e ? (d = await s.get(e)) == null ? void 0 : d.snapshot : null;
        return l || (l = (h = (await s.getAll()).sort((y, v) => y.updatedAt - v.updatedAt).pop()) == null ? void 0 : h.snapshot), {
          records: await r.getAll(),
          schema: await i.get(On.Schema),
          sessionStateSnapshot: l
        };
      }
    );
  }
  async storeChanges({
    schema: e,
    changes: t,
    sessionId: r,
    sessionStateSnapshot: i
  }) {
    await this.tx("readwrite", [On.Records, On.Schema, On.SessionState], async (s) => {
      const l = s.objectStore(On.Records), c = s.objectStore(On.Schema), d = s.objectStore(On.SessionState);
      for (const [h, g] of Object.entries(t.added))
        await l.put(g, h);
      for (const [h, g] of Object.values(t.updated))
        await l.put(g, g.id);
      for (const h of Object.keys(t.removed))
        await l.delete(h);
      c.put(e.serialize(), On.Schema), i && r ? d.put(
        {
          snapshot: i,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (i || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async storeSnapshot({
    schema: e,
    snapshot: t,
    sessionId: r,
    sessionStateSnapshot: i
  }) {
    await this.tx("readwrite", [On.Records, On.Schema, On.SessionState], async (s) => {
      const l = s.objectStore(On.Records), c = s.objectStore(On.Schema), d = s.objectStore(On.SessionState);
      await l.clear();
      for (const [h, g] of Object.entries(t))
        await l.put(g, h);
      c.put(e.serialize(), On.Schema), i && r ? d.put(
        {
          snapshot: i,
          updatedAt: Date.now(),
          id: r
        },
        r
      ) : (i || r) && console.error("sessionStateSnapshot and instanceId must be provided together");
    });
  }
  async pruneSessions() {
    await this.tx("readwrite", [On.SessionState], async (e) => {
      const t = e.objectStore(On.SessionState), r = (await t.getAll()).sort((s, l) => s.updatedAt - l.updatedAt);
      if (r.length < 10) {
        await e.done;
        return;
      }
      const i = r.slice(0, r.length - 10);
      for (const { id: s } of i)
        await t.delete(s);
    });
  }
  async getAsset(e) {
    return await this.tx("readonly", [On.Assets], async (t) => await t.objectStore(On.Assets).get(e));
  }
  async storeAsset(e, t) {
    await this.tx("readwrite", [On.Assets], async (r) => {
      await r.objectStore(On.Assets).put(t, e);
    });
  }
};
/** @internal */
U(Ux, "connectedInstances", /* @__PURE__ */ new Set());
let mE = Ux;
function IO() {
  const n = JSON.parse(eO(H8) || "[]") ?? [];
  return Array.isArray(n) ? n : [];
}
function Goe(n) {
  const e = new Set(IO());
  e.add(n), tO(H8, JSON.stringify([...e]));
}
var z1 = { exports: {} }, sx = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f4;
function qoe() {
  if (f4) return sx;
  f4 = 1;
  var n = aw(), e = Symbol.for("react.element"), t = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, i = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, s = { key: !0, ref: !0, __self: !0, __source: !0 };
  function l(c, d, h) {
    var g, y = {}, v = null, w = null;
    h !== void 0 && (v = "" + h), d.key !== void 0 && (v = "" + d.key), d.ref !== void 0 && (w = d.ref);
    for (g in d) r.call(d, g) && !s.hasOwnProperty(g) && (y[g] = d[g]);
    if (c && c.defaultProps) for (g in d = c.defaultProps, d) y[g] === void 0 && (y[g] = d[g]);
    return { $$typeof: e, type: c, key: v, ref: w, props: y, _owner: i.current };
  }
  return sx.Fragment = t, sx.jsx = l, sx.jsxs = l, sx;
}
var ax = {}, h4;
function Yoe() {
  if (h4) return ax;
  h4 = 1;
  var n = {};
  /**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  return n.NODE_ENV !== "production" && function() {
    var e = aw(), t = Symbol.for("react.element"), r = Symbol.for("react.portal"), i = Symbol.for("react.fragment"), s = Symbol.for("react.strict_mode"), l = Symbol.for("react.profiler"), c = Symbol.for("react.provider"), d = Symbol.for("react.context"), h = Symbol.for("react.forward_ref"), g = Symbol.for("react.suspense"), y = Symbol.for("react.suspense_list"), v = Symbol.for("react.memo"), w = Symbol.for("react.lazy"), C = Symbol.for("react.offscreen"), E = Symbol.iterator, P = "@@iterator";
    function I(se) {
      if (se === null || typeof se != "object")
        return null;
      var Ue = E && se[E] || se[P];
      return typeof Ue == "function" ? Ue : null;
    }
    var k = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(se) {
      {
        for (var Ue = arguments.length, tt = new Array(Ue > 1 ? Ue - 1 : 0), rt = 1; rt < Ue; rt++)
          tt[rt - 1] = arguments[rt];
        O("error", se, tt);
      }
    }
    function O(se, Ue, tt) {
      {
        var rt = k.ReactDebugCurrentFrame, zt = rt.getStackAddendum();
        zt !== "" && (Ue += "%s", tt = tt.concat([zt]));
        var Vt = tt.map(function(un) {
          return String(un);
        });
        Vt.unshift("Warning: " + Ue), Function.prototype.apply.call(console[se], console, Vt);
      }
    }
    var z = !1, F = !1, H = !1, V = !1, re = !1, q;
    q = Symbol.for("react.module.reference");
    function J(se) {
      return !!(typeof se == "string" || typeof se == "function" || se === i || se === l || re || se === s || se === g || se === y || V || se === C || z || F || H || typeof se == "object" && se !== null && (se.$$typeof === w || se.$$typeof === v || se.$$typeof === c || se.$$typeof === d || se.$$typeof === h || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      se.$$typeof === q || se.getModuleId !== void 0));
    }
    function ie(se, Ue, tt) {
      var rt = se.displayName;
      if (rt)
        return rt;
      var zt = Ue.displayName || Ue.name || "";
      return zt !== "" ? tt + "(" + zt + ")" : tt;
    }
    function W(se) {
      return se.displayName || "Context";
    }
    function Y(se) {
      if (se == null)
        return null;
      if (typeof se.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof se == "function")
        return se.displayName || se.name || null;
      if (typeof se == "string")
        return se;
      switch (se) {
        case i:
          return "Fragment";
        case r:
          return "Portal";
        case l:
          return "Profiler";
        case s:
          return "StrictMode";
        case g:
          return "Suspense";
        case y:
          return "SuspenseList";
      }
      if (typeof se == "object")
        switch (se.$$typeof) {
          case d:
            var Ue = se;
            return W(Ue) + ".Consumer";
          case c:
            var tt = se;
            return W(tt._context) + ".Provider";
          case h:
            return ie(se, se.render, "ForwardRef");
          case v:
            var rt = se.displayName || null;
            return rt !== null ? rt : Y(se.type) || "Memo";
          case w: {
            var zt = se, Vt = zt._payload, un = zt._init;
            try {
              return Y(un(Vt));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var oe = Object.assign, le = 0, ce, Q, he, ke, te, me, Oe;
    function Ze() {
    }
    Ze.__reactDisabledLog = !0;
    function De() {
      {
        if (le === 0) {
          ce = console.log, Q = console.info, he = console.warn, ke = console.error, te = console.group, me = console.groupCollapsed, Oe = console.groupEnd;
          var se = {
            configurable: !0,
            enumerable: !0,
            value: Ze,
            writable: !0
          };
          Object.defineProperties(console, {
            info: se,
            log: se,
            warn: se,
            error: se,
            group: se,
            groupCollapsed: se,
            groupEnd: se
          });
        }
        le++;
      }
    }
    function yt() {
      {
        if (le--, le === 0) {
          var se = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: oe({}, se, {
              value: ce
            }),
            info: oe({}, se, {
              value: Q
            }),
            warn: oe({}, se, {
              value: he
            }),
            error: oe({}, se, {
              value: ke
            }),
            group: oe({}, se, {
              value: te
            }),
            groupCollapsed: oe({}, se, {
              value: me
            }),
            groupEnd: oe({}, se, {
              value: Oe
            })
          });
        }
        le < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var it = k.ReactCurrentDispatcher, We;
    function Qe(se, Ue, tt) {
      {
        if (We === void 0)
          try {
            throw Error();
          } catch (zt) {
            var rt = zt.stack.trim().match(/\n( *(at )?)/);
            We = rt && rt[1] || "";
          }
        return `
` + We + se;
      }
    }
    var gt = !1, Pt;
    {
      var mn = typeof WeakMap == "function" ? WeakMap : Map;
      Pt = new mn();
    }
    function Zt(se, Ue) {
      if (!se || gt)
        return "";
      {
        var tt = Pt.get(se);
        if (tt !== void 0)
          return tt;
      }
      var rt;
      gt = !0;
      var zt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var Vt;
      Vt = it.current, it.current = null, De();
      try {
        if (Ue) {
          var un = function() {
            throw Error();
          };
          if (Object.defineProperty(un.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(un, []);
            } catch (yr) {
              rt = yr;
            }
            Reflect.construct(se, [], un);
          } else {
            try {
              un.call();
            } catch (yr) {
              rt = yr;
            }
            se.call(un.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (yr) {
            rt = yr;
          }
          se();
        }
      } catch (yr) {
        if (yr && rt && typeof yr.stack == "string") {
          for (var en = yr.stack.split(`
`), Lr = rt.stack.split(`
`), ar = en.length - 1, zn = Lr.length - 1; ar >= 1 && zn >= 0 && en[ar] !== Lr[zn]; )
            zn--;
          for (; ar >= 1 && zn >= 0; ar--, zn--)
            if (en[ar] !== Lr[zn]) {
              if (ar !== 1 || zn !== 1)
                do
                  if (ar--, zn--, zn < 0 || en[ar] !== Lr[zn]) {
                    var Mi = `
` + en[ar].replace(" at new ", " at ");
                    return se.displayName && Mi.includes("<anonymous>") && (Mi = Mi.replace("<anonymous>", se.displayName)), typeof se == "function" && Pt.set(se, Mi), Mi;
                  }
                while (ar >= 1 && zn >= 0);
              break;
            }
        }
      } finally {
        gt = !1, it.current = Vt, yt(), Error.prepareStackTrace = zt;
      }
      var Es = se ? se.displayName || se.name : "", Un = Es ? Qe(Es) : "";
      return typeof se == "function" && Pt.set(se, Un), Un;
    }
    function an(se, Ue, tt) {
      return Zt(se, !1);
    }
    function ln(se) {
      var Ue = se.prototype;
      return !!(Ue && Ue.isReactComponent);
    }
    function Yt(se, Ue, tt) {
      if (se == null)
        return "";
      if (typeof se == "function")
        return Zt(se, ln(se));
      if (typeof se == "string")
        return Qe(se);
      switch (se) {
        case g:
          return Qe("Suspense");
        case y:
          return Qe("SuspenseList");
      }
      if (typeof se == "object")
        switch (se.$$typeof) {
          case h:
            return an(se.render);
          case v:
            return Yt(se.type, Ue, tt);
          case w: {
            var rt = se, zt = rt._payload, Vt = rt._init;
            try {
              return Yt(Vt(zt), Ue, tt);
            } catch {
            }
          }
        }
      return "";
    }
    var Gn = Object.prototype.hasOwnProperty, xr = {}, Hr = k.ReactDebugCurrentFrame;
    function Pr(se) {
      if (se) {
        var Ue = se._owner, tt = Yt(se.type, se._source, Ue ? Ue.type : null);
        Hr.setExtraStackFrame(tt);
      } else
        Hr.setExtraStackFrame(null);
    }
    function wr(se, Ue, tt, rt, zt) {
      {
        var Vt = Function.call.bind(Gn);
        for (var un in se)
          if (Vt(se, un)) {
            var en = void 0;
            try {
              if (typeof se[un] != "function") {
                var Lr = Error((rt || "React class") + ": " + tt + " type `" + un + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof se[un] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Lr.name = "Invariant Violation", Lr;
              }
              en = se[un](Ue, un, rt, tt, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (ar) {
              en = ar;
            }
            en && !(en instanceof Error) && (Pr(zt), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", rt || "React class", tt, un, typeof en), Pr(null)), en instanceof Error && !(en.message in xr) && (xr[en.message] = !0, Pr(zt), L("Failed %s type: %s", tt, en.message), Pr(null));
          }
      }
    }
    var Vr = Array.isArray;
    function Kr(se) {
      return Vr(se);
    }
    function si(se) {
      {
        var Ue = typeof Symbol == "function" && Symbol.toStringTag, tt = Ue && se[Symbol.toStringTag] || se.constructor.name || "Object";
        return tt;
      }
    }
    function mo(se) {
      try {
        return Tr(se), !1;
      } catch {
        return !0;
      }
    }
    function Tr(se) {
      return "" + se;
    }
    function Ir(se) {
      if (mo(se))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", si(se)), Tr(se);
    }
    var Zr = k.ReactCurrentOwner, Ko = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ee, ve;
    function $e(se) {
      if (Gn.call(se, "ref")) {
        var Ue = Object.getOwnPropertyDescriptor(se, "ref").get;
        if (Ue && Ue.isReactWarning)
          return !1;
      }
      return se.ref !== void 0;
    }
    function mt(se) {
      if (Gn.call(se, "key")) {
        var Ue = Object.getOwnPropertyDescriptor(se, "key").get;
        if (Ue && Ue.isReactWarning)
          return !1;
      }
      return se.key !== void 0;
    }
    function cn(se, Ue) {
      typeof se.ref == "string" && Zr.current;
    }
    function yn(se, Ue) {
      {
        var tt = function() {
          Ee || (Ee = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ue));
        };
        tt.isReactWarning = !0, Object.defineProperty(se, "key", {
          get: tt,
          configurable: !0
        });
      }
    }
    function qn(se, Ue) {
      {
        var tt = function() {
          ve || (ve = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ue));
        };
        tt.isReactWarning = !0, Object.defineProperty(se, "ref", {
          get: tt,
          configurable: !0
        });
      }
    }
    var Rn = function(se, Ue, tt, rt, zt, Vt, un) {
      var en = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: se,
        key: Ue,
        ref: tt,
        props: un,
        // Record the component responsible for creating this element.
        _owner: Vt
      };
      return en._store = {}, Object.defineProperty(en._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(en, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: rt
      }), Object.defineProperty(en, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: zt
      }), Object.freeze && (Object.freeze(en.props), Object.freeze(en)), en;
    };
    function sr(se, Ue, tt, rt, zt) {
      {
        var Vt, un = {}, en = null, Lr = null;
        tt !== void 0 && (Ir(tt), en = "" + tt), mt(Ue) && (Ir(Ue.key), en = "" + Ue.key), $e(Ue) && (Lr = Ue.ref, cn(Ue, zt));
        for (Vt in Ue)
          Gn.call(Ue, Vt) && !Ko.hasOwnProperty(Vt) && (un[Vt] = Ue[Vt]);
        if (se && se.defaultProps) {
          var ar = se.defaultProps;
          for (Vt in ar)
            un[Vt] === void 0 && (un[Vt] = ar[Vt]);
        }
        if (en || Lr) {
          var zn = typeof se == "function" ? se.displayName || se.name || "Unknown" : se;
          en && yn(un, zn), Lr && qn(un, zn);
        }
        return Rn(se, en, Lr, zt, rt, Zr.current, un);
      }
    }
    var bn = k.ReactCurrentOwner, vn = k.ReactDebugCurrentFrame;
    function fn(se) {
      if (se) {
        var Ue = se._owner, tt = Yt(se.type, se._source, Ue ? Ue.type : null);
        vn.setExtraStackFrame(tt);
      } else
        vn.setExtraStackFrame(null);
    }
    var Ii;
    Ii = !1;
    function oo(se) {
      return typeof se == "object" && se !== null && se.$$typeof === t;
    }
    function ki() {
      {
        if (bn.current) {
          var se = Y(bn.current.type);
          if (se)
            return `

Check the render method of \`` + se + "`.";
        }
        return "";
      }
    }
    function Cs(se) {
      return "";
    }
    var ka = {};
    function Ra(se) {
      {
        var Ue = ki();
        if (!Ue) {
          var tt = typeof se == "string" ? se : se.displayName || se.name;
          tt && (Ue = `

Check the top-level render call using <` + tt + ">.");
        }
        return Ue;
      }
    }
    function yo(se, Ue) {
      {
        if (!se._store || se._store.validated || se.key != null)
          return;
        se._store.validated = !0;
        var tt = Ra(Ue);
        if (ka[tt])
          return;
        ka[tt] = !0;
        var rt = "";
        se && se._owner && se._owner !== bn.current && (rt = " It was passed a child from " + Y(se._owner.type) + "."), fn(se), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', tt, rt), fn(null);
      }
    }
    function Ul(se, Ue) {
      {
        if (typeof se != "object")
          return;
        if (Kr(se))
          for (var tt = 0; tt < se.length; tt++) {
            var rt = se[tt];
            oo(rt) && yo(rt, Ue);
          }
        else if (oo(se))
          se._store && (se._store.validated = !0);
        else if (se) {
          var zt = I(se);
          if (typeof zt == "function" && zt !== se.entries)
            for (var Vt = zt.call(se), un; !(un = Vt.next()).done; )
              oo(un.value) && yo(un.value, Ue);
        }
      }
    }
    function Xs(se) {
      {
        var Ue = se.type;
        if (Ue == null || typeof Ue == "string")
          return;
        var tt;
        if (typeof Ue == "function")
          tt = Ue.propTypes;
        else if (typeof Ue == "object" && (Ue.$$typeof === h || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ue.$$typeof === v))
          tt = Ue.propTypes;
        else
          return;
        if (tt) {
          var rt = Y(Ue);
          wr(tt, se.props, "prop", rt, se);
        } else if (Ue.PropTypes !== void 0 && !Ii) {
          Ii = !0;
          var zt = Y(Ue);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", zt || "Unknown");
        }
        typeof Ue.getDefaultProps == "function" && !Ue.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function vo(se) {
      {
        for (var Ue = Object.keys(se.props), tt = 0; tt < Ue.length; tt++) {
          var rt = Ue[tt];
          if (rt !== "children" && rt !== "key") {
            fn(se), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", rt), fn(null);
            break;
          }
        }
        se.ref !== null && (fn(se), L("Invalid attribute `ref` supplied to `React.Fragment`."), fn(null));
      }
    }
    var vi = {};
    function So(se, Ue, tt, rt, zt, Vt) {
      {
        var un = J(se);
        if (!un) {
          var en = "";
          (se === void 0 || typeof se == "object" && se !== null && Object.keys(se).length === 0) && (en += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Lr = Cs();
          Lr ? en += Lr : en += ki();
          var ar;
          se === null ? ar = "null" : Kr(se) ? ar = "array" : se !== void 0 && se.$$typeof === t ? (ar = "<" + (Y(se.type) || "Unknown") + " />", en = " Did you accidentally export a JSX literal instead of a component?") : ar = typeof se, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", ar, en);
        }
        var zn = sr(se, Ue, tt, zt, Vt);
        if (zn == null)
          return zn;
        if (un) {
          var Mi = Ue.children;
          if (Mi !== void 0)
            if (rt)
              if (Kr(Mi)) {
                for (var Es = 0; Es < Mi.length; Es++)
                  Ul(Mi[Es], se);
                Object.freeze && Object.freeze(Mi);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Ul(Mi, se);
        }
        if (Gn.call(Ue, "key")) {
          var Un = Y(se), yr = Object.keys(Ue).filter(function(Aa) {
            return Aa !== "key";
          }), Gt = yr.length > 0 ? "{key: someKey, " + yr.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!vi[Un + Gt]) {
            var xo = yr.length > 0 ? "{" + yr.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Gt, Un, xo, Un), vi[Un + Gt] = !0;
          }
        }
        return se === i ? vo(zn) : Xs(zn), zn;
      }
    }
    function $i(se, Ue, tt) {
      return So(se, Ue, tt, !0);
    }
    function Wo(se, Ue, tt) {
      return So(se, Ue, tt, !1);
    }
    var Ri = Wo, Ma = $i;
    ax.Fragment = i, ax.jsx = Ri, ax.jsxs = Ma;
  }(), ax;
}
var p4;
function Xoe() {
  if (p4) return z1.exports;
  p4 = 1;
  var n = {};
  return n.NODE_ENV === "production" ? z1.exports = qoe() : z1.exports = Yoe(), z1.exports;
}
var m = Xoe(), xM = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
var g4;
function Zoe() {
  return g4 || (g4 = 1, function(n) {
    (function() {
      var e = {}.hasOwnProperty;
      function t() {
        for (var s = "", l = 0; l < arguments.length; l++) {
          var c = arguments[l];
          c && (s = i(s, r(c)));
        }
        return s;
      }
      function r(s) {
        if (typeof s == "string" || typeof s == "number")
          return s;
        if (typeof s != "object")
          return "";
        if (Array.isArray(s))
          return t.apply(null, s);
        if (s.toString !== Object.prototype.toString && !s.toString.toString().includes("[native code]"))
          return s.toString();
        var l = "";
        for (var c in s)
          e.call(s, c) && s[c] && (l = i(l, c));
        return l;
      }
      function i(s, l) {
        return l ? s ? s + " " + l : s + l : s;
      }
      n.exports ? (t.default = t, n.exports = t) : window.classNames = t;
    })();
  }(xM)), xM.exports;
}
var Qoe = Zoe();
const It = /* @__PURE__ */ wh(Qoe), K8 = "3.7.0", m4 = {
  major: "2024-09-13T14:36:29.063Z",
  minor: "2025-01-07T15:59:09.453Z",
  patch: "2025-01-07T15:59:09.453Z"
}, Joe = { error: null };
class kO extends M.Component {
  constructor() {
    super(...arguments);
    U(this, "state", Joe);
  }
  static getDerivedStateFromError(t) {
    return { error: t };
  }
  componentDidCatch(t) {
    var r, i;
    (i = (r = this.props).onError) == null || i.call(r, t);
  }
  render() {
    const { error: t } = this.state;
    if (t !== null) {
      const { fallback: r } = this.props;
      return /* @__PURE__ */ m.jsx(r, { error: t });
    }
    return this.props.children;
  }
}
function Yx({
  children: n,
  fallback: e,
  ...t
}) {
  return e === null ? n : /* @__PURE__ */ m.jsx(kO, { fallback: e, ...t, children: n });
}
function RO(n, e) {
  return ZE(`${n}_${e}`);
}
function Vy(n) {
  return ZE(`${M.useId()}${n ?? ""}`);
}
function bc(n) {
  const e = Sa(M.useContext(W8));
  return ZE(`${e}_${n}`);
}
function ZE(n) {
  return n.replace(/:/g, "_");
}
const W8 = M.createContext(null);
function ese({ children: n }) {
  const e = Vy();
  return /* @__PURE__ */ m.jsx(W8.Provider, { value: e, children: n });
}
const MO = M.createContext(null);
function be() {
  const n = Bt.useContext(MO);
  if (!n)
    throw new Error(
      "useEditor must be used inside of the <Tldraw /> or <TldrawEditor /> components"
    );
  return n;
}
function _h() {
  return Bt.useContext(MO);
}
function AO({
  editor: n,
  children: e
}) {
  return /* @__PURE__ */ m.jsx(MO.Provider, { value: n, children: /* @__PURE__ */ m.jsx(ese, { children: e }) });
}
function tse() {
  return /* @__PURE__ */ m.jsx("div", { className: "tl-background" });
}
function Ky(n, e, t, r, i, s) {
  M.useLayoutEffect(() => {
    const l = n.current;
    if (!l || e === void 0) return;
    let c = `translate(${e}px, ${t}px)`;
    r !== void 0 && (c += ` scale(${r})`), i !== void 0 && (c += ` rotate(${i}rad)`), s && (c += ` translate(${s.x}px, ${s.y}px)`), l.style.transform = c;
  });
}
const po = {
  linear: (n) => n,
  easeInQuad: (n) => n * n,
  easeOutQuad: (n) => n * (2 - n),
  easeInOutQuad: (n) => n < 0.5 ? 2 * n * n : -1 + (4 - 2 * n) * n,
  easeInCubic: (n) => n * n * n,
  easeOutCubic: (n) => --n * n * n + 1,
  easeInOutCubic: (n) => n < 0.5 ? 4 * n * n * n : (n - 1) * (2 * n - 2) * (2 * n - 2) + 1,
  easeInQuart: (n) => n * n * n * n,
  easeOutQuart: (n) => 1 - --n * n * n * n,
  easeInOutQuart: (n) => n < 0.5 ? 8 * n * n * n * n : 1 - 8 * --n * n * n * n,
  easeInQuint: (n) => n * n * n * n * n,
  easeOutQuint: (n) => 1 + --n * n * n * n * n,
  easeInOutQuint: (n) => n < 0.5 ? 16 * n * n * n * n * n : 1 + 16 * --n * n * n * n * n,
  easeInSine: (n) => 1 - Math.cos(n * Math.PI / 2),
  easeOutSine: (n) => Math.sin(n * Math.PI / 2),
  easeInOutSine: (n) => -(Math.cos(Math.PI * n) - 1) / 2,
  easeInExpo: (n) => n <= 0 ? 0 : Math.pow(2, 10 * n - 10),
  easeOutExpo: (n) => n >= 1 ? 1 : 1 - Math.pow(2, -10 * n),
  easeInOutExpo: (n) => n <= 0 ? 0 : n >= 1 ? 1 : n < 0.5 ? Math.pow(2, 20 * n - 10) / 2 : (2 - Math.pow(2, -20 * n + 10)) / 2
};
class R {
  constructor(e = 0, t = 0, r = 1) {
    this.x = e, this.y = t, this.z = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get pressure() {
    return this.z;
  }
  set(e = this.x, t = this.y, r = this.z) {
    return this.x = e, this.y = t, this.z = r, this;
  }
  setTo({ x: e = 0, y: t = 0, z: r = 1 }) {
    return this.x = e, this.y = t, this.z = r, this;
  }
  rot(e) {
    if (e === 0) return this;
    const { x: t, y: r } = this, i = Math.sin(e), s = Math.cos(e);
    return this.x = t * s - r * i, this.y = t * i + r * s, this;
  }
  rotWith(e, t) {
    if (t === 0) return this;
    const r = this.x - e.x, i = this.y - e.y, s = Math.sin(t), l = Math.cos(t);
    return this.x = e.x + (r * l - i * s), this.y = e.y + (r * s + i * l), this;
  }
  clone() {
    const { x: e, y: t, z: r } = this;
    return new R(e, t, r);
  }
  sub(e) {
    return this.x -= e.x, this.y -= e.y, this;
  }
  subXY(e, t) {
    return this.x -= e, this.y -= t, this;
  }
  subScalar(e) {
    return this.x -= e, this.y -= e, this;
  }
  add(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  addXY(e, t) {
    return this.x += e, this.y += t, this;
  }
  addScalar(e) {
    return this.x += e, this.y += e, this;
  }
  clamp(e, t) {
    return this.x = Math.max(this.x, e), this.y = Math.max(this.y, e), t !== void 0 && (this.x = Math.min(this.x, t), this.y = Math.min(this.y, t)), this;
  }
  div(e) {
    return this.x /= e, this.y /= e, this;
  }
  divV(e) {
    return this.x /= e.x, this.y /= e.y, this;
  }
  mul(e) {
    return this.x *= e, this.y *= e, this;
  }
  mulV(e) {
    return this.x *= e.x, this.y *= e.y, this;
  }
  abs() {
    return this.x = Math.abs(this.x), this.y = Math.abs(this.y), this;
  }
  nudge(e, t) {
    const r = R.Tan(e, this);
    return this.add(r.mul(t));
  }
  neg() {
    return this.x *= -1, this.y *= -1, this;
  }
  cross(e) {
    return this.x = this.y * e.z - this.z * e.y, this.y = this.z * e.x - this.x * e.z, this;
  }
  dpr(e) {
    return R.Dpr(this, e);
  }
  cpr(e) {
    return R.Cpr(this, e);
  }
  len2() {
    return R.Len2(this);
  }
  len() {
    return R.Len(this);
  }
  pry(e) {
    return R.Pry(this, e);
  }
  per() {
    const { x: e, y: t } = this;
    return this.x = t, this.y = -e, this;
  }
  uni() {
    return R.Uni(this);
  }
  tan(e) {
    return R.Tan(this, e);
  }
  dist(e) {
    return R.Dist(this, e);
  }
  distanceToLineSegment(e, t) {
    return R.DistanceToLineSegment(e, t, this);
  }
  slope(e) {
    return R.Slope(this, e);
  }
  snapToGrid(e) {
    return this.x = Math.round(this.x / e) * e, this.y = Math.round(this.y / e) * e, this;
  }
  angle(e) {
    return R.Angle(this, e);
  }
  toAngle() {
    return R.ToAngle(this);
  }
  lrp(e, t) {
    return this.x = this.x + (e.x - this.x) * t, this.y = this.y + (e.y - this.y) * t, this;
  }
  equals(e) {
    return R.Equals(this, e);
  }
  equalsXY(e, t) {
    return R.EqualsXY(this, e, t);
  }
  norm() {
    const e = this.len();
    return this.x = e === 0 ? 0 : this.x / e, this.y = e === 0 ? 0 : this.y / e, this;
  }
  toFixed() {
    return R.ToFixed(this);
  }
  toString() {
    return R.ToString(R.ToFixed(this));
  }
  toJson() {
    return R.ToJson(this);
  }
  toArray() {
    return R.ToArray(this);
  }
  static Add(e, t) {
    return new R(e.x + t.x, e.y + t.y);
  }
  static AddXY(e, t, r) {
    return new R(e.x + t, e.y + r);
  }
  static Sub(e, t) {
    return new R(e.x - t.x, e.y - t.y);
  }
  static SubXY(e, t, r) {
    return new R(e.x - t, e.y - r);
  }
  static AddScalar(e, t) {
    return new R(e.x + t, e.y + t);
  }
  static SubScalar(e, t) {
    return new R(e.x - t, e.y - t);
  }
  static Div(e, t) {
    return new R(e.x / t, e.y / t);
  }
  static Mul(e, t) {
    return new R(e.x * t, e.y * t);
  }
  static DivV(e, t) {
    return new R(e.x / t.x, e.y / t.y);
  }
  static MulV(e, t) {
    return new R(e.x * t.x, e.y * t.y);
  }
  static Neg(e) {
    return new R(-e.x, -e.y);
  }
  /**
   * Get the perpendicular vector to A.
   */
  static Per(e) {
    return new R(e.y, -e.x);
  }
  static Abs(e) {
    return new R(Math.abs(e.x), Math.abs(e.y));
  }
  // Get the distance between two points.
  static Dist(e, t) {
    return ((e.y - t.y) ** 2 + (e.x - t.x) ** 2) ** 0.5;
  }
  // Get whether a distance between two points is less than a number. This is faster to calulate than using `Vec.Dist(a, b) < n`.
  static DistMin(e, t, r) {
    return (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y) < r ** 2;
  }
  // Get the squared distance between two points. This is faster to calculate (no square root) so useful for "minimum distance" checks where the actual measurement does not matter.
  static Dist2(e, t) {
    return (e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y);
  }
  /**
   * Dot product of two vectors which is used to calculate the angle between them.
   */
  static Dpr(e, t) {
    return e.x * t.x + e.y * t.y;
  }
  static Cross(e, t) {
    return new R(
      e.y * t.z - e.z * t.y,
      e.z * t.x - e.x * t.z
      // A.z = A.x * V.y - A.y * V.x
    );
  }
  /**
   * Cross product of two vectors which is used to calculate the area of a parallelogram.
   */
  static Cpr(e, t) {
    return e.x * t.y - t.x * e.y;
  }
  static Len2(e) {
    return e.x * e.x + e.y * e.y;
  }
  static Len(e) {
    return (e.x * e.x + e.y * e.y) ** 0.5;
  }
  /**
   * Get the projection of A onto B.
   */
  static Pry(e, t) {
    return R.Dpr(e, t) / R.Len(t);
  }
  /**
   * Get the unit vector of A.
   */
  static Uni(e) {
    return R.Div(e, R.Len(e));
  }
  static Tan(e, t) {
    return R.Uni(R.Sub(e, t));
  }
  static Min(e, t) {
    return new R(Math.min(e.x, t.x), Math.min(e.y, t.y));
  }
  static Max(e, t) {
    return new R(Math.max(e.x, t.x), Math.max(e.y, t.y));
  }
  static From({ x: e, y: t, z: r = 1 }) {
    return new R(e, t, r);
  }
  static FromArray(e) {
    return new R(e[0], e[1]);
  }
  static Rot(e, t = 0) {
    const r = Math.sin(t), i = Math.cos(t);
    return new R(e.x * i - e.y * r, e.x * r + e.y * i);
  }
  static RotWith(e, t, r) {
    const i = e.x - t.x, s = e.y - t.y, l = Math.sin(r), c = Math.cos(r);
    return new R(t.x + (i * c - s * l), t.y + (i * l + s * c));
  }
  /**
   * Get the nearest point on a line with a known unit vector that passes through point A
   *
   * ```ts
   * Vec.nearestPointOnLineThroughPoint(A, u, Point)
   * ```
   *
   * @param A - Any point on the line
   * @param u - The unit vector for the line.
   * @param P - A point not on the line to test.
   */
  static NearestPointOnLineThroughPoint(e, t, r) {
    return R.Mul(t, R.Sub(r, e).pry(t)).add(e);
  }
  static NearestPointOnLineSegment(e, t, r, i = !0) {
    if (R.Equals(e, r) || R.Equals(t, r)) return R.From(r);
    const s = R.Tan(t, e), l = R.Add(e, R.Mul(s, R.Sub(r, e).pry(s)));
    if (i) {
      if (l.x < Math.min(e.x, t.x)) return R.Cast(e.x < t.x ? e : t);
      if (l.x > Math.max(e.x, t.x)) return R.Cast(e.x > t.x ? e : t);
      if (l.y < Math.min(e.y, t.y)) return R.Cast(e.y < t.y ? e : t);
      if (l.y > Math.max(e.y, t.y)) return R.Cast(e.y > t.y ? e : t);
    }
    return l;
  }
  static DistanceToLineThroughPoint(e, t, r) {
    return R.Dist(r, R.NearestPointOnLineThroughPoint(e, t, r));
  }
  static DistanceToLineSegment(e, t, r, i = !0) {
    return R.Dist(r, R.NearestPointOnLineSegment(e, t, r, i));
  }
  static Snap(e, t = 1) {
    return new R(Math.round(e.x / t) * t, Math.round(e.y / t) * t);
  }
  static Cast(e) {
    return e instanceof R ? e : R.From(e);
  }
  static Slope(e, t) {
    return e.x === t.y ? NaN : (e.y - t.y) / (e.x - t.x);
  }
  static IsNaN(e) {
    return isNaN(e.x) || isNaN(e.y);
  }
  static Angle(e, t) {
    return Math.atan2(t.y - e.y, t.x - e.x);
  }
  /**
   * Linearly interpolate between two points.
   * @param A - The first point.
   * @param B - The second point.
   * @param t - The interpolation value between 0 and 1.
   * @returns The interpolated point.
   */
  static Lrp(e, t, r) {
    return R.Sub(t, e).mul(r).add(e);
  }
  static Med(e, t) {
    return new R((e.x + t.x) / 2, (e.y + t.y) / 2);
  }
  static Equals(e, t) {
    return Math.abs(e.x - t.x) < 1e-4 && Math.abs(e.y - t.y) < 1e-4;
  }
  static EqualsXY(e, t, r) {
    return e.x === t && e.y === r;
  }
  static Clockwise(e, t, r) {
    return (r.x - e.x) * (t.y - e.y) - (t.x - e.x) * (r.y - e.y) < 0;
  }
  static Rescale(e, t) {
    const r = R.Len(e);
    return new R(t * e.x / r, t * e.y / r);
  }
  static ScaleWithOrigin(e, t, r) {
    return R.Sub(e, r).mul(t).add(r);
  }
  static ToFixed(e) {
    return new R(jd(e.x), jd(e.y));
  }
  static ToInt(e) {
    return new R(
      parseInt(e.x.toFixed(0)),
      parseInt(e.y.toFixed(0)),
      parseInt((e.z ?? 0).toFixed(0))
    );
  }
  static ToCss(e) {
    return `${e.x},${e.y}`;
  }
  static Nudge(e, t, r) {
    return R.Add(e, R.Tan(t, e).mul(r));
  }
  static ToString(e) {
    return `${e.x}, ${e.y}`;
  }
  static ToAngle(e) {
    let t = Math.atan2(e.y, e.x);
    return t < 0 && (t += Math.PI * 2), t;
  }
  static FromAngle(e, t = 1) {
    return new R(Math.cos(e) * t, Math.sin(e) * t);
  }
  static ToArray(e) {
    return [e.x, e.y, e.z];
  }
  static ToJson(e) {
    const { x: t, y: r, z: i } = e;
    return { x: t, y: r, z: i };
  }
  static Average(e) {
    const t = e.length, r = new R(0, 0);
    if (t === 0)
      return r;
    for (let i = 0; i < t; i++)
      r.add(e[i]);
    return r.div(t);
  }
  static Clamp(e, t, r) {
    return r === void 0 ? new R(Math.min(Math.max(e.x, t)), Math.min(Math.max(e.y, t))) : new R(Math.min(Math.max(e.x, t), r), Math.min(Math.max(e.y, t), r));
  }
  /**
   * Get an array of points (with simulated pressure) between two points.
   *
   * @param A - The first point.
   * @param B - The second point.
   * @param steps - The number of points to return.
   */
  static PointsBetween(e, t, r = 6) {
    const i = [];
    for (let s = 0; s < r; s++) {
      const l = po.easeInQuad(s / (r - 1)), c = R.Lrp(e, t, l);
      c.z = Math.min(1, 0.5 + Math.abs(0.5 - nse(l)) * 0.65), i.push(c);
    }
    return i;
  }
  static SnapToGrid(e, t = 8) {
    return new R(Math.round(e.x / t) * t, Math.round(e.y / t) * t);
  }
}
const nse = (n) => n < 0.5 ? 2 * n * n : -1 + (4 - 2 * n) * n;
function Yn(n) {
  return `${Se(n.x)},${Se(n.y)} `;
}
function xa(n, e) {
  return `${Se((n.x + e.x) / 2)},${Se((n.y + e.y) / 2)} `;
}
const Xn = Math.PI, Or = Xn / 2, hr = Xn * 2, rse = Math.sin;
function Do(n, e, t) {
  return Math.max(e, typeof t < "u" ? Math.min(n, t) : n);
}
function U1(n, e = 1e10) {
  return n ? Math.round(n * e) / e : 0;
}
function fh(n, e, t = 1e-6) {
  return Math.abs(n - e) <= t;
}
function G8(n, e) {
  const t = Math.pow(n - e, 2) / Math.pow(n + e, 2);
  return Xn * (n + e) * (1 + 3 * t / (10 + Math.sqrt(4 - 3 * t)));
}
function Yp(n) {
  return n = n % hr, n < 0 ? n = n + hr : n === 0 && (n = 0), n;
}
function mw(n, e) {
  return n = Yp(n), e = Yp(e), n > e && (e += hr), e - n;
}
function q8(n, e) {
  return hr - mw(n, e);
}
function SC(n, e) {
  const t = (e - n) % hr;
  return 2 * t % hr - t;
}
function KA(n) {
  return (hr + n) % hr;
}
function yE(n, e) {
  const t = hr / e;
  let r = Math.floor((KA(n) + t / 2) / t) * t % hr;
  return r < Xn && (r += hr), r > Xn && (r -= hr), r;
}
function Y8(n, e) {
  return n === e || fh(n % (Math.PI / 2) - e % (Math.PI / 2), 0);
}
function ise(n) {
  return n * Xn / 180;
}
function ose(n) {
  return n * 180 / Xn;
}
function tg(n, e, t) {
  return new R(n.x, n.y).add(R.FromAngle(t, e));
}
function wM(n, e, t) {
  const r = n / 2, i = e / 2, s = [];
  let l = 1 / 0, c = -1 / 0, d = 1 / 0, h = -1 / 0;
  for (let C = 0; C < t; C++) {
    const E = hr / t, P = -Or + C * E, I = r + r * Math.cos(P), k = i + i * Math.sin(P);
    I < l && (l = I), k < d && (d = k), I > c && (c = I), k > h && (h = k), s.push(new R(I, k));
  }
  const g = c - l, y = h - d, v = n - g, w = e - y;
  if (v !== 0 || w !== 0)
    for (let C = 0; C < s.length; C++) {
      const E = s[C];
      E.x = (E.x - l) / g * n, E.y = (E.y - d) / y * e;
    }
  return s;
}
function lx(n, e, t, r) {
  return n < r && t < e;
}
function pc(n, e, t, r) {
  const i = Math.max(n, t), s = Math.min(e, r);
  return i <= s ? [i, s] : null;
}
function y4(n, e, t) {
  return (e.x - n.x) * (t.y - n.y) - (t.x - n.x) * (e.y - n.y);
}
function Ja(n, e) {
  let t = 0, r, i;
  for (let s = 0; s < e.length; s++) {
    if (r = e[s], r.x === n.x && r.y === n.y || (i = e[(s + 1) % e.length], R.Dist(n, r) + R.Dist(n, i) === R.Dist(r, i))) return !0;
    r.y <= n.y ? i.y > n.y && y4(r, i, n) > 0 && (t += 1) : i.y <= n.y && y4(r, i, n) < 0 && (t -= 1);
  }
  return t !== 0;
}
function Se(n) {
  return Math.round(n * 1e4) / 1e4;
}
function jd(n) {
  return Math.round(n * 100) / 100;
}
const v4 = (n) => Math.abs(n) < Number.MAX_SAFE_INTEGER;
function oh(n, e, t) {
  return t < 0 ? mw(n, e) : q8(n, e);
}
function WA(n, e, t, r) {
  let i;
  if (Math.abs(n) > Xn) {
    i = SC(e, r);
    const s = SC(r, t);
    return Math.abs(i) < Math.abs(s) ? i / n : (n - s) / n;
  } else {
    i = SC(e, r);
    const s = i / n;
    return Math.sign(i) !== Math.sign(n) ? Math.abs(s) > 0.5 ? 1 : 0 : s;
  }
}
function sse(n, e, t, r) {
  const i = 2 * ((e - n) % hr) % hr - (e - n) % hr;
  return r ? (hr - Math.abs(i)) * (t ? 1 : -1) : i;
}
function DO(n, e, t) {
  const r = -2 * (n.x * (e.y - t.y) - n.y * (e.x - t.x) + e.x * t.y - t.x * e.y), i = ((n.x * n.x + n.y * n.y) * (t.y - e.y) + (e.x * e.x + e.y * e.y) * (n.y - t.y) + (t.x * t.x + t.y * t.y) * (e.y - n.y)) / r, s = ((n.x * n.x + n.y * n.y) * (e.x - t.x) + (e.x * e.x + e.y * e.y) * (t.x - n.x) + (t.x * t.x + t.y * t.y) * (n.x - e.x)) / r;
  return !Number.isFinite(i) || !Number.isFinite(s) ? null : new R(i, s);
}
function ase(n, e, t, r, i) {
  if (t === null)
    return [R.From(n), R.From(e)];
  const s = [], l = R.Angle(t, n), c = R.Angle(t, e), d = mw(l, c);
  for (let h = 0; h < i; h++) {
    const g = h / (i - 1), y = l + d * g, v = tg(t, r, y);
    s.push(v);
  }
  return s;
}
const bM = ({ brush: n, color: e, opacity: t, className: r }) => {
  const i = M.useRef(null);
  Ky(i, n.x, n.y);
  const s = Se(Math.max(1, n.w)), l = Se(Math.max(1, n.h));
  return /* @__PURE__ */ m.jsx("svg", { className: "tl-overlays__item", ref: i, children: e ? /* @__PURE__ */ m.jsxs("g", { className: "tl-brush", opacity: t, children: [
    /* @__PURE__ */ m.jsx("rect", { width: s, height: l, fill: e, opacity: 0.75 }),
    /* @__PURE__ */ m.jsx("rect", { width: s, height: l, fill: "none", stroke: e, opacity: 0.1 })
  ] }) : /* @__PURE__ */ m.jsx("rect", { className: `tl-brush tl-brush__default ${r}`, width: s, height: l }) });
}, Er = {
  isSafari: !1,
  isIos: !1,
  isChromeForIos: !1,
  isFirefox: !1,
  isAndroid: !1,
  isWebview: !1,
  isDarwin: !1
};
typeof window < "u" && "navigator" in window && (Er.isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent), Er.isIos = !!navigator.userAgent.match(/iPad/i) || !!navigator.userAgent.match(/iPhone/i), Er.isChromeForIos = /crios.*safari/i.test(navigator.userAgent), Er.isFirefox = /firefox/i.test(navigator.userAgent), Er.isAndroid = /android/i.test(navigator.userAgent), Er.isDarwin = window.navigator.userAgent.toLowerCase().indexOf("mac") > -1);
const S4 = {
  isLocked: !1,
  wheelBehavior: "pan",
  panSpeed: 1,
  zoomSpeed: 1,
  zoomSteps: [0.1, 0.25, 0.5, 1, 2, 4, 8]
}, CM = {
  duration: 0,
  easing: po.easeInOutCubic
}, x4 = {
  CAMERA_MOVE: -10
}, lse = ["top", "right", "bottom", "left"], w4 = 0, OO = 2, $1 = 1, b4 = 5, cse = 128;
var EM = {};
const use = {}, X8 = pa(
  "pointerCaptureTrackingObject",
  // ideally we wouldn't store this mutable value in an atom but it's not
  // a big deal for debug values
  {
    defaults: { all: /* @__PURE__ */ new Map() },
    shouldStoreForSession: !1
  }
), Ei = {
  // --- DEBUG VALUES ---
  logPreventDefaults: pa("logPreventDefaults", {
    defaults: { all: !1 }
  }),
  logPointerCaptures: pa("logPointerCaptures", {
    defaults: { all: !1 }
  }),
  logElementRemoves: pa("logElementRemoves", {
    defaults: { all: !1 }
  }),
  debugSvg: pa("debugSvg", {
    defaults: { all: !1 }
  }),
  showFps: pa("showFps", {
    defaults: { all: !1 }
  }),
  measurePerformance: pa("measurePerformance", { defaults: { all: !1 } }),
  throwToBlob: pa("throwToBlob", {
    defaults: { all: !1 }
  }),
  reconnectOnPing: pa("reconnectOnPing", {
    defaults: { all: !1 }
  }),
  debugCursors: pa("debugCursors", {
    defaults: { all: !1 }
  }),
  forceSrgb: pa("forceSrgbColors", { defaults: { all: !1 } }),
  debugGeometry: pa("debugGeometry", { defaults: { all: !1 } }),
  hideShapes: pa("hideShapes", { defaults: { all: !1 } }),
  editOnType: pa("editOnType", { defaults: { all: !1 } })
};
if (typeof Element < "u") {
  const n = Element.prototype.removeChild;
  wc("element removal logging", () => {
    Ei.logElementRemoves.get() ? Element.prototype.removeChild = function(e) {
      return console.warn("[tldraw] removing child:", e), n.call(this, e);
    } : Element.prototype.removeChild = n;
  });
}
function pa(n, {
  defaults: e,
  shouldStoreForSession: t = !0
}) {
  return dse({
    name: n,
    defaults: e,
    shouldStoreForSession: t
  });
}
function dse(n) {
  const e = hse(n), t = n.shouldStoreForSession ? fse(n.name) : null, r = mi(`debug:${n.name}`, t ?? e);
  return typeof window < "u" && (n.shouldStoreForSession && wc(`debug:${n.name}`, () => {
    const i = r.get();
    i === e ? s6(`tldraw_debug:${n.name}`) : nO(`tldraw_debug:${n.name}`, JSON.stringify(i));
  }), Object.defineProperty(window, `tldraw${n.name.replace(/^[a-z]/, (i) => i.toUpperCase())}`, {
    get() {
      return r.get();
    },
    set(i) {
      r.set(i);
    },
    configurable: !0
  })), Object.assign(r, n);
}
function fse(n) {
  try {
    return JSON.parse(o6(`tldraw_debug:${n}`) ?? "null");
  } catch {
    return null;
  }
}
function _M(n) {
  try {
    return n();
  } catch {
    return null;
  }
}
function hse(n) {
  switch (_M(() => EM.TLDRAW_ENV) ?? _M(() => EM.VERCEL_PUBLIC_TLDRAW_ENV) ?? _M(() => EM.NEXT_PUBLIC_TLDRAW_ENV) ?? // default to production because if we don't have one of these, this is probably a library use
  "production") {
    case "production":
      return n.defaults.production ?? n.defaults.all;
    case "preview":
    case "staging":
      return n.defaults.staging ?? n.defaults.all;
    default:
      return n.defaults.development ?? n.defaults.all;
  }
}
function vE(n) {
  if (n instanceof HTMLElement) return n;
  if (n.parentElement) return vE(n.parentElement);
  throw Error("Could not find a parent element of an HTML type!");
}
function wn(n) {
  n.preventDefault(), Ei.logPreventDefaults.get() && console.warn("preventDefault called on event:", n);
}
function yw(n, e) {
  if (n.setPointerCapture(e.pointerId), Ei.logPointerCaptures.get()) {
    const t = X8.get();
    t.set(n, (t.get(n) ?? 0) + 1), console.warn("setPointerCapture called on element:", n, e);
  }
}
function vw(n, e) {
  if (n.hasPointerCapture(e.pointerId) && (n.releasePointerCapture(e.pointerId), Ei.logPointerCaptures.get())) {
    const t = X8.get();
    t.get(n) === 1 ? t.delete(n) : t.has(n) ? t.set(n, t.get(n) - 1) : console.warn("Release without capture"), console.warn("releasePointerCapture called on element:", n, e);
  }
}
const Ti = (n) => n.stopPropagation(), cs = (n, e, t) => {
  n && n.style.setProperty(e, t);
}, ms = (n) => Er.isDarwin ? n.metaKey : n.ctrlKey || n.metaKey;
function Xa(n) {
  return n.isKilled = !0, {
    point: {
      x: n.clientX,
      y: n.clientY,
      z: n.pressure
    },
    shiftKey: n.shiftKey,
    altKey: n.altKey,
    ctrlKey: n.metaKey || n.ctrlKey,
    metaKey: n.metaKey,
    accelKey: ms(n),
    pointerId: n.pointerId,
    button: n.button,
    isPen: n.pointerType === "pen"
  };
}
function jO() {
  const n = be();
  return M.useMemo(
    function() {
      let r, i;
      function s(E) {
        if (!E.isKilled) {
          if (E.button === OO) {
            n.dispatch({
              type: "pointer",
              target: "canvas",
              name: "right_click",
              ...Xa(E)
            });
            return;
          }
          E.button !== 0 && E.button !== 1 && E.button !== 5 || (yw(E.currentTarget, E), n.dispatch({
            type: "pointer",
            target: "canvas",
            name: "pointer_down",
            ...Xa(E)
          }));
        }
      }
      function l(E) {
        E.isKilled || E.clientX === r && E.clientY === i || (r = E.clientX, i = E.clientY, n.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          ...Xa(E)
        }));
      }
      function c(E) {
        E.isKilled || E.button !== 0 && E.button !== 1 && E.button !== 2 && E.button !== 5 || (r = E.clientX, i = E.clientY, vw(E.currentTarget, E), n.dispatch({
          type: "pointer",
          target: "canvas",
          name: "pointer_up",
          ...Xa(E)
        }));
      }
      function d(E) {
        if (E.isKilled || n.getInstanceState().isPenMode && E.pointerType !== "pen") return;
        const P = E.pointerType === "mouse" || E.pointerType === "pen";
        n.updateInstanceState({ isHoveringCanvas: P ? !0 : null });
      }
      function h(E) {
        if (E.isKilled || n.getInstanceState().isPenMode && E.pointerType !== "pen") return;
        const P = E.pointerType === "mouse" || E.pointerType === "pen";
        n.updateInstanceState({ isHoveringCanvas: P ? !1 : null });
      }
      function g(E) {
        E.isKilled = !0, wn(E);
      }
      function y(E) {
        E.isKilled = !0, E.target instanceof HTMLElement && E.target.tagName !== "A" && E.target.tagName !== "TEXTAREA" && // When in EditingShape state, we are actually clicking on a 'DIV'
        // not A/TEXTAREA element yet. So, to preserve cursor position
        // for edit mode on mobile we need to not preventDefault.
        // TODO: Find out if we still need this preventDefault in general though.
        !(n.getEditingShape() && E.target.className.includes("tl-text-content")) && wn(E);
      }
      function v(E) {
        wn(E);
      }
      async function w(E) {
        var I, k;
        if (wn(E), Ti(E), !((k = (I = E.dataTransfer) == null ? void 0 : I.files) != null && k.length)) return;
        const P = Array.from(E.dataTransfer.files);
        await n.putExternalContent({
          type: "files",
          files: P,
          point: n.screenToPage({ x: E.clientX, y: E.clientY }),
          ignoreParent: !1
        });
      }
      function C(E) {
        Ti(E);
      }
      return {
        onPointerDown: s,
        onPointerMove: l,
        onPointerUp: c,
        onPointerEnter: d,
        onPointerLeave: h,
        onDragOver: v,
        onDrop: w,
        onTouchStart: g,
        onTouchEnd: y,
        onClick: C
      };
    },
    [n]
  );
}
function pse() {
  const n = be();
  M.useEffect(() => {
    let e = n.getInstanceState().isCoarsePointer;
    const t = (l) => {
      const c = l.pointerType !== "mouse";
      e !== c && (e = c, n.updateInstanceState({ isCoarsePointer: c }));
    };
    window.addEventListener("pointerdown", t, { capture: !0 });
    const r = window.matchMedia && window.matchMedia("(any-pointer: coarse)"), i = Er.isFirefox && !Er.isAndroid && !Er.isIos, s = () => {
      const l = i ? !1 : r.matches;
      e === l && (e = l, n.updateInstanceState({ isCoarsePointer: l }));
    };
    return r && (r.addEventListener("change", s), s()), () => {
      window.removeEventListener("pointerdown", t, { capture: !0 }), r && r.removeEventListener("change", s);
    };
  }, [n]);
}
const Z8 = M.createContext(null);
function Q8({ container: n, children: e }) {
  return /* @__PURE__ */ m.jsx(Z8.Provider, { value: n, children: e });
}
function io() {
  return Sa(M.useContext(Z8), "useContainer used outside of <Tldraw />");
}
function gse() {
  const n = be(), e = io(), t = Pe("isFocused", () => n.getIsFocused(), [n]);
  M.useEffect(() => {
    if (!e) return;
    function r(i) {
      if (i.isSpecialRedispatchedEvent) return;
      wn(i), Ti(i);
      const s = e.querySelector(".tl-canvas");
      if (!s) return;
      const l = new DragEvent(i.type, i);
      l.isSpecialRedispatchedEvent = !0, s.dispatchEvent(l);
    }
    return e.addEventListener("dragover", r), e.addEventListener("drop", r), () => {
      e.removeEventListener("dragover", r), e.removeEventListener("drop", r);
    };
  }, [e]), M.useEffect(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    let r = null;
    const i = () => {
      r != null && r();
      const s = `(resolution: ${window.devicePixelRatio}dppx)`, l = matchMedia(s), c = (d) => {
        d.type === "change" && i();
      };
      l.addEventListener ? l.addEventListener("change", i) : l.addListener && l.addListener(c), r = () => {
        l.removeEventListener ? l.removeEventListener("change", i) : l.removeListener && l.removeListener(c);
      }, n.updateInstanceState({ devicePixelRatio: window.devicePixelRatio });
    };
    return i(), () => {
      r == null || r();
    };
  }, [n]), M.useEffect(() => {
    if (!t) return;
    const r = (c) => {
      if (c.altKey && // todo: When should we allow the alt key to be used? Perhaps states should declare which keys matter to them?
      (n.isIn("zoom") || !n.getPath().endsWith(".idle")) && !B1(n) && wn(c), c.isKilled) return;
      switch (c.isKilled = !0, c.key) {
        case "=":
        case "-":
        case "0": {
          if (c.metaKey || c.ctrlKey) {
            wn(c);
            return;
          }
          break;
        }
        case "Tab": {
          if (B1(n))
            return;
          break;
        }
        case ",":
          return;
        case "Escape": {
          if ((n.getEditingShape() || n.getSelectedShapeIds().length > 0) && wn(c), n.menus.getOpenMenus().length > 0) return;
          n.inputs.keys.has("Escape") || (n.inputs.keys.add("Escape"), n.cancel(), e.focus());
          return;
        }
        default:
          if (B1(n))
            return;
      }
      const d = {
        type: "keyboard",
        name: c.repeat ? "key_repeat" : "key_down",
        key: c.key,
        code: c.code,
        shiftKey: c.shiftKey,
        altKey: c.altKey,
        ctrlKey: c.metaKey || c.ctrlKey,
        metaKey: c.metaKey,
        accelKey: ms(c)
      };
      n.dispatch(d);
    }, i = (c) => {
      if (c.isKilled || (c.isKilled = !0, B1(n)) || c.key === ",")
        return;
      const d = {
        type: "keyboard",
        name: "key_up",
        key: c.key,
        code: c.code,
        shiftKey: c.shiftKey,
        altKey: c.altKey,
        ctrlKey: c.metaKey || c.ctrlKey,
        metaKey: c.metaKey,
        accelKey: ms(c)
      };
      n.dispatch(d);
    };
    function s(c) {
      var d, h;
      if (e.contains(c.target)) {
        const g = c.touches[0].pageX, y = c.touches[0].radiusX || 0;
        (g - y < 10 || g + y > n.getViewportScreenBounds().width - 10) && (((d = c.target) == null ? void 0 : d.tagName) === "BUTTON" && ((h = c.target) == null || h.click()), wn(c));
      }
    }
    const l = (c) => {
      e.contains(c.target) && (c.ctrlKey || c.metaKey) && wn(c);
    };
    return e.addEventListener("touchstart", s, { passive: !1 }), e.addEventListener("wheel", l, { passive: !1 }), document.addEventListener("gesturestart", wn), document.addEventListener("gesturechange", wn), document.addEventListener("gestureend", wn), e.addEventListener("keydown", r), e.addEventListener("keyup", i), () => {
      e.removeEventListener("touchstart", s), e.removeEventListener("wheel", l), document.removeEventListener("gesturestart", wn), document.removeEventListener("gesturechange", wn), document.removeEventListener("gestureend", wn), e.removeEventListener("keydown", r), e.removeEventListener("keyup", i);
    };
  }, [n, e, t]);
}
const mse = ["input", "select", "button", "textarea"];
function B1(n) {
  const { activeElement: e } = document;
  return n.menus.hasOpenMenus() || e && (e.getAttribute("contenteditable") || mse.indexOf(e.tagName.toLowerCase()) > -1);
}
const yse = ["textarea", "input"];
function vse(n) {
  const e = be();
  M.useEffect(() => {
    const t = n.current;
    if (!t) return;
    const r = (i) => {
      var s;
      if (i instanceof PointerEvent && i.pointerType === "pen") {
        i.isKilled = !0;
        const { target: l } = i;
        if (yse.includes((s = l.tagName) == null ? void 0 : s.toLocaleLowerCase()) || e.isIn("select.editing_shape"))
          return;
        wn(i);
      }
    };
    return t.addEventListener("touchstart", r), t.addEventListener("touchend", r), () => {
      t.removeEventListener("touchstart", r), t.removeEventListener("touchend", r);
    };
  }, [e, n]);
}
function Sse(n, e, t) {
  return Math.max(e, Math.min(n, t));
}
const zo = {
  toVector(n, e) {
    return n === void 0 && (n = e), Array.isArray(n) ? n : [n, n];
  },
  add(n, e) {
    return [n[0] + e[0], n[1] + e[1]];
  },
  sub(n, e) {
    return [n[0] - e[0], n[1] - e[1]];
  },
  addTo(n, e) {
    n[0] += e[0], n[1] += e[1];
  },
  subTo(n, e) {
    n[0] -= e[0], n[1] -= e[1];
  }
};
function C4(n, e, t) {
  return e === 0 || Math.abs(e) === 1 / 0 ? Math.pow(n, t * 5) : n * e * t / (e + t * n);
}
function E4(n, e, t, r = 0.15) {
  return r === 0 ? Sse(n, e, t) : n < e ? -C4(e - n, t - e, r) + e : n > t ? +C4(n - t, t - e, r) + t : n;
}
function xse(n, [e, t], [r, i]) {
  const [[s, l], [c, d]] = n;
  return [E4(e, s, l, r), E4(t, c, d, i)];
}
var QE = {};
function wse(n, e) {
  if (typeof n != "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function bse(n) {
  var e = wse(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function ds(n, e, t) {
  return e = bse(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function _4(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function ii(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _4(Object(t), !0).forEach(function(r) {
      ds(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : _4(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
const J8 = {
  pointer: {
    start: "down",
    change: "move",
    end: "up"
  },
  mouse: {
    start: "down",
    change: "move",
    end: "up"
  },
  touch: {
    start: "start",
    change: "move",
    end: "end"
  },
  gesture: {
    start: "start",
    change: "change",
    end: "end"
  }
};
function P4(n) {
  return n ? n[0].toUpperCase() + n.slice(1) : "";
}
const Cse = ["enter", "leave"];
function Ese(n = !1, e) {
  return n && !Cse.includes(e);
}
function _se(n, e = "", t = !1) {
  const r = J8[n], i = r && r[e] || e;
  return "on" + P4(n) + P4(i) + (Ese(t, i) ? "Capture" : "");
}
const Pse = ["gotpointercapture", "lostpointercapture"];
function Tse(n) {
  let e = n.substring(2).toLowerCase();
  const t = !!~e.indexOf("passive");
  t && (e = e.replace("passive", ""));
  const r = Pse.includes(e) ? "capturecapture" : "capture", i = !!~e.indexOf(r);
  return i && (e = e.replace("capture", "")), {
    device: e,
    capture: i,
    passive: t
  };
}
function Ise(n, e = "") {
  const t = J8[n], r = t && t[e] || e;
  return n + r;
}
function eB(n) {
  return "touches" in n;
}
function kse(n) {
  return eB(n) ? "touch" : "pointerType" in n ? n.pointerType : "mouse";
}
function Rse(n) {
  return Array.from(n.touches).filter((e) => {
    var t, r;
    return e.target === n.currentTarget || ((t = n.currentTarget) === null || t === void 0 || (r = t.contains) === null || r === void 0 ? void 0 : r.call(t, e.target));
  });
}
function GA(n, e) {
  try {
    const t = e.clientX - n.clientX, r = e.clientY - n.clientY, i = (e.clientX + n.clientX) / 2, s = (e.clientY + n.clientY) / 2, l = Math.hypot(t, r);
    return {
      angle: -(Math.atan2(t, r) * 180) / Math.PI,
      distance: l,
      origin: [i, s]
    };
  } catch {
  }
  return null;
}
function Mse(n) {
  return Rse(n).map((e) => e.identifier);
}
function T4(n, e) {
  const [t, r] = Array.from(n.touches).filter((i) => e.includes(i.identifier));
  return GA(t, r);
}
const I4 = 40, k4 = 800;
function tB(n) {
  let {
    deltaX: e,
    deltaY: t,
    deltaMode: r
  } = n;
  return r === 1 ? (e *= I4, t *= I4) : r === 2 && (e *= k4, t *= k4), [e, t];
}
function Ase(n) {
  const e = {};
  if ("buttons" in n && (e.buttons = n.buttons), "shiftKey" in n) {
    const {
      shiftKey: t,
      altKey: r,
      metaKey: i,
      ctrlKey: s
    } = n;
    Object.assign(e, {
      shiftKey: t,
      altKey: r,
      metaKey: i,
      ctrlKey: s
    });
  }
  return e;
}
function SE(n, ...e) {
  return typeof n == "function" ? n(...e) : n;
}
function Dse() {
}
function Ose(...n) {
  return n.length === 0 ? Dse : n.length === 1 ? n[0] : function() {
    let e;
    for (const t of n)
      e = t.apply(this, arguments) || e;
    return e;
  };
}
function R4(n, e) {
  return Object.assign({}, e, n || {});
}
const jse = 32;
class nB {
  constructor(e, t, r) {
    this.ctrl = e, this.args = t, this.key = r, this.state || (this.state = {}, this.computeValues([0, 0]), this.computeInitial(), this.init && this.init(), this.reset());
  }
  get state() {
    return this.ctrl.state[this.key];
  }
  set state(e) {
    this.ctrl.state[this.key] = e;
  }
  get shared() {
    return this.ctrl.state.shared;
  }
  get eventStore() {
    return this.ctrl.gestureEventStores[this.key];
  }
  get timeoutStore() {
    return this.ctrl.gestureTimeoutStores[this.key];
  }
  get config() {
    return this.ctrl.config[this.key];
  }
  get sharedConfig() {
    return this.ctrl.config.shared;
  }
  get handler() {
    return this.ctrl.handlers[this.key];
  }
  reset() {
    const {
      state: e,
      shared: t,
      ingKey: r,
      args: i
    } = this;
    t[r] = e._active = e.active = e._blocked = e._force = !1, e._step = [!1, !1], e.intentional = !1, e._movement = [0, 0], e._distance = [0, 0], e._direction = [0, 0], e._delta = [0, 0], e._bounds = [[-1 / 0, 1 / 0], [-1 / 0, 1 / 0]], e.args = i, e.axis = void 0, e.memo = void 0, e.elapsedTime = e.timeDelta = 0, e.direction = [0, 0], e.distance = [0, 0], e.overflow = [0, 0], e._movementBound = [!1, !1], e.velocity = [0, 0], e.movement = [0, 0], e.delta = [0, 0], e.timeStamp = 0;
  }
  start(e) {
    const t = this.state, r = this.config;
    t._active || (this.reset(), this.computeInitial(), t._active = !0, t.target = e.target, t.currentTarget = e.currentTarget, t.lastOffset = r.from ? SE(r.from, t) : t.offset, t.offset = t.lastOffset, t.startTime = t.timeStamp = e.timeStamp);
  }
  computeValues(e) {
    const t = this.state;
    t._values = e, t.values = this.config.transform(e);
  }
  computeInitial() {
    const e = this.state;
    e._initial = e._values, e.initial = e.values;
  }
  compute(e) {
    const {
      state: t,
      config: r,
      shared: i
    } = this;
    t.args = this.args;
    let s = 0;
    if (e && (t.event = e, r.preventDefault && e.cancelable && t.event.preventDefault(), t.type = e.type, i.touches = this.ctrl.pointerIds.size || this.ctrl.touchIds.size, i.locked = !!document.pointerLockElement, Object.assign(i, Ase(e)), i.down = i.pressed = i.buttons % 2 === 1 || i.touches > 0, s = e.timeStamp - t.timeStamp, t.timeStamp = e.timeStamp, t.elapsedTime = t.timeStamp - t.startTime), t._active) {
      const F = t._delta.map(Math.abs);
      zo.addTo(t._distance, F);
    }
    this.axisIntent && this.axisIntent(e);
    const [l, c] = t._movement, [d, h] = r.threshold, {
      _step: g,
      values: y
    } = t;
    if (r.hasCustomTransform ? (g[0] === !1 && (g[0] = Math.abs(l) >= d && y[0]), g[1] === !1 && (g[1] = Math.abs(c) >= h && y[1])) : (g[0] === !1 && (g[0] = Math.abs(l) >= d && Math.sign(l) * d), g[1] === !1 && (g[1] = Math.abs(c) >= h && Math.sign(c) * h)), t.intentional = g[0] !== !1 || g[1] !== !1, !t.intentional) return;
    const v = [0, 0];
    if (r.hasCustomTransform) {
      const [F, H] = y;
      v[0] = g[0] !== !1 ? F - g[0] : 0, v[1] = g[1] !== !1 ? H - g[1] : 0;
    } else
      v[0] = g[0] !== !1 ? l - g[0] : 0, v[1] = g[1] !== !1 ? c - g[1] : 0;
    this.restrictToAxis && !t._blocked && this.restrictToAxis(v);
    const w = t.offset, C = t._active && !t._blocked || t.active;
    C && (t.first = t._active && !t.active, t.last = !t._active && t.active, t.active = i[this.ingKey] = t._active, e && (t.first && ("bounds" in r && (t._bounds = SE(r.bounds, t)), this.setup && this.setup()), t.movement = v, this.computeOffset()));
    const [E, P] = t.offset, [[I, k], [L, O]] = t._bounds;
    t.overflow = [E < I ? -1 : E > k ? 1 : 0, P < L ? -1 : P > O ? 1 : 0], t._movementBound[0] = t.overflow[0] ? t._movementBound[0] === !1 ? t._movement[0] : t._movementBound[0] : !1, t._movementBound[1] = t.overflow[1] ? t._movementBound[1] === !1 ? t._movement[1] : t._movementBound[1] : !1;
    const z = t._active ? r.rubberband || [0, 0] : [0, 0];
    if (t.offset = xse(t._bounds, t.offset, z), t.delta = zo.sub(t.offset, w), this.computeMovement(), C && (!t.last || s > jse)) {
      t.delta = zo.sub(t.offset, w);
      const F = t.delta.map(Math.abs);
      zo.addTo(t.distance, F), t.direction = t.delta.map(Math.sign), t._direction = t._delta.map(Math.sign), !t.first && s > 0 && (t.velocity = [F[0] / s, F[1] / s], t.timeDelta = s);
    }
  }
  emit() {
    const e = this.state, t = this.shared, r = this.config;
    if (e._active || this.clean(), (e._blocked || !e.intentional) && !e._force && !r.triggerAllEvents) return;
    const i = this.handler(ii(ii(ii({}, t), e), {}, {
      [this.aliasKey]: e.values
    }));
    i !== void 0 && (e.memo = i);
  }
  clean() {
    this.eventStore.clean(), this.timeoutStore.clean();
  }
}
function Lse([n, e], t) {
  const r = Math.abs(n), i = Math.abs(e);
  if (r > i && r > t)
    return "x";
  if (i > r && i > t)
    return "y";
}
class Nse extends nB {
  constructor(...e) {
    super(...e), ds(this, "aliasKey", "xy");
  }
  reset() {
    super.reset(), this.state.axis = void 0;
  }
  init() {
    this.state.offset = [0, 0], this.state.lastOffset = [0, 0];
  }
  computeOffset() {
    this.state.offset = zo.add(this.state.lastOffset, this.state.movement);
  }
  computeMovement() {
    this.state.movement = zo.sub(this.state.offset, this.state.lastOffset);
  }
  axisIntent(e) {
    const t = this.state, r = this.config;
    if (!t.axis && e) {
      const i = typeof r.axisThreshold == "object" ? r.axisThreshold[kse(e)] : r.axisThreshold;
      t.axis = Lse(t._movement, i);
    }
    t._blocked = (r.lockDirection || !!r.axis) && !t.axis || !!r.axis && r.axis !== t.axis;
  }
  restrictToAxis(e) {
    if (this.config.axis || this.config.lockDirection)
      switch (this.state.axis) {
        case "x":
          e[1] = 0;
          break;
        case "y":
          e[0] = 0;
          break;
      }
  }
}
const M4 = (n) => n, A4 = 0.15, LO = {
  enabled(n = !0) {
    return n;
  },
  eventOptions(n, e, t) {
    return ii(ii({}, t.shared.eventOptions), n);
  },
  preventDefault(n = !1) {
    return n;
  },
  triggerAllEvents(n = !1) {
    return n;
  },
  rubberband(n = 0) {
    switch (n) {
      case !0:
        return [A4, A4];
      case !1:
        return [0, 0];
      default:
        return zo.toVector(n);
    }
  },
  from(n) {
    if (typeof n == "function") return n;
    if (n != null) return zo.toVector(n);
  },
  transform(n, e, t) {
    const r = n || t.shared.transform;
    if (this.hasCustomTransform = !!r, QE.NODE_ENV === "development") {
      const i = r || M4;
      return (s) => {
        const l = i(s);
        return (!isFinite(l[0]) || !isFinite(l[1])) && console.warn(`[@use-gesture]: config.transform() must produce a valid result, but it was: [${l[0]},${[1]}]`), l;
      };
    }
    return r || M4;
  },
  threshold(n) {
    return zo.toVector(n, 0);
  }
};
QE.NODE_ENV === "development" && Object.assign(LO, {
  domTarget(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
    return NaN;
  },
  lockDirection(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `lockDirection` option has been merged with `axis`. Use it as in `{ axis: 'lock' }`");
    return NaN;
  },
  initial(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `initial` option has been renamed to `from`.");
    return NaN;
  }
});
const Fse = 0, Sw = ii(ii({}, LO), {}, {
  axis(n, e, {
    axis: t
  }) {
    if (this.lockDirection = t === "lock", !this.lockDirection) return t;
  },
  axisThreshold(n = Fse) {
    return n;
  },
  bounds(n = {}) {
    if (typeof n == "function")
      return (s) => Sw.bounds(n(s));
    if ("current" in n)
      return () => n.current;
    if (typeof HTMLElement == "function" && n instanceof HTMLElement)
      return n;
    const {
      left: e = -1 / 0,
      right: t = 1 / 0,
      top: r = -1 / 0,
      bottom: i = 1 / 0
    } = n;
    return [[e, t], [r, i]];
  }
}), xw = typeof window < "u" && window.document && window.document.createElement;
function rB() {
  return xw && "ontouchstart" in window;
}
function zse() {
  return rB() || xw && window.navigator.maxTouchPoints > 1;
}
function Use() {
  return xw && "onpointerdown" in window;
}
function $se() {
  return xw && "exitPointerLock" in window.document;
}
function Bse() {
  try {
    return "constructor" in GestureEvent;
  } catch {
    return !1;
  }
}
const Rl = {
  isBrowser: xw,
  gesture: Bse(),
  touch: rB(),
  touchscreen: zse(),
  pointer: Use(),
  pointerLock: $se()
}, Hse = 250, Vse = 180, Kse = 0.5, Wse = 50, Gse = 250, qse = 10, D4 = {
  mouse: 0,
  touch: 0,
  pen: 8
}, Yse = ii(ii({}, Sw), {}, {
  device(n, e, {
    pointer: {
      touch: t = !1,
      lock: r = !1,
      mouse: i = !1
    } = {}
  }) {
    return this.pointerLock = r && Rl.pointerLock, Rl.touch && t ? "touch" : this.pointerLock ? "mouse" : Rl.pointer && !i ? "pointer" : Rl.touch ? "touch" : "mouse";
  },
  preventScrollAxis(n, e, {
    preventScroll: t
  }) {
    if (this.preventScrollDelay = typeof t == "number" ? t : t || t === void 0 && n ? Hse : void 0, !(!Rl.touchscreen || t === !1))
      return n || (t !== void 0 ? "y" : void 0);
  },
  pointerCapture(n, e, {
    pointer: {
      capture: t = !0,
      buttons: r = 1,
      keys: i = !0
    } = {}
  }) {
    return this.pointerButtons = r, this.keys = i, !this.pointerLock && this.device === "pointer" && t;
  },
  threshold(n, e, {
    filterTaps: t = !1,
    tapsThreshold: r = 3,
    axis: i = void 0
  }) {
    const s = zo.toVector(n, t ? r : i ? 1 : 0);
    return this.filterTaps = t, this.tapsThreshold = r, s;
  },
  swipe({
    velocity: n = Kse,
    distance: e = Wse,
    duration: t = Gse
  } = {}) {
    return {
      velocity: this.transform(zo.toVector(n)),
      distance: this.transform(zo.toVector(e)),
      duration: t
    };
  },
  delay(n = 0) {
    switch (n) {
      case !0:
        return Vse;
      case !1:
        return 0;
      default:
        return n;
    }
  },
  axisThreshold(n) {
    return n ? ii(ii({}, D4), n) : D4;
  },
  keyboardDisplacement(n = qse) {
    return n;
  }
});
QE.NODE_ENV === "development" && Object.assign(Yse, {
  useTouch(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `useTouch` option has been renamed to `pointer.touch`. Use it as in `{ pointer: { touch: true } }`.");
    return NaN;
  },
  experimental_preventWindowScrollY(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `experimental_preventWindowScrollY` option has been renamed to `preventScroll`.");
    return NaN;
  },
  swipeVelocity(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeVelocity` option has been renamed to `swipe.velocity`. Use it as in `{ swipe: { velocity: 0.5 } }`.");
    return NaN;
  },
  swipeDistance(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDistance` option has been renamed to `swipe.distance`. Use it as in `{ swipe: { distance: 50 } }`.");
    return NaN;
  },
  swipeDuration(n) {
    if (n !== void 0)
      throw Error("[@use-gesture]: `swipeDuration` option has been renamed to `swipe.duration`. Use it as in `{ swipe: { duration: 250 } }`.");
    return NaN;
  }
});
function iB(n) {
  const [e, t] = n.overflow, [r, i] = n._delta, [s, l] = n._direction;
  (e < 0 && r > 0 && s < 0 || e > 0 && r < 0 && s > 0) && (n._movement[0] = n._movementBound[0]), (t < 0 && i > 0 && l < 0 || t > 0 && i < 0 && l > 0) && (n._movement[1] = n._movementBound[1]);
}
const Xse = 30, Zse = 100;
class Qse extends nB {
  constructor(...e) {
    super(...e), ds(this, "ingKey", "pinching"), ds(this, "aliasKey", "da");
  }
  init() {
    this.state.offset = [1, 0], this.state.lastOffset = [1, 0], this.state._pointerEvents = /* @__PURE__ */ new Map();
  }
  reset() {
    super.reset();
    const e = this.state;
    e._touchIds = [], e.canceled = !1, e.cancel = this.cancel.bind(this), e.turns = 0;
  }
  computeOffset() {
    const {
      type: e,
      movement: t,
      lastOffset: r
    } = this.state;
    e === "wheel" ? this.state.offset = zo.add(t, r) : this.state.offset = [(1 + t[0]) * r[0], t[1] + r[1]];
  }
  computeMovement() {
    const {
      offset: e,
      lastOffset: t
    } = this.state;
    this.state.movement = [e[0] / t[0], e[1] - t[1]];
  }
  axisIntent() {
    const e = this.state, [t, r] = e._movement;
    if (!e.axis) {
      const i = Math.abs(t) * Xse - Math.abs(r);
      i < 0 ? e.axis = "angle" : i > 0 && (e.axis = "scale");
    }
  }
  restrictToAxis(e) {
    this.config.lockDirection && (this.state.axis === "scale" ? e[1] = 0 : this.state.axis === "angle" && (e[0] = 0));
  }
  cancel() {
    const e = this.state;
    e.canceled || setTimeout(() => {
      e.canceled = !0, e._active = !1, this.compute(), this.emit();
    }, 0);
  }
  touchStart(e) {
    this.ctrl.setEventIds(e);
    const t = this.state, r = this.ctrl.touchIds;
    if (t._active && t._touchIds.every((s) => r.has(s)) || r.size < 2) return;
    this.start(e), t._touchIds = Array.from(r).slice(0, 2);
    const i = T4(e, t._touchIds);
    i && this.pinchStart(e, i);
  }
  pointerStart(e) {
    if (e.buttons != null && e.buttons % 2 !== 1) return;
    this.ctrl.setEventIds(e), e.target.setPointerCapture(e.pointerId);
    const t = this.state, r = t._pointerEvents, i = this.ctrl.pointerIds;
    if (t._active && Array.from(r.keys()).every((l) => i.has(l)) || (r.size < 2 && r.set(e.pointerId, e), t._pointerEvents.size < 2)) return;
    this.start(e);
    const s = GA(...Array.from(r.values()));
    s && this.pinchStart(e, s);
  }
  pinchStart(e, t) {
    const r = this.state;
    r.origin = t.origin, this.computeValues([t.distance, t.angle]), this.computeInitial(), this.compute(e), this.emit();
  }
  touchMove(e) {
    if (!this.state._active) return;
    const t = T4(e, this.state._touchIds);
    t && this.pinchMove(e, t);
  }
  pointerMove(e) {
    const t = this.state._pointerEvents;
    if (t.has(e.pointerId) && t.set(e.pointerId, e), !this.state._active) return;
    const r = GA(...Array.from(t.values()));
    r && this.pinchMove(e, r);
  }
  pinchMove(e, t) {
    const r = this.state, i = r._values[1], s = t.angle - i;
    let l = 0;
    Math.abs(s) > 270 && (l += Math.sign(s)), this.computeValues([t.distance, t.angle - 360 * l]), r.origin = t.origin, r.turns = l, r._movement = [r._values[0] / r._initial[0] - 1, r._values[1] - r._initial[1]], this.compute(e), this.emit();
  }
  touchEnd(e) {
    this.ctrl.setEventIds(e), this.state._active && this.state._touchIds.some((t) => !this.ctrl.touchIds.has(t)) && (this.state._active = !1, this.compute(e), this.emit());
  }
  pointerEnd(e) {
    const t = this.state;
    this.ctrl.setEventIds(e);
    try {
      e.target.releasePointerCapture(e.pointerId);
    } catch {
    }
    t._pointerEvents.has(e.pointerId) && t._pointerEvents.delete(e.pointerId), t._active && t._pointerEvents.size < 2 && (t._active = !1, this.compute(e), this.emit());
  }
  gestureStart(e) {
    e.cancelable && e.preventDefault();
    const t = this.state;
    t._active || (this.start(e), this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY], this.compute(e), this.emit());
  }
  gestureMove(e) {
    if (e.cancelable && e.preventDefault(), !this.state._active) return;
    const t = this.state;
    this.computeValues([e.scale, e.rotation]), t.origin = [e.clientX, e.clientY];
    const r = t._movement;
    t._movement = [e.scale - 1, e.rotation], t._delta = zo.sub(t._movement, r), this.compute(e), this.emit();
  }
  gestureEnd(e) {
    this.state._active && (this.state._active = !1, this.compute(e), this.emit());
  }
  wheel(e) {
    const t = this.config.modifierKey;
    t && (Array.isArray(t) ? !t.find((r) => e[r]) : !e[t]) || (this.state._active ? this.wheelChange(e) : this.wheelStart(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this)));
  }
  wheelStart(e) {
    this.start(e), this.wheelChange(e);
  }
  wheelChange(e) {
    "uv" in e || (e.cancelable && e.preventDefault(), QE.NODE_ENV === "development" && !e.defaultPrevented && console.warn("[@use-gesture]: To properly support zoom on trackpads, try using the `target` option.\n\nThis message will only appear in development mode."));
    const r = this.state;
    r._delta = [-tB(e)[1] / Zse * r.offset[0], 0], zo.addTo(r._movement, r._delta), iB(r), this.state.origin = [e.clientX, e.clientY], this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    const t = this.config.device;
    t && (e(t, "start", this[t + "Start"].bind(this)), e(t, "change", this[t + "Move"].bind(this)), e(t, "end", this[t + "End"].bind(this)), e(t, "cancel", this[t + "End"].bind(this)), e("lostPointerCapture", "", this[t + "End"].bind(this))), this.config.pinchOnWheel && e("wheel", "", this.wheel.bind(this), {
      passive: !1
    });
  }
}
const Jse = ii(ii({}, LO), {}, {
  device(n, e, {
    shared: t,
    pointer: {
      touch: r = !1
    } = {}
  }) {
    if (t.target && !Rl.touch && Rl.gesture) return "gesture";
    if (Rl.touch && r) return "touch";
    if (Rl.touchscreen) {
      if (Rl.pointer) return "pointer";
      if (Rl.touch) return "touch";
    }
  },
  bounds(n, e, {
    scaleBounds: t = {},
    angleBounds: r = {}
  }) {
    const i = (l) => {
      const c = R4(SE(t, l), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    }, s = (l) => {
      const c = R4(SE(r, l), {
        min: -1 / 0,
        max: 1 / 0
      });
      return [c.min, c.max];
    };
    return typeof t != "function" && typeof r != "function" ? [i(), s()] : (l) => [i(l), s(l)];
  },
  threshold(n, e, t) {
    return this.lockDirection = t.axis === "lock", zo.toVector(n, this.lockDirection ? [0.1, 3] : 0);
  },
  modifierKey(n) {
    return n === void 0 ? "ctrlKey" : n;
  },
  pinchOnWheel(n = !0) {
    return n;
  }
});
ii(ii({}, Sw), {}, {
  mouseOnly: (n = !0) => n
});
class eae extends Nse {
  constructor(...e) {
    super(...e), ds(this, "ingKey", "wheeling");
  }
  wheel(e) {
    this.state._active || this.start(e), this.wheelChange(e), this.timeoutStore.add("wheelEnd", this.wheelEnd.bind(this));
  }
  wheelChange(e) {
    const t = this.state;
    t._delta = tB(e), zo.addTo(t._movement, t._delta), iB(t), this.compute(e), this.emit();
  }
  wheelEnd() {
    this.state._active && (this.state._active = !1, this.compute(), this.emit());
  }
  bind(e) {
    e("wheel", "", this.wheel.bind(this));
  }
}
const tae = Sw;
ii(ii({}, Sw), {}, {
  mouseOnly: (n = !0) => n
});
const NO = /* @__PURE__ */ new Map(), qA = /* @__PURE__ */ new Map();
function nae(n) {
  NO.set(n.key, n.engine), qA.set(n.key, n.resolver);
}
const rae = {
  key: "pinch",
  engine: Qse,
  resolver: Jse
}, iae = {
  key: "wheel",
  engine: eae,
  resolver: tae
};
var FO = {};
function oae(n, e) {
  if (n == null) return {};
  var t = {}, r = Object.keys(n), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function sae(n, e) {
  if (n == null) return {};
  var t = oae(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (i = 0; i < s.length; i++)
      r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
const aae = {
  target(n) {
    if (n)
      return () => "current" in n ? n.current : n;
  },
  enabled(n = !0) {
    return n;
  },
  window(n = Rl.isBrowser ? window : void 0) {
    return n;
  },
  eventOptions({
    passive: n = !0,
    capture: e = !1
  } = {}) {
    return {
      passive: n,
      capture: e
    };
  },
  transform(n) {
    return n;
  }
}, lae = ["target", "eventOptions", "window", "enabled", "transform"];
function xC(n = {}, e) {
  const t = {};
  for (const [r, i] of Object.entries(e))
    switch (typeof i) {
      case "function":
        if (FO.NODE_ENV === "development") {
          const s = i.call(t, n[r], r, n);
          Number.isNaN(s) || (t[r] = s);
        } else
          t[r] = i.call(t, n[r], r, n);
        break;
      case "object":
        t[r] = xC(n[r], i);
        break;
      case "boolean":
        i && (t[r] = n[r]);
        break;
    }
  return t;
}
function cae(n, e, t = {}) {
  const r = n, {
    target: i,
    eventOptions: s,
    window: l,
    enabled: c,
    transform: d
  } = r, h = sae(r, lae);
  if (t.shared = xC({
    target: i,
    eventOptions: s,
    window: l,
    enabled: c,
    transform: d
  }, aae), e) {
    const g = qA.get(e);
    t[e] = xC(ii({
      shared: t.shared
    }, h), g);
  } else
    for (const g in h) {
      const y = qA.get(g);
      if (y)
        t[g] = xC(ii({
          shared: t.shared
        }, h[g]), y);
      else if (FO.NODE_ENV === "development" && !["drag", "pinch", "scroll", "wheel", "move", "hover"].includes(g)) {
        if (g === "domTarget")
          throw Error("[@use-gesture]: `domTarget` option has been renamed to `target`.");
        console.warn(`[@use-gesture]: Unknown config key \`${g}\` was used. Please read the documentation for further information.`);
      }
    }
  return t;
}
class oB {
  constructor(e, t) {
    ds(this, "_listeners", /* @__PURE__ */ new Set()), this._ctrl = e, this._gestureKey = t;
  }
  add(e, t, r, i, s) {
    const l = this._listeners, c = Ise(t, r), d = this._gestureKey ? this._ctrl.config[this._gestureKey].eventOptions : {}, h = ii(ii({}, d), s);
    e.addEventListener(c, i, h);
    const g = () => {
      e.removeEventListener(c, i, h), l.delete(g);
    };
    return l.add(g), g;
  }
  clean() {
    this._listeners.forEach((e) => e()), this._listeners.clear();
  }
}
class uae {
  constructor() {
    ds(this, "_timeouts", /* @__PURE__ */ new Map());
  }
  add(e, t, r = 140, ...i) {
    this.remove(e), this._timeouts.set(e, window.setTimeout(t, r, ...i));
  }
  remove(e) {
    const t = this._timeouts.get(e);
    t && window.clearTimeout(t);
  }
  clean() {
    this._timeouts.forEach((e) => void window.clearTimeout(e)), this._timeouts.clear();
  }
}
class dae {
  constructor(e) {
    ds(this, "gestures", /* @__PURE__ */ new Set()), ds(this, "_targetEventStore", new oB(this)), ds(this, "gestureEventStores", {}), ds(this, "gestureTimeoutStores", {}), ds(this, "handlers", {}), ds(this, "config", {}), ds(this, "pointerIds", /* @__PURE__ */ new Set()), ds(this, "touchIds", /* @__PURE__ */ new Set()), ds(this, "state", {
      shared: {
        shiftKey: !1,
        metaKey: !1,
        ctrlKey: !1,
        altKey: !1
      }
    }), fae(this, e);
  }
  setEventIds(e) {
    if (eB(e))
      return this.touchIds = new Set(Mse(e)), this.touchIds;
    if ("pointerId" in e)
      return e.type === "pointerup" || e.type === "pointercancel" ? this.pointerIds.delete(e.pointerId) : e.type === "pointerdown" && this.pointerIds.add(e.pointerId), this.pointerIds;
  }
  applyHandlers(e, t) {
    this.handlers = e, this.nativeHandlers = t;
  }
  applyConfig(e, t) {
    this.config = cae(e, t, this.config);
  }
  clean() {
    this._targetEventStore.clean();
    for (const e of this.gestures)
      this.gestureEventStores[e].clean(), this.gestureTimeoutStores[e].clean();
  }
  effect() {
    return this.config.shared.target && this.bind(), () => this._targetEventStore.clean();
  }
  bind(...e) {
    const t = this.config.shared, r = {};
    let i;
    if (!(t.target && (i = t.target(), !i))) {
      if (t.enabled) {
        for (const l of this.gestures) {
          const c = this.config[l], d = O4(r, c.eventOptions, !!i);
          if (c.enabled) {
            const h = NO.get(l);
            new h(this, e, l).bind(d);
          }
        }
        const s = O4(r, t.eventOptions, !!i);
        for (const l in this.nativeHandlers)
          s(l, "", (c) => this.nativeHandlers[l](ii(ii({}, this.state.shared), {}, {
            event: c,
            args: e
          })), void 0, !0);
      }
      for (const s in r)
        r[s] = Ose(...r[s]);
      if (!i) return r;
      for (const s in r) {
        const {
          device: l,
          capture: c,
          passive: d
        } = Tse(s);
        this._targetEventStore.add(i, l, "", r[s], {
          capture: c,
          passive: d
        });
      }
    }
  }
}
function iy(n, e) {
  n.gestures.add(e), n.gestureEventStores[e] = new oB(n, e), n.gestureTimeoutStores[e] = new uae();
}
function fae(n, e) {
  e.drag && iy(n, "drag"), e.wheel && iy(n, "wheel"), e.scroll && iy(n, "scroll"), e.move && iy(n, "move"), e.pinch && iy(n, "pinch"), e.hover && iy(n, "hover");
}
const O4 = (n, e, t) => (r, i, s, l = {}, c = !1) => {
  var d, h;
  const g = (d = l.capture) !== null && d !== void 0 ? d : e.capture, y = (h = l.passive) !== null && h !== void 0 ? h : e.passive;
  let v = c ? r : _se(r, i, g);
  t && y && (v += "Passive"), n[v] = n[v] || [], n[v].push(s);
}, hae = /^on(Drag|Wheel|Scroll|Move|Pinch|Hover)/;
function pae(n) {
  const e = {}, t = {}, r = /* @__PURE__ */ new Set();
  for (let i in n)
    hae.test(i) ? (r.add(RegExp.lastMatch), t[i] = n[i]) : e[i] = n[i];
  return [t, e, r];
}
function oy(n, e, t, r, i, s) {
  if (!n.has(t)) return;
  if (!NO.has(r)) {
    FO.NODE_ENV === "development" && console.warn(`[@use-gesture]: You've created a custom handler that that uses the \`${r}\` gesture but isn't properly configured.

Please add \`${r}Action\` when creating your handler.`);
    return;
  }
  const l = t + "Start", c = t + "End", d = (h) => {
    let g;
    return h.first && l in e && e[l](h), t in e && (g = e[t](h)), h.last && c in e && e[c](h), g;
  };
  i[r] = d, s[r] = s[r] || {};
}
function gae(n, e) {
  const [t, r, i] = pae(n), s = {};
  return oy(i, t, "onDrag", "drag", s, e), oy(i, t, "onWheel", "wheel", s, e), oy(i, t, "onScroll", "scroll", s, e), oy(i, t, "onPinch", "pinch", s, e), oy(i, t, "onMove", "move", s, e), oy(i, t, "onHover", "hover", s, e), {
    handlers: s,
    config: e,
    nativeHandlers: r
  };
}
function mae(n, e = {}, t, r) {
  const i = Bt.useMemo(() => new dae(n), []);
  if (i.applyHandlers(n, r), i.applyConfig(e, t), Bt.useEffect(i.effect.bind(i)), Bt.useEffect(() => i.clean.bind(i), []), e.target === void 0)
    return i.bind.bind(i);
}
function yae(n) {
  return n.forEach(nae), function(t, r) {
    const {
      handlers: i,
      nativeHandlers: s,
      config: l
    } = gae(t, r || {});
    return mae(i, l, void 0, s);
  };
}
const j4 = 10, vae = /Mac|iPod|iPhone|iPad/.test(
  // eslint-disable-next-line @typescript-eslint/no-deprecated
  typeof window > "u" ? "node" : window.navigator.platform
);
function sB(n) {
  let { deltaY: e, deltaX: t } = n, r = 0;
  return n.ctrlKey || n.altKey || n.metaKey ? r = (Math.abs(e) > j4 ? j4 * Math.sign(e) : e) / 100 : n.shiftKey && !vae && (t = e, e = 0), { x: -t, y: -e, z: -r };
}
const Sae = yae([iae, rae]);
let sy;
const xae = (n) => sy === void 0 ? (sy = n, !1) : n - sy > 120 && n - sy < 160 ? (sy = n, !0) : (sy = n, !1);
function wae(n) {
  const e = be(), t = M.useMemo(() => {
    let r = "not sure";
    const i = ({ event: E }) => {
      if (!e.getInstanceState().isFocused || (r = "not sure", xae(Date.now())))
        return;
      const P = e.getEditingShapeId();
      if (P) {
        const L = e.getShape(P);
        if (L && e.getShapeUtil(L).canScroll(L)) {
          const z = e.getShapePageBounds(P);
          if (z != null && z.containsPoint(e.inputs.currentPagePoint))
            return;
        }
      }
      wn(E), Ti(E);
      const I = sB(E);
      if (I.x === 0 && I.y === 0) return;
      const k = {
        type: "wheel",
        name: "wheel",
        delta: I,
        point: new R(E.clientX, E.clientY),
        shiftKey: E.shiftKey,
        altKey: E.altKey,
        ctrlKey: E.metaKey || E.ctrlKey,
        metaKey: E.metaKey,
        accelKey: ms(E)
      };
      e.dispatch(k);
    };
    let s = 1, l = 1, c = 1, d = 0;
    const h = new R(), g = new R(), y = (E) => {
      const P = n.current;
      r = "not sure";
      const { event: I, origin: k, da: L } = E;
      I instanceof WheelEvent || (I.target === P || P != null && P.contains(I.target)) && (g.x = k[0], g.y = k[1], h.x = k[0], h.y = k[1], s = L[0], l = e.getZoomLevel(), e.dispatch({
        type: "pinch",
        name: "pinch_start",
        point: { x: k[0], y: k[1], z: e.getZoomLevel() },
        delta: { x: 0, y: 0 },
        shiftKey: I.shiftKey,
        altKey: I.altKey,
        ctrlKey: I.metaKey || I.ctrlKey,
        metaKey: I.metaKey,
        accelKey: ms(I)
      }));
    }, v = (E) => {
      if (E && (r = "zooming"), r === "zooming")
        return;
      const P = Math.abs(d - s), I = R.Dist(h, g);
      switch (r) {
        case "not sure": {
          P > 24 ? r = "zooming" : I > 16 && (r = "panning");
          break;
        }
        case "panning": {
          P > 64 && (r = "zooming");
          break;
        }
      }
    };
    return {
      onWheel: i,
      onPinchStart: y,
      onPinchEnd: (E) => {
        const P = n.current, { event: I, origin: k, offset: L } = E;
        if (I instanceof WheelEvent || !(I.target === P || P != null && P.contains(I.target))) return;
        const O = L[0];
        r = "not sure", e.timers.requestAnimationFrame(() => {
          e.dispatch({
            type: "pinch",
            name: "pinch_end",
            point: { x: k[0], y: k[1], z: O },
            delta: { x: k[0], y: k[1] },
            shiftKey: I.shiftKey,
            altKey: I.altKey,
            ctrlKey: I.metaKey || I.ctrlKey,
            metaKey: I.metaKey,
            accelKey: ms(I)
          });
        });
      },
      onPinch: (E) => {
        const P = n.current, { event: I, origin: k, offset: L, da: O } = E;
        if (I instanceof WheelEvent || !(I.target === P || P != null && P.contains(I.target))) return;
        const z = E.type === "gesturechange" || E.type === "gestureend";
        d = O[0];
        const F = k[0] - g.x, H = k[1] - g.y;
        switch (g.x = k[0], g.y = k[1], v(z), r) {
          case "zooming": {
            c = L[0], e.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: k[0], y: k[1], z: c },
              delta: { x: F, y: H },
              shiftKey: I.shiftKey,
              altKey: I.altKey,
              ctrlKey: I.metaKey || I.ctrlKey,
              metaKey: I.metaKey,
              accelKey: ms(I)
            });
            break;
          }
          case "panning": {
            e.dispatch({
              type: "pinch",
              name: "pinch",
              point: { x: k[0], y: k[1], z: l },
              delta: { x: F, y: H },
              shiftKey: I.shiftKey,
              altKey: I.altKey,
              ctrlKey: I.metaKey || I.ctrlKey,
              metaKey: I.metaKey,
              accelKey: ms(I)
            });
            break;
          }
        }
      }
    };
  }, [e, n]);
  Sae(t, {
    target: n,
    eventOptions: { passive: !1 },
    pinch: {
      from: () => [e.getZoomLevel(), 0],
      // Return the camera z to use when pinch starts
      scaleBounds: () => {
        const r = e.getBaseZoom(), i = e.getCameraOptions().zoomSteps, s = i[0] * r, l = i[i.length - 1] * r;
        return { from: e.getZoomLevel(), max: l, min: s };
      }
    }
  });
}
function PM(n, e, t) {
  const r = n.getShape(e), i = n.getShapeHandles(r);
  return { shape: r, handle: i.find((s) => s.id === t) };
}
function bae(n, e) {
  const t = be();
  return M.useMemo(() => {
    const r = (d) => {
      if (d.isKilled) return;
      const h = vE(d.currentTarget);
      yw(h, d);
      const { shape: g, handle: y } = PM(t, n, e);
      y && t.dispatch({
        type: "pointer",
        target: "handle",
        handle: y,
        shape: g,
        name: "pointer_down",
        ...Xa(d)
      });
    };
    let i, s;
    return {
      onPointerDown: r,
      onPointerMove: (d) => {
        if (d.isKilled || d.clientX === i && d.clientY === s) return;
        i = d.clientX, s = d.clientY;
        const { shape: h, handle: g } = PM(t, n, e);
        g && t.dispatch({
          type: "pointer",
          target: "handle",
          handle: g,
          shape: h,
          name: "pointer_move",
          ...Xa(d)
        });
      },
      onPointerUp: (d) => {
        if (d.isKilled) return;
        const h = vE(d.currentTarget);
        vw(h, d);
        const { shape: g, handle: y } = PM(t, n, e);
        y && t.dispatch({
          type: "pointer",
          target: "handle",
          handle: y,
          shape: g,
          name: "pointer_up",
          ...Xa(d)
        });
      }
    };
  }, [t, n, e]);
}
function Cae(n) {
  const e = be();
  M.useLayoutEffect(() => {
    const t = N$(
      () => {
        n.current && e.updateViewportScreenBounds(n.current);
      },
      200,
      {
        trailing: !0
      }
    ), r = e.timers.setInterval(t, 1e3);
    window.addEventListener("resize", t);
    const i = new ResizeObserver((c) => {
      c[0].contentRect && t();
    }), s = n.current;
    let l = null;
    return s && (i.observe(s), l = Eae(s), l.addEventListener("scroll", t)), () => {
      clearInterval(r), window.removeEventListener("resize", t), i.disconnect(), l == null || l.removeEventListener("scroll", t), t.cancel();
    };
  }, [e, n]);
}
/*!
 * Author: excalidraw
 * MIT License: https://github.com/excalidraw/excalidraw/blob/master/LICENSE
 * https://github.com/excalidraw/excalidraw/blob/48c3465b19f10ec755b3eb84e21a01a468e96e43/packages/excalidraw/utils.ts#L600
 */
const Eae = (n) => {
  let e = n.parentElement;
  for (; e; ) {
    if (e === document.body)
      return document;
    const { overflowY: t } = window.getComputedStyle(e);
    if (e.scrollHeight > e.clientHeight && (t === "auto" || t === "scroll" || t === "overlay"))
      return e;
    e = e.parentElement;
  }
  return document;
};
class Xe {
  constructor(e = 0, t = 0, r = 0, i = 0) {
    U(this, "x", 0);
    U(this, "y", 0);
    U(this, "w", 0);
    U(this, "h", 0);
    this.x = e, this.y = t, this.w = r, this.h = i;
  }
  // eslint-disable-next-line no-restricted-syntax
  get point() {
    return new R(this.x, this.y);
  }
  // eslint-disable-next-line no-restricted-syntax
  set point(e) {
    this.x = e.x, this.y = e.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minX() {
    return this.x;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minX(e) {
    this.x = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midX() {
    return this.x + this.w / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxX() {
    return this.x + this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  get minY() {
    return this.y;
  }
  // eslint-disable-next-line no-restricted-syntax
  set minY(e) {
    this.y = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get midY() {
    return this.y + this.h / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get maxY() {
    return this.y + this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  get width() {
    return this.w;
  }
  // eslint-disable-next-line no-restricted-syntax
  set width(e) {
    this.w = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get height() {
    return this.h;
  }
  // eslint-disable-next-line no-restricted-syntax
  set height(e) {
    this.h = e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get aspectRatio() {
    return this.width / this.height;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return new R(this.midX, this.midY);
  }
  // eslint-disable-next-line no-restricted-syntax
  set center(e) {
    this.minX = e.x - this.width / 2, this.minY = e.y - this.height / 2;
  }
  // eslint-disable-next-line no-restricted-syntax
  get corners() {
    return [
      new R(this.minX, this.minY),
      new R(this.maxX, this.minY),
      new R(this.maxX, this.maxY),
      new R(this.minX, this.maxY)
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get cornersAndCenter() {
    return [
      new R(this.minX, this.minY),
      new R(this.maxX, this.minY),
      new R(this.maxX, this.maxY),
      new R(this.minX, this.maxY),
      this.center
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get sides() {
    const { corners: e } = this;
    return [
      [e[0], e[1]],
      [e[1], e[2]],
      [e[2], e[3]],
      [e[3], e[0]]
    ];
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return new R(this.w, this.h);
  }
  toFixed() {
    return this.x = U1(this.x), this.y = U1(this.y), this.w = U1(this.w), this.h = U1(this.h), this;
  }
  setTo(e) {
    return this.x = e.x, this.y = e.y, this.w = e.w, this.h = e.h, this;
  }
  set(e = 0, t = 0, r = 0, i = 0) {
    return this.x = e, this.y = t, this.w = r, this.h = i, this;
  }
  expand(e) {
    const t = Math.min(this.minX, e.minX), r = Math.min(this.minY, e.minY), i = Math.max(this.maxX, e.maxX), s = Math.max(this.maxY, e.maxY);
    return this.x = t, this.y = r, this.w = i - t, this.h = s - r, this;
  }
  expandBy(e) {
    return this.x -= e, this.y -= e, this.w += e * 2, this.h += e * 2, this;
  }
  scale(e) {
    return this.x /= e, this.y /= e, this.w /= e, this.h /= e, this;
  }
  clone() {
    const { x: e, y: t, w: r, h: i } = this;
    return new Xe(e, t, r, i);
  }
  translate(e) {
    return this.x += e.x, this.y += e.y, this;
  }
  snapToGrid(e) {
    const t = Math.round(this.minX / e) * e, r = Math.round(this.minY / e) * e, i = Math.round(this.maxX / e) * e, s = Math.round(this.maxY / e) * e;
    this.minX = t, this.minY = r, this.width = Math.max(1, i - t), this.height = Math.max(1, s - r);
  }
  collides(e) {
    return Xe.Collides(this, e);
  }
  contains(e) {
    return Xe.Contains(this, e);
  }
  includes(e) {
    return Xe.Includes(this, e);
  }
  containsPoint(e, t = 0) {
    return Xe.ContainsPoint(this, e, t);
  }
  getHandlePoint(e) {
    switch (e) {
      case "top_left":
        return new R(this.minX, this.minY);
      case "top_right":
        return new R(this.maxX, this.minY);
      case "bottom_left":
        return new R(this.minX, this.maxY);
      case "bottom_right":
        return new R(this.maxX, this.maxY);
      case "top":
        return new R(this.midX, this.minY);
      case "right":
        return new R(this.maxX, this.midY);
      case "bottom":
        return new R(this.midX, this.maxY);
      case "left":
        return new R(this.minX, this.midY);
    }
  }
  toJson() {
    return { x: this.minX, y: this.minY, w: this.w, h: this.h };
  }
  resize(e, t, r) {
    const { minX: i, minY: s, maxX: l, maxY: c } = this;
    let { minX: d, minY: h, maxX: g, maxY: y } = this;
    switch (e) {
      case "left":
      case "top_left":
      case "bottom_left": {
        d += t;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        g += t;
        break;
      }
    }
    switch (e) {
      case "top":
      case "top_left":
      case "top_right": {
        h += r;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        y += r;
        break;
      }
    }
    const v = (g - d) / (l - i), w = (y - h) / (c - s), C = v < 0, E = w < 0;
    if (C) {
      const P = g;
      g = d, d = P;
    }
    if (E) {
      const P = y;
      y = h, h = P;
    }
    this.minX = d, this.minY = h, this.width = Math.abs(g - d), this.height = Math.abs(y - h);
  }
  union(e) {
    const t = Math.min(this.minX, e.x), r = Math.min(this.minY, e.y), i = Math.max(this.maxX, e.w + e.x), s = Math.max(this.maxY, e.h + e.y);
    return this.x = t, this.y = r, this.width = i - t, this.height = s - r, this;
  }
  static From(e) {
    return new Xe(e.x, e.y, e.w, e.h);
  }
  static FromCenter(e, t) {
    return new Xe(e.x - t.x / 2, e.y - t.y / 2, t.x, t.y);
  }
  static FromPoints(e) {
    if (e.length === 0) return new Xe();
    let t = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0, l;
    for (let c = 0, d = e.length; c < d; c++)
      l = e[c], t = Math.min(l.x, t), r = Math.min(l.y, r), i = Math.max(l.x, i), s = Math.max(l.y, s);
    return new Xe(t, r, i - t, s - r);
  }
  static Expand(e, t) {
    const r = Math.min(t.minX, e.minX), i = Math.min(t.minY, e.minY), s = Math.max(t.maxX, e.maxX), l = Math.max(t.maxY, e.maxY);
    return new Xe(r, i, s - r, l - i);
  }
  static ExpandBy(e, t) {
    return new Xe(e.minX - t, e.minY - t, e.width + t * 2, e.height + t * 2);
  }
  static Collides(e, t) {
    return !(e.maxX < t.minX || e.minX > t.maxX || e.maxY < t.minY || e.minY > t.maxY);
  }
  static Contains(e, t) {
    return e.minX < t.minX && e.minY < t.minY && e.maxY > t.maxY && e.maxX > t.maxX;
  }
  static Includes(e, t) {
    return Xe.Collides(e, t) || Xe.Contains(e, t);
  }
  static ContainsPoint(e, t, r = 0) {
    return !(t.x < e.minX - r || t.y < e.minY - r || t.x > e.maxX + r || t.y > e.maxY + r);
  }
  static Common(e) {
    let t = 1 / 0, r = 1 / 0, i = -1 / 0, s = -1 / 0;
    for (let l = 0; l < e.length; l++) {
      const c = e[l];
      t = Math.min(t, c.minX), r = Math.min(r, c.minY), i = Math.max(i, c.maxX), s = Math.max(s, c.maxY);
    }
    return new Xe(t, r, i - t, s - r);
  }
  static Sides(e, t = 0) {
    const { corners: r } = e;
    return [
      [r[0], r[1]],
      [r[1], r[2]],
      [r[2], r[3]],
      [r[3], r[0]]
    ];
  }
  static Resize(e, t, r, i, s = !1) {
    const { minX: l, minY: c, maxX: d, maxY: h } = e;
    let { minX: g, minY: y, maxX: v, maxY: w } = e;
    switch (t) {
      case "left":
      case "top_left":
      case "bottom_left": {
        g += r;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        v += r;
        break;
      }
    }
    switch (t) {
      case "top":
      case "top_left":
      case "top_right": {
        y += i;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        w += i;
        break;
      }
    }
    const C = (v - g) / (d - l), E = (w - y) / (h - c), P = C < 0, I = E < 0;
    if (s) {
      const L = (d - l) / (h - c), O = Math.abs(v - g), z = Math.abs(w - y), F = O * (E < 0 ? 1 : -1) * (1 / L), H = z * (C < 0 ? 1 : -1) * L, V = L < O / z;
      switch (t) {
        case "top_left": {
          V ? y = w + F : g = v + H;
          break;
        }
        case "top_right": {
          V ? y = w + F : v = g - H;
          break;
        }
        case "bottom_right": {
          V ? w = y - F : v = g - H;
          break;
        }
        case "bottom_left": {
          V ? w = y - F : g = v + H;
          break;
        }
        case "bottom":
        case "top": {
          const re = (g + v) / 2, q = z * L;
          g = re - q / 2, v = re + q / 2;
          break;
        }
        case "left":
        case "right": {
          const re = (y + w) / 2, q = O / L;
          y = re - q / 2, w = re + q / 2;
          break;
        }
      }
    }
    if (P) {
      const L = v;
      v = g, g = L;
    }
    if (I) {
      const L = w;
      w = y, y = L;
    }
    const k = new Xe(g, y, Math.abs(v - g), Math.abs(w - y));
    return {
      box: k,
      scaleX: +(k.width / e.width * (C > 0 ? 1 : -1)).toFixed(5),
      scaleY: +(k.height / e.height * (E > 0 ? 1 : -1)).toFixed(5)
    };
  }
  equals(e) {
    return Xe.Equals(this, e);
  }
  static Equals(e, t) {
    return t.x === e.x && t.y === e.y && t.w === e.w && t.h === e.h;
  }
  zeroFix() {
    return this.w = Math.max(1, this.w), this.h = Math.max(1, this.h), this;
  }
  static ZeroFix(e) {
    return new Xe(e.x, e.y, Math.max(1, e.w), Math.max(1, e.h));
  }
}
function _ae(n) {
  switch (n) {
    case "top":
      return "bottom";
    case "bottom":
      return "top";
    case "top_left":
      return "bottom_left";
    case "top_right":
      return "bottom_right";
    case "bottom_left":
      return "top_left";
    case "bottom_right":
      return "top_right";
    default:
      return n;
  }
}
function Pae(n) {
  switch (n) {
    case "left":
      return "right";
    case "right":
      return "left";
    case "top_left":
      return "top_right";
    case "top_right":
      return "top_left";
    case "bottom_left":
      return "bottom_right";
    case "bottom_right":
      return "bottom_left";
    default:
      return n;
  }
}
function Tae(n) {
  return n === "top_left" || n === "top_right" || n === "bottom_right" || n === "bottom_left";
}
class qe {
  constructor(e, t, r, i, s, l) {
    U(this, "a", 1);
    U(this, "b", 0);
    U(this, "c", 0);
    U(this, "d", 1);
    U(this, "e", 0);
    U(this, "f", 0);
    this.a = e, this.b = t, this.c = r, this.d = i, this.e = s, this.f = l;
  }
  equals(e) {
    return this === e || this.a === e.a && this.b === e.b && this.c === e.c && this.d === e.d && this.e === e.e && this.f === e.f;
  }
  identity() {
    return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.e = 0, this.f = 0, this;
  }
  multiply(e) {
    const t = e, { a: r, b: i, c: s, d: l, e: c, f: d } = this;
    return this.a = r * t.a + s * t.b, this.c = r * t.c + s * t.d, this.e = r * t.e + s * t.f + c, this.b = i * t.a + l * t.b, this.d = i * t.c + l * t.d, this.f = i * t.e + l * t.f + d, this;
  }
  rotate(e, t, r) {
    return e === 0 ? this : t === void 0 ? this.multiply(qe.Rotate(e)) : this.translate(t, r).multiply(qe.Rotate(e)).translate(-t, -r);
  }
  translate(e, t) {
    return this.multiply(qe.Translate(e, t));
  }
  scale(e, t) {
    return this.multiply(qe.Scale(e, t));
  }
  invert() {
    const { a: e, b: t, c: r, d: i, e: s, f: l } = this, c = e * i - t * r;
    return this.a = i / c, this.b = t / -c, this.c = r / -c, this.d = e / c, this.e = (i * s - r * l) / -c, this.f = (t * s - e * l) / c, this;
  }
  applyToPoint(e) {
    return qe.applyToPoint(this, e);
  }
  applyToPoints(e) {
    return qe.applyToPoints(this, e);
  }
  rotation() {
    return qe.Rotation(this);
  }
  point() {
    return qe.Point(this);
  }
  decomposed() {
    return qe.Decompose(this);
  }
  toCssString() {
    return qe.toCssString(this);
  }
  setTo(e) {
    return Object.assign(this, e), this;
  }
  decompose() {
    return qe.Decompose(this);
  }
  clone() {
    return new qe(this.a, this.b, this.c, this.d, this.e, this.f);
  }
  /* --------------------- Static --------------------- */
  static Identity() {
    return new qe(1, 0, 0, 1, 0, 0);
  }
  static Translate(e, t) {
    return new qe(1, 0, 0, 1, e, t);
  }
  static Rotate(e, t, r) {
    if (e === 0) return qe.Identity();
    const i = Math.cos(e), s = Math.sin(e), l = new qe(i, s, -s, i, 0, 0);
    return t === void 0 ? l : qe.Compose(qe.Translate(t, r), l, qe.Translate(-t, -r));
  }
  static Scale(e, t, r, i) {
    const s = new qe(e, 0, 0, t, 0, 0);
    return r === void 0 ? s : qe.Compose(qe.Translate(r, i), s, qe.Translate(-r, -i));
  }
  static Multiply(e, t) {
    return {
      a: e.a * t.a + e.c * t.b,
      c: e.a * t.c + e.c * t.d,
      e: e.a * t.e + e.c * t.f + e.e,
      b: e.b * t.a + e.d * t.b,
      d: e.b * t.c + e.d * t.d,
      f: e.b * t.e + e.d * t.f + e.f
    };
  }
  static Inverse(e) {
    const t = e.a * e.d - e.b * e.c;
    return {
      a: e.d / t,
      b: e.b / -t,
      c: e.c / -t,
      d: e.a / t,
      e: (e.d * e.e - e.c * e.f) / -t,
      f: (e.b * e.e - e.a * e.f) / t
    };
  }
  static Absolute(e) {
    const t = e.a * e.d - e.b * e.c;
    return {
      a: e.d / t,
      b: e.b / -t,
      c: e.c / -t,
      d: e.a / t,
      e: (e.d * e.e - e.c * e.f) / t,
      f: (e.b * e.e - e.a * e.f) / -t
    };
  }
  static Compose(...e) {
    const t = qe.Identity();
    for (let r = 0, i = e.length; r < i; r++)
      t.multiply(e[r]);
    return t;
  }
  static Point(e) {
    return new R(e.e, e.f);
  }
  static Rotation(e) {
    let t;
    if (e.a !== 0 || e.c !== 0) {
      const r = (e.a * e.a + e.c * e.c) ** 0.5;
      t = Math.acos(e.a / r) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const r = (e.b * e.b + e.d * e.d) ** 0.5;
      t = Or + Math.acos(e.b / r) * (e.d > 0 ? -1 : 1);
    } else
      t = 0;
    return KA(t);
  }
  static Decompose(e) {
    let t, r, i;
    if (e.a !== 0 || e.c !== 0) {
      const s = (e.a * e.a + e.c * e.c) ** 0.5;
      t = s, r = (e.a * e.d - e.b * e.c) / s, i = Math.acos(e.a / s) * (e.c > 0 ? -1 : 1);
    } else if (e.b !== 0 || e.d !== 0) {
      const s = (e.b * e.b + e.d * e.d) ** 0.5;
      t = (e.a * e.d - e.b * e.c) / s, r = s, i = Or + Math.acos(e.b / s) * (e.d > 0 ? -1 : 1);
    } else
      t = 0, r = 0, i = 0;
    return {
      x: e.e,
      y: e.f,
      scaleX: t,
      scaleY: r,
      rotation: KA(i)
    };
  }
  static Smooth(e, t = 1e10) {
    return e.a = Math.round(e.a * t) / t, e.b = Math.round(e.b * t) / t, e.c = Math.round(e.c * t) / t, e.d = Math.round(e.d * t) / t, e.e = Math.round(e.e * t) / t, e.f = Math.round(e.f * t) / t, e;
  }
  static toCssString(e) {
    return `matrix(${Se(e.a)}, ${Se(e.b)}, ${Se(
      e.c
    )}, ${Se(e.d)}, ${Se(e.e)}, ${Se(e.f)})`;
  }
  static applyToPoint(e, t) {
    return new R(
      e.a * t.x + e.c * t.y + e.e,
      e.b * t.x + e.d * t.y + e.f,
      t.z
    );
  }
  static applyToXY(e, t, r) {
    return [e.a * t + e.c * r + e.e, e.b * t + e.d * r + e.f];
  }
  static applyToPoints(e, t) {
    return t.map(
      (r) => new R(e.a * r.x + e.c * r.y + e.e, e.b * r.x + e.d * r.y + e.f, r.z)
    );
  }
  static applyToBounds(e, t) {
    return new Xe(e.e + t.minX, e.f + t.minY, t.width, t.height);
  }
  static From(e) {
    return new qe(e.a, e.b, e.c, e.d, e.e, e.f);
  }
  static Cast(e) {
    return e instanceof qe ? e : qe.From(e);
  }
}
class Ph {
  constructor(e) {
    U(this, "isFilled", !1);
    U(this, "isClosed", !0);
    U(this, "isLabel", !1);
    U(this, "debugColor");
    U(this, "ignore");
    U(this, "_vertices");
    U(this, "_bounds");
    U(this, "_area");
    U(this, "_length");
    this.isFilled = e.isFilled, this.isClosed = e.isClosed, this.isLabel = e.isLabel ?? !1, this.debugColor = e.debugColor, this.ignore = e.ignore;
  }
  // hitTestPoint(point: Vec, margin = 0, hitInside = false) {
  // 	// We've removed the broad phase here; that should be done outside of the call
  // 	return this.distanceToPoint(point, hitInside) <= margin
  // }
  hitTestPoint(e, t = 0, r = !1) {
    return this.isClosed && (this.isFilled || r) && Ja(e, this.vertices) ? !0 : R.Dist2(e, this.nearestPoint(e)) <= t * t;
  }
  distanceToPoint(e, t = !1) {
    return e.dist(this.nearestPoint(e)) * (this.isClosed && (this.isFilled || t) && Ja(e, this.vertices) ? -1 : 1);
  }
  distanceToLineSegment(e, t) {
    if (e.equals(t)) return this.distanceToPoint(e);
    const { vertices: r } = this;
    let i, s = 1 / 0, l, c, d;
    for (let h = 0; h < r.length; h++)
      c = r[h], d = R.NearestPointOnLineSegment(e, t, c, !0), l = R.Dist2(c, d), l < s && (s = l, i = d);
    if (!i) throw Error("nearest point not found");
    return this.isClosed && this.isFilled && Ja(i, this.vertices) ? -s : s;
  }
  hitTestLineSegment(e, t, r = 0) {
    return this.distanceToLineSegment(e, t) <= r;
  }
  nearestPointOnLineSegment(e, t) {
    const { vertices: r } = this;
    let i, s = 1 / 0, l, c, d;
    for (let h = 0; h < r.length; h++)
      c = r[h], d = R.NearestPointOnLineSegment(e, t, c, !0), l = R.Dist2(c, d), l < s && (s = l, i = d);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  isPointInBounds(e, t = 0) {
    const { bounds: r } = this;
    return !(e.x < r.minX - t || e.y < r.minY - t || e.x > r.maxX + t || e.y > r.maxY + t);
  }
  // eslint-disable-next-line no-restricted-syntax
  get vertices() {
    return this._vertices || (this._vertices = this.getVertices()), this._vertices;
  }
  getBounds() {
    return Xe.FromPoints(this.vertices);
  }
  // eslint-disable-next-line no-restricted-syntax
  get bounds() {
    return this._bounds || (this._bounds = this.getBounds()), this._bounds;
  }
  // eslint-disable-next-line no-restricted-syntax
  get center() {
    return this.bounds.center;
  }
  // eslint-disable-next-line no-restricted-syntax
  get area() {
    return this._area || (this._area = this.getArea()), this._area;
  }
  getArea() {
    if (!this.isClosed)
      return 0;
    const { vertices: e } = this;
    let t = 0;
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r], l = e[(r + 1) % i];
      t += s.x * l.y - l.x * s.y;
    }
    return t / 2;
  }
  toSimpleSvgPath() {
    let e = "";
    const { vertices: t } = this, r = t.length;
    if (r === 0) return e;
    e += `M${t[0].x},${t[0].y}`;
    for (let i = 1; i < r; i++)
      e += `L${t[i].x},${t[i].y}`;
    return this.isClosed && (e += "Z"), e;
  }
  // eslint-disable-next-line no-restricted-syntax
  get length() {
    return this._length ? this._length : (this._length = this.getLength(), this._length);
  }
  getLength() {
    const { vertices: e } = this;
    let t, r = e[0], i = 0;
    for (let s = 1; s < e.length; s++)
      t = e[s], i += R.Dist2(r, t), r = t;
    return Math.sqrt(i);
  }
}
class jl extends Ph {
  constructor(t) {
    super({ ...t, isClosed: !0, isFilled: !1 });
    U(this, "children", []);
    U(this, "ignoredChildren", []);
    for (const r of t.children)
      r.ignore ? this.ignoredChildren.push(r) : this.children.push(r);
    if (this.children.length === 0) throw Error("Group2d must have at least one child");
  }
  getVertices() {
    return this.children.filter((t) => !t.isLabel).flatMap((t) => t.vertices);
  }
  nearestPoint(t) {
    let r = 1 / 0, i;
    const { children: s } = this;
    if (s.length === 0)
      throw Error("no children");
    let l, c;
    for (const d of s)
      l = d.nearestPoint(t), c = R.Dist2(l, t), c < r && (r = c, i = l);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  distanceToPoint(t, r = !1) {
    return Math.min(...this.children.map((i, s) => i.distanceToPoint(t, r || s > 0)));
  }
  hitTestPoint(t, r, i) {
    return !!this.children.filter((s) => !s.isLabel).find((s) => s.hitTestPoint(t, r, i));
  }
  hitTestLineSegment(t, r, i) {
    return !!this.children.filter((s) => !s.isLabel).find((s) => s.hitTestLineSegment(t, r, i));
  }
  getArea() {
    return this.children[0].area;
  }
  toSimpleSvgPath() {
    let t = "";
    for (const i of this.children)
      t += i.toSimpleSvgPath();
    const r = Xe.FromPoints(this.vertices).corners;
    for (let i = 0, s = r.length; i < s; i++) {
      const l = r[i], c = r[(i - 1 + s) % s], d = l.dist(c), h = r[(i + 1) % s], g = l.dist(h), y = l.clone().lrp(c, 4 / d), v = l, w = l.clone().lrp(h, 4 / g);
      t += `M${y.x},${y.y} L${v.x},${v.y} L${w.x},${w.y} `;
    }
    return t;
  }
  getLength() {
    return this.children.reduce((t, r) => r.isLabel ? t : t + r.length, 0);
  }
  getSvgPathData() {
    return this.children.map((t, r) => t.isLabel ? "" : t.getSvgPathData(r === 0)).join(" ");
  }
}
function Iae(n = !0) {
  const [e, t] = M.useState(0), r = be();
  M.useEffect(() => {
    if (!n) return;
    const i = () => t((s) => s + 1);
    return r.on("tick", i), () => {
      r.off("tick", i);
    };
  }, [r, n]);
}
const kae = Ho(function({
  showStroke: e = !0,
  showVertices: t = !0,
  showClosestPointOnOutline: r = !0
}) {
  const i = be();
  Iae(r);
  const s = i.getZoomLevel(), l = i.getRenderingShapes(), {
    inputs: { currentPagePoint: c }
  } = i;
  return /* @__PURE__ */ m.jsx(
    "svg",
    {
      style: {
        position: "absolute",
        pointerEvents: "none",
        zIndex: 999999999,
        top: 0,
        left: 0,
        overflow: "visible"
      },
      children: l.map((d) => {
        const h = i.getShape(d.id);
        if (h.type === "group") return null;
        const g = i.getShapeGeometry(h), y = i.getShapePageTransform(h), v = i.getPointInShapeSpace(h, c), w = g.nearestPoint(v), C = g.distanceToPoint(v, !0), E = Math.abs(C) * s, P = C < 0, { vertices: I } = g;
        return /* @__PURE__ */ m.jsxs(
          "g",
          {
            transform: y.toCssString(),
            strokeLinecap: "round",
            strokeLinejoin: "round",
            children: [
              e && /* @__PURE__ */ m.jsx(
                "g",
                {
                  stroke: g.debugColor ?? "red",
                  opacity: "1",
                  strokeWidth: 2 / s,
                  fill: "none",
                  children: /* @__PURE__ */ m.jsx(aB, { geometry: g })
                }
              ),
              t && I.map((k, L) => /* @__PURE__ */ m.jsx(
                "circle",
                {
                  cx: k.x,
                  cy: k.y,
                  r: 2 / s,
                  fill: `hsl(${Ry(L, [0, I.length - 1], [120, 200])}, 100%, 50%)`,
                  stroke: "black",
                  strokeWidth: 1 / s
                },
                `v${L}`
              )),
              r && E < 150 && /* @__PURE__ */ m.jsx(
                "line",
                {
                  x1: w.x,
                  y1: w.y,
                  x2: v.x,
                  y2: v.y,
                  opacity: 1 - E / 150,
                  stroke: P ? "goldenrod" : "dodgerblue",
                  strokeWidth: 2 / s
                }
              )
            ]
          },
          d.id + "_outline"
        );
      })
    }
  );
});
function aB({ geometry: n }) {
  return n instanceof jl ? /* @__PURE__ */ m.jsx(m.Fragment, { children: [...n.children, ...n.ignoredChildren].map((e, t) => /* @__PURE__ */ m.jsx(aB, { geometry: e }, t)) }) : /* @__PURE__ */ m.jsx("path", { d: n.toSimpleSvgPath() });
}
function lB(n) {
  return Dte(n);
}
function cB() {
  const n = be(), e = Aie(
    "userIds",
    () => lB(n.getCollaborators().map((t) => t.userId)).sort(),
    { isEqual: (t, r) => {
      var i;
      return t.join(",") === ((i = r.join) == null ? void 0 : i.call(r, ","));
    } },
    [n]
  );
  return Pe(e);
}
function JE(n) {
  const e = be();
  return Pe(
    `latestPresence:${n}`,
    () => e.getCollaborators().find((r) => r.userId === n),
    [e, n]
  ) ?? null;
}
const Rae = Ho(function() {
  return cB().map((t) => /* @__PURE__ */ m.jsx(Mae, { collaboratorId: t }, t));
}), Mae = Ho(function({
  collaboratorId: e
}) {
  const t = be(), r = JE(e), i = Dae(t, r);
  if (!(r && r.currentPageId === t.getCurrentPageId()))
    return null;
  switch (i) {
    case "inactive": {
      const { followingUserId: s, highlightedUserIds: l } = t.getInstanceState();
      if (!(s === r.userId || l.includes(r.userId)))
        return null;
      break;
    }
    case "idle": {
      const { highlightedUserIds: s } = t.getInstanceState();
      if (r.followingUserId === t.user.getId() && !(r.chatMessage || s.includes(r.userId)))
        return null;
      break;
    }
  }
  return /* @__PURE__ */ m.jsx(Aae, { latestPresence: r });
}), Aae = Ho(function({
  latestPresence: e
}) {
  const t = be(), {
    CollaboratorBrush: r,
    CollaboratorScribble: i,
    CollaboratorCursor: s,
    CollaboratorHint: l,
    CollaboratorShapeIndicator: c
  } = Br(), d = t.getZoomLevel(), h = t.getViewportPageBounds(), { userId: g, chatMessage: y, brush: v, scribbles: w, selectedShapeIds: C, userName: E, cursor: P, color: I } = e;
  if (!P) return null;
  const k = !(P.x < h.minX - 12 / d || P.y < h.minY - 16 / d || P.x > h.maxX - 12 / d || P.y > h.maxY - 16 / d);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    v && r ? /* @__PURE__ */ m.jsx(
      r,
      {
        className: "tl-collaborator__brush",
        brush: v,
        color: I,
        opacity: 0.1
      },
      g + "_brush"
    ) : null,
    k && s ? /* @__PURE__ */ m.jsx(
      s,
      {
        className: "tl-collaborator__cursor",
        point: P,
        color: I,
        zoom: d,
        name: E !== "New User" ? E : null,
        chatMessage: y ?? ""
      },
      g + "_cursor"
    ) : l ? /* @__PURE__ */ m.jsx(
      l,
      {
        className: "tl-collaborator__cursor-hint",
        point: P,
        color: I,
        zoom: d,
        viewport: h
      },
      g + "_cursor_hint"
    ) : null,
    i && w.length ? /* @__PURE__ */ m.jsx(m.Fragment, { children: w.map((L) => /* @__PURE__ */ m.jsx(
      i,
      {
        className: "tl-collaborator__scribble",
        scribble: L,
        color: I,
        zoom: d,
        opacity: L.color === "laser" ? 0.5 : 0.1
      },
      g + "_scribble_" + L.id
    )) }) : null,
    c && C.filter((L) => !t.isShapeHidden(L)).map((L) => /* @__PURE__ */ m.jsx(
      c,
      {
        className: "tl-collaborator__shape-indicator",
        shapeId: L,
        color: I,
        opacity: 0.5
      },
      g + "_" + L
    ))
  ] });
});
function L4(n, e) {
  return e > n.options.collaboratorInactiveTimeoutMs ? "inactive" : e > n.options.collaboratorIdleTimeoutMs ? "idle" : "active";
}
function Dae(n, e) {
  const t = M.useRef((e == null ? void 0 : e.lastActivityTimestamp) ?? -1), [r, i] = M.useState(
    () => L4(n, Date.now() - t.current)
  );
  return M.useEffect(() => {
    const s = n.timers.setInterval(() => {
      i(L4(n, Date.now() - t.current));
    }, n.options.collaboratorCheckIntervalMs);
    return () => clearInterval(s);
  }, [n]), e && (t.current = e.lastActivityTimestamp ?? 1 / 0), r;
}
function Oae() {
  const n = be(), e = Pe("is menu open", () => n.menus.hasAnyOpenMenus(), [n]), [t, r] = M.useState(!1), i = e || t, s = jO(), l = M.useRef({
    isDown: !1,
    isDragging: !1,
    start: new R()
  }), c = M.useCallback(
    (g) => {
      g.button === 0 && (r(!0), l.current = {
        isDown: !0,
        isDragging: !1,
        start: new R(g.clientX, g.clientY)
      }), n.menus.clearOpenMenus();
    },
    [n]
  ), d = M.useCallback(
    (g) => {
      var y, v, w;
      if (l.current.isDown) {
        if (l.current.isDragging) {
          (y = s.onPointerMove) == null || y.call(s, g);
          return;
        }
        if (
          // We're pointing, but are we dragging?
          R.Dist2(l.current.start, new R(g.clientX, g.clientY)) > n.options.dragDistanceSquared
        ) {
          l.current = {
            ...l.current,
            isDown: !0,
            isDragging: !0
          };
          const { x: C, y: E } = l.current.start;
          (v = s.onPointerDown) == null || v.call(s, {
            ...g,
            clientX: C,
            clientY: E,
            button: 0
          }), (w = s.onPointerMove) == null || w.call(s, g);
        }
      }
    },
    [s, n]
  ), h = M.useCallback(
    (g) => {
      var y;
      (y = s.onPointerUp) == null || y.call(s, g), r(!1), l.current = {
        isDown: !1,
        isDragging: !1,
        start: new R(g.clientX, g.clientY)
      };
    },
    [s]
  );
  return i && /* @__PURE__ */ m.jsx(
    "div",
    {
      className: "tlui-menu-click-capture",
      "data-testid": "menu-click-capture.content",
      ...s,
      onPointerDown: c,
      onPointerMove: d,
      onPointerUp: h
    }
  );
}
const uB = M.memo(function({
  id: e,
  shape: t,
  util: r,
  index: i,
  backgroundIndex: s,
  opacity: l
}) {
  const c = be(), { ShapeErrorFallback: d } = Br(), h = M.useRef(null), g = M.useRef(null), y = M.useRef({
    transform: "",
    clipPath: "none",
    width: 0,
    height: 0,
    x: 0,
    y: 0,
    isCulled: !1
  });
  dh(
    "set shape stuff",
    () => {
      const C = c.getShape(e);
      if (!C) return;
      const E = y.current, P = c.getShapeClipPath(e) ?? "none";
      P !== E.clipPath && (cs(h.current, "clip-path", P), cs(g.current, "clip-path", P), E.clipPath = P);
      const I = c.getShapePageTransform(e), k = qe.toCssString(I), L = c.getShapeGeometry(C).bounds;
      k !== E.transform && (cs(h.current, "transform", k), cs(g.current, "transform", k), E.transform = k);
      const O = Math.max(L.width, 1), z = Math.max(L.height, 1);
      (O !== E.width || z !== E.height) && (cs(h.current, "width", O + "px"), cs(h.current, "height", z + "px"), cs(g.current, "width", O + "px"), cs(g.current, "height", z + "px"), E.width = O, E.height = z);
    },
    [c]
  ), dh(
    "set opacity and z-index",
    () => {
      const C = h.current, E = g.current;
      cs(C, "opacity", l), cs(E, "opacity", l), cs(C, "z-index", i), cs(E, "z-index", s);
    },
    [l, i, s]
  ), dh(
    "set display",
    () => {
      if (!c.getShape(e)) return;
      const P = c.getCulledShapes().has(e);
      P !== y.current.isCulled && (cs(h.current, "display", P ? "none" : "block"), cs(g.current, "display", P ? "none" : "block"), y.current.isCulled = P);
    },
    [c]
  );
  const v = M.useCallback(
    (C) => c.annotateError(C, { origin: "shape", willCrashApp: !1 }),
    [c]
  );
  if (!t) return null;
  const w = "fill" in t.props && t.props.fill !== "none";
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    r.backgroundComponent && /* @__PURE__ */ m.jsx(
      "div",
      {
        ref: g,
        className: "tl-shape tl-shape-background",
        "data-shape-type": t.type,
        "data-shape-id": t.id,
        draggable: !1,
        children: /* @__PURE__ */ m.jsx(Yx, { fallback: d, onError: v, children: /* @__PURE__ */ m.jsx(fB, { shape: t, util: r }) })
      }
    ),
    /* @__PURE__ */ m.jsx(
      "div",
      {
        ref: h,
        className: "tl-shape",
        "data-shape-type": t.type,
        "data-shape-is-filled": w,
        "data-shape-id": t.id,
        draggable: !1,
        children: /* @__PURE__ */ m.jsx(Yx, { fallback: d, onError: v, children: /* @__PURE__ */ m.jsx(dB, { shape: t, util: r }) })
      }
    )
  ] });
}), dB = M.memo(
  function({ shape: e, util: t }) {
    return WE(
      "InnerShape:" + e.type,
      () => (
        // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
        // calling the render method with stale data.
        t.component(t.editor.store.unsafeGetWithoutCapture(e.id))
      ),
      [t, e.id]
    );
  },
  (n, e) => n.shape.props === e.shape.props && n.shape.meta === e.shape.meta && n.util === e.util
), fB = M.memo(
  function({
    shape: e,
    util: t
  }) {
    return WE(
      "InnerShape:" + e.type,
      () => {
        var r;
        return (
          // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
          // calling the render method with stale data.
          (r = t.backgroundComponent) == null ? void 0 : r.call(t, t.editor.store.unsafeGetWithoutCapture(e.id))
        );
      },
      [t, e.id]
    );
  },
  (n, e) => n.shape.props === e.shape.props && n.shape.meta === e.shape.meta && n.util === e.util
);
function jae({ className: n }) {
  const e = be(), { Background: t, SvgDefs: r, ShapeIndicators: i } = Br(), s = M.useRef(null), l = M.useRef(null), c = M.useRef(null), d = io();
  Cae(s), gse(), pse(), wae(s), vse(s);
  const h = M.useRef({ lodDisableTextOutline: !1, allowTextOutline: !0 });
  dh(
    "position layers",
    function() {
      const { x: k, y: L, z: O } = e.getCamera();
      if (h.current.allowTextOutline && Er.isSafari && (d.style.setProperty("--tl-text-outline", "none"), h.current.allowTextOutline = !1), h.current.allowTextOutline && O < e.options.textShadowLod !== h.current.lodDisableTextOutline) {
        const H = O < e.options.textShadowLod;
        d.style.setProperty(
          "--tl-text-outline",
          H ? "none" : "var(--tl-text-outline-reference)"
        ), h.current.lodDisableTextOutline = H;
      }
      const z = O >= 1 ? Ry(O, [1, 8], [0.125, 0.5], !0) : Ry(O, [0.1, 1], [-2, 0.125], !0), F = `scale(${Se(O)}) translate(${Se(
        k + z
      )}px,${Se(L + z)}px)`;
      cs(l.current, "transform", F), cs(c.current, "transform", F);
    },
    [e, d]
  );
  const g = jO(), y = Pe(
    "shapeSvgDefs",
    () => {
      const I = /* @__PURE__ */ new Map();
      for (const k of Xr(e.shapeUtils)) {
        if (!k) return;
        const L = k.getCanvasSvgDefs();
        for (const { key: O, component: z } of L)
          I.has(O) || I.set(O, /* @__PURE__ */ m.jsx(z, {}, O));
      }
      return [...I.values()];
    },
    [e]
  ), v = Pe("debug_shapes", () => Ei.hideShapes.get(), [Ei]), w = Pe("debug_svg", () => Ei.debugSvg.get(), [Ei]), C = Pe("debug_geometry", () => Ei.debugGeometry.get(), [
    Ei
  ]), E = Pe(
    "isEditingAnything",
    () => e.getEditingShapeId() !== null,
    [e]
  ), P = Pe(
    "isSelectingAnything",
    () => !!e.getSelectedShapeIds().length,
    [e]
  );
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        ref: s,
        draggable: !1,
        "data-iseditinganything": E,
        "data-isselectinganything": P,
        className: It("tl-canvas", n),
        "data-testid": "canvas",
        ...g,
        children: [
          /* @__PURE__ */ m.jsx("svg", { className: "tl-svg-context", children: /* @__PURE__ */ m.jsxs("defs", { children: [
            y,
            /* @__PURE__ */ m.jsx(Yae, {}),
            /* @__PURE__ */ m.jsx(Xae, {}),
            r && /* @__PURE__ */ m.jsx(r, {})
          ] }) }),
          t && /* @__PURE__ */ m.jsx("div", { className: "tl-background__wrapper", children: /* @__PURE__ */ m.jsx(t, {}) }),
          /* @__PURE__ */ m.jsx(Nae, {}),
          /* @__PURE__ */ m.jsxs("div", { ref: l, className: "tl-html-layer tl-shapes", draggable: !1, children: [
            /* @__PURE__ */ m.jsx(ele, {}),
            /* @__PURE__ */ m.jsx(Jae, {}),
            v ? null : w ? /* @__PURE__ */ m.jsx(Kae, {}) : /* @__PURE__ */ m.jsx(Gae, {})
          ] }),
          /* @__PURE__ */ m.jsx("div", { className: "tl-overlays", children: /* @__PURE__ */ m.jsxs("div", { ref: c, className: "tl-html-layer", children: [
            C ? /* @__PURE__ */ m.jsx(kae, {}) : null,
            /* @__PURE__ */ m.jsx(Bae, {}),
            /* @__PURE__ */ m.jsx(zae, {}),
            /* @__PURE__ */ m.jsx(Fae, {}),
            /* @__PURE__ */ m.jsx(Uae, {}),
            i && /* @__PURE__ */ m.jsx(i, {}),
            /* @__PURE__ */ m.jsx(qae, {}),
            /* @__PURE__ */ m.jsx($ae, {}),
            /* @__PURE__ */ m.jsx(Qae, {}),
            /* @__PURE__ */ m.jsx(Rae, {})
          ] }) }),
          /* @__PURE__ */ m.jsx(tle, {})
        ]
      }
    ),
    /* @__PURE__ */ m.jsx(Oae, {}),
    /* @__PURE__ */ m.jsx(Lae, {})
  ] });
}
function Lae() {
  const { InFrontOfTheCanvas: n } = Br();
  return n ? /* @__PURE__ */ m.jsx(n, {}) : null;
}
function Nae() {
  const n = be(), e = Pe("gridSize", () => n.getDocumentSettings().gridSize, [n]), { x: t, y: r, z: i } = Pe("camera", () => n.getCamera(), [n]), s = Pe("isGridMode", () => n.getInstanceState().isGridMode, [n]), { Grid: l } = Br();
  return l && s ? /* @__PURE__ */ m.jsx(l, { x: t, y: r, z: i, size: e }) : null;
}
function Fae() {
  const n = be(), e = Pe("scribbles", () => n.getInstanceState().scribbles, [n]), t = Pe("zoomLevel", () => n.getZoomLevel(), [n]), { Scribble: r } = Br();
  return r && e.length ? e.map((i) => /* @__PURE__ */ m.jsx(r, { className: "tl-user-scribble", scribble: i, zoom: t }, i.id)) : null;
}
function zae() {
  const n = be(), e = Pe("brush", () => n.getInstanceState().brush, [n]), { Brush: t } = Br();
  return t && e ? /* @__PURE__ */ m.jsx(t, { className: "tl-user-brush", brush: e }) : null;
}
function Uae() {
  const n = be(), e = Pe("zoomBrush", () => n.getInstanceState().zoomBrush, [n]), { ZoomBrush: t } = Br();
  return t && e ? /* @__PURE__ */ m.jsx(t, { className: "tl-user-brush tl-zoom-brush", brush: e }) : null;
}
function $ae() {
  const n = be(), e = Pe("snapLines", () => n.snaps.getIndicators(), [n]), t = Pe("zoomLevel", () => n.getZoomLevel(), [n]), { SnapIndicator: r } = Br();
  return r && e.length > 0 ? e.map((i) => /* @__PURE__ */ m.jsx(r, { className: "tl-user-snapline", line: i, zoom: t }, i.id)) : null;
}
function Bae() {
  const n = be(), e = Pe(
    "handles shapeIdWithHandles",
    () => {
      const { isReadonly: t, isChangingStyle: r } = n.getInstanceState();
      if (t || r) return !1;
      const i = n.getOnlySelectedShape();
      return !i || !n.getShapeHandles(i) ? !1 : i.id;
    },
    [n]
  );
  return e ? /* @__PURE__ */ m.jsx(Hae, { shapeId: e }) : null;
}
function Hae({ shapeId: n }) {
  const e = be(), { Handles: t } = Br(), r = Pe("zoomLevel", () => e.getZoomLevel(), [e]), i = Pe("coarse pointer", () => e.getInstanceState().isCoarsePointer, [
    e
  ]), s = Pe("handles transform", () => e.getShapePageTransform(n), [
    e,
    n
  ]), l = Pe(
    "handles",
    () => {
      const d = e.getShapeHandles(n);
      if (!d) return null;
      const h = (i ? e.options.coarseHandleRadius : e.options.handleRadius) / r * 2;
      return d.filter(
        (g) => (
          // if the handle isn't a virtual handle, we'll display it
          // but for virtual handles, we'll only display them if they're far enough away from vertex handles
          g.type !== "virtual" || !d.some(
            (y) => (
              // skip the handle we're checking against
              // and check that their distance isn't below the minimum distance
              y !== g && // only check against vertex handles
              y.type === "vertex" && R.Dist(g, y) < h
            )
          )
        )
      ).sort((g) => g.type === "vertex" ? 1 : -1);
    },
    [e, r, i, n]
  ), c = Pe("isHidden", () => e.isShapeHidden(n), [e, n]);
  return !t || !l || !s || c ? null : /* @__PURE__ */ m.jsx(t, { children: /* @__PURE__ */ m.jsx("g", { transform: qe.toCssString(s), children: l.map((d) => /* @__PURE__ */ m.jsx(
    Vae,
    {
      shapeId: n,
      handle: d,
      zoom: r,
      isCoarse: i
    },
    d.id
  )) }) });
}
function Vae({
  shapeId: n,
  handle: e,
  zoom: t,
  isCoarse: r
}) {
  const i = bae(n, e.id), { Handle: s } = Br();
  return s ? /* @__PURE__ */ m.jsx("g", { "aria-label": "handle", transform: `translate(${e.x}, ${e.y})`, ...i, children: /* @__PURE__ */ m.jsx(s, { shapeId: n, handle: e, zoom: t, isCoarse: r }) }) : null;
}
function Kae() {
  const n = be();
  return Pe("rendering shapes", () => n.getRenderingShapes(), [n]).map((t) => /* @__PURE__ */ m.jsxs(M.Fragment, { children: [
    /* @__PURE__ */ m.jsx(uB, { ...t }),
    /* @__PURE__ */ m.jsx(Zae, { id: t.id, mode: "iframe" })
  ] }, t.id + "_fragment"));
}
function Wae() {
  const n = be(), e = M.useRef(/* @__PURE__ */ new Set());
  return dh(
    "reflow for culled shapes",
    () => {
      const t = n.getCulledShapes();
      if (e.current.size === t.size && [...t].every((i) => e.current.has(i)))
        return;
      e.current = t;
      const r = document.getElementsByClassName("tl-canvas");
      r.length !== 0 && r[0].offsetHeight;
    },
    [n]
  ), null;
}
function Gae() {
  const n = be(), e = Pe("rendering shapes", () => n.getRenderingShapes(), [n]);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    e.map((t) => /* @__PURE__ */ m.jsx(uB, { ...t }, t.id + "_shape")),
    Er.isSafari && /* @__PURE__ */ m.jsx(Wae, {})
  ] });
}
function qae() {
  const n = be(), { ShapeIndicator: e } = Br(), t = Pe("hinting shape ids", () => GD(n.getHintingShapeIds()), [n]);
  return !t.length || !e ? null : t.map((r) => /* @__PURE__ */ m.jsx(e, { className: "tl-user-indicator__hint", shapeId: r }, r + "_hinting"));
}
function Yae() {
  return /* @__PURE__ */ m.jsxs("g", { id: bc("cursor"), children: [
    /* @__PURE__ */ m.jsxs("g", { fill: "rgba(0,0,0,.2)", transform: "translate(-11,-11)", children: [
      /* @__PURE__ */ m.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ m.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ m.jsxs("g", { fill: "white", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ m.jsx("path", { d: "m12 24.4219v-16.015l11.591 11.619h-6.781l-.411.124z" }),
      /* @__PURE__ */ m.jsx("path", { d: "m21.0845 25.0962-3.605 1.535-4.682-11.089 3.686-1.553z" })
    ] }),
    /* @__PURE__ */ m.jsxs("g", { fill: "currentColor", transform: "translate(-12,-12)", children: [
      /* @__PURE__ */ m.jsx("path", { d: "m19.751 24.4155-1.844.774-3.1-7.374 1.841-.775z" }),
      /* @__PURE__ */ m.jsx("path", { d: "m13 10.814v11.188l2.969-2.866.428-.139h4.768z" })
    ] })
  ] });
}
function Xae() {
  const n = bc("cursor_hint");
  return /* @__PURE__ */ m.jsx("path", { id: n, fill: "currentColor", d: "M -2,-5 2,0 -2,5 Z" });
}
function Zae({ id: n, mode: e }) {
  const t = be(), [r, i] = M.useState(null), s = Pe(
    "is in root",
    () => {
      const l = t.getShape(n);
      return (l == null ? void 0 : l.parentId) === t.getCurrentPageId();
    },
    [t, n]
  );
  return M.useEffect(() => {
    if (!s) return;
    let l = null;
    const c = wc("shape to svg", async () => {
      const d = Math.random();
      l = d;
      const g = t.isShapeOfType(n, "frame") ? 0 : 10;
      let y = t.getShapePageBounds(n);
      if (!y) return;
      y = y.clone().expandBy(g);
      const v = await t.getSvgString([n], {
        padding: g,
        background: t.getInstanceState().exportBackground
      });
      if (l !== d || !v) return;
      const w = `data:image/svg+xml;utf8,${encodeURIComponent(v.svg)}`;
      i({ src: w, bounds: y });
    });
    return () => {
      l = null, c();
    };
  }, [t, n, s]), !s || !r ? null : e === "iframe" ? /* @__PURE__ */ m.jsx(
    "iframe",
    {
      src: r.src,
      width: r.bounds.width,
      height: r.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        border: "none",
        transform: `translate(${r.bounds.x}px, ${r.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  ) : /* @__PURE__ */ m.jsx(
    "img",
    {
      src: r.src,
      width: r.bounds.width,
      height: r.bounds.height,
      referrerPolicy: "no-referrer",
      style: {
        position: "absolute",
        top: 0,
        left: 0,
        transform: `translate(${r.bounds.x}px, ${r.bounds.maxY + 12}px)`,
        outline: "1px solid black",
        maxWidth: "none"
      }
    }
  );
}
function Qae() {
  const n = be(), e = Pe("selection rotation", () => n.getSelectionRotation(), [
    n
  ]), t = Pe(
    "selection bounds",
    () => n.getSelectionRotatedPageBounds(),
    [n]
  ), { SelectionForeground: r } = Br();
  return !t || !r ? null : /* @__PURE__ */ m.jsx(r, { bounds: t, rotation: e });
}
function Jae() {
  const n = be(), e = Pe("selection rotation", () => n.getSelectionRotation(), [
    n
  ]), t = Pe(
    "selection bounds",
    () => n.getSelectionRotatedPageBounds(),
    [n]
  ), { SelectionBackground: r } = Br();
  return !t || !r ? null : /* @__PURE__ */ m.jsx(r, { bounds: t, rotation: e });
}
function ele() {
  const { OnTheCanvas: n } = Br();
  return n ? /* @__PURE__ */ m.jsx(n, {}) : null;
}
function tle() {
  const n = be(), e = Pe("camera state", () => n.getCameraState(), [n]);
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      className: It("tl-hit-test-blocker", {
        "tl-hit-test-blocker__hidden": e === "idle"
      })
    }
  );
}
function nle({
  className: n,
  zoom: e,
  point: t,
  color: r,
  viewport: i,
  opacity: s = 1
}) {
  const l = M.useRef(null);
  Ky(
    l,
    Do(t.x, i.minX + 5 / e, i.maxX - 5 / e),
    Do(t.y, i.minY + 5 / e, i.maxY - 5 / e),
    1 / e,
    R.Angle(i.center, t)
  );
  const c = bc("cursor_hint");
  return /* @__PURE__ */ m.jsxs("svg", { ref: l, className: It("tl-overlays__item", n), children: [
    /* @__PURE__ */ m.jsx(
      "use",
      {
        href: `#${c}`,
        color: r,
        strokeWidth: 3,
        stroke: "var(--color-background)"
      }
    ),
    /* @__PURE__ */ m.jsx("use", { href: `#${c}`, color: r, opacity: s })
  ] });
}
const N4 = M.memo(function({
  className: e,
  zoom: t,
  point: r,
  color: i,
  name: s,
  chatMessage: l
}) {
  const c = M.useRef(null);
  Ky(c, r == null ? void 0 : r.x, r == null ? void 0 : r.y, 1 / t);
  const d = bc("cursor");
  return r ? /* @__PURE__ */ m.jsxs("div", { ref: c, className: It("tl-overlays__item", e), children: [
    /* @__PURE__ */ m.jsx("svg", { className: "tl-cursor", children: /* @__PURE__ */ m.jsx("use", { href: `#${d}`, color: i }) }),
    l ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      s && /* @__PURE__ */ m.jsx("div", { className: "tl-nametag-title", style: { color: i }, children: s }),
      /* @__PURE__ */ m.jsx("div", { className: "tl-nametag-chat", style: { backgroundColor: i }, children: l })
    ] }) : s && /* @__PURE__ */ m.jsx("div", { className: "tl-nametag", style: { backgroundColor: i }, children: s })
  ] }) : null;
});
function rle({ x: n, y: e, z: t, size: r }) {
  const i = Vy("grid"), s = be(), { gridSteps: l } = s.options;
  return /* @__PURE__ */ m.jsxs("svg", { className: "tl-grid", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [
    /* @__PURE__ */ m.jsx("defs", { children: l.map(({ min: c, mid: d, step: h }, g) => {
      const y = h * r * t, v = 0.5 + n * t, w = 0.5 + e * t, C = v > 0 ? v % y : y + v % y, E = w > 0 ? w % y : y + w % y, P = t < d ? Ry(t, [c, d], [0, 1]) : 1;
      return /* @__PURE__ */ m.jsx(
        "pattern",
        {
          id: RO(i, `${h}`),
          width: y,
          height: y,
          patternUnits: "userSpaceOnUse",
          children: /* @__PURE__ */ m.jsx("circle", { className: "tl-grid-dot", cx: C, cy: E, r: 1, opacity: P })
        },
        g
      );
    }) }),
    l.map(({ step: c }, d) => /* @__PURE__ */ m.jsx("rect", { width: "100%", height: "100%", fill: `url(#${i}_${c})` }, d))
  ] });
}
function ile({ handle: n, isCoarse: e, className: t, zoom: r }) {
  const i = be(), s = (e ? i.options.coarseHandleRadius : i.options.handleRadius) / r;
  if (n.type === "clone") {
    const c = 3 / r, d = `M0,${-c} A${c},${c} 0 0,1 0,${c}`, h = lse.indexOf(n.id);
    return /* @__PURE__ */ m.jsxs("g", { className: It(`tl-handle tl-handle__${n.type}`, t), children: [
      /* @__PURE__ */ m.jsx("circle", { className: "tl-handle__bg", r: s }),
      /* @__PURE__ */ m.jsx("path", { className: "tl-handle__fg", d, transform: `rotate(${-90 + 90 * h})` })
    ] });
  }
  const l = (n.type === "create" && e ? 3 : 4) / Math.max(r, 0.25);
  return /* @__PURE__ */ m.jsxs("g", { className: It(`tl-handle tl-handle__${n.type}`, t), children: [
    /* @__PURE__ */ m.jsx("circle", { className: "tl-handle__bg", r: s }),
    /* @__PURE__ */ m.jsx("circle", { className: "tl-handle__fg", r: l })
  ] });
}
const ole = ({ children: n }) => /* @__PURE__ */ m.jsx("svg", { className: "tl-user-handles tl-overlays__item", children: n }), sle = () => {
  const { Spinner: n } = Br();
  return /* @__PURE__ */ m.jsx(rj, { children: n ? /* @__PURE__ */ m.jsx(n, {}) : null });
};
function zO(n, e = !0) {
  const t = n.length;
  if (t < 2)
    return "";
  let r = n[0], i = n[1];
  if (t === 2)
    return `M${Yn(r)}L${Yn(i)}`;
  let s = "";
  for (let l = 2, c = t - 1; l < c; l++)
    r = n[l], i = n[l + 1], s += xa(r, i);
  return e ? `M${xa(n[0], n[1])}Q${Yn(n[1])}${xa(
    n[1],
    n[2]
  )}T${s}${xa(n[t - 1], n[0])}${xa(n[0], n[1])}Z` : `M${Yn(n[0])}Q${Yn(n[1])}${xa(n[1], n[2])}${n.length > 3 ? "T" : ""}${s}L${Yn(n[t - 1])}`;
}
function F4({ scribble: n, zoom: e, color: t, opacity: r, className: i }) {
  return n.points.length ? /* @__PURE__ */ m.jsx("svg", { className: i && It("tl-overlays__item", i), children: /* @__PURE__ */ m.jsx(
    "path",
    {
      className: "tl-scribble",
      d: zO(n.points, !1),
      stroke: t ?? `var(--color-${n.color})`,
      fill: "none",
      strokeWidth: 8 / e,
      opacity: r ?? n.opacity
    }
  ) }) : null;
}
function hB({ bounds: n, rotation: e }) {
  const t = M.useRef(null);
  return Ky(t, n.x, n.y, 1, e), M.useLayoutEffect(() => {
    const r = t.current;
    r && (r.style.width = Se(Math.max(1, n.width)) + "px", r.style.height = Se(Math.max(1, n.height)) + "px");
  }, [n.width, n.height]), /* @__PURE__ */ m.jsx("div", { ref: t, className: "tl-selection__bg", draggable: !1 });
}
function ale({ bounds: n, rotation: e }) {
  const t = be(), r = M.useRef(null), i = Pe("only selected shape", () => t.getOnlySelectedShape(), [t]), s = i ? t.getShapeUtil(i).expandSelectionOutlinePx(i) : 0;
  return Ky(r, n == null ? void 0 : n.x, n == null ? void 0 : n.y, 1, e, {
    x: -s,
    y: -s
  }), n = s instanceof Xe ? n.clone().expand(s).zeroFix() : n.clone().expandBy(s).zeroFix(), /* @__PURE__ */ m.jsx(
    "svg",
    {
      ref: r,
      className: "tl-overlays__item tl-selection__fg",
      "data-testid": "selection-foreground",
      children: /* @__PURE__ */ m.jsx(
        "rect",
        {
          className: It("tl-selection__fg__outline"),
          width: Se(n.width),
          height: Se(n.height)
        }
      )
    }
  );
}
const lle = () => /* @__PURE__ */ m.jsx("div", { className: "tl-shape-error-boundary" }), cle = ({ shape: n, util: e }) => WE(
  "Indicator: " + n.type,
  () => (
    // always fetch the latest shape from the store even if the props/meta have not changed, to avoid
    // calling the render method with stale data.
    e.indicator(e.editor.store.unsafeGetWithoutCapture(n.id))
  )
), ule = ({ editor: n, id: e }) => {
  const t = Pe("shape for indicator", () => n.store.get(e), [n, e]), { ShapeIndicatorErrorFallback: r } = Br();
  return !t || t.isLocked ? null : /* @__PURE__ */ m.jsx(
    Yx,
    {
      fallback: r,
      onError: (i) => n.annotateError(i, { origin: "react.shapeIndicator", willCrashApp: !1 }),
      children: /* @__PURE__ */ m.jsx(cle, { shape: t, util: n.getShapeUtil(t) }, t.id)
    }
  );
}, z4 = M.memo(function({
  shapeId: e,
  className: t,
  color: r,
  hidden: i,
  opacity: s
}) {
  const l = be(), c = M.useRef(null);
  return dh(
    "indicator transform",
    () => {
      const d = c.current;
      if (!d) return;
      const h = l.getShapePageTransform(e);
      h && d.style.setProperty("transform", h.toCssString());
    },
    [l, e]
  ), M.useLayoutEffect(() => {
    const d = c.current;
    d && d.style.setProperty("display", i ? "none" : "block");
  }, [i]), /* @__PURE__ */ m.jsx("svg", { ref: c, className: It("tl-overlays__item", t), children: /* @__PURE__ */ m.jsx("g", { className: "tl-shape-indicator", stroke: r ?? "var(--color-selected)", opacity: s, children: /* @__PURE__ */ m.jsx(ule, { editor: l, id: e }) }) });
}), dle = () => /* @__PURE__ */ m.jsx("circle", { cx: 4, cy: 4, r: 8, strokeWidth: "1", stroke: "red" }), pB = M.memo(function() {
  const e = be(), t = M.useRef(/* @__PURE__ */ new Set()), r = Pe(
    "should display selected ids",
    () => {
      const l = t.current, c = /* @__PURE__ */ new Set();
      if (
        // We only show indicators when in the following states...
        e.isInAny(
          "select.idle",
          "select.brushing",
          "select.scribble_brushing",
          "select.editing_shape",
          "select.pointing_shape",
          "select.pointing_selection",
          "select.pointing_handle"
        ) && // ...but we hide indicators when we've just changed a style (so that the user can see the change)
        !e.getInstanceState().isChangingStyle
      ) {
        const d = e.getSelectedShapeIds();
        for (const h of d)
          c.add(h);
        if (e.isInAny("select.idle", "select.editing_shape")) {
          const h = e.getInstanceState();
          if (h.isHoveringCanvas && !h.isCoarsePointer) {
            const g = e.getHoveredShapeId();
            g && c.add(g);
          }
        }
      }
      if (l.size !== c.size)
        return t.current = c, c;
      for (const d of c)
        if (!l.has(d))
          return t.current = c, c;
      return l;
    },
    [e]
  ), i = Pe("rendering shapes", () => e.getRenderingShapes(), [e]), { ShapeIndicator: s } = Br();
  return s ? i.map(({ id: l }) => /* @__PURE__ */ m.jsx(s, { shapeId: l, hidden: !r.has(l) }, l + "_indicator")) : null;
});
function fle({ points: n, zoom: e }) {
  const t = 2.5 / e, r = n.reduce((v, w) => Math.min(v, w.x), 1 / 0), i = n.reduce((v, w) => Math.max(v, w.x), -1 / 0), s = n.reduce((v, w) => Math.min(v, w.y), 1 / 0), l = n.reduce((v, w) => Math.max(v, w.y), -1 / 0), c = n.some((v) => v.x === r && v.y === s);
  let d, h, g, y;
  return c ? (d = r, h = s, g = i, y = l) : (d = r, h = l, g = i, y = s), /* @__PURE__ */ m.jsxs("g", { className: "tl-snap-indicator", stroke: "lime", children: [
    /* @__PURE__ */ m.jsx("line", { x1: d, y1: h, x2: g, y2: y }),
    n.map((v, w) => /* @__PURE__ */ m.jsx("g", { transform: `translate(${v.x},${v.y})`, children: /* @__PURE__ */ m.jsx(
      "path",
      {
        className: "tl-snap-point",
        d: `M ${-t},${-t} L ${t},${t} M ${-t},${t} L ${t},${-t}`
      }
    ) }, w))
  ] });
}
function hle({ gaps: n, direction: e, zoom: t }) {
  const r = 3.5 / t;
  let i = [-1 / 0, 1 / 0], s = null;
  const l = e === "horizontal";
  for (const d of n) {
    if (s = pc(
      i[0],
      i[1],
      l ? d.startEdge[0].y : d.startEdge[0].x,
      l ? d.startEdge[1].y : d.startEdge[1].x
    ), s)
      i = s;
    else
      continue;
    if (s = pc(
      i[0],
      i[1],
      l ? d.endEdge[0].y : d.endEdge[0].x,
      l ? d.endEdge[1].y : d.endEdge[1].x
    ), s)
      i = s;
    else
      continue;
  }
  if (i === null)
    return null;
  const c = (i[0] + i[1]) / 2;
  return /* @__PURE__ */ m.jsx("g", { className: "tl-snap-indicator", stroke: "cyan", children: n.map(({ startEdge: d, endEdge: h }, g) => /* @__PURE__ */ m.jsx(M.Fragment, { children: l ? (
    // horizontal gap
    /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: d[0].x,
          y1: c - 2 * r,
          x2: d[1].x,
          y2: c + 2 * r
        }
      ),
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: h[0].x,
          y1: c - 2 * r,
          x2: h[1].x,
          y2: c + 2 * r
        }
      ),
      /* @__PURE__ */ m.jsx("line", { x1: d[0].x, y1: c, x2: h[0].x, y2: c }),
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: (d[0].x + h[0].x) / 2,
          y1: c - r,
          x2: (d[0].x + h[0].x) / 2,
          y2: c + r
        }
      )
    ] })
  ) : (
    // vertical gap
    /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: c - 2 * r,
          y1: d[0].y,
          x2: c + 2 * r,
          y2: d[1].y
        }
      ),
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: c - 2 * r,
          y1: h[0].y,
          x2: c + 2 * r,
          y2: h[1].y
        }
      ),
      /* @__PURE__ */ m.jsx("line", { x1: c, y1: d[0].y, x2: c, y2: h[0].y }),
      /* @__PURE__ */ m.jsx(
        "line",
        {
          x1: c - r,
          y1: (d[0].y + h[0].y) / 2,
          x2: c + r,
          y2: (d[0].y + h[0].y) / 2
        }
      )
    ] })
  ) }, g)) });
}
function ple({ className: n, line: e, zoom: t }) {
  return /* @__PURE__ */ m.jsx("svg", { className: It("tl-overlays__item", n), children: e.type === "points" ? /* @__PURE__ */ m.jsx(fle, { ...e, zoom: t }) : e.type === "gaps" ? /* @__PURE__ */ m.jsx(hle, { ...e, zoom: t }) : null });
}
function UO() {
  return /* @__PURE__ */ m.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", children: /* @__PURE__ */ m.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ m.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ m.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ m.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
const gle = () => null;
function gB(n, e) {
  const t = M.useRef(n);
  return e(n, t.current) ? t.current : (t.current = n, n);
}
const mle = (n, e) => (n ?? (n = null), e ?? (e = null), n === e ? !0 : !n || !e ? !1 : U$(n, e));
function sh(n) {
  return gB(n, mle);
}
const yle = (n, e) => (n ?? (n = null), e ?? (e = null), n === e ? !0 : !n || !e ? !1 : ZD(n, e));
function fg(n) {
  return gB(n, yle);
}
const mB = M.createContext(null);
function vle({
  overrides: n = {},
  children: e
}) {
  const t = fg(n), r = M.useMemo(
    () => ({
      Background: tse,
      SvgDefs: gle,
      Brush: bM,
      ZoomBrush: bM,
      CollaboratorBrush: bM,
      Cursor: N4,
      CollaboratorCursor: N4,
      CollaboratorHint: nle,
      CollaboratorShapeIndicator: z4,
      Grid: rle,
      Scribble: F4,
      SnapIndicator: ple,
      Handles: ole,
      Handle: ile,
      CollaboratorScribble: F4,
      ErrorFallback: vB,
      ShapeErrorFallback: lle,
      ShapeIndicatorErrorFallback: dle,
      Spinner: UO,
      SelectionBackground: hB,
      SelectionForeground: ale,
      ShapeIndicators: pB,
      ShapeIndicator: z4,
      OnTheCanvas: null,
      InFrontOfTheCanvas: null,
      Canvas: jae,
      LoadingScreen: sle,
      ...t
    }),
    [t]
  );
  return /* @__PURE__ */ m.jsx(mB.Provider, { value: r, children: e });
}
function Br() {
  const n = M.useContext(mB);
  if (!n)
    throw new Error("useEditorComponents must be used inside of <EditorComponentsProvider />");
  return n;
}
const e_ = {
  openWindow(n, e) {
    window.open(n, e, "noopener noreferrer");
  },
  refreshPage() {
    window.location.reload();
  },
  async hardReset() {
    var n;
    return await ((n = window.__tldraw__hardReset) == null ? void 0 : n.call(window));
  }
};
function yB() {
  e_.hardReset();
}
function Sle() {
  e_.refreshPage();
}
var xle = {};
const wle = "https://github.com/tldraw/tldraw/issues/new", vB = ({ error: n, editor: e }) => {
  const t = M.useRef(null), [r, i] = M.useState(xle.NODE_ENV === "development"), [s, l] = M.useState(!1), [c, d] = M.useState(!1);
  let h = null;
  try {
    h = Br().Canvas ?? null;
  } catch {
  }
  const g = n instanceof Error ? n.message : String(n), y = n instanceof Error ? n.stack : null, v = Pe(
    "isDarkMode",
    () => {
      try {
        if (e)
          return e.user.getIsDarkMode();
      } catch {
      }
      return null;
    },
    [e]
  ), [w, C] = M.useState(null);
  M.useLayoutEffect(() => {
    var z;
    v !== null && C(v);
    let L = (z = t.current) == null ? void 0 : z.parentElement, O = !1;
    for (; L; ) {
      if (L.classList.contains("tl-theme__dark") || L.classList.contains("tl-theme__light")) {
        O = !0;
        break;
      }
      L = L.parentElement;
    }
    if (O) {
      C(null);
      return;
    }
    typeof window < "u" && "matchMedia" in window && C(window.matchMedia("(prefers-color-scheme: dark)").matches);
  }, [v]), M.useEffect(() => {
    if (s) {
      const L = e == null ? void 0 : e.timers.setTimeout(() => {
        l(!1);
      }, 2e3);
      return () => clearTimeout(L);
    }
  }, [s, e]);
  const E = () => {
    const L = document.createElement("textarea");
    L.value = y ?? g, document.body.appendChild(L), L.select(), document.execCommand("copy"), L.remove(), l(!0);
  }, P = () => {
    Sle();
  }, I = async () => {
    yB();
  }, k = new URL(wle);
  return k.searchParams.set("title", g), k.searchParams.set("labels", "bug"), k.searchParams.set(
    "body",
    `Hey, I ran into an error while using tldraw:

\`\`\`js
${y ?? g}
\`\`\`

My browser: ${navigator.userAgent}`
  ), /* @__PURE__ */ m.jsxs(
    "div",
    {
      ref: t,
      className: It(
        "tl-container tl-error-boundary",
        // error-boundary is sometimes used outside of the theme
        // container, so we need to provide it with a theme for our
        // styles to work correctly
        w === null ? "" : w ? "tl-theme__dark" : "tl-theme__light"
      ),
      children: [
        /* @__PURE__ */ m.jsx("div", { className: "tl-error-boundary__overlay" }),
        e && // opportunistically attempt to render the canvas to reassure
        // the user that their document is still there. there's a good
        // chance this won't work (ie the error that we're currently
        // notifying the user about originates in the canvas) so it's
        // not a big deal if it doesn't work - in that case we just have
        // a plain grey background.
        /* @__PURE__ */ m.jsx(kO, { onError: $x, fallback: () => null, children: /* @__PURE__ */ m.jsx(AO, { editor: e, children: /* @__PURE__ */ m.jsx("div", { className: "tl-overlay tl-error-boundary__canvas", children: h ? /* @__PURE__ */ m.jsx(h, {}) : null }) }) }),
        /* @__PURE__ */ m.jsx(
          "div",
          {
            className: It("tl-modal", "tl-error-boundary__content", {
              "tl-error-boundary__content__expanded": r && !c
            }),
            children: c ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
              /* @__PURE__ */ m.jsx("h2", { children: "Are you sure?" }),
              /* @__PURE__ */ m.jsx("p", { children: "Resetting your data will delete your drawing and cannot be undone." }),
              /* @__PURE__ */ m.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ m.jsx("button", { onClick: () => d(!1), children: "Cancel" }),
                /* @__PURE__ */ m.jsx("button", { className: "tl-error-boundary__reset", onClick: I, children: "Reset data" })
              ] })
            ] }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
              /* @__PURE__ */ m.jsx("h2", { children: "Something went wrong" }),
              /* @__PURE__ */ m.jsx("p", { children: "Please refresh the page to continue." }),
              /* @__PURE__ */ m.jsxs("p", { children: [
                "If you keep seeing this screen, you can create a",
                " ",
                /* @__PURE__ */ m.jsx("a", { href: k.toString(), children: "GitHub issue" }),
                " or ask for help on",
                " ",
                /* @__PURE__ */ m.jsx("a", { href: "https://discord.gg/Cq6cPsTfNy", children: "Discord" }),
                ". If you are still stuck, you can reset the tldraw data on your machine. This may erase the project you were working on, so try to get help first."
              ] }),
              r && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
                "Message:",
                /* @__PURE__ */ m.jsx("h4", { children: /* @__PURE__ */ m.jsx("code", { children: g }) }),
                "Stack trace:",
                /* @__PURE__ */ m.jsxs("div", { className: "tl-error-boundary__content__error", children: [
                  /* @__PURE__ */ m.jsx("pre", { children: /* @__PURE__ */ m.jsx("code", { children: y ?? g }) }),
                  /* @__PURE__ */ m.jsx("button", { onClick: E, children: s ? "Copied!" : "Copy" })
                ] })
              ] }),
              /* @__PURE__ */ m.jsxs("div", { className: "tl-error-boundary__content__actions", children: [
                /* @__PURE__ */ m.jsx("button", { onClick: () => i(!r), children: r ? "Hide details" : "Show details" }),
                /* @__PURE__ */ m.jsxs("div", { className: "tl-error-boundary__content__actions__group", children: [
                  /* @__PURE__ */ m.jsx(
                    "button",
                    {
                      className: "tl-error-boundary__reset",
                      onClick: () => d(!0),
                      children: "Reset data"
                    }
                  ),
                  /* @__PURE__ */ m.jsx("button", { className: "tl-error-boundary__refresh", onClick: P, children: "Refresh Page" })
                ] })
              ] })
            ] })
          }
        )
      ]
    }
  );
};
var ble = {};
const SB = "TLDRAW_USER_DATA_v3", xB = kn({
  id: sn,
  name: sn.nullable().optional(),
  color: sn.nullable().optional(),
  // N.B. These are duplicated in TLdrawAppUser.
  locale: sn.nullable().optional(),
  animationSpeed: Ht.nullable().optional(),
  edgeScrollSpeed: Ht.nullable().optional(),
  colorScheme: VE("light", "dark", "system").optional(),
  isSnapMode: Tn.nullable().optional(),
  isWrapMode: Tn.nullable().optional(),
  isDynamicSizeMode: Tn.nullable().optional(),
  isPasteAtCursorMode: Tn.nullable().optional()
}), Rd = {
  AddAnimationSpeed: 1,
  AddIsSnapMode: 2,
  MakeFieldsNullable: 3,
  AddEdgeScrollSpeed: 4,
  AddExcalidrawSelectMode: 5,
  AddDynamicSizeMode: 6,
  AllowSystemColorScheme: 7,
  AddPasteAtCursor: 8
}, $O = Math.max(...Object.values(Rd));
function Cle(n) {
  n.version < Rd.AddAnimationSpeed && (n.user.animationSpeed = 1), n.version < Rd.AddIsSnapMode && (n.user.isSnapMode = !1), n.version < Rd.MakeFieldsNullable, n.version < Rd.AddEdgeScrollSpeed && (n.user.edgeScrollSpeed = 1), n.version < Rd.AddExcalidrawSelectMode && (n.user.isWrapMode = !1), n.version < Rd.AllowSystemColorScheme && (n.user.isDarkMode === !0 ? n.user.colorScheme = "dark" : n.user.isDarkMode === !1 && (n.user.colorScheme = "light"), delete n.user.isDarkMode), n.version < Rd.AddDynamicSizeMode && (n.user.isDynamicSizeMode = !1), n.version < Rd.AddPasteAtCursor && (n.user.isPasteAtCursorMode = !1), n.version = $O;
}
const YA = [
  "#FF802B",
  "#EC5E41",
  "#F2555A",
  "#F04F88",
  "#E34BA9",
  "#BD54C6",
  "#9D5BD2",
  "#7B66DC",
  "#02B1CC",
  "#11B3A3",
  "#39B178",
  "#55B467"
];
function wB() {
  return YA[Math.floor(Math.random() * YA.length)];
}
function Ele() {
  var n, e;
  return typeof window < "u" && "matchMedia" in window ? ((e = (n = window.matchMedia) == null ? void 0 : n.call(window, "(prefers-reduced-motion: reduce)")) == null ? void 0 : e.matches) ?? !1 : !1;
}
const Tl = Object.freeze({
  name: "New User",
  locale: Tie(),
  color: wB(),
  // N.B. These are duplicated in TLdrawAppUser.
  edgeScrollSpeed: 1,
  animationSpeed: Ele() ? 0 : 1,
  isSnapMode: !1,
  isWrapMode: !1,
  isDynamicSizeMode: !1,
  isPasteAtCursorMode: !1,
  colorScheme: "light"
});
function TM() {
  return {
    id: or(),
    color: wB()
  };
}
function bB(n) {
  if (n === null || typeof n != "object" || !("version" in n) || !("user" in n) || typeof n.version != "number")
    return TM();
  const e = $r(n);
  Cle(e);
  try {
    return xB.validate(e.user);
  } catch {
    return TM();
  }
}
function _le() {
  const n = JSON.parse(eO(SB) || "null") ?? null;
  return bB(n);
}
const t_ = mi("globalUserData", null);
function Ple() {
  tO(
    SB,
    JSON.stringify({
      version: $O,
      user: t_.get()
    })
  );
}
function CB(n) {
  xB.validate(n), t_.set(n), Ple(), Ile();
}
const Tle = typeof process < "u" && ble.NODE_ENV === "test", Ey = typeof BroadcastChannel < "u" && !Tle ? new BroadcastChannel("tldraw-user-sync") : null;
Ey == null || Ey.addEventListener("message", (n) => {
  const e = n.data;
  (e == null ? void 0 : e.type) === _B && (e == null ? void 0 : e.origin) !== EB() && t_.set(bB(e.data));
});
let IM = null;
function EB() {
  return IM === null && (IM = or()), IM;
}
const _B = "tldraw-user-preferences-change";
function Ile() {
  Ey == null || Ey.postMessage({
    type: _B,
    origin: EB(),
    data: {
      user: BO(),
      version: $O
    }
  });
}
function BO() {
  let n = t_.get();
  return n || (n = _le(), CB(n)), n;
}
const kle = Le(
  "defaultLocalStorageUserPrefs",
  () => BO()
);
function PB(n = {}) {
  return {
    userPreferences: n.userPreferences ?? kle,
    setUserPreferences: n.setUserPreferences ?? CB
  };
}
var kM = { exports: {} }, U4;
function Rle() {
  return U4 || (U4 = 1, function(n) {
    var e = Object.prototype.hasOwnProperty, t = "~";
    function r() {
    }
    Object.create && (r.prototype = /* @__PURE__ */ Object.create(null), new r().__proto__ || (t = !1));
    function i(d, h, g) {
      this.fn = d, this.context = h, this.once = g || !1;
    }
    function s(d, h, g, y, v) {
      if (typeof g != "function")
        throw new TypeError("The listener must be a function");
      var w = new i(g, y || d, v), C = t ? t + h : h;
      return d._events[C] ? d._events[C].fn ? d._events[C] = [d._events[C], w] : d._events[C].push(w) : (d._events[C] = w, d._eventsCount++), d;
    }
    function l(d, h) {
      --d._eventsCount === 0 ? d._events = new r() : delete d._events[h];
    }
    function c() {
      this._events = new r(), this._eventsCount = 0;
    }
    c.prototype.eventNames = function() {
      var h = [], g, y;
      if (this._eventsCount === 0) return h;
      for (y in g = this._events)
        e.call(g, y) && h.push(t ? y.slice(1) : y);
      return Object.getOwnPropertySymbols ? h.concat(Object.getOwnPropertySymbols(g)) : h;
    }, c.prototype.listeners = function(h) {
      var g = t ? t + h : h, y = this._events[g];
      if (!y) return [];
      if (y.fn) return [y.fn];
      for (var v = 0, w = y.length, C = new Array(w); v < w; v++)
        C[v] = y[v].fn;
      return C;
    }, c.prototype.listenerCount = function(h) {
      var g = t ? t + h : h, y = this._events[g];
      return y ? y.fn ? 1 : y.length : 0;
    }, c.prototype.emit = function(h, g, y, v, w, C) {
      var E = t ? t + h : h;
      if (!this._events[E]) return !1;
      var P = this._events[E], I = arguments.length, k, L;
      if (P.fn) {
        switch (P.once && this.removeListener(h, P.fn, void 0, !0), I) {
          case 1:
            return P.fn.call(P.context), !0;
          case 2:
            return P.fn.call(P.context, g), !0;
          case 3:
            return P.fn.call(P.context, g, y), !0;
          case 4:
            return P.fn.call(P.context, g, y, v), !0;
          case 5:
            return P.fn.call(P.context, g, y, v, w), !0;
          case 6:
            return P.fn.call(P.context, g, y, v, w, C), !0;
        }
        for (L = 1, k = new Array(I - 1); L < I; L++)
          k[L - 1] = arguments[L];
        P.fn.apply(P.context, k);
      } else {
        var O = P.length, z;
        for (L = 0; L < O; L++)
          switch (P[L].once && this.removeListener(h, P[L].fn, void 0, !0), I) {
            case 1:
              P[L].fn.call(P[L].context);
              break;
            case 2:
              P[L].fn.call(P[L].context, g);
              break;
            case 3:
              P[L].fn.call(P[L].context, g, y);
              break;
            case 4:
              P[L].fn.call(P[L].context, g, y, v);
              break;
            default:
              if (!k) for (z = 1, k = new Array(I - 1); z < I; z++)
                k[z - 1] = arguments[z];
              P[L].fn.apply(P[L].context, k);
          }
      }
      return !0;
    }, c.prototype.on = function(h, g, y) {
      return s(this, h, g, y, !1);
    }, c.prototype.once = function(h, g, y) {
      return s(this, h, g, y, !0);
    }, c.prototype.removeListener = function(h, g, y, v) {
      var w = t ? t + h : h;
      if (!this._events[w]) return this;
      if (!g)
        return l(this, w), this;
      var C = this._events[w];
      if (C.fn)
        C.fn === g && (!v || C.once) && (!y || C.context === y) && l(this, w);
      else {
        for (var E = 0, P = [], I = C.length; E < I; E++)
          (C[E].fn !== g || v && !C[E].once || y && C[E].context !== y) && P.push(C[E]);
        P.length ? this._events[w] = P.length === 1 ? P[0] : P : l(this, w);
      }
      return this;
    }, c.prototype.removeAllListeners = function(h) {
      var g;
      return h ? (g = t ? t + h : h, this._events[g] && l(this, g)) : (this._events = new r(), this._eventsCount = 0), this;
    }, c.prototype.off = c.prototype.removeListener, c.prototype.addListener = c.prototype.on, c.prefixed = t, c.EventEmitter = c, n.exports = c;
  }(kM)), kM.exports;
}
var Mle = Rle();
const Ale = /* @__PURE__ */ wh(Mle), _y = "TLDRAW_TAB_ID_v2", Ud = globalThis.window;
function Dle() {
  return Ud ? ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(
    // eslint-disable-next-line @typescript-eslint/no-deprecated
    Ud.navigator.platform
  ) || // iPad on iOS 13 detection
  Er.isDarwin && "ontouchend" in document : !1;
}
const Xx = Ud ? Ud[_y] ?? o6(_y) ?? "TLDRAW_INSTANCE_STATE_V1_" + or() : "<error>";
Ud && (Ud[_y] = Xx, Dle() ? nO(_y, Xx) : s6(_y));
Ud == null || Ud.addEventListener("beforeunload", () => {
  nO(_y, Xx);
});
const TB = {
  Initial: 0
}, n_ = Math.max(...Object.values(TB));
function Ole(n) {
  n.version < TB.Initial, n.version = n_;
}
const IB = kn({
  version: Ht,
  currentPageId: Wx.optional(),
  isFocusMode: Tn.optional(),
  exportBackground: Tn.optional(),
  isDebugMode: Tn.optional(),
  isToolLocked: Tn.optional(),
  isGridMode: Tn.optional(),
  pageStates: No(
    kn({
      pageId: Wx,
      camera: kn({
        x: Ht,
        y: Ht,
        z: Ht
      }).optional(),
      selectedShapeIds: No(Il).optional(),
      focusedGroupId: Il.nullable().optional()
    })
  ).optional()
});
function jle(n) {
  if (!n || typeof n != "object")
    return console.warn("Invalid instance state"), null;
  if (!("version" in n) || typeof n.version != "number")
    return console.warn("No version in instance state"), null;
  n.version !== n_ && (n = $r(n), Ole(n));
  try {
    return IB.validate(n);
  } catch (e) {
    return console.warn(e), null;
  }
}
function HO(n) {
  const e = n.query.ids("page");
  return Le(
    "sessionStateSnapshot",
    () => {
      const t = n.get(hs);
      if (!t) return null;
      const r = [...e.get()];
      return {
        version: n_,
        currentPageId: t.currentPageId,
        exportBackground: t.exportBackground,
        isFocusMode: t.isFocusMode,
        isDebugMode: t.isDebugMode,
        isToolLocked: t.isToolLocked,
        isGridMode: t.isGridMode,
        pageStates: r.map((i) => {
          const s = n.get(Ml.createId(i)), l = n.get(vc.createId(i));
          return {
            pageId: i,
            camera: {
              x: (l == null ? void 0 : l.x) ?? 0,
              y: (l == null ? void 0 : l.y) ?? 0,
              z: (l == null ? void 0 : l.z) ?? 1
            },
            selectedShapeIds: (s == null ? void 0 : s.selectedShapeIds) ?? [],
            focusedGroupId: (s == null ? void 0 : s.focusedGroupId) ?? null
          };
        })
      };
    },
    { isEqual: ph }
  );
}
function XA(n, e, t) {
  const r = jle(e);
  if (!r) return;
  const i = $6(n.get(hs)), s = t != null && t.forceOverwrite ? r : i, l = t != null && t.forceOverwrite ? i : r, c = n.schema.types.instance.create({
    id: hs,
    ...i,
    // the integrity checker will ensure that the currentPageId is valid
    currentPageId: r.currentPageId,
    isDebugMode: (s == null ? void 0 : s.isDebugMode) ?? (l == null ? void 0 : l.isDebugMode),
    isFocusMode: (s == null ? void 0 : s.isFocusMode) ?? (l == null ? void 0 : l.isFocusMode),
    isToolLocked: (s == null ? void 0 : s.isToolLocked) ?? (l == null ? void 0 : l.isToolLocked),
    isGridMode: (s == null ? void 0 : s.isGridMode) ?? (l == null ? void 0 : l.isGridMode),
    exportBackground: (s == null ? void 0 : s.exportBackground) ?? (l == null ? void 0 : l.exportBackground)
  });
  n.atomic(() => {
    var d, h, g;
    for (const y of r.pageStates ?? []) {
      if (!n.has(y.pageId)) continue;
      const v = vc.createId(y.pageId), w = Ml.createId(y.pageId), C = n.get(v), E = n.get(w);
      n.put([
        vc.create({
          id: v,
          x: ((d = y.camera) == null ? void 0 : d.x) ?? (C == null ? void 0 : C.x),
          y: ((h = y.camera) == null ? void 0 : h.y) ?? (C == null ? void 0 : C.y),
          z: ((g = y.camera) == null ? void 0 : g.z) ?? (C == null ? void 0 : C.z)
        }),
        Ml.create({
          id: w,
          pageId: y.pageId,
          selectedShapeIds: y.selectedShapeIds ?? (E == null ? void 0 : E.selectedShapeIds),
          focusedGroupId: y.focusedGroupId ?? (E == null ? void 0 : E.focusedGroupId)
        })
      ]);
    }
    n.put([c]), n.ensureStoreIsUsable();
  });
}
function Lle(n) {
  var i;
  const e = [];
  for (const s of Object.values(n))
    (i = s.typeName) != null && i.match(/^(instance.*|pointer|camera)$/) && e.push(s);
  const t = e.filter(
    (s) => s.typeName === "instance" && s.id !== hs
  )[0];
  if (!t) return null;
  const r = {
    version: n_,
    currentPageId: t.currentPageId,
    exportBackground: !!t.exportBackground,
    isFocusMode: !!t.isFocusMode,
    isDebugMode: !!t.isDebugMode,
    isToolLocked: !!t.isToolLocked,
    isGridMode: !1,
    pageStates: e.filter((s) => s.typeName === "instance_page_state" && s.instanceId === t.id).map((s) => {
      const l = n[s.cameraId] ?? { x: 0, y: 0, z: 1 };
      return {
        pageId: s.pageId,
        camera: {
          x: l.x,
          y: l.y,
          z: l.z
        },
        selectedShapeIds: s.selectedShapeIds,
        focusedGroupId: s.focusedGroupId
      };
    })
  };
  try {
    return IB.validate(r), r;
  } catch {
    return null;
  }
}
function kB(n, e, t) {
  let r = {};
  if ("store" in e) {
    const l = n.schema.migrateStoreSnapshot(e);
    if (l.type !== "success")
      throw new Error("Failed to migrate store snapshot: " + l.reason);
    r.document = {
      schema: n.schema.serialize(),
      store: Rx(
        l.value,
        (c, { typeName: d }) => n.scopedTypes.document.has(d)
      )
    };
  } else
    r = e;
  const i = $6(n.get(hs)), s = RB.get(n, HO).get();
  n.atomic(() => {
    r.document && n.loadStoreSnapshot(r.document), i && n.update(hs, (l) => ({ ...l, ...i })), s && XA(n, s), r.session && XA(n, r.session, {
      forceOverwrite: t == null ? void 0 : t.forceOverwriteSessionState
    });
  });
}
const RB = new Cu();
function Nle(n) {
  const t = RB.get(n, HO).get();
  if (!t)
    throw new Error("Session state is not ready yet");
  return {
    document: n.getStoreSnapshot(),
    session: t
  };
}
function MB(n) {
  const e = [], t = /* @__PURE__ */ new Set();
  for (const r of n) {
    if (t.has(r.type))
      throw new Error(`Binding type "${r.type}" is defined more than once`);
    e.push(r), t.add(r.type);
  }
  return e;
}
function mh({ children: n, className: e = "", ...t }) {
  return /* @__PURE__ */ m.jsx("svg", { ...t, className: It("tl-svg-container", e), children: n });
}
function VO(n, e, t, r) {
  const i = n.x - t.x, s = n.y - t.y, l = r.x - t.x, c = r.y - t.y, d = e.x - n.x, h = e.y - n.y, g = l * s - c * i, y = d * s - h * i, v = c * d - l * h;
  if (g === 0 || y === 0 || v === 0) return null;
  if (v !== 0) {
    const w = g / v, C = y / v;
    if (0 <= w && w <= 1 && 0 <= C && C <= 1)
      return R.AddXY(n, w * d, w * h);
  }
  return null;
}
function ww(n, e, t, r) {
  const i = (e.x - n.x) * (e.x - n.x) + (e.y - n.y) * (e.y - n.y), s = 2 * ((e.x - n.x) * (n.x - t.x) + (e.y - n.y) * (n.y - t.y)), l = t.x * t.x + t.y * t.y + n.x * n.x + n.y * n.y - 2 * (t.x * n.x + t.y * n.y) - r * r, c = s * s - 4 * i * l;
  if (c < 0 || c === 0) return null;
  const d = Math.sqrt(c), h = (-s + d) / (2 * i), g = (-s - d) / (2 * i);
  if ((h < 0 || h > 1) && (g < 0 || g > 1))
    return null;
  const y = [];
  return 0 <= h && h <= 1 && y.push(R.Lrp(n, e, h)), 0 <= g && g <= 1 && y.push(R.Lrp(n, e, g)), y.length === 0 ? null : y;
}
function Fle(n, e, t) {
  const r = [];
  let i;
  for (let s = 0, l = t.length - 1; s < l; s++)
    i = VO(n, e, t[s], t[s + 1]), i && r.push(i);
  return r.length === 0 ? null : r;
}
function KO(n, e, t) {
  const r = [];
  let i;
  for (let s = 1, l = t.length; s < l + 1; s++)
    i = VO(
      n,
      e,
      t[s - 1],
      t[s % t.length]
    ), i && r.push(i);
  return r.length === 0 ? null : r;
}
function zle(n, e, t, r) {
  let i = t.x - n.x, s = t.y - n.y;
  const l = Math.sqrt(i * i + s * s), c = (l * l - r * r + e * e) / (2 * l), d = Math.sqrt(e * e - c * c);
  return i /= l, s /= l, [
    new R(n.x + i * c - s * d, n.y + s * c + i * d),
    new R(n.x + i * c + s * d, n.y + s * c - i * d)
  ];
}
function ZA(n, e, t) {
  const r = [];
  let i, s, l;
  for (let c = 0, d = t.length; c < d; c++)
    i = t[c], s = t[(c + 1) % t.length], l = ww(i, s, n, e), l && r.push(...l);
  return r.length === 0 ? null : r;
}
function $4(n, e, t) {
  const r = [];
  let i, s, l;
  for (let c = 1, d = t.length; c < d; c++)
    i = t[c - 1], s = t[c], l = ww(i, s, n, e), l && r.push(...l);
  return r.length === 0 ? null : r;
}
function H1(n, e, t) {
  return (t.y - n.y) * (e.x - n.x) > (e.y - n.y) * (t.x - n.x);
}
function WO(n, e, t, r) {
  return H1(n, t, r) !== H1(e, t, r) && H1(n, e, t) !== H1(n, e, r);
}
function B4(n, e) {
  const t = /* @__PURE__ */ new Map();
  let r, i, s, l;
  for (let c = 0, d = n.length; c < d; c++)
    if (r = n[c], Ja(r, e)) {
      const h = RM(r);
      t.has(h) || t.set(h, r);
    }
  for (let c = 0, d = e.length; c < d; c++)
    if (r = e[c], Ja(r, n)) {
      const h = RM(r);
      t.has(h) || t.set(h, r);
    }
  for (let c = 0, d = n.length; c < d; c++) {
    r = n[c], i = n[(c + 1) % n.length];
    for (let h = 0, g = e.length; h < g; h++) {
      s = e[h], l = e[(h + 1) % e.length];
      const y = VO(r, i, s, l);
      if (y !== null) {
        const v = RM(y);
        t.has(v) || t.set(v, y);
      }
    }
  }
  return t.size === 0 ? null : Ule([...t.values()]);
}
function RM(n) {
  return `${n.x},${n.y}`;
}
function Ule(n) {
  const e = R.Average(n);
  return n.sort((t, r) => R.Angle(e, t) - R.Angle(e, r));
}
function GO(n, e) {
  let t, r, i, s;
  for (let l = 0, c = n.length; l < c; l++) {
    t = n[l], r = n[(l + 1) % c];
    for (let d = 0, h = e.length; d < h; d++)
      if (i = e[d], s = e[(d + 1) % h], WO(t, r, i, s)) return !0;
  }
  return !1;
}
function $le(n, e) {
  let t, r, i, s;
  for (let l = 0, c = n.length; l < c; l++) {
    t = n[l], r = n[(l + 1) % c];
    for (let d = 1, h = e.length; d < h; d++)
      if (i = e[d - 1], s = e[d], WO(t, r, i, s)) return !0;
  }
  return !1;
}
class Ld extends Ph {
  constructor(t) {
    super({ ...t, isClosed: !1, isFilled: !1 });
    U(this, "start");
    U(this, "end");
    U(this, "d");
    U(this, "u");
    U(this, "ul");
    const { start: r, end: i } = t;
    this.start = r, this.end = i, this.d = r.clone().sub(i), this.u = this.d.clone().uni(), this.ul = this.u.len();
  }
  getLength() {
    return this.d.len();
  }
  midPoint() {
    return this.start.lrp(this.end, 0.5);
  }
  getVertices() {
    return [this.start, this.end];
  }
  nearestPoint(t) {
    const { start: r, end: i, d: s, u: l, ul: c } = this;
    if (s.len() === 0 || c === 0) return r;
    const d = R.Sub(t, r).dpr(l) / c, h = r.x + l.x * d;
    if (h < Math.min(r.x, i.x)) return r.x < i.x ? r : i;
    if (h > Math.max(r.x, i.x)) return r.x > i.x ? r : i;
    const g = r.y + l.y * d;
    return g < Math.min(r.y, i.y) ? r.y < i.y ? r : i : g > Math.max(r.y, i.y) ? r.y > i.y ? r : i : new R(h, g);
  }
  hitTestLineSegment(t, r, i = 0) {
    return WO(t, r, this.start, this.end) || this.distanceToLineSegment(t, r) <= i;
  }
  getSvgPathData(t = !0) {
    const { start: r, end: i } = this;
    return `${t ? `M${r.toFixed()}` : ""} L${i.toFixed()}`;
  }
}
class Wy extends Ph {
  constructor(t) {
    super({ isClosed: !1, isFilled: !1, ...t });
    U(this, "points");
    U(this, "_segments");
    const { points: r } = t;
    this.points = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { vertices: t } = this;
      for (let r = 0, i = t.length - 1; r < i; r++) {
        const s = t[r], l = t[r + 1];
        this._segments.push(new Ld({ start: s, end: l }));
      }
      this.isClosed && this._segments.push(new Ld({ start: t[t.length - 1], end: t[0] }));
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((t, r) => t + r.length, 0);
  }
  getVertices() {
    return this.points;
  }
  nearestPoint(t) {
    const { segments: r } = this;
    let i = this.points[0], s = 1 / 0, l, c;
    for (let d = 0; d < r.length; d++)
      l = r[d].nearestPoint(t), c = R.Dist2(l, t), c < s && (i = l, s = c);
    if (!i) throw Error("nearest point not found");
    return i;
  }
  hitTestLineSegment(t, r, i = 0) {
    const { segments: s } = this;
    for (let l = 0, c = s.length; l < c; l++)
      if (s[l].hitTestLineSegment(t, r, i))
        return !0;
    return !1;
  }
  getSvgPathData() {
    const { vertices: t } = this;
    return t.length < 2 ? "" : t.reduce((r, i, s) => s === 0 ? `M ${i.x} ${i.y}` : `${r} L ${i.x} ${i.y}`, "");
  }
}
class Ci extends Wy {
  constructor(e) {
    super({ ...e }), this.isClosed = !0;
  }
}
class Tu extends Ci {
  constructor(t) {
    const { x: r = 0, y: i = 0, width: s, height: l } = t;
    super({
      ...t,
      points: [
        new R(r, i),
        new R(r + s, i),
        new R(r + s, i + l),
        new R(r, i + l)
      ]
    });
    U(this, "x");
    U(this, "y");
    U(this, "w");
    U(this, "h");
    this.x = r, this.y = i, this.w = s, this.h = l;
  }
  getBounds() {
    return new Xe(this.x, this.y, this.w, this.h);
  }
  getSvgPathData() {
    const { x: t, y: r, w: i, h: s } = this;
    return `M${t},${r} h${i} v${s} h-${i}z`;
  }
}
class Cc {
  constructor(e) {
    this.editor = e;
  }
  /**
   * Whether the shape can be snapped to by another shape.
   *
   * @public
   */
  canSnap(e) {
    return !0;
  }
  /**
   * Whether the shape can be scrolled while editing.
   *
   * @public
   */
  canScroll(e) {
    return !1;
  }
  /**
   * Whether the shape can be bound to. See {@link TLShapeUtilCanBindOpts} for details.
   *
   * @public
   */
  canBind(e) {
    return !0;
  }
  /**
   * Whether the shape can be double clicked to edit.
   *
   * @public
   */
  canEdit(e) {
    return !1;
  }
  /**
   * Whether the shape can be resized.
   *
   * @public
   */
  canResize(e) {
    return !0;
  }
  /**
   * Whether the shape can be edited in read-only mode.
   *
   * @public
   */
  canEditInReadOnly(e) {
    return !1;
  }
  /**
   * Whether the shape can be cropped.
   *
   * @public
   */
  canCrop(e) {
    return !1;
  }
  /**
   * Whether the shape participates in stacking, aligning, and distributing.
   *
   * @public
   */
  canBeLaidOut(e) {
    return !0;
  }
  /**
   * Does this shape provide a background for its children? If this is true,
   * then any children with a `renderBackground` method will have their
   * backgrounds rendered _above_ this shape. Otherwise, the children's
   * backgrounds will be rendered above either the next ancestor that provides
   * a background, or the canvas background.
   *
   * @internal
   */
  providesBackgroundForChildren(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its resize handles when selected.
   *
   * @public
   */
  hideResizeHandles(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its rotation handles when selected.
   *
   * @public
   */
  hideRotateHandle(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its selection bounds background when selected.
   *
   * @public
   */
  hideSelectionBoundsBg(e) {
    return !1;
  }
  /**
   * Whether the shape should hide its selection bounds foreground when selected.
   *
   * @public
   */
  hideSelectionBoundsFg(e) {
    return !1;
  }
  /**
   * Whether the shape's aspect ratio is locked.
   *
   * @public
   */
  isAspectRatioLocked(e) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape.
   * @param type - The shape type.
   * @public
   */
  canReceiveNewChildrenOfType(e, t) {
    return !1;
  }
  /**
   * Get whether the shape can receive children of a given type.
   *
   * @param shape - The shape type.
   * @param shapes - The shapes that are being dropped.
   * @public
   */
  canDropShapes(e, t) {
    return !1;
  }
  /** @internal */
  expandSelectionOutlinePx(e) {
    return 0;
  }
  /**
   * Return elements to be added to the \<defs\> section of the canvases SVG context. This can be
   * used to define SVG content (e.g. patterns & masks) that can be referred to by ID from svg
   * elements returned by `component`.
   *
   * Each def should have a unique `key`. If multiple defs from different shapes all have the same
   * key, only one will be used.
   */
  getCanvasSvgDefs() {
    return [];
  }
  /**
   * Get the geometry to use when snapping to this this shape in translate/resize operations. See
   * {@link BoundsSnapGeometry} for details.
   */
  getBoundsSnapGeometry(e) {
    return {};
  }
  /**
   * Get the geometry to use when snapping handles to this shape. See {@link HandleSnapGeometry}
   * for details.
   */
  getHandleSnapGeometry(e) {
    return {};
  }
  getText(e) {
  }
}
/**
 * Props allow you to define the shape's properties in a way that the editor can understand.
 * This has two main uses:
 *
 * 1. Validation. Shapes will be validated using these props to stop bad data from being saved.
 * 2. Styles. Each {@link @tldraw/tlschema#StyleProp} in the props can be set on many shapes at
 *    once, and will be remembered from one shape to the next.
 *
 * @example
 * ```tsx
 * import {T, TLBaseShape, TLDefaultColorStyle, DefaultColorStyle, ShapeUtil} from 'tldraw'
 *
 * type MyShape = TLBaseShape<'mine', {
 *      color: TLDefaultColorStyle,
 *      text: string,
 * }>
 *
 * class MyShapeUtil extends ShapeUtil<MyShape> {
 *     static props = {
 *         // we use tldraw's built-in color style:
 *         color: DefaultColorStyle,
 *         // validate that the text prop is a string:
 *         text: T.string,
 *     }
 * }
 * ```
 */
U(Cc, "props"), /**
 * Migrations allow you to make changes to a shape's props over time. Read the
 * {@link https://www.tldraw.dev/docs/persistence#Shape-props-migrations | shape prop migrations}
 * guide for more information.
 */
U(Cc, "migrations"), /**
 * The type of the shape util, which should match the shape's type.
 *
 * @public
 */
U(Cc, "type");
function mc(n, e, t = {}) {
  const {
    closed: r = !1,
    snap: i = 1,
    start: s = "outset",
    end: l = "outset",
    lengthRatio: c = 2,
    style: d = "dashed",
    forceSolid: h = !1
  } = t;
  let g = 0, y = 0, v = 1, w = 0, C = 0;
  if (h)
    return {
      strokeDasharray: "none",
      strokeDashoffset: "none"
    };
  switch (d) {
    case "dashed": {
      v = 1, g = Math.min(e * c, n / 4);
      break;
    }
    case "dotted": {
      v = 100, g = e / v;
      break;
    }
    default:
      return {
        strokeDasharray: "none",
        strokeDashoffset: "none"
      };
  }
  return r || (s === "outset" ? (n += g / 2, C += g / 2) : s === "skip" && (n -= g, C -= g), l === "outset" ? n += g / 2 : l === "skip" && (n -= g)), y = Math.floor(n / g / (2 * v)), y -= y % i, y < 3 && d === "dashed" ? n / e < 4 ? (g = n, y = 1, w = 0) : (g = n * (1 / 3), w = n * (1 / 3)) : (g = n / y / (2 * v), r ? (C = g / 2, w = (n - y * g) / y) : w = (n - y * g) / Math.max(1, y - 1)), {
    strokeDasharray: [g, w].join(" "),
    strokeDashoffset: C.toString()
  };
}
function H4({ bounds: n, className: e }) {
  const t = be(), r = Pe("zoom level", () => t.getZoomLevel(), [t]);
  return /* @__PURE__ */ m.jsx("g", { className: e, pointerEvents: "none", strokeLinecap: "round", strokeLinejoin: "round", children: n.sides.map((i, s) => {
    const { strokeDasharray: l, strokeDashoffset: c } = mc(
      i[0].dist(i[1]),
      1 / r,
      {
        style: "dashed",
        lengthRatio: 4
      }
    );
    return /* @__PURE__ */ m.jsx(
      "line",
      {
        x1: i[0].x,
        y1: i[0].y,
        x2: i[1].x,
        y2: i[1].y,
        strokeDasharray: l,
        strokeDashoffset: c
      },
      s
    );
  }) });
}
class wC extends Cc {
  hideSelectionBoundsFg() {
    return !0;
  }
  canBind() {
    return !1;
  }
  getDefaultProps() {
    return {};
  }
  getGeometry(e) {
    const t = this.editor.getSortedChildIdsForParent(e.id);
    return t.length === 0 ? new Tu({ width: 1, height: 1, isFilled: !1 }) : new jl({
      children: t.map((r) => {
        const i = this.editor.getShape(r), s = this.editor.getShapeGeometry(r), l = this.editor.getShapeLocalTransform(i).applyToPoints(s.vertices);
        return s.isClosed ? new Ci({
          points: l,
          isFilled: !0
        }) : new Wy({
          points: l
        });
      })
    });
  }
  component(e) {
    const t = this.editor.getErasingShapeIds().includes(e.id), { hintingShapeIds: r } = this.editor.getCurrentPageState(), i = r.length > 0 && r.some(
      (c) => c !== e.id && this.editor.isShapeOfType(this.editor.getShape(c), "group")
    ), s = this.editor.getCurrentPageState().focusedGroupId !== e.id;
    if (!t && // always show the outline while we're erasing the group
    // show the outline while the group is focused unless something outside of the group is being hinted
    // this happens dropping shapes from a group onto some outside group
    (s || i))
      return null;
    const l = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(H4, { className: "tl-group", bounds: l }) });
  }
  indicator(e) {
    const t = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ m.jsx(H4, { className: "", bounds: t });
  }
  onChildrenChange(e) {
    const t = this.editor.getSortedChildIdsForParent(e.id);
    if (t.length === 0) {
      this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.deleteShapes([e.id]);
      return;
    } else if (t.length === 1) {
      this.editor.getCurrentPageState().focusedGroupId === e.id && this.editor.popFocusedGroupId(), this.editor.reparentShapes(t, e.parentId), this.editor.deleteShapes([e.id]);
      return;
    }
  }
}
U(wC, "type", "group"), U(wC, "props", J6), U(wC, "migrations", e8);
const AB = [
  // created by grouping interactions, probably the corest core shape that we have
  wC
], Ble = new Set(AB.map((n) => n.type));
function DB(n) {
  const e = [...AB], t = /* @__PURE__ */ new Set();
  for (const r of n) {
    if (Ble.has(r.type))
      throw new Error(
        `Shape type "${r.type}" is a core shapes type and cannot be overridden`
      );
    if (t.has(r.type))
      throw new Error(`Shape type "${r.type}" is defined more than once`);
    e.push(r), t.add(r.type);
  }
  return e;
}
var Gy = j$();
const Hle = /* @__PURE__ */ wh(Gy);
function OB(n, e) {
  const t = /* @__PURE__ */ new Map();
  return async function(i) {
    const s = t.get(i);
    if (s) return s;
    const l = (async () => {
      try {
        const c = await Eu(i, e);
        return on(c.ok), await n(c);
      } catch (c) {
        return console.error(c), null;
      }
    })();
    return t.set(i, l), l;
  };
}
const r_ = OB(async (n) => await yc.blobToDataUrl(await n.blob())), Vle = /@import\s+(?:"([^"]+)"|'([^']+)'|url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\))([^;]+);/gi, Kle = /@font-face\s*{([^}]+)}/gi, jB = /url\s*\(\s*(?:"([^"]+)"|'([^']+)'|([^'")]+))\s*\)/gi, Wle = /(?:^|;)\s*font-family\s*:\s*(?:([^'"][^;\n]+)|"([^"]+)"|'([^']+)')\s*(?:;|$)/gi;
function Gle(n) {
  return Array.from(n.matchAll(Vle), (e) => ({
    url: e[1] || e[2] || e[3] || e[4] || e[5],
    extras: e[6]
  }));
}
function LB(n, e) {
  return Array.from(n.matchAll(Kle), (t) => {
    const r = t[1], i = Array.from(r.matchAll(jB), (l) => {
      var d;
      const c = l[1] || l[2] || l[3];
      return {
        original: c,
        resolved: ((d = Wt(c, e)) == null ? void 0 : d.href) ?? null
      };
    }), s = new Set(
      Array.from(r.matchAll(Wle), (l) => (l[1] || l[2] || l[3]).toLowerCase())
    );
    return { fontFace: r, urls: i, fontFamilies: s };
  });
}
function qle(n) {
  const e = /\s*(?:([^'"][^;\n\s,]+)|"([^"]+)"|'([^']+)')\s*/gi, t = /\s*,\s*/gi, r = /* @__PURE__ */ new Set();
  for (; ; ) {
    const i = e.exec(n);
    if (!i)
      break;
    const s = i[1] || i[2] || i[3];
    if (r.add(s.toLowerCase()), t.lastIndex = e.lastIndex, !t.exec(n))
      break;
    e.lastIndex = t.lastIndex;
  }
  return r;
}
function NB(n) {
  return !(n.startsWith("-") || n.startsWith("animation") || n.startsWith("transition") || n === "cursor" || n === "pointer-events" || n === "user-select" || n === "touch-action");
}
function Yle(n, e) {
  return {
    imports: Gle(n),
    fontFaces: LB(n, e)
  };
}
function Xle(n) {
  return Array.from(n.matchAll(jB), (e) => ({
    original: e[0],
    url: e[1] || e[2] || e[3]
  }));
}
const Zle = /* @__PURE__ */ new Set([
  "border-collapse",
  "border-spacing",
  "caption-side",
  "color",
  "cursor",
  "direction",
  "empty-cells",
  "font-family",
  "font-size",
  "font-style",
  "font-variant",
  "font-weight",
  "font-size-adjust",
  "font-stretch",
  "font",
  "letter-spacing",
  "line-height",
  "list-style-image",
  "list-style-position",
  "list-style-type",
  "list-style",
  "orphans",
  "quotes",
  "tab-size",
  "text-align",
  "text-align-last",
  "text-decoration-color",
  "text-indent",
  "text-justify",
  "text-shadow",
  "text-transform",
  "visibility",
  "white-space",
  "widows",
  "word-break",
  "word-spacing",
  "word-wrap"
]);
function FB(n) {
  return Zle.has(n);
}
var Qle = Object.create, zB = Object.defineProperty, Jle = Object.getOwnPropertyDescriptor, ece = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), UB = (n) => {
  throw TypeError(n);
}, $B = (n, e, t) => e in n ? zB(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, tce = (n) => [, , , Qle(null)], BB = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], HB = (n) => n !== void 0 && typeof n != "function" ? UB("Function expected") : n, nce = (n, e, t, r, i) => ({ kind: BB[n], name: e, metadata: r, addInitializer: (s) => t._ ? UB("Already initialized") : i.push(HB(s || null)) }), rce = (n, e) => $B(e, ece("metadata"), n[3]), ice = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, oce = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = BB[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Jle(i, t)), I = r.length - 1; I >= 0; I--)
    d = nce(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, HB(l) && (P[C] = l);
  return P && zB(i, t, P), i;
}, V1 = (n, e, t) => $B(n, typeof e != "symbol" ? e + "" : e, t), VB, i_;
VB = [Ca];
class qO {
  constructor() {
    ice(i_, 5, this), V1(this, "fontFacesPromise", null), V1(this, "foundFontNames", /* @__PURE__ */ new Set()), V1(this, "fontFacesToEmbed", /* @__PURE__ */ new Set()), V1(this, "pendingPromises", []);
  }
  startFindingCurrentDocumentFontFaces() {
    on(!this.fontFacesPromise, "FontEmbedder already started"), this.fontFacesPromise = sce();
  }
  onFontFamilyValue(e) {
    on(this.fontFacesPromise, "FontEmbedder not started");
    const t = qle(e);
    for (const r of t) {
      if (this.foundFontNames.has(r)) return;
      this.foundFontNames.add(r), this.pendingPromises.push(
        this.fontFacesPromise.then((i) => {
          const s = i.filter((l) => l.fontFamilies.has(r));
          for (const l of s)
            if (!this.fontFacesToEmbed.has(l)) {
              this.fontFacesToEmbed.add(l);
              for (const c of l.urls)
                !c.resolved || c.embedded || (c.embedded = r_(c.resolved));
            }
        })
      );
    }
  }
  async createCss() {
    await Promise.all(this.pendingPromises);
    let e = "";
    for (const t of this.fontFacesToEmbed) {
      let r = `@font-face {${t.fontFace}}`;
      for (const i of t.urls) {
        if (!i.embedded) continue;
        const s = await i.embedded;
        s && (r = r.replace(i.original, s));
      }
      e += r;
    }
    return e;
  }
}
i_ = tce();
oce(i_, 1, "onFontFamilyValue", VB, qO);
rce(i_, qO);
async function sce() {
  var e;
  const n = [];
  for (const t of document.styleSheets) {
    let r;
    try {
      r = t.cssRules;
    } catch {
    }
    if (r) {
      for (const i of t.cssRules)
        if (i instanceof CSSFontFaceRule)
          n.push(LB(i.cssText, t.href ?? document.baseURI));
        else if (i instanceof CSSImportRule) {
          const s = new URL(i.href, ((e = i.parentStyleSheet) == null ? void 0 : e.href) ?? document.baseURI);
          n.push(QA(s.href));
        }
    } else t.href && n.push(QA(t.href));
  }
  return rn(await Promise.all(n)).flat();
}
const QA = OB(async (n) => {
  const e = Yle(await n.text(), n.url), t = await Promise.all(
    e.imports.map(({ url: r }) => QA(new URL(r, n.url).href))
  );
  return [...e.fontFaces, ...rn(t).flat()];
});
function KB(n) {
  if (n.shadowRoot)
    return n.shadowRoot.childNodes;
  if (uce(n)) {
    const e = n.assignedNodes();
    if (e != null && e.length)
      return e;
  }
  return n.childNodes;
}
function* JA(n) {
  for (const e of KB(n))
    ace(e) && (yield e);
}
function o_(n) {
  var e;
  return ((e = n.ownerDocument) == null ? void 0 : e.defaultView) ?? globalThis;
}
function ace(n) {
  return n instanceof o_(n).Element;
}
function lce(n) {
  return n instanceof o_(n).ShadowRoot;
}
function cce(n) {
  return "getRootNode" in n && lce(n.getRootNode());
}
function uce(n) {
  return cce(n) && n instanceof o_(n).HTMLSlotElement;
}
function dce(n) {
  return n.style;
}
function YO(n, e) {
  return o_(n).getComputedStyle(n, e);
}
const Xp = {};
class fce {
  constructor(e) {
    U(this, "styles", /* @__PURE__ */ new Map());
    U(this, "fonts", new qO());
    this.root = e;
  }
  readRootElementStyles(e) {
    this.readElementStyles(e, {
      shouldRespectDefaults: !1,
      shouldSkipInheritedParentStyles: !1
    });
    const t = Array.from(JA(e));
    for (; t.length; ) {
      const r = t.pop();
      t.push(...JA(r)), this.readElementStyles(r, {
        shouldRespectDefaults: !0,
        shouldSkipInheritedParentStyles: !0
      });
    }
  }
  readElementStyles(e, { shouldRespectDefaults: t = !0, shouldSkipInheritedParentStyles: r = !0 }) {
    var c;
    const i = t ? mce(e.tagName.toLowerCase()) : Xp, s = r ? ((c = this.styles.get(e.parentElement)) == null ? void 0 : c.self) ?? Xp : Xp, l = {
      self: hce(e, { defaultStyles: i, parentStyles: s }),
      before: V4(e, "::before"),
      after: V4(e, "::after")
    };
    this.styles.set(e, l);
  }
  fetchResources() {
    const e = [];
    for (const t of this.styles.values())
      for (const r of Xr(t))
        if (r)
          for (const [i, s] of Object.entries(r)) {
            if (!s) continue;
            i === "font-family" && this.fonts.onFontFamilyValue(s);
            const l = Xle(s);
            l.length !== 0 && e.push(
              ...l.map(async ({ url: c, original: d }) => {
                const h = await r_(c) ?? "data:";
                r[i] = s.replace(d, `url("${h}")`);
              })
            );
          }
    return Promise.all(e);
  }
  // custom elements are tricky. if we serialize the dom as-is, the custom elements wont have
  // their shadow-dom contents serialized. after we've read all the styles, we need to unwrap the
  // contents of each custom elements shadow dom directly into the parent element itself.
  unwrapCustomElements() {
    const e = /* @__PURE__ */ new Set(), t = (r, i) => {
      if (e.has(r)) return;
      e.add(r);
      const s = r.shadowRoot;
      if (s) {
        const l = document.createElement("div");
        this.styles.set(l, this.styles.get(r)), l.setAttribute("data-tl-custom-element", r.tagName), (i ?? r.parentElement).appendChild(l);
        for (const c of s.childNodes)
          c instanceof Element ? t(c, l) : l.appendChild(c.cloneNode(!0));
        r.remove();
      } else if (i) {
        if (r.tagName.toLowerCase() === "style")
          return;
        const l = r.cloneNode(!1);
        this.styles.set(l, this.styles.get(r)), i.appendChild(l);
        for (const c of KB(r))
          c instanceof Element ? t(c, l) : l.appendChild(c.cloneNode(!0));
      }
    };
    for (const r of this.styles.keys())
      t(r, null);
  }
  embedStyles() {
    let e = "";
    for (const [t, r] of this.styles) {
      if (r.after || r.before) {
        const s = `pseudo-${or()}`;
        t.classList.add(s), r.before && (e += `.${s}::before {${K4(r.before)}}
`), r.after && (e += `.${s}::after {${K4(r.after)}}
`);
      }
      const i = dce(t);
      for (const [s, l] of Object.entries(r.self))
        l && i.setProperty(s, l);
      i.fontKerning === "auto" && (i.fontKerning = "normal");
    }
    return e;
  }
  async getFontFaceCss() {
    return await this.fonts.createCss();
  }
  dispose() {
    gce();
  }
}
function hce(n, { defaultStyles: e, parentStyles: t }) {
  return n.computedStyleMap ? WB(n.computedStyleMap(), { defaultStyles: e, parentStyles: t }) : XO(YO(n), { defaultStyles: e, parentStyles: t });
}
function V4(n, e) {
  const t = YO(n, e), r = t.getPropertyValue("content");
  if (!(r === "" || r === "none"))
    return XO(t, { defaultStyles: Xp, parentStyles: Xp });
}
function WB(n, { defaultStyles: e, parentStyles: t }) {
  const r = {};
  for (const i of n.keys()) {
    if (!NB(i)) continue;
    const s = n.get(i).toString();
    e[i] !== s && (t[i] === s && FB(i) || (r[i] = s));
  }
  return r;
}
function XO(n, { defaultStyles: e, parentStyles: t }) {
  const r = {};
  for (const i of n) {
    if (!NB(i)) continue;
    const s = n.getPropertyValue(i);
    e[i] !== s && (t[i] === s && FB(i) || (r[i] = s));
  }
  return r;
}
function K4(n) {
  let e = "";
  for (const [t, r] of Object.entries(n))
    e += `${t}: ${r};`;
  return e;
}
let Py;
const W4 = {};
function pce() {
  if (!Py) {
    const n = document.createElement("iframe");
    n.style.display = "none", document.body.appendChild(n);
    const e = Sa(n.contentDocument, "frame must have a document"), t = document.createElementNS("http://www.w3.org/2000/svg", "svg"), r = document.createElementNS("http://www.w3.org/2000/svg", "foreignObject");
    t.appendChild(r), e.body.appendChild(t), Py = { iframe: n, foreignObject: r, document: e };
  }
  return Py;
}
function gce() {
  Py && (document.body.removeChild(Py.iframe), Py = void 0);
}
const G4 = { defaultStyles: Xp, parentStyles: Xp };
function mce(n) {
  let e = W4[n];
  if (!e) {
    const { foreignObject: t, document: r } = pce(), i = r.createElement(n);
    t.appendChild(i), e = i.computedStyleMap ? WB(i.computedStyleMap(), G4) : XO(YO(i), G4), t.removeChild(i), W4[n] = e;
  }
  return e;
}
function yce(n, e) {
  Array.from(n.attributes).forEach((r) => {
    e.setAttribute(r.name, r.value);
  });
}
function q4(n, e) {
  return n.replaceWith(e), e;
}
async function Ox(n, e) {
  const t = document.createElement("img");
  e && yce(e, t), t.setAttribute("src", n ?? "data:"), t.setAttribute("decoding", "sync"), t.setAttribute("loading", "eager");
  try {
    await t.decode();
  } catch {
  }
  return t;
}
async function vce(n) {
  try {
    const e = n.toDataURL();
    return await Ox(e, n);
  } catch {
    return await Ox(null, n);
  }
}
async function Sce(n) {
  try {
    const e = await Ya.getVideoFrameAsDataUrl(n);
    return Ox(e, n);
  } catch (e) {
    console.error("Could not get video frame", e);
  }
  if (n.poster) {
    const e = await r_(n.poster);
    return Ox(e, n);
  }
  return Ox(null, n);
}
async function GB(n) {
  if (n instanceof HTMLCanvasElement)
    return q4(n, await vce(n));
  if (n instanceof HTMLVideoElement)
    return q4(n, await Sce(n));
  if (n instanceof HTMLImageElement) {
    const e = n.currentSrc || n.src, t = await r_(e);
    n.setAttribute("src", t ?? "data:"), n.setAttribute("decoding", "sync"), n.setAttribute("loading", "eager");
    try {
      await n.decode();
    } catch {
    }
    return n;
  } else n instanceof HTMLInputElement ? n.setAttribute("value", n.value) : n instanceof HTMLTextAreaElement && (n.textContent = n.value);
  await Promise.all(
    Array.from(JA(n), (e) => GB(e))
  );
}
function s_(n) {
  const e = M.useRef();
  return M.useLayoutEffect(() => {
    e.current = n;
  }), M.useDebugValue(n), M.useCallback((...t) => {
    const r = e.current;
    return on(r, "fn does not exist"), r(...t);
  }, []);
}
function xce(n) {
  const e = uw("useReactiveEvent", () => n);
  return M.useLayoutEffect(() => {
    e.set(n);
  }), M.useDebugValue(n), M.useCallback(
    (...t) => {
      const r = e.get();
      return on(r, "fn does not exist"), r(...t);
    },
    [e]
  );
}
const ZO = M.createContext(null);
function wce({
  context: n,
  editor: e,
  children: t
}) {
  const r = e.options.exportProvider;
  return /* @__PURE__ */ m.jsx(AO, { editor: e, children: /* @__PURE__ */ m.jsx(Q8, { container: e.getContainer(), children: /* @__PURE__ */ m.jsx(ZO.Provider, { value: n, children: /* @__PURE__ */ m.jsx(r, { children: t }) }) }) });
}
function bw() {
  return M.useContext(ZO);
}
function bce() {
  const n = M.useContext(ZO), [e] = M.useState(WD);
  return M.useEffect(() => (n == null || n.waitUntil(e), () => {
    e.resolve();
  }), [e, n]), s_(() => {
    e.resolve();
  });
}
var Cce = Object.create, qB = Object.defineProperty, Ece = Object.getOwnPropertyDescriptor, _ce = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), YB = (n) => {
  throw TypeError(n);
}, XB = (n, e, t) => e in n ? qB(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Pce = (n) => [, , , Cce(null)], ZB = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], QB = (n) => n !== void 0 && typeof n != "function" ? YB("Function expected") : n, Tce = (n, e, t, r, i) => ({ kind: ZB[n], name: e, metadata: r, addInitializer: (s) => t._ ? YB("Already initialized") : i.push(QB(s || null)) }), Ice = (n, e) => XB(e, _ce("metadata"), n[3]), kce = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Rce = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = ZB[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Ece(i, t)), I = r.length - 1; I >= 0; I--)
    d = Tce(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, QB(l) && (P[C] = l);
  return P && qB(i, t, P), i;
}, Y4 = (n, e, t) => XB(n, typeof e != "symbol" ? e + "" : e, t), JB, a_;
JB = [Ca];
class QO {
  constructor(e) {
    this.maxDelayTimeMs = e, kce(a_, 5, this), Y4(this, "isResolved", !1), Y4(this, "promisesToWaitFor", []);
  }
  waitUntil(e) {
    if (this.isResolved)
      throw new Error(
        "Cannot `waitUntil` - the export has already been resolved. Make sure to call `waitUntil` as soon as possible during an export - ie within the first react effect after rendering."
      );
    this.promisesToWaitFor.push(
      e.catch((t) => console.error("Error whilst waiting for export:", t))
    );
  }
  async resolvePromises() {
    let e = null;
    for (; this.promisesToWaitFor.length !== e; )
      e = this.promisesToWaitFor.length, await Promise.allSettled(this.promisesToWaitFor), await MA(0);
  }
  async resolve() {
    const e = MA(this.maxDelayTimeMs).then(() => "timeout"), t = this.resolvePromises().then(() => "resolved");
    await Promise.race([e, t]) === "timeout" && console.warn("[tldraw] Export delay timed out after ${this.maxDelayTimeMs}ms"), this.isResolved = !0;
  }
}
a_ = Pce();
Rce(a_, 1, "waitUntil", JB, QO);
Ice(a_, QO);
function Mce(n, e, t = {}) {
  var I, k;
  if (!window.document) throw Error("No document");
  const {
    scale: r = 1,
    // should we include the background in the export? or is it transparent?
    background: i = !1,
    padding: s = n.options.defaultSvgPadding,
    preserveAspectRatio: l
  } = t, c = t.darkMode ?? n.user.getIsDarkMode(), d = n.getShapeAndDescendantIds(e), h = n.getUnorderedRenderingShapes(!1).filter(({ id: L }) => d.has(L));
  let g = null;
  if (t.bounds)
    g = t.bounds;
  else
    for (const { id: L } of h) {
      const O = n.getShapeMaskedPageBounds(L);
      O && (g ? g.union(O) : g = O.clone());
    }
  if (!g) return;
  const y = e.length === 1 && n.isShapeOfType(n.getShape(e[0]), "frame") ? e[0] : null;
  y || g.expandBy(s);
  const v = g.width * r, w = g.height * r;
  try {
    (k = (I = document.body).focus) == null || k.call(I);
  } catch {
  }
  const C = new QO(n.options.maxExportDelayMs), E = WD();
  return C.waitUntil(E), { jsx: /* @__PURE__ */ m.jsx(
    Ace,
    {
      editor: n,
      preserveAspectRatio: l,
      scale: r,
      bbox: g,
      background: i,
      singleFrameShapeId: y,
      isDarkMode: c,
      renderingShapes: h,
      onMount: E.resolve,
      waitUntil: C.waitUntil
    }
  ), width: v, height: w, exportDelay: C };
}
function Ace({
  editor: n,
  preserveAspectRatio: e,
  scale: t,
  bbox: r,
  background: i,
  singleFrameShapeId: s,
  isDarkMode: l,
  renderingShapes: c,
  onMount: d,
  waitUntil: h
}) {
  const g = Vy(), y = Wd({ isDarkMode: l }), v = uw("export state", { defsById: {}, shapeElements: null }), { defsById: w, shapeElements: C } = Pe(v), E = s_((k) => {
    v.update((L) => {
      if (xc(L.defsById, k.key)) return L;
      const O = Promise.resolve(k.getElement());
      return h(
        O.then((z) => {
          v.update((F) => ({
            ...F,
            defsById: { ...F.defsById, [k.key]: { pending: !1, element: z } }
          }));
        })
      ), {
        ...L,
        defsById: { ...L.defsById, [k.key]: { pending: !0, element: O } }
      };
    });
  }), P = M.useMemo(
    () => ({
      isDarkMode: l,
      waitUntil: h,
      addExportDef: E
    }),
    [l, h, E]
  ), I = M.useRef(!1);
  return M.useLayoutEffect(() => {
    if (I.current)
      throw new Error("SvgExport should only render once - do not use with react strict mode");
    I.current = !0, (async () => {
      const k = {}, L = c.map(
        async ({ id: z, opacity: F, index: H, backgroundIndex: V }) => {
          var ie, W;
          if (z === s) return [];
          const re = n.getShape(z);
          if (n.isShapeOfType(re, "group")) return [];
          const q = [], J = n.getShapeUtil(re);
          if (J.toSvg || J.toBackgroundSvg) {
            const [Y, oe] = await Promise.all([
              (ie = J.toSvg) == null ? void 0 : ie.call(J, re, P),
              (W = J.toBackgroundSvg) == null ? void 0 : W.call(J, re, P)
            ]), le = n.getShapePageTransform(re);
            let ce = le.toCssString(), Q = 1;
            "scale" in re.props && re.props.scale !== 1 && (Q = re.props.scale, ce = `${ce} scale(${re.props.scale}, ${re.props.scale})`);
            const he = n.getShapeMask(re.id), ke = he ? qe.From(qe.Inverse(le)).applyToPoints(he) : null, te = RO(g, re.id);
            ke && (k[te] = {
              pending: !1,
              element: /* @__PURE__ */ m.jsx("clipPath", { id: te, children: /* @__PURE__ */ m.jsx(
                "path",
                {
                  d: `M${ke.map(({ x: me, y: Oe }) => `${me / Q},${Oe / Q}`).join("L")}Z`
                }
              ) })
            }), Y && q.push({
              zIndex: H,
              element: /* @__PURE__ */ m.jsx(
                "g",
                {
                  transform: ce,
                  opacity: F,
                  clipPath: he ? `url(#${te})` : void 0,
                  children: Y
                },
                `fg_${re.id}`
              )
            }), oe && q.push({
              zIndex: V,
              element: /* @__PURE__ */ m.jsx(
                "g",
                {
                  transform: ce,
                  opacity: F,
                  clipPath: he ? `url(#${te})` : void 0,
                  children: oe
                },
                `bg_${re.id}`
              )
            });
          } else
            q.push({
              zIndex: H,
              element: /* @__PURE__ */ m.jsx(
                X4,
                {
                  shape: re,
                  util: J,
                  component: dB,
                  className: "tl-shape",
                  bbox: r,
                  opacity: F
                },
                `fg_${re.id}`
              )
            }), J.backgroundComponent && q.push({
              zIndex: V,
              element: /* @__PURE__ */ m.jsx(
                X4,
                {
                  shape: re,
                  util: J,
                  component: fB,
                  className: "tl-shape tl-shape-background",
                  bbox: r,
                  opacity: F
                },
                `bg_${re.id}`
              )
            });
          return q;
        }
      ), O = (await Promise.all(L)).flat();
      Gy.flushSync(() => {
        v.update((z) => ({
          ...z,
          shapeElements: O.sort((F, H) => F.zIndex - H.zIndex).map(({ element: F }) => F),
          defsById: { ...z.defsById, ...k }
        }));
      });
    })();
  }, [r, n, P, g, c, s, v]), M.useEffect(() => {
    C !== null && d();
  }, [d, C]), /* @__PURE__ */ m.jsx(wce, { editor: n, context: P, children: /* @__PURE__ */ m.jsxs(
    "svg",
    {
      preserveAspectRatio: e,
      direction: "ltr",
      width: r.width * t,
      height: r.height * t,
      viewBox: `${r.minX} ${r.minY} ${r.width} ${r.height}`,
      strokeLinecap: "round",
      strokeLinejoin: "round",
      style: {
        backgroundColor: i ? s ? y.solid : y.background : "transparent"
      },
      "data-color-mode": l ? "dark" : "light",
      className: `tl-container tl-theme__force-sRGB ${l ? "tl-theme__dark" : "tl-theme__light"}`,
      children: [
        /* @__PURE__ */ m.jsx("defs", { children: Object.entries(w).map(
          ([k, L]) => L.pending ? null : /* @__PURE__ */ m.jsx(M.Fragment, { children: L.element }, k)
        ) }),
        C
      ]
    }
  ) });
}
function X4({
  shape: n,
  util: e,
  className: t,
  component: r,
  bbox: i,
  opacity: s
}) {
  const l = be(), c = qe.Translate(-i.minX, -i.minY).multiply(
    l.getShapePageTransform(n.id)
  ), d = l.getShapeGeometry(n.id).bounds, h = Math.max(d.width, 1), g = Math.max(d.height, 1);
  return /* @__PURE__ */ m.jsx(kO, { fallback: () => null, children: /* @__PURE__ */ m.jsx(
    "foreignObject",
    {
      x: i.minX,
      y: i.minY,
      width: i.w,
      height: i.h,
      className: "tl-shape-foreign-object",
      children: /* @__PURE__ */ m.jsx(
        "div",
        {
          className: t,
          "data-shape-type": n.type,
          style: {
            clipPath: l.getShapeClipPath(n.id),
            transform: c.toCssString(),
            width: h,
            height: g,
            opacity: s
          },
          children: /* @__PURE__ */ m.jsx(r, { shape: n, util: e })
        }
      )
    }
  ) });
}
let Dce = 1;
async function Oce(n, e, t = {}) {
  const r = Mce(n, e, t);
  if (!r) return;
  const i = n.getContainer(), s = document.createElement("div");
  s.className = "tldraw-svg-export", s.inert = !0, s.tabIndex = -1, Object.assign(s.style, {
    position: "absolute",
    top: "0px",
    left: "0px",
    width: r.width + "px",
    height: r.height + "px",
    pointerEvents: "none",
    opacity: 0
  }), i.appendChild(s);
  const l = L$.createRoot(s, { identifierPrefix: `export_${Dce++}_` });
  try {
    await Promise.resolve(), Gy.flushSync(() => {
      l.render(r.jsx);
    }), await r.exportDelay.resolve();
    const c = s.firstElementChild;
    return on(c instanceof SVGSVGElement, "Expected an SVG element"), await jce(c), { svg: c, width: r.width, height: r.height };
  } finally {
    setTimeout(() => {
      l.unmount(), i.removeChild(s);
    }, 0);
  }
}
async function jce(n) {
  const e = [
    ...n.querySelectorAll("foreignObject.tl-shape-foreign-object > *")
  ];
  if (!e.length) return;
  const t = new fce(n);
  try {
    t.fonts.startFindingCurrentDocumentFontFaces(), await Promise.all(e.map((s) => GB(s)));
    for (const s of e)
      t.readRootElementStyles(s);
    await t.fetchResources();
    const r = await t.getFontFaceCss();
    t.unwrapCustomElements();
    const i = t.embedStyles();
    if (r || i) {
      const s = document.createElementNS("http://www.w3.org/2000/svg", "style");
      s.textContent = `${r}
${i}`, n.prepend(s);
    }
  } finally {
    t.dispose();
  }
}
const gc = {
  /**
   * A set of strings representing any open menus. When menus are open,
   * certain interactions will behave differently; for example, when a
   * draw tool is selected and a menu is open, a pointer-down will not
   * create a dot (because the user is probably trying to close the menu)
   * however a pointer-down event followed by a drag will begin drawing
   * a line (because the user is BOTH trying to close the menu AND start
   * drawing a line).
   *
   * @public
   */
  menus: mi("open menus", []),
  /**
   * Get the current open menus.
   *
   * @param contextId - An optional context to get menus for.
   *
   * @public
   */
  getOpenMenus(n) {
    return n ? this.menus.get().filter((e) => e.endsWith("-" + n)) : this.menus.get();
  },
  /**
   * Add an open menu.
   *
   * @example
   * ```ts
   * addOpenMenu('menu-id')
   * addOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to add.
   * @param contextId - An optional context to add the menu to.
   *
   * @public
   */
  addOpenMenu(n, e = "") {
    const t = e ? `${n}-${e}` : n, r = new Set(this.menus.get());
    r.has(t) || (r.add(t), this.menus.set([...r]));
  },
  /**
   * Delete an open menu.
   *
   * @example
   * ```ts
   * deleteOpenMenu('menu-id')
   * deleteOpenMenu('menu-id', myEditorId)
   * ```
   *
   * @param id - The id of the menu to delete.
   * @param contextId - An optional context to delete the menu from.
   *
   * @public
   */
  deleteOpenMenu(n, e = "") {
    const t = e ? `${n}-${e}` : n, r = new Set(this.menus.get());
    r.has(t) && (r.delete(t), this.menus.set([...r]));
  },
  /**
   * Clear all open menus.
   *
   * @example
   * ```ts
   * clearOpenMenus()
   * clearOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to clear menus for.
   *
   * @public
   */
  clearOpenMenus(n) {
    this.menus.set(n ? this.menus.get().filter((e) => !e.endsWith("-" + n)) : []);
  },
  _hiddenMenus: [],
  /**
   * Hide all open menus. Restore them with the `showOpenMenus` method.
   *
   * @example
   * ```ts
   * hideOpenMenus()
   * hideOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to hide menus for.
   *
   * @public
   */
  hideOpenMenus(n) {
    if (this._hiddenMenus = [...this.getOpenMenus(n)], this._hiddenMenus.length !== 0)
      for (const e of this._hiddenMenus)
        this.deleteOpenMenu(e, n);
  },
  /**
   * Show all hidden menus.
   *
   * @example
   * ```ts
   * showOpenMenus()
   * showOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - An optional context to show menus for.
   *
   * @public
   */
  showOpenMenus(n) {
    if (this._hiddenMenus.length !== 0) {
      for (const e of this._hiddenMenus)
        this.addOpenMenu(e, n);
      this._hiddenMenus = [];
    }
  },
  /**
   * Get whether a menu is open for a given context.
   *
   * @example
   * ```ts
   * isMenuOpem(id, myEditorId)
   * ```
   *
   * @param id - The id of the menu to check.
   * @param contextId - An optional context to check menus for.
   *
   * @public
   */
  isMenuOpen(n, e) {
    return this.getOpenMenus(e).includes(n);
  },
  /**
   * Get whether any menus are open for a given context.
   *
   * @example
   * ```ts
   * hasOpenMenus(myEditorId)
   * ```
   *
   * @param contextId - A context to check menus for.
   *
   * @public
   */
  hasOpenMenus(n) {
    return this.getOpenMenus(n).length > 0;
  },
  /**
   * Get whether any menus are open for any context.
   *
   * @example
   * ```ts
   * hasAnyOpenMenus()
   * ```
   *
   * @public
   */
  hasAnyOpenMenus() {
    return this.getOpenMenus().length > 0;
  },
  forContext(n) {
    return {
      getOpenMenus: () => this.getOpenMenus(n),
      addOpenMenu: (e) => this.addOpenMenu(e, n),
      deleteOpenMenu: (e) => this.deleteOpenMenu(e, n),
      clearOpenMenus: () => this.clearOpenMenus(n),
      // Gets whether any menus are open
      isMenuOpen: (e) => this.isMenuOpen(e, n),
      hasOpenMenus: () => this.hasOpenMenus(n),
      hasAnyOpenMenus: () => this.hasAnyOpenMenus()
    };
  }
}, eD = new vne(), Lce = {
  maxShapesPerPage: 4e3,
  maxFilesAtOnce: 100,
  maxPages: 40,
  animationMediumMs: 320,
  followChaseViewportSnap: 2,
  doubleClickDurationMs: 450,
  multiClickDurationMs: 200,
  coarseDragDistanceSquared: 36,
  // 6 squared
  dragDistanceSquared: 16,
  // 4 squared
  defaultSvgPadding: 32,
  cameraSlideFriction: 0.09,
  maxPointsPerDrawShape: 500,
  gridSteps: [
    { min: -1, mid: 0.15, step: 64 },
    { min: 0.05, mid: 0.375, step: 16 },
    { min: 0.15, mid: 1, step: 4 },
    { min: 0.7, mid: 2.5, step: 1 }
  ],
  collaboratorInactiveTimeoutMs: 6e4,
  collaboratorIdleTimeoutMs: 3e3,
  collaboratorCheckIntervalMs: 1200,
  cameraMovingTimeoutMs: 64,
  hitTestMargin: 8,
  edgeScrollDelay: 200,
  edgeScrollEaseDuration: 200,
  edgeScrollSpeed: 25,
  edgeScrollDistance: 8,
  coarsePointerWidth: 12,
  coarseHandleRadius: 20,
  handleRadius: 12,
  longPressDurationMs: 500,
  textShadowLod: 0.35,
  adjacentShapeMargin: 10,
  flattenImageBoundsExpand: 64,
  flattenImageBoundsPadding: 16,
  laserDelayMs: 1200,
  maxExportDelayMs: 5e3,
  temporaryAssetPreviewLifetimeMs: 18e4,
  actionShortcutsLocation: "swap",
  createTextOnCanvasDoubleClick: !0,
  exportProvider: M.Fragment
};
function Z4(n, e) {
  if (!e) return !1;
  switch (n.type) {
    case "mixed":
      return e.type === "mixed";
    case "shared":
      return e.type === "shared" && n.value === e.value;
    default:
      throw ro(n);
  }
}
class Nce {
  constructor(e) {
    /** @internal */
    U(this, "map");
    this.map = new Map(e);
  }
  get(e) {
    return this.map.get(e);
  }
  getAsKnownValue(e) {
    const t = this.get(e);
    if (t && t.type !== "mixed")
      return t.value;
  }
  // eslint-disable-next-line no-restricted-syntax
  get size() {
    return this.map.size;
  }
  equals(e) {
    if (this.size !== e.size) return !1;
    const t = /* @__PURE__ */ new Set();
    for (const [r, i] of this) {
      if (!Z4(i, e.get(r))) return !1;
      t.add(r);
    }
    for (const [r, i] of e)
      if (!t.has(r) && !Z4(i, this.get(r)))
        return !1;
    return !0;
  }
  keys() {
    return this.map.keys();
  }
  values() {
    return this.map.values();
  }
  entries() {
    return this.map.entries();
  }
  [Symbol.iterator]() {
    return this.map[Symbol.iterator]();
  }
}
class tD extends Nce {
  set(e, t) {
    this.map.set(e, t);
  }
  applyValue(e, t) {
    const r = this.get(e);
    if (!r) {
      this.set(e, { type: "shared", value: t });
      return;
    }
    switch (r.type) {
      case "mixed":
        return;
      case "shared":
        r.value !== t && this.set(e, { type: "mixed" });
        return;
      default:
        ro(r, "type");
    }
  }
}
function Fce(n, e, t) {
  return Eu(n).then(function(r) {
    return r.arrayBuffer();
  }).then(function(r) {
    return new File([r], e, { type: t });
  });
}
const zce = "https://cdn.tldraw.com";
function ch() {
  return `${zce}/${K8}`;
}
function Uce(n) {
  switch (n.type) {
    case "shapes":
      return `s${n.shapeIds.map((t) => MM(t.slice(6))).join(".")}`;
    case "page":
      return "p" + MM(rl.parseId(n.pageId));
    case "viewport": {
      const { bounds: e, pageId: t } = n;
      let r = `v${Math.round(e.x)}.${Math.round(e.y)}.${Math.round(e.w)}.${Math.round(e.h)}`;
      return t && (r += "." + MM(rl.parseId(t))), r;
    }
    default:
      ro(n);
  }
}
function $ce(n) {
  switch (n[0]) {
    case "s":
      return { type: "shapes", shapeIds: n.slice(1).split(".").filter(Boolean).map((r) => Sr(decodeURIComponent(r))) };
    case "p":
      return { type: "page", pageId: rl.createId(decodeURIComponent(n.slice(1))) };
    case "v": {
      const [t, r, i, s, l] = n.slice(1).split(".");
      return {
        type: "viewport",
        bounds: new Xe(Number(t), Number(r), Number(i), Number(s)),
        pageId: l ? rl.createId(decodeURIComponent(l)) : void 0
      };
    }
    default:
      throw Error("Invalid deep link string");
  }
}
function MM(n) {
  return encodeURIComponent(n).replace(/\./g, "%2E");
}
function Bce(n, e) {
  var i;
  let t = n;
  const r = new Set(e);
  for (; r.has(t); )
    t = (i = /^.*(\d+)$/.exec(t)) != null && i[1] ? t.replace(/(\d+)(?=\D?)$/, (s) => (+s + 1).toString()) : `${t} 1`;
  return t;
}
function K1(n, e, t, r) {
  if (t.length === 0) return [];
  const i = /* @__PURE__ */ new Map();
  for (const l of rn(t.map((c) => n.getShape(c)))) {
    const { parentId: c } = l;
    i.has(c) || i.set(c, {
      children: rn(
        n.getSortedChildIdsForParent(c).map((d) => n.getShape(d))
      ),
      moving: /* @__PURE__ */ new Set()
    }), i.get(c).moving.add(l);
  }
  const s = [];
  switch (e) {
    case "toBack": {
      i.forEach(({ moving: l, children: c }) => Hce(l, c, s));
      break;
    }
    case "toFront": {
      i.forEach(({ moving: l, children: c }) => Vce(l, c, s));
      break;
    }
    case "forward": {
      i.forEach(
        ({ moving: l, children: c }) => Kce(n, l, c, s, r)
      );
      break;
    }
    case "backward": {
      i.forEach(
        ({ moving: l, children: c }) => Wce(n, l, c, s, r)
      );
      break;
    }
  }
  return s;
}
function Hce(n, e, t) {
  const r = e.length;
  if (n.size === r) return;
  let i, s;
  for (let l = 0; l < r; l++) {
    const c = e[l];
    if (n.has(c))
      i = c.index, n.delete(c);
    else {
      s = c.index;
      break;
    }
  }
  if (n.size !== 0) {
    const l = My(i, s, n.size);
    t.push(
      ...Array.from(n.values()).sort(gs).map((c, d) => ({ ...c, index: l[d] }))
    );
  }
}
function Vce(n, e, t) {
  const r = e.length;
  if (n.size === r) return;
  let i, s;
  for (let l = r - 1; l > -1; l--) {
    const c = e[l];
    if (n.has(c))
      s = c.index, n.delete(c);
    else {
      i = c.index;
      break;
    }
  }
  if (n.size !== 0) {
    const l = My(i, s, n.size);
    t.push(
      ...Array.from(n.values()).sort(gs).map((c, d) => ({ ...c, index: l[d] }))
    );
  }
}
function Q4(n, e) {
  const t = n.getShapeGeometry(e), r = n.getShapePageTransform(e);
  return !t || !r ? null : r.applyToPoints(t.vertices);
}
function e9(n, e) {
  const t = Array.from(e).map((i) => {
    const s = Q4(n, i);
    return s ? { shape: i, vertices: s } : null;
  }).filter(Boolean);
  return (i) => {
    const s = Q4(n, i);
    return s ? t.some((l) => GO(l.vertices, s)) : !1;
  };
}
function Kce(n, e, t, r, i) {
  var d;
  const s = e9(n, e), l = t.length;
  if (e.size === l) return;
  let c = { name: "skipping" };
  for (let h = 0; h < l; h++) {
    const g = e.has(t[h]);
    switch (c.name) {
      case "skipping": {
        if (!g) continue;
        c = { name: "selecting", selectIndex: h };
        break;
      }
      case "selecting": {
        if (g || !(i != null && i.considerAllShapes) && !s(t[h])) continue;
        const { selectIndex: y } = c;
        My(t[h].index, (d = t[h + 1]) == null ? void 0 : d.index, h - y).forEach(
          (v, w) => {
            const C = t[y + w];
            e.has(C) && r.push({ ...C, index: v });
          }
        ), c = { name: "skipping" };
        break;
      }
    }
  }
}
function Wce(n, e, t, r, i) {
  var d;
  const s = e9(n, e), l = t.length;
  if (e.size === l) return;
  let c = { name: "skipping" };
  for (let h = l - 1; h > -1; h--) {
    const g = e.has(t[h]);
    switch (c.name) {
      case "skipping": {
        if (!g) continue;
        c = { name: "selecting", selectIndex: h };
        break;
      }
      case "selecting": {
        if (g || !(i != null && i.considerAllShapes) && !s(t[h])) continue;
        My((d = t[h - 1]) == null ? void 0 : d.index, t[h].index, c.selectIndex - h).forEach(
          (y, v) => {
            const w = t[h + v + 1];
            e.has(w) && r.push({ ...w, index: y });
          }
        ), c = { name: "skipping" };
        break;
      }
    }
  }
}
function t9({
  editor: n,
  ids: e
}) {
  const t = rn(e.map((l) => n.getShape(l))), r = n.getShapesSharedRotation(e), i = n.getShapesRotatedPageBounds(e);
  if (!i)
    return null;
  const s = i.center.clone().rotWith(i.point, r);
  return {
    pageCenter: s,
    initialCursorAngle: s.angle(n.inputs.originPagePoint),
    initialShapesRotation: r,
    shapeSnapshots: t.map((l) => ({
      shape: l,
      initialPagePoint: n.getShapePageTransform(l.id).point()
    }))
  };
}
function bC({
  delta: n,
  editor: e,
  snapshot: t,
  stage: r,
  centerOverride: i
}) {
  const { pageCenter: s, shapeSnapshots: l } = t;
  e.updateShapes(
    l.map(({ shape: d, initialPagePoint: h }) => {
      const g = va(d.parentId) ? e.getShapePageTransform(d.parentId) : qe.Identity(), y = R.RotWith(h, i ?? s, n), v = qe.applyToPoint(
        // use the current parent transform in case it has moved/resized since the start
        // (e.g. if rotating a shape at the edge of a group)
        qe.Inverse(g),
        y
      ), w = Yp(d.rotation + n);
      return {
        id: d.id,
        type: d.type,
        x: v.x,
        y: v.y,
        rotation: w
      };
    })
  );
  const c = [];
  l.forEach(({ shape: d }) => {
    var v, w, C;
    const h = e.getShape(d.id);
    if (!h) return;
    const g = e.getShapeUtil(d);
    if (r === "start" || r === "one-off") {
      const E = (v = g.onRotateStart) == null ? void 0 : v.call(g, d);
      E && c.push(E);
    }
    const y = (w = g.onRotate) == null ? void 0 : w.call(g, d, h);
    if (y && c.push(y), r === "end" || r === "one-off") {
      const E = (C = g.onRotateEnd) == null ? void 0 : C.call(g, d, h);
      E && c.push(E);
    }
  }), c.length > 0 && e.updateShapes(c);
}
const Gce = (n) => {
  const { store: e } = n, t = e.query.filterHistory("binding"), r = e.query.records("binding");
  function i() {
    const s = r.get(), l = /* @__PURE__ */ new Map();
    for (const c of s) {
      const { fromId: d, toId: h } = c, g = l.get(d);
      g ? g.push(c) : l.set(d, [c]);
      const y = l.get(h);
      y ? y.push(c) : l.set(h, [c]);
    }
    return l;
  }
  return Le("arrowBindingsIndex", (s, l) => {
    if (Gp(s))
      return i();
    const c = s, d = t.getDiffSince(l);
    if (d === Za)
      return i();
    let h;
    function g(w) {
      h ?? (h = new Map(c));
      const C = h.get(w.fromId), E = C == null ? void 0 : C.filter((k) => k.id !== w.id);
      E != null && E.length ? h.set(w.fromId, E) : h.delete(w.fromId);
      const P = h.get(w.toId), I = P == null ? void 0 : P.filter((k) => k.id !== w.id);
      I != null && I.length ? h.set(w.toId, I) : h.delete(w.toId);
    }
    function y(w) {
      h ?? (h = new Map(c));
      let C = h.get(w);
      return C ? C === c.get(w) && (C = C.slice(0), h.set(w, C)) : (C = [], h.set(w, C)), C;
    }
    function v(w) {
      y(w.fromId).push(w), y(w.toId).push(w);
    }
    for (const w of d) {
      for (const C of Xr(w.added))
        v(C);
      for (const [C, E] of Xr(w.updated))
        g(C), v(E);
      for (const C of Xr(w.removed))
        g(C);
    }
    return h ?? c;
  });
};
function qce(n, e, t) {
  const r = n.getShapeMaskedPageBounds(e);
  return r === void 0 ? !0 : !t.includes(r);
}
const Yce = (n) => {
  function e(t) {
    const r = t.getCurrentPageShapeIds(), i = t.getViewportPageBounds(), s = /* @__PURE__ */ new Set();
    return r.forEach((l) => {
      qce(t, l, i) && s.add(l);
    }), s;
  }
  return Le("getCulledShapes", (t) => {
    if (Gp(t))
      return e(n);
    const r = e(n);
    if (t.size !== r.size) return r;
    for (const i of t)
      if (!r.has(i))
        return r;
    return t;
  });
}, Xce = (n) => {
  const e = n.query.ids("shape"), t = n.query.filterHistory("shape");
  function r() {
    const i = {}, s = e.get(), l = Array(s.size);
    return s.forEach((c) => l.push(n.get(c))), l.sort(gs), l.forEach((c) => {
      i[c.parentId] || (i[c.parentId] = []), i[c.parentId].push(c.id);
    }), i;
  }
  return Le(
    "parentsToChildrenWithIndexes",
    (i, s) => {
      if (Gp(i))
        return r();
      const l = t.getDiffSince(s);
      if (l === Za)
        return r();
      if (l.length === 0) return i;
      let c = null;
      const d = (y) => {
        c || (c = { ...i }), c[y] ? c[y] === i[y] && (c[y] = [...c[y]]) : c[y] = [];
      }, h = /* @__PURE__ */ new Set();
      let g;
      for (let y = 0, v = l.length; y < v; y++) {
        g = l[y];
        for (const w of Object.values(g.added))
          vy(w) && (d(w.parentId), c[w.parentId].push(w.id), h.add(c[w.parentId]));
        for (const [w, C] of Object.values(g.updated))
          if (vy(C) && vy(w)) {
            if (w.parentId !== C.parentId)
              d(w.parentId), d(C.parentId), c[w.parentId].splice(c[w.parentId].indexOf(C.id), 1), c[C.parentId].push(C.id), h.add(c[C.parentId]);
            else if (w.index !== C.index) {
              d(C.parentId);
              const E = c[C.parentId].indexOf(C.id);
              c[C.parentId][E] = C.id, h.add(c[C.parentId]);
            }
          }
        for (const w of Object.values(g.removed))
          vy(w) && (d(w.parentId), c[w.parentId].splice(c[w.parentId].indexOf(w.id), 1));
      }
      for (const y of h) {
        const v = rn(y.map((w) => n.get(w)));
        v.sort(gs), y.splice(0, y.length, ...v.map((w) => w.id));
      }
      return c ?? i;
    }
  );
}, AM = (n, e, t) => {
  for (; !ga(t.parentId); ) {
    const r = n.get(t.parentId);
    if (!r) return !1;
    t = r;
  }
  return t.parentId === e;
}, Zce = (n, e) => {
  const t = n.query.ids("shape");
  let r = null;
  function i() {
    const s = e();
    return r = s, new Set(
      [...t.get()].filter((l) => AM(n, s, n.get(l)))
    );
  }
  return Le("_shapeIdsInCurrentPage", (s, l) => {
    if (Gp(s))
      return i();
    const c = e();
    if (c !== r)
      return i();
    const d = n.history.getDiffSince(l);
    if (d === Za)
      return i();
    const h = new yC(
      s
    );
    for (const y of d) {
      for (const v of Object.values(y.added))
        vy(v) && AM(n, c, v) && h.add(v.id);
      for (const [v, w] of Object.values(y.updated))
        vy(w) && (AM(n, c, w) ? h.add(w.id) : h.remove(w.id));
      for (const v of Object.keys(y.removed))
        va(v) && h.remove(v);
    }
    const g = h.get();
    return g ? xx(g.value, g.diff) : s;
  });
};
var Qce = Object.create, n9 = Object.defineProperty, Jce = Object.getOwnPropertyDescriptor, eue = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), r9 = (n) => {
  throw TypeError(n);
}, i9 = (n, e, t) => e in n ? n9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, tue = (n) => [, , , Qce(null)], o9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], s9 = (n) => n !== void 0 && typeof n != "function" ? r9("Function expected") : n, nue = (n, e, t, r, i) => ({ kind: o9[n], name: e, metadata: r, addInitializer: (s) => t._ ? r9("Already initialized") : i.push(s9(s || null)) }), rue = (n, e) => i9(e, eue("metadata"), n[3]), iue = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, a9 = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = o9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Jce(i, t)), I = r.length - 1; I >= 0; I--)
    d = nue(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, s9(l) && (P[C] = l);
  return P && n9(i, t, P), i;
}, ay = (n, e, t) => i9(n, typeof e != "symbol" ? e + "" : e, t), l9, c9, Cw;
const oue = 40;
c9 = [Ca], l9 = [Ca];
class l_ {
  constructor(e) {
    this.editor = e, iue(Cw, 5, this), ay(this, "_clickId", ""), ay(this, "_clickTimeout"), ay(this, "_clickScreenPoint"), ay(this, "_previousScreenPoint"), ay(this, "_clickState", "idle"), ay(this, "lastPointerInfo", {});
  }
  _getClickTimeout(e, t = or()) {
    this._clickId = t, clearTimeout(this._clickTimeout), this._clickTimeout = this.editor.timers.setTimeout(
      () => {
        if (this._clickState === e && this._clickId === t) {
          switch (this._clickState) {
            case "pendingTriple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "double_click",
                phase: "settle"
              });
              break;
            }
            case "pendingQuadruple": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "triple_click",
                phase: "settle"
              });
              break;
            }
            case "pendingOverflow": {
              this.editor.dispatch({
                ...this.lastPointerInfo,
                type: "click",
                name: "quadruple_click",
                phase: "settle"
              });
              break;
            }
          }
          this._clickState = "idle";
        }
      },
      e === "idle" || e === "pendingDouble" ? this.editor.options.doubleClickDurationMs : this.editor.options.multiClickDurationMs
    );
  }
  /**
   * The current click state.
   *
   * @public
   */
  // eslint-disable-next-line no-restricted-syntax
  get clickState() {
    return this._clickState;
  }
  handlePointerEvent(e) {
    switch (e.name) {
      case "pointer_down": {
        if (!this._clickState) return e;
        switch (this._clickScreenPoint = R.From(e.point), this._previousScreenPoint && R.Dist2(this._previousScreenPoint, this._clickScreenPoint) > oue ** 2 && (this._clickState = "idle"), this._previousScreenPoint = this._clickScreenPoint, this.lastPointerInfo = e, this._clickState) {
          case "pendingDouble":
            return this._clickState = "pendingTriple", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "double_click",
              phase: "down"
            };
          case "pendingTriple":
            return this._clickState = "pendingQuadruple", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "triple_click",
              phase: "down"
            };
          case "pendingQuadruple":
            return this._clickState = "pendingOverflow", this._clickTimeout = this._getClickTimeout(this._clickState), {
              ...e,
              type: "click",
              name: "quadruple_click",
              phase: "down"
            };
          case "idle": {
            this._clickState = "pendingDouble";
            break;
          }
          case "pendingOverflow": {
            this._clickState = "overflow";
            break;
          }
        }
        return this._clickTimeout = this._getClickTimeout(this._clickState), e;
      }
      case "pointer_up": {
        if (!this._clickState) return e;
        switch (this._clickScreenPoint = R.From(e.point), this._clickState) {
          case "pendingTriple":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "double_click",
              phase: "up"
            };
          case "pendingQuadruple":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "triple_click",
              phase: "up"
            };
          case "pendingOverflow":
            return {
              ...this.lastPointerInfo,
              type: "click",
              name: "quadruple_click",
              phase: "up"
            };
        }
        return e;
      }
      case "pointer_move":
        return this._clickState !== "idle" && this._clickScreenPoint && R.Dist2(this._clickScreenPoint, this.editor.inputs.currentScreenPoint) > (this.editor.getInstanceState().isCoarsePointer ? this.editor.options.coarseDragDistanceSquared : this.editor.options.dragDistanceSquared) && this.cancelDoubleClickTimeout(), e;
    }
    return e;
  }
  cancelDoubleClickTimeout() {
    this._clickTimeout = clearTimeout(this._clickTimeout), this._clickState = "idle";
  }
}
Cw = tue();
a9(Cw, 1, "_getClickTimeout", c9, l_);
a9(Cw, 1, "cancelDoubleClickTimeout", l9, l_);
rue(Cw, l_);
class sue {
  constructor(e) {
    U(this, "_isEdgeScrolling", !1);
    U(this, "_edgeScrollDuration", -1);
    this.editor = e;
  }
  /**
   * Update the camera position when the mouse is close to the edge of the screen.
   * Run this on every tick when in a state where edge scrolling is enabled.
   *
   * @public
   */
  updateEdgeScrolling(e) {
    const { editor: t } = this, r = this.getEdgeScroll();
    if (r.x === 0 && r.y === 0)
      this._isEdgeScrolling && (this._isEdgeScrolling = !1, this._edgeScrollDuration = 0);
    else if (this._isEdgeScrolling || (this._isEdgeScrolling = !0, this._edgeScrollDuration = 0), this._edgeScrollDuration += e, this._edgeScrollDuration > t.options.edgeScrollDelay) {
      const i = t.options.edgeScrollEaseDuration > 0 ? po.easeInCubic(
        Math.min(
          1,
          this._edgeScrollDuration / (t.options.edgeScrollDelay + t.options.edgeScrollEaseDuration)
        )
      ) : 1;
      this.moveCameraWhenCloseToEdge({
        x: r.x * i,
        y: r.y * i
      });
    }
  }
  /**
   * Helper function to get the scroll proximity factor for a given position.
   * @param position - The mouse position on the axis.
   * @param dimension - The component dimension on the axis.
   * @param isCoarse - Whether the pointer is coarse.
   * @param insetStart - Whether the pointer is inset at the start of the axis.
   * @param insetEnd - Whether the pointer is inset at the end of the axis.
   * @internal
   */
  getEdgeProximityFactors(e, t, r, i, s) {
    const { editor: l } = this, c = l.options.edgeScrollDistance, d = r ? l.options.coarsePointerWidth : 0, h = e - d, g = e + d, y = i ? 0 : c, v = s ? t : t - c;
    return h < y ? Math.min(1, (y - h) / c) : g > v ? -Math.min(1, (g - v) / c) : 0;
  }
  getEdgeScroll() {
    const { editor: e } = this, {
      inputs: {
        currentScreenPoint: { x: t, y: r }
      }
    } = e, i = e.getViewportScreenBounds(), {
      isCoarsePointer: s,
      insets: [l, c, d, h]
    } = e.getInstanceState(), g = this.getEdgeProximityFactors(t, i.w, s, h, c), y = this.getEdgeProximityFactors(r, i.h, s, l, d);
    return {
      x: g,
      y
    };
  }
  /**
   * Moves the camera when the mouse is close to the edge of the screen.
   * @public
   */
  moveCameraWhenCloseToEdge(e) {
    const { editor: t } = this;
    if (!t.inputs.isDragging || t.inputs.isPanning || t.getCameraOptions().isLocked || e.x === 0 && e.y === 0) return;
    const r = t.getViewportScreenBounds(), i = r.w < 1e3 ? 0.612 : 1, s = r.h < 1e3 ? 0.612 : 1, l = t.getZoomLevel(), c = t.user.getEdgeScrollSpeed() * t.options.edgeScrollSpeed, d = c * e.x * i / l, h = c * e.y * s / l, { x: g, y, z: v } = t.getCamera();
    t.setCamera(new R(g + d, y + h, v));
  }
}
class aue {
  constructor(e, t) {
    U(this, "disposeSideEffectListener");
    this.editor = e, this.disposeSideEffectListener = e.sideEffects.registerAfterChangeHandler(
      "instance",
      (i, s) => {
        i.isFocused !== s.isFocused && this.updateContainerClass();
      }
    );
    const r = e.getInstanceState().isFocused;
    t !== r && e.updateInstanceState({ isFocused: !!t }), this.updateContainerClass();
  }
  /**
   * The editor's focus state and the container's focus state
   * are not necessarily always in sync. For that reason we
   * can't rely on the css `:focus` or `:focus-within` selectors to style the
   * editor when it is in focus.
   *
   * For that reason we synchronize the editor's focus state with a
   * special class on the container: tl-container__focused
   */
  updateContainerClass() {
    const e = this.editor.getContainer();
    this.editor.getInstanceState().isFocused ? e.classList.add("tl-container__focused") : e.classList.remove("tl-container__focused");
  }
  focus() {
    this.editor.getContainer().focus();
  }
  blur() {
    this.editor.complete(), this.editor.getContainer().blur();
  }
  dispose() {
    var e;
    (e = this.disposeSideEffectListener) == null || e.call(this);
  }
}
function cx(n) {
  return cue;
}
class lue {
  constructor() {
    U(this, "length", 0);
    U(this, "head", null);
    U(this, "tail", this);
  }
  push(e) {
    return new JO(e, this);
  }
  toArray() {
    return Fd;
  }
  [Symbol.iterator]() {
    return {
      next() {
        return { value: void 0, done: !0 };
      }
    };
  }
}
const cue = new lue();
class JO {
  constructor(e, t) {
    U(this, "length");
    this.head = e, this.tail = t, this.length = t.length + 1;
  }
  push(e) {
    return new JO(e, this);
  }
  toArray() {
    return Array.from(this);
  }
  [Symbol.iterator]() {
    let e = this;
    return {
      next() {
        if (e.length) {
          const t = e.head;
          return e = e.tail, { value: t, done: !1 };
        } else
          return { value: void 0, done: !0 };
      }
    };
  }
}
class uue {
  constructor(e) {
    U(this, "store");
    U(this, "dispose");
    U(this, "state", "recording");
    U(this, "pendingDiff", new fue());
    U(this, "stacks", mi(
      "HistoryManager.stacks",
      {
        undos: cx(),
        redos: cx()
      },
      {
        isEqual: (e, t) => e.undos === t.undos && e.redos === t.redos
      }
    ));
    U(this, "annotateError");
    /** @internal */
    U(this, "_isInBatch", !1);
    this.store = e.store, this.annotateError = e.annotateError ?? $x, this.dispose = this.store.addHistoryInterceptor((t, r) => {
      if (r === "user")
        switch (this.state) {
          case "recording":
            this.pendingDiff.apply(t.changes), this.stacks.update(({ undos: i }) => ({ undos: i, redos: cx() }));
            break;
          case "recordingPreserveRedoStack":
            this.pendingDiff.apply(t.changes);
            break;
          case "paused":
            break;
          default:
            ro(this.state);
        }
    });
  }
  flushPendingDiff() {
    if (this.pendingDiff.isEmpty()) return;
    const e = this.pendingDiff.clear();
    this.stacks.update(({ undos: t, redos: r }) => ({
      undos: t.push({ type: "diff", diff: e }),
      redos: r
    }));
  }
  getNumUndos() {
    return this.stacks.get().undos.length + (this.pendingDiff.isEmpty() ? 0 : 1);
  }
  getNumRedos() {
    return this.stacks.get().redos.length;
  }
  batch(e, t) {
    const r = this.state;
    r !== "paused" && (t != null && t.history) && (this.state = due[t.history]);
    try {
      if (this._isInBatch)
        return Dl(e), this;
      this._isInBatch = !0;
      try {
        Dl(e);
      } catch (i) {
        throw this.annotateError(i), i;
      } finally {
        this._isInBatch = !1;
      }
      return this;
    } finally {
      this.state = r;
    }
  }
  // History
  _undo({ pushToRedoStack: e, toMark: t = void 0 }) {
    var i;
    const r = this.state;
    this.state = "paused";
    try {
      let { undos: s, redos: l } = this.stacks.get();
      const c = this.pendingDiff.clear(), d = b6(c), h = Kx(c);
      e && !d && (l = l.push({ type: "diff", diff: c }));
      let g = !1;
      if (d)
        for (; ((i = s.head) == null ? void 0 : i.type) === "stop"; ) {
          const y = s.head;
          if (s = s.tail, e && (l = l.push(y)), y.id === t) {
            g = !0;
            break;
          }
        }
      if (!g)
        e: for (; s.head; ) {
          const y = s.head;
          switch (s = s.tail, e && (l = l.push(y)), y.type) {
            case "diff":
              Ax(h, [Kx(y.diff)]);
              break;
            case "stop":
              if (!t) break e;
              if (y.id === t) {
                g = !0;
                break e;
              }
              break;
            default:
              ro(y);
          }
        }
      if (!g && t)
        return this;
      this.store.applyDiff(h, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: s, redos: l });
    } finally {
      this.state = r;
    }
    return this;
  }
  undo() {
    return this._undo({ pushToRedoStack: !0 }), this;
  }
  redo() {
    var t;
    const e = this.state;
    this.state = "paused";
    try {
      this.flushPendingDiff();
      let { undos: r, redos: i } = this.stacks.get();
      if (i.length === 0)
        return this;
      for (; ((t = i.head) == null ? void 0 : t.type) === "stop"; )
        r = r.push(i.head), i = i.tail;
      const s = iE();
      for (; i.head; ) {
        const l = i.head;
        if (r = r.push(l), i = i.tail, l.type === "diff")
          Ax(s, [l.diff]);
        else
          break;
      }
      this.store.applyDiff(s, { ignoreEphemeralKeys: !0 }), this.store.ensureStoreIsUsable(), this.stacks.set({ undos: r, redos: i });
    } finally {
      this.state = e;
    }
    return this;
  }
  bail() {
    return this._undo({ pushToRedoStack: !1 }), this;
  }
  bailToMark(e) {
    return this._undo({ pushToRedoStack: !1, toMark: e }), this;
  }
  squashToMark(e) {
    var s;
    let t = this.stacks.get().undos;
    const r = [];
    for (; t.head && !(t.head.type === "stop" && t.head.id === e); )
      t.head.type === "diff" && r.push(t.head.diff), t = t.tail;
    if (!t.head || ((s = t.head) == null ? void 0 : s.id) !== e)
      return console.error("Could not find mark to squash to: ", e), this;
    if (r.length === 0)
      return this;
    const i = iE();
    return Ax(i, r.reverse()), this.stacks.update(({ redos: l }) => ({
      undos: t.push({
        type: "diff",
        diff: i
      }),
      redos: l
    })), this;
  }
  /** @internal */
  _mark(e) {
    Dl(() => {
      this.flushPendingDiff(), this.stacks.update(({ undos: t, redos: r }) => ({ undos: t.push({ type: "stop", id: e }), redos: r }));
    });
  }
  clear() {
    this.stacks.set({ undos: cx(), redos: cx() }), this.pendingDiff.clear();
  }
  /** @internal */
  getMarkIdMatching(e) {
    let t = this.stacks.get().undos;
    for (; t.head; ) {
      if (t.head.type === "stop" && t.head.id.includes(e))
        return t.head.id;
      t = t.tail;
    }
    return null;
  }
  /** @internal */
  debug() {
    const { undos: e, redos: t } = this.stacks.get();
    return {
      undos: e.toArray(),
      redos: t.toArray(),
      pendingDiff: this.pendingDiff.debug(),
      state: this.state
    };
  }
}
const due = {
  record: "recording",
  "record-preserveRedoStack": "recordingPreserveRedoStack",
  ignore: "paused"
  /* Paused */
};
class fue {
  constructor() {
    U(this, "diff", iE());
    U(this, "isEmptyAtom", mi("PendingDiff.isEmpty", !0));
  }
  clear() {
    const e = this.diff;
    return this.diff = iE(), this.isEmptyAtom.set(!0), e;
  }
  isEmpty() {
    return this.isEmptyAtom.get();
  }
  apply(e) {
    Ax(this.diff, [e]), this.isEmptyAtom.set(b6(this.diff));
  }
  debug() {
    return { diff: this.diff, isEmpty: this.isEmpty() };
  }
}
class hue {
  constructor(e) {
    U(this, "scribbleItems", /* @__PURE__ */ new Map());
    U(this, "state", "paused");
    this.editor = e;
  }
  addScribble(e, t = or()) {
    const r = {
      id: t,
      scribble: {
        id: t,
        size: 20,
        color: "accent",
        opacity: 0.8,
        delay: 0,
        points: [],
        shrink: 0.1,
        taper: !0,
        ...e,
        state: "starting"
      },
      timeoutMs: 0,
      delayRemaining: e.delay ?? 0,
      prev: null,
      next: null
    };
    return this.scribbleItems.set(t, r), r;
  }
  reset() {
    this.editor.updateInstanceState({ scribbles: [] }), this.scribbleItems.clear();
  }
  /**
   * Start stopping the scribble. The scribble won't be removed until its last point is cleared.
   *
   * @public
   */
  stop(e) {
    const t = this.scribbleItems.get(e);
    if (!t) throw Error(`Scribble with id ${e} not found`);
    return t.delayRemaining = Math.min(t.delayRemaining, 200), t.scribble.state = "stopping", t;
  }
  /**
   * Set the scribble's next point.
   *
   * @param id - The id of the scribble to add a point to.
   * @param x - The x coordinate of the point.
   * @param y - The y coordinate of the point.
   * @param z - The z coordinate of the point.
   * @public
   */
  addPoint(e, t, r, i = 0.5) {
    const s = this.scribbleItems.get(e);
    if (!s) throw Error(`Scribble with id ${e} not found`);
    const { prev: l } = s, c = { x: t, y: r, z: i };
    return (!l || R.Dist(l, c) >= 1) && (s.next = c), s;
  }
  /**
   * Update on each animation frame.
   *
   * @param elapsed - The number of milliseconds since the last tick.
   * @public
   */
  tick(e) {
    this.scribbleItems.size !== 0 && this.editor.run(() => {
      this.scribbleItems.forEach((t) => {
        if (t.scribble.state === "starting") {
          const { next: d, prev: h } = t;
          d && d !== h && (t.prev = d, t.scribble.points.push(d)), t.scribble.points.length > 8 && (t.scribble.state = "active");
          return;
        }
        t.delayRemaining > 0 && (t.delayRemaining = Math.max(0, t.delayRemaining - e)), t.timeoutMs += e, t.timeoutMs >= 16 && (t.timeoutMs = 0);
        const { delayRemaining: r, timeoutMs: i, prev: s, next: l, scribble: c } = t;
        switch (c.state) {
          case "active": {
            l && l !== s ? (t.prev = l, c.points.push(l), r === 0 && c.points.length > 8 && c.points.shift()) : i === 0 && (c.points.length > 1 ? c.points.shift() : t.delayRemaining = c.delay);
            break;
          }
          case "stopping": {
            if (t.delayRemaining === 0 && i === 0) {
              if (c.points.length === 1) {
                this.scribbleItems.delete(t.id);
                return;
              }
              c.shrink && (c.size = Math.max(1, c.size * (1 - c.shrink))), c.points.shift();
            }
            break;
          }
        }
      }), this.editor.updateInstanceState({
        scribbles: Array.from(this.scribbleItems.values()).map(({ scribble: t }) => ({
          ...t,
          points: [...t.points]
        })).slice(-5)
        // limit to three as a minor sanity check
      });
    });
  }
}
var pue = Object.create, u9 = Object.defineProperty, gue = Object.getOwnPropertyDescriptor, mue = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), d9 = (n) => {
  throw TypeError(n);
}, f9 = (n, e, t) => e in n ? u9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, yue = (n) => [, , , pue(null)], h9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], p9 = (n) => n !== void 0 && typeof n != "function" ? d9("Function expected") : n, vue = (n, e, t, r, i) => ({ kind: h9[n], name: e, metadata: r, addInitializer: (s) => t._ ? d9("Already initialized") : i.push(p9(s || null)) }), Sue = (n, e) => f9(e, mue("metadata"), n[3]), xue = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, c_ = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = h9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, gue(i, t)), I = r.length - 1; I >= 0; I--)
    d = vue(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, p9(l) && (P[C] = l);
  return P && u9(i, t, P), i;
}, wue = (n, e, t) => f9(n, e + "", t), g9, m9, y9, v9, hg;
const Ft = (n) => Math.round(n * 10 ** 8) / 10 ** 8;
function Md(n, e, t, r, i) {
  const s = n.filter(
    (c) => (r === "forward" ? c.startNode.id === e : c.endNode.id === e) && Ft(c.length) === Ft(t) && pc(
      c.breadthIntersection[0],
      c.breadthIntersection[1],
      i[0],
      i[1]
    )
  );
  if (s.length === 0) return [];
  const l = /* @__PURE__ */ new Set();
  return s.forEach((c) => {
    const d = r === "forward" ? c.endNode.id : c.startNode.id;
    if (!l.has(d)) {
      l.add(d);
      const h = Md(
        n,
        d,
        t,
        r,
        pc(
          c.breadthIntersection[0],
          c.breadthIntersection[1],
          i[0],
          i[1]
        )
      );
      s.push(...h);
    }
  }), s;
}
function bue(n) {
  n.sort((e, t) => t.gaps.length - e.gaps.length);
  for (let e = n.length - 1; e > 0; e--) {
    const t = n[e];
    for (let r = e - 1; r >= 0; r--) {
      const i = n[r];
      if (i.direction === t.direction && t.gaps.every(
        (s) => i.gaps.some(
          (l) => Ft(s.startEdge[0].x) === Ft(l.startEdge[0].x) && Ft(s.startEdge[0].y) === Ft(l.startEdge[0].y) && Ft(s.startEdge[1].x) === Ft(l.startEdge[1].x) && Ft(s.startEdge[1].y) === Ft(l.startEdge[1].y)
        ) && i.gaps.some(
          (l) => Ft(s.endEdge[0].x) === Ft(l.endEdge[0].x) && Ft(s.endEdge[0].y) === Ft(l.endEdge[0].y) && Ft(s.endEdge[1].x) === Ft(l.endEdge[1].x) && Ft(s.endEdge[1].y) === Ft(l.endEdge[1].y)
        )
      )) {
        n.splice(e, 1);
        break;
      }
    }
  }
}
v9 = [Le], y9 = [Le], m9 = [Le], g9 = [Le];
class qy {
  constructor(e) {
    this.manager = e, xue(hg, 5, this), wue(this, "editor"), this.editor = e.editor;
  }
  getSnapPointsCache() {
    const { editor: e } = this;
    return e.store.createComputedCache("snapPoints", (t) => {
      const r = e.getShapePageTransform(t.id);
      if (!r) return;
      const s = e.getShapeUtil(t).getBoundsSnapGeometry(t).points ?? e.getShapeGeometry(t).bounds.cornersAndCenter;
      if (!(!r || !s))
        return s.map((l, c) => {
          const { x: d, y: h } = qe.applyToPoint(r, l);
          return { x: d, y: h, id: `${t.id}:${c}` };
        });
    });
  }
  getSnapPoints(e) {
    return this.getSnapPointsCache().get(e) ?? [];
  }
  getSnappablePoints() {
    const e = this.getSnapPointsCache(), t = this.manager.getSnappableShapes(), r = [];
    for (const i of t) {
      const s = e.get(i);
      s && r.push(...s);
    }
    return r;
  }
  getSnappableGapNodes() {
    return Array.from(this.manager.getSnappableShapes(), (e) => ({
      id: e,
      pageBounds: Sa(this.editor.getShapePageBounds(e))
    }));
  }
  getVisibleGaps() {
    const e = [], t = [];
    let r, i;
    const s = this.getSnappableGapNodes().sort((c, d) => c.pageBounds.minX - d.pageBounds.minX);
    for (let c = 0; c < s.length; c++) {
      r = s[c];
      for (let d = c + 1; d < s.length; d++)
        i = s[d], // is there space between the boxes
        r.pageBounds.maxX < i.pageBounds.minX && // and they overlap in the y axis
        lx(
          r.pageBounds.minY,
          r.pageBounds.maxY,
          i.pageBounds.minY,
          i.pageBounds.maxY
        ) && e.push({
          startNode: r,
          endNode: i,
          startEdge: [
            new R(r.pageBounds.maxX, r.pageBounds.minY),
            new R(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new R(i.pageBounds.minX, i.pageBounds.minY),
            new R(i.pageBounds.minX, i.pageBounds.maxY)
          ],
          length: i.pageBounds.minX - r.pageBounds.maxX,
          breadthIntersection: pc(
            r.pageBounds.minY,
            r.pageBounds.maxY,
            i.pageBounds.minY,
            i.pageBounds.maxY
          )
        });
    }
    const l = s.sort((c, d) => c.pageBounds.minY - d.pageBounds.minY);
    for (let c = 0; c < l.length; c++) {
      r = l[c];
      for (let d = c + 1; d < l.length; d++)
        i = l[d], // is there space between the boxes
        r.pageBounds.maxY < i.pageBounds.minY && // do they overlap in the x axis
        lx(
          r.pageBounds.minX,
          r.pageBounds.maxX,
          i.pageBounds.minX,
          i.pageBounds.maxX
        ) && t.push({
          startNode: r,
          endNode: i,
          startEdge: [
            new R(r.pageBounds.minX, r.pageBounds.maxY),
            new R(r.pageBounds.maxX, r.pageBounds.maxY)
          ],
          endEdge: [
            new R(i.pageBounds.minX, i.pageBounds.minY),
            new R(i.pageBounds.maxX, i.pageBounds.minY)
          ],
          length: i.pageBounds.minY - r.pageBounds.maxY,
          breadthIntersection: pc(
            r.pageBounds.minX,
            r.pageBounds.maxX,
            i.pageBounds.minX,
            i.pageBounds.maxX
          )
        });
    }
    return { horizontal: e, vertical: t };
  }
  snapTranslateShapes({
    lockedAxis: e,
    initialSelectionPageBounds: t,
    initialSelectionSnapPoints: r,
    dragDelta: i
  }) {
    var P, I;
    const s = this.manager.getSnapThreshold(), l = this.getSnappablePoints(), c = t.clone().translate(i), d = r.map(
      ({ x: k, y: L }, O) => ({
        id: "selection:" + O,
        x: k + i.x,
        y: L + i.y
      })
    ), h = l, g = [], y = [], v = new R(s, s);
    this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: g,
      nearestSnapsY: y,
      otherNodeSnapPoints: h,
      selectionSnapPoints: d
    }), this.collectGapSnaps({
      selectionPageBounds: c,
      nearestSnapsX: g,
      nearestSnapsY: y,
      minOffset: v
    });
    const w = new R(
      e === "x" ? 0 : ((P = g[0]) == null ? void 0 : P.nudge) ?? 0,
      e === "y" ? 0 : ((I = y[0]) == null ? void 0 : I.nudge) ?? 0
    );
    v.x = 0, v.y = 0, g.length = 0, y.length = 0, d.forEach((k) => {
      k.x += w.x, k.y += w.y;
    }), c.translate(w), this.collectPointSnaps({
      minOffset: v,
      nearestSnapsX: g,
      nearestSnapsY: y,
      otherNodeSnapPoints: h,
      selectionSnapPoints: d
    }), this.collectGapSnaps({
      selectionPageBounds: c,
      nearestSnapsX: g,
      nearestSnapsY: y,
      minOffset: v
    });
    const C = this.getPointSnapLines({
      nearestSnapsX: g,
      nearestSnapsY: y
    }), E = this.getGapSnapLines({
      selectionPageBounds: c,
      nearestSnapsX: g,
      nearestSnapsY: y
    });
    return this.manager.setIndicators([...E, ...C]), { nudge: w };
  }
  snapResizeShapes({
    initialSelectionPageBounds: e,
    dragDelta: t,
    handle: r,
    isAspectRatioLocked: i,
    isResizingFromCenter: s
  }) {
    var H, V;
    const l = this.manager.getSnapThreshold(), {
      box: c,
      scaleX: d,
      scaleY: h
    } = Xe.Resize(
      e,
      r,
      s ? t.x * 2 : t.x,
      s ? t.y * 2 : t.y,
      i
    );
    let g = r;
    d < 0 && (g = Pae(g)), h < 0 && (g = _ae(g)), s && (c.center = e.center);
    const y = g === "top" || g === "bottom", v = g === "left" || g === "right", w = J4(g, c), C = this.getSnappablePoints(), E = [], P = [], I = new R(l, l);
    this.collectPointSnaps({
      minOffset: I,
      nearestSnapsX: E,
      nearestSnapsY: P,
      otherNodeSnapPoints: C,
      selectionSnapPoints: w
    });
    const k = new R(
      y ? 0 : ((H = E[0]) == null ? void 0 : H.nudge) ?? 0,
      v ? 0 : ((V = P[0]) == null ? void 0 : V.nudge) ?? 0
    );
    if (i && Tae(g) && k.len() !== 0) {
      const re = E.length && P.length ? Math.abs(k.x) < Math.abs(k.y) ? "x" : "y" : E.length ? "x" : "y", q = e.aspectRatio;
      re === "x" ? (P.length = 0, k.y = k.x / q, (g === "bottom_left" || g === "top_right") && (k.y = -k.y)) : (E.length = 0, k.x = k.y * q, (g === "bottom_left" || g === "top_right") && (k.x = -k.x));
    }
    const L = R.Add(t, k), { box: O } = Xe.Resize(
      e,
      r,
      s ? L.x * 2 : L.x,
      s ? L.y * 2 : L.y,
      i
    );
    s && (O.center = e.center);
    const z = J4("any", O);
    E.length = 0, P.length = 0, I.x = 0, I.y = 0, this.collectPointSnaps({
      minOffset: I,
      nearestSnapsX: E,
      nearestSnapsY: P,
      otherNodeSnapPoints: C,
      selectionSnapPoints: z
    });
    const F = this.getPointSnapLines({
      nearestSnapsX: E,
      nearestSnapsY: P
    });
    return this.manager.setIndicators([...F]), { nudge: k };
  }
  collectPointSnaps({
    selectionSnapPoints: e,
    otherNodeSnapPoints: t,
    minOffset: r,
    nearestSnapsX: i,
    nearestSnapsY: s
  }) {
    for (const l of e)
      for (const c of t) {
        const d = R.Sub(l, c), h = Math.abs(d.x), g = Math.abs(d.y);
        Ft(h) <= Ft(r.x) && (Ft(h) < Ft(r.x) && (i.length = 0), i.push({
          type: "points",
          points: { thisPoint: l, otherPoint: c },
          nudge: c.x - l.x
        }), r.x = h), Ft(g) <= Ft(r.y) && (Ft(g) < Ft(r.y) && (s.length = 0), s.push({
          type: "points",
          points: { thisPoint: l, otherPoint: c },
          nudge: c.y - l.y
        }), r.y = g);
      }
  }
  collectGapSnaps({
    selectionPageBounds: e,
    minOffset: t,
    nearestSnapsX: r,
    nearestSnapsY: i
  }) {
    const { horizontal: s, vertical: l } = this.getVisibleGaps();
    for (const c of s) {
      if (!lx(
        c.breadthIntersection[0],
        c.breadthIntersection[1],
        e.minY,
        e.maxY
      ))
        continue;
      const h = c.startEdge[0].x + c.length / 2 - e.center.x;
      if (c.length > e.width && Ft(Math.abs(h)) <= Ft(t.x)) {
        Ft(Math.abs(h)) < Ft(t.x) && (r.length = 0), t.x = Math.abs(h);
        const I = {
          type: "gap_center",
          gap: c,
          nudge: h
        }, k = r.find(({ type: O }) => O === "gap_center"), L = k && pc(
          c.breadthIntersection[0],
          c.breadthIntersection[1],
          k.gap.breadthIntersection[0],
          k.gap.breadthIntersection[1]
        );
        k && k.gap.length > c.length && L ? r[r.indexOf(k)] = I : (!k || !L) && r.push(I);
      }
      const y = c.startNode.pageBounds.minX - c.length, v = e.maxX, w = y - v;
      Ft(Math.abs(w)) <= Ft(t.x) && (Ft(Math.abs(w)) < Ft(t.x) && (r.length = 0), t.x = Math.abs(w), r.push({
        type: "gap_duplicate",
        gap: c,
        protrusionDirection: "left",
        nudge: w
      }));
      const C = c.endNode.pageBounds.maxX + c.length, E = e.minX, P = C - E;
      Ft(Math.abs(P)) <= Ft(t.x) && (Ft(Math.abs(P)) < Ft(t.x) && (r.length = 0), t.x = Math.abs(P), r.push({
        type: "gap_duplicate",
        gap: c,
        protrusionDirection: "right",
        nudge: P
      }));
    }
    for (const c of l) {
      if (!lx(
        c.breadthIntersection[0],
        c.breadthIntersection[1],
        e.minX,
        e.maxX
      ))
        continue;
      const h = c.startEdge[0].y + c.length / 2 - e.center.y;
      if (c.length > e.height && Ft(Math.abs(h)) <= Ft(t.y)) {
        Ft(Math.abs(h)) < Ft(t.y) && (i.length = 0), t.y = Math.abs(h);
        const I = {
          type: "gap_center",
          gap: c,
          nudge: h
        }, k = i.find(({ type: O }) => O === "gap_center"), L = k && lx(
          k.gap.breadthIntersection[0],
          k.gap.breadthIntersection[1],
          c.breadthIntersection[0],
          c.breadthIntersection[1]
        );
        k && k.gap.length > c.length && L ? i[i.indexOf(k)] = I : (!k || !L) && i.push(I);
        continue;
      }
      const y = c.startNode.pageBounds.minY - c.length, v = e.maxY, w = y - v;
      Ft(Math.abs(w)) <= Ft(t.y) && (Ft(Math.abs(w)) < Ft(t.y) && (i.length = 0), t.y = Math.abs(w), i.push({
        type: "gap_duplicate",
        gap: c,
        protrusionDirection: "top",
        nudge: w
      }));
      const C = c.endNode.pageBounds.maxY + c.length, E = e.minY, P = C - E;
      Ft(Math.abs(P)) <= Ft(t.y) && (Ft(Math.abs(P)) < Ft(t.y) && (i.length = 0), t.y = Math.abs(P), i.push({
        type: "gap_duplicate",
        gap: c,
        protrusionDirection: "bottom",
        nudge: P
      }));
    }
  }
  getPointSnapLines({
    nearestSnapsX: e,
    nearestSnapsY: t
  }) {
    const r = {}, i = {};
    if (e.length > 0) {
      for (const s of e)
        if (s.type === "points") {
          const l = Ft(s.points.otherPoint.x);
          r[l] || (r[l] = []), r[l].push(s.points);
        }
    }
    if (t.length > 0) {
      for (const s of t)
        if (s.type === "points") {
          const l = Ft(s.points.otherPoint.y);
          i[l] || (i[l] = []), i[l].push(s.points);
        }
    }
    return Object.values(r).concat(Object.values(i)).map((s) => ({
      id: or(),
      type: "points",
      points: GD(
        s.map((l) => R.From(l.otherPoint)).concat(s.map((l) => R.From(l.thisPoint))),
        (l, c) => l.equals(c)
      )
    }));
  }
  getGapSnapLines({
    selectionPageBounds: e,
    nearestSnapsX: t,
    nearestSnapsY: r
  }) {
    const { vertical: i, horizontal: s } = this.getVisibleGaps(), l = {
      top: e.sides[0],
      right: e.sides[1],
      // need bottom and left to be sorted asc, which .sides is not.
      bottom: [e.corners[3], e.corners[2]],
      left: [e.corners[0], e.corners[3]]
    }, c = [];
    if (t.length > 0)
      for (const d of t) {
        if (d.type === "points") continue;
        const {
          gap: { breadthIntersection: h, startEdge: g, startNode: y, endNode: v, length: w, endEdge: C }
        } = d;
        switch (d.type) {
          case "gap_center": {
            const E = (w - e.width) / 2, P = pc(
              h[0],
              h[1],
              e.minY,
              e.maxY
            );
            c.push({
              type: "gaps",
              direction: "horizontal",
              id: or(),
              gaps: [
                ...Md(
                  s,
                  y.id,
                  E,
                  "backward",
                  P
                ),
                {
                  startEdge: g,
                  endEdge: l.left
                },
                {
                  startEdge: l.right,
                  endEdge: C
                },
                ...Md(
                  s,
                  v.id,
                  E,
                  "forward",
                  P
                )
              ]
            });
            break;
          }
          case "gap_duplicate": {
            const E = pc(
              h[0],
              h[1],
              e.minY,
              e.maxY
            );
            c.push({
              type: "gaps",
              direction: "horizontal",
              id: or(),
              gaps: d.protrusionDirection === "left" ? [
                {
                  startEdge: l.right,
                  endEdge: g.map(
                    (P) => P.clone().addXY(-y.pageBounds.width, 0)
                  )
                },
                { startEdge: g, endEdge: C },
                ...Md(
                  s,
                  v.id,
                  w,
                  "forward",
                  E
                )
              ] : [
                ...Md(
                  s,
                  y.id,
                  w,
                  "backward",
                  E
                ),
                { startEdge: g, endEdge: C },
                {
                  startEdge: C.map(
                    (P) => P.clone().addXY(d.gap.endNode.pageBounds.width, 0)
                  ),
                  endEdge: l.left
                }
              ]
            });
            break;
          }
        }
      }
    if (r.length > 0)
      for (const d of r) {
        if (d.type === "points") continue;
        const {
          gap: { breadthIntersection: h, startEdge: g, startNode: y, endNode: v, length: w, endEdge: C }
        } = d;
        switch (d.type) {
          case "gap_center": {
            const E = (w - e.height) / 2, P = pc(
              h[0],
              h[1],
              e.minX,
              e.maxX
            );
            c.push({
              type: "gaps",
              direction: "vertical",
              id: or(),
              gaps: [
                ...Md(
                  i,
                  y.id,
                  E,
                  "backward",
                  P
                ),
                {
                  startEdge: g,
                  endEdge: l.top
                },
                {
                  startEdge: l.bottom,
                  endEdge: C
                },
                ...Md(
                  i,
                  d.gap.endNode.id,
                  E,
                  "forward",
                  P
                )
              ]
            });
            break;
          }
          case "gap_duplicate":
            {
              const E = pc(
                h[0],
                h[1],
                e.minX,
                e.maxX
              );
              c.push({
                type: "gaps",
                direction: "vertical",
                id: or(),
                gaps: d.protrusionDirection === "top" ? [
                  {
                    startEdge: l.bottom,
                    endEdge: g.map(
                      (P) => P.clone().addXY(0, -y.pageBounds.height)
                    )
                  },
                  { startEdge: g, endEdge: C },
                  ...Md(
                    i,
                    v.id,
                    w,
                    "forward",
                    E
                  )
                ] : [
                  ...Md(
                    i,
                    y.id,
                    w,
                    "backward",
                    E
                  ),
                  { startEdge: g, endEdge: C },
                  {
                    startEdge: C.map(
                      (P) => P.clone().addXY(0, v.pageBounds.height)
                    ),
                    endEdge: l.top
                  }
                ]
              });
            }
            break;
        }
      }
    return bue(c), c;
  }
}
hg = yue();
c_(hg, 1, "getSnapPointsCache", v9, qy);
c_(hg, 1, "getSnappablePoints", y9, qy);
c_(hg, 1, "getSnappableGapNodes", m9, qy);
c_(hg, 1, "getVisibleGaps", g9, qy);
Sue(hg, qy);
function J4(n, e) {
  const { minX: t, maxX: r, minY: i, maxY: s } = e, l = [];
  switch (n) {
    case "top":
    case "left":
    case "top_left":
    case "any":
      l.push({
        id: "top_left",
        handle: "top_left",
        x: t,
        y: i
      });
  }
  switch (n) {
    case "top":
    case "right":
    case "top_right":
    case "any":
      l.push({
        id: "top_right",
        handle: "top_right",
        x: r,
        y: i
      });
  }
  switch (n) {
    case "bottom":
    case "right":
    case "bottom_right":
    case "any":
      l.push({
        id: "bottom_right",
        handle: "bottom_right",
        x: r,
        y: s
      });
  }
  switch (n) {
    case "bottom":
    case "left":
    case "bottom_left":
    case "any":
      l.push({
        id: "bottom_left",
        handle: "bottom_left",
        x: t,
        y: s
      });
  }
  return l;
}
var Cue = Object.create, S9 = Object.defineProperty, Eue = Object.getOwnPropertyDescriptor, _ue = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), x9 = (n) => {
  throw TypeError(n);
}, w9 = (n, e, t) => e in n ? S9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Pue = (n) => [, , , Cue(null)], b9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], C9 = (n) => n !== void 0 && typeof n != "function" ? x9("Function expected") : n, Tue = (n, e, t, r, i) => ({ kind: b9[n], name: e, metadata: r, addInitializer: (s) => t._ ? x9("Already initialized") : i.push(C9(s || null)) }), Iue = (n, e) => w9(e, _ue("metadata"), n[3]), kue = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Rue = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = b9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Eue(i, t)), I = r.length - 1; I >= 0; I--)
    d = Tue(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, C9(l) && (P[C] = l);
  return P && S9(i, t, P), i;
}, Mue = (n, e, t) => w9(n, e + "", t), E9, u_;
const Aue = () => null, Due = () => [];
E9 = [Le];
class ej {
  constructor(e) {
    this.manager = e, kue(u_, 5, this), Mue(this, "editor"), this.editor = e.editor;
  }
  getSnapGeometryCache() {
    const { editor: e } = this;
    return e.store.createComputedCache("handle snap geometry", (t) => {
      const r = e.getShapeUtil(t).getHandleSnapGeometry(t), i = r.getSelfSnapOutline ? r.getSelfSnapOutline.bind(r) : Aue, s = r.getSelfSnapPoints ? r.getSelfSnapPoints.bind(r) : Due;
      return {
        outline: r.outline === void 0 ? e.getShapeGeometry(t) : r.outline,
        points: r.points ?? [],
        getSelfSnapOutline: i,
        getSelfSnapPoints: s
      };
    });
  }
  *iterateSnapPointsInPageSpace(e, t) {
    var i, s;
    const r = (i = this.getSnapGeometryCache().get(e)) == null ? void 0 : i.getSelfSnapPoints(t);
    if (r && r.length) {
      const l = Sa(this.editor.getShapePageTransform(e));
      for (const c of r)
        yield l.applyToPoint(c);
    }
    for (const l of this.manager.getSnappableShapes()) {
      if (l === e) continue;
      const c = (s = this.getSnapGeometryCache().get(l)) == null ? void 0 : s.points;
      if (!c || !c.length) continue;
      const d = Sa(this.editor.getShapePageTransform(l));
      for (const h of c)
        yield d.applyToPoint(h);
    }
  }
  *iterateSnapOutlines(e, t) {
    var i, s;
    const r = (i = this.getSnapGeometryCache().get(e)) == null ? void 0 : i.getSelfSnapOutline(t);
    r && (yield { shapeId: e, outline: r });
    for (const l of this.manager.getSnappableShapes()) {
      if (l === e) continue;
      const c = (s = this.getSnapGeometryCache().get(l)) == null ? void 0 : s.outline;
      c && (yield { shapeId: l, outline: c });
    }
  }
  getHandleSnapPosition({
    currentShapeId: e,
    handle: t,
    handleInPageSpace: r
  }) {
    const i = this.manager.getSnapThreshold();
    let s = i, l = null;
    for (const h of this.iterateSnapPointsInPageSpace(e, t))
      R.DistMin(r, h, s) && (s = R.Dist(r, h), l = h);
    if (l) return l;
    let c = i, d = null;
    for (const { shapeId: h, outline: g } of this.iterateSnapOutlines(e, t)) {
      const y = Sa(this.editor.getShapePageTransform(h)), v = this.editor.getPointInShapeSpace(h, r), w = g.nearestPoint(v), C = y.applyToPoint(w);
      R.DistMin(r, C, c) && (c = R.Dist(r, C), d = C);
    }
    return d || null;
  }
  snapHandle({
    currentShapeId: e,
    handle: t
  }) {
    const i = Sa(this.editor.getShapePageTransform(e)).applyToPoint(t), s = this.getHandleSnapPosition({ currentShapeId: e, handle: t, handleInPageSpace: i });
    return s ? (this.manager.setIndicators([
      {
        id: or(),
        type: "points",
        points: [s]
      }
    ]), { nudge: R.Sub(s, i) }) : null;
  }
}
u_ = Pue();
Rue(u_, 1, "getSnapGeometryCache", E9, ej);
Iue(u_, ej);
var Oue = Object.create, _9 = Object.defineProperty, jue = Object.getOwnPropertyDescriptor, Lue = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), P9 = (n) => {
  throw TypeError(n);
}, T9 = (n, e, t) => e in n ? _9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Nue = (n) => [, , , Oue(null)], I9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], k9 = (n) => n !== void 0 && typeof n != "function" ? P9("Function expected") : n, Fue = (n, e, t, r, i) => ({ kind: I9[n], name: e, metadata: r, addInitializer: (s) => t._ ? P9("Already initialized") : i.push(k9(s || null)) }), zue = (n, e) => T9(e, Lue("metadata"), n[3]), Uue = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, tj = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = I9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, jue(i, t)), I = r.length - 1; I >= 0; I--)
    d = Fue(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, k9(l) && (P[C] = l);
  return P && _9(i, t, P), i;
}, DM = (n, e, t) => T9(n, typeof e != "symbol" ? e + "" : e, t), R9, M9, A9, Yy;
A9 = [Le], M9 = [Le], R9 = [Le];
class Ew {
  constructor(e) {
    this.editor = e, Uue(Yy, 5, this), DM(this, "shapeBounds"), DM(this, "handles"), DM(this, "_snapIndicators", mi("snapLines", void 0)), this.shapeBounds = new qy(this), this.handles = new ej(this);
  }
  getIndicators() {
    return this._snapIndicators.get() ?? Fd;
  }
  clearIndicators() {
    this.getIndicators().length && this._snapIndicators.set(void 0);
  }
  setIndicators(e) {
    this._snapIndicators.set(e);
  }
  getSnapThreshold() {
    return 8 / this.editor.getZoomLevel();
  }
  getSnappableShapes() {
    const { editor: e } = this, t = e.getViewportPageBounds(), r = e.getSelectedShapeIds(), i = /* @__PURE__ */ new Set(), s = (l) => {
      if (va(l)) {
        const d = e.getShape(l);
        d && e.isShapeOfType(d, "frame") && i.add(l);
      }
      const c = e.getSortedChildIdsForParent(l);
      for (const d of c) {
        if (r.includes(d)) continue;
        const h = e.getShape(d);
        if (!h || !e.getShapeUtil(h).canSnap(h)) continue;
        const y = e.getShapePageBounds(d);
        if (y && t.includes(y)) {
          if (e.isShapeOfType(h, "group")) {
            s(d);
            continue;
          }
          i.add(d);
        }
      }
    };
    return s(this.getCurrentCommonAncestor() ?? e.getCurrentPageId()), i;
  }
  getCurrentCommonAncestor() {
    return this.editor.findCommonAncestor(this.editor.getSelectedShapes());
  }
}
Yy = Nue();
tj(Yy, 1, "getSnapThreshold", A9, Ew);
tj(Yy, 1, "getSnappableShapes", M9, Ew);
tj(Yy, 1, "getCurrentCommonAncestor", R9, Ew);
zue(Yy, Ew);
const $ue = /\r?\n|\r/g;
function eU(n) {
  return n.replace($ue, `
`).split(`
`).map((e) => e || " ").join(`
`);
}
const Bue = {
  start: "left",
  "start-legacy": "left",
  middle: "center",
  "middle-legacy": "center",
  end: "right",
  "end-legacy": "right"
}, Hue = /\s/;
class Vue {
  constructor(e) {
    U(this, "baseElem");
    this.editor = e, this.baseElem = document.createElement("div"), this.baseElem.classList.add("tl-text"), this.baseElem.classList.add("tl-text-measure"), this.baseElem.tabIndex = -1;
  }
  measureText(e, t) {
    const r = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(r), r.setAttribute("dir", "auto"), r.style.setProperty("unicode-bidi", "plaintext"), r.style.setProperty("font-family", t.fontFamily), r.style.setProperty("font-style", t.fontStyle), r.style.setProperty("font-weight", t.fontWeight), r.style.setProperty("font-size", t.fontSize + "px"), r.style.setProperty("line-height", t.lineHeight * t.fontSize + "px"), r.style.setProperty("max-width", t.maxWidth === null ? null : t.maxWidth + "px"), r.style.setProperty("min-width", t.minWidth === null ? null : t.minWidth + "px"), r.style.setProperty("padding", t.padding), r.style.setProperty(
      "overflow-wrap",
      t.disableOverflowWrapBreaking ? "normal" : "break-word"
    ), r.textContent = eU(e);
    const i = r.scrollWidth, s = r.getBoundingClientRect();
    return r.remove(), {
      x: 0,
      y: 0,
      w: s.width,
      h: s.height,
      scrollWidth: i
    };
  }
  /**
   * Given an html element, measure the position of each span of unbroken
   * word/white-space characters within any text nodes it contains.
   */
  measureElementTextNodeSpans(e, { shouldTruncateToFirstLine: t = !1 } = {}) {
    const r = [], i = e.getBoundingClientRect(), s = -i.left, l = -i.top, c = new Range(), d = e.childNodes[0];
    let h = 0, g = null, y = null, v = 0, w = 0, C = !1;
    for (const E of e.childNodes)
      if (E.nodeType === Node.TEXT_NODE)
        for (const P of E.textContent ?? "") {
          c.setStart(d, h), c.setEnd(d, h + P.length);
          const I = c.getClientRects(), k = I[I.length - 1], L = k.top + l, O = k.left + s, z = k.right + s, F = O < w, H = Hue.test(P);
          if (
            // If we're at a word boundary...
            H !== y || // ...or we're on a different line...
            L !== v || // ...or we're at the start of the text and haven't created a span yet...
            !g
          ) {
            if (g) {
              if (t && L !== v) {
                C = !0;
                break;
              }
              r.push(g);
            }
            g = {
              box: { x: O, y: L, w: k.width, h: k.height },
              text: P
            }, w = O;
          } else
            F && (g.box.x = O), g.box.w = F ? g.box.w + k.width : z - g.box.x, g.text += P;
          P === `
` && (w = 0), y = H, v = L, h += P.length;
        }
    return g && r.push(g), { spans: r, didTruncate: C };
  }
  /**
   * Measure text into individual spans. Spans are created by rendering the
   * text, then dividing it up according to line breaks and word boundaries.
   *
   * It works by having the browser render the text, then measuring the
   * position of each character. You can use this to replicate the text-layout
   * algorithm of the current browser in e.g. an SVG export.
   */
  measureTextSpans(e, t) {
    if (e === "") return [];
    const r = this.baseElem.cloneNode();
    this.editor.getContainer().appendChild(r);
    const i = Math.ceil(t.width - t.padding * 2);
    r.setAttribute("dir", "auto"), r.style.setProperty("unicode-bidi", "plaintext"), r.style.setProperty("width", `${i}px`), r.style.setProperty("height", "min-content"), r.style.setProperty("font-size", `${t.fontSize}px`), r.style.setProperty("font-family", t.fontFamily), r.style.setProperty("font-weight", t.fontWeight), r.style.setProperty("line-height", `${t.lineHeight * t.fontSize}px`), r.style.setProperty("text-align", Bue[t.textAlign]);
    const s = t.overflow === "truncate-ellipsis" || t.overflow === "truncate-clip";
    s && (r.style.setProperty("overflow-wrap", "anywhere"), r.style.setProperty("word-break", "break-all"));
    const l = eU(e);
    r.textContent = l;
    const { spans: c, didTruncate: d } = this.measureElementTextNodeSpans(r, {
      shouldTruncateToFirstLine: s
    });
    if (t.overflow === "truncate-ellipsis" && d) {
      r.textContent = "…";
      const h = Math.ceil(this.measureElementTextNodeSpans(r).spans[0].box.w);
      r.style.setProperty("width", `${i - h}px`), r.textContent = l;
      const g = this.measureElementTextNodeSpans(r, {
        shouldTruncateToFirstLine: !0
      }).spans, y = g[g.length - 1];
      return g.push({
        text: "…",
        box: {
          x: Math.min(y.box.x + y.box.w, t.width - t.padding - h),
          y: y.box.y,
          w: h,
          h: y.box.h
        }
      }), g;
    }
    return r.remove(), c;
  }
}
var Kue = {}, Wue = Object.create, D9 = Object.defineProperty, Gue = Object.getOwnPropertyDescriptor, que = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), O9 = (n) => {
  throw TypeError(n);
}, j9 = (n, e, t) => e in n ? D9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, Yue = (n) => [, , , Wue(null)], L9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], N9 = (n) => n !== void 0 && typeof n != "function" ? O9("Function expected") : n, Xue = (n, e, t, r, i) => ({ kind: L9[n], name: e, metadata: r, addInitializer: (s) => t._ ? O9("Already initialized") : i.push(N9(s || null)) }), Zue = (n, e) => j9(e, que("metadata"), n[3]), Que = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, F9 = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = L9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Gue(i, t)), I = r.length - 1; I >= 0; I--)
    d = Xue(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, N9(l) && (P[C] = l);
  return P && D9(i, t, P), i;
}, W1 = (n, e, t) => j9(n, typeof e != "symbol" ? e + "" : e, t), z9, U9, _w;
const tU = typeof process < "u" && Kue.NODE_ENV === "test" ? (
  // At test time we should use actual raf and not throttle, because throttle was set up to evaluate immediately during tests, which causes stack overflow
  // for the tick manager since it sets up a raf loop.
  function(e) {
    const t = requestAnimationFrame(e);
    return () => cancelAnimationFrame(t);
  }
) : l6;
U9 = [Ca], z9 = [Ca];
class d_ {
  constructor(e) {
    this.editor = e, Que(_w, 5, this), W1(this, "cancelRaf"), W1(this, "isPaused", !0), W1(this, "now", 0), W1(this, "prevPoint", new R()), this.editor.disposables.add(this.dispose), this.start();
  }
  start() {
    var e;
    this.isPaused = !1, (e = this.cancelRaf) == null || e.call(this), this.cancelRaf = tU(this.tick), this.now = Date.now();
  }
  tick() {
    if (this.isPaused)
      return;
    const e = Date.now(), t = e - this.now;
    this.now = e, this.updatePointerVelocity(t), this.editor.emit("frame", t), this.editor.emit("tick", t), this.cancelRaf = tU(this.tick);
  }
  dispose() {
    var e;
    this.isPaused = !0, (e = this.cancelRaf) == null || e.call(this);
  }
  updatePointerVelocity(e) {
    const {
      prevPoint: t,
      editor: {
        inputs: { currentScreenPoint: r, pointerVelocity: i }
      }
    } = this;
    if (e === 0) return;
    const s = R.Sub(r, t);
    this.prevPoint = r.clone();
    const l = s.len(), c = l ? s.div(l) : new R(0, 0), d = i.clone().lrp(c.mul(l / e), 0.5);
    Math.abs(d.x) < 0.01 && (d.x = 0), Math.abs(d.y) < 0.01 && (d.y = 0), i.equals(d) || (this.editor.inputs.pointerVelocity = d);
  }
}
_w = Yue();
F9(_w, 1, "tick", U9, d_);
F9(_w, 1, "dispose", z9, d_);
Zue(_w, d_);
var Jue = Object.create, $9 = Object.defineProperty, ede = Object.getOwnPropertyDescriptor, tde = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), B9 = (n) => {
  throw TypeError(n);
}, H9 = (n, e, t) => e in n ? $9(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, nde = (n) => [, , , Jue(null)], V9 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], K9 = (n) => n !== void 0 && typeof n != "function" ? B9("Function expected") : n, rde = (n, e, t, r, i) => ({ kind: V9[n], name: e, metadata: r, addInitializer: (s) => t._ ? B9("Already initialized") : i.push(K9(s || null)) }), ide = (n, e) => H9(e, tde("metadata"), n[3]), ode = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Nl = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = V9[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, ede(i, t)), I = r.length - 1; I >= 0; I--)
    d = rde(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, K9(l) && (P[C] = l);
  return P && $9(i, t, P), i;
}, nU = (n, e, t) => H9(n, typeof e != "symbol" ? e + "" : e, t), W9, G9, q9, Y9, X9, Z9, Q9, J9, e7, t7, n7, r7, Gs;
r7 = [Le], n7 = [Le], t7 = [Le], e7 = [Le], J9 = [Le], Q9 = [Le], Z9 = [Le], X9 = [Le], Y9 = [Le], q9 = [Le], G9 = [Le], W9 = [Le];
class Ta {
  constructor(e, t) {
    if (this.user = e, this.inferDarkMode = t, ode(Gs, 5, this), nU(this, "systemColorScheme", mi("systemColorScheme", "light")), nU(this, "disposables", /* @__PURE__ */ new Set()), typeof window > "u" || !("matchMedia" in window)) return;
    const r = window.matchMedia("(prefers-color-scheme: dark)");
    r != null && r.matches && this.systemColorScheme.set("dark");
    const i = (s) => {
      s.matches ? this.systemColorScheme.set("dark") : this.systemColorScheme.set("light");
    };
    r == null || r.addEventListener("change", i), this.disposables.add(() => r == null ? void 0 : r.removeEventListener("change", i));
  }
  dispose() {
    this.disposables.forEach((e) => e());
  }
  updateUserPreferences(e) {
    this.user.setUserPreferences({
      ...this.user.userPreferences.get(),
      ...e
    });
  }
  getUserPreferences() {
    return {
      id: this.getId(),
      name: this.getName(),
      locale: this.getLocale(),
      color: this.getColor(),
      animationSpeed: this.getAnimationSpeed(),
      isSnapMode: this.getIsSnapMode(),
      colorScheme: this.user.userPreferences.get().colorScheme,
      isDarkMode: this.getIsDarkMode(),
      isWrapMode: this.getIsWrapMode(),
      isDynamicResizeMode: this.getIsDynamicResizeMode()
    };
  }
  getIsDarkMode() {
    switch (this.user.userPreferences.get().colorScheme) {
      case "dark":
        return !0;
      case "light":
        return !1;
      case "system":
        return this.systemColorScheme.get() === "dark";
      default:
        return this.inferDarkMode ? this.systemColorScheme.get() === "dark" : !1;
    }
  }
  getEdgeScrollSpeed() {
    return this.user.userPreferences.get().edgeScrollSpeed ?? Tl.edgeScrollSpeed;
  }
  getAnimationSpeed() {
    return this.user.userPreferences.get().animationSpeed ?? Tl.animationSpeed;
  }
  getId() {
    return this.user.userPreferences.get().id;
  }
  getName() {
    return this.user.userPreferences.get().name ?? Tl.name;
  }
  getLocale() {
    return this.user.userPreferences.get().locale ?? Tl.locale;
  }
  getColor() {
    return this.user.userPreferences.get().color ?? Tl.color;
  }
  getIsSnapMode() {
    return this.user.userPreferences.get().isSnapMode ?? Tl.isSnapMode;
  }
  getIsWrapMode() {
    return this.user.userPreferences.get().isWrapMode ?? Tl.isWrapMode;
  }
  getIsDynamicResizeMode() {
    return this.user.userPreferences.get().isDynamicSizeMode ?? Tl.isDynamicSizeMode;
  }
  getIsPasteAtCursorMode() {
    return this.user.userPreferences.get().isPasteAtCursorMode ?? Tl.isPasteAtCursorMode;
  }
}
Gs = nde();
Nl(Gs, 1, "getUserPreferences", r7, Ta);
Nl(Gs, 1, "getIsDarkMode", n7, Ta);
Nl(Gs, 1, "getEdgeScrollSpeed", t7, Ta);
Nl(Gs, 1, "getAnimationSpeed", e7, Ta);
Nl(Gs, 1, "getId", J9, Ta);
Nl(Gs, 1, "getName", Q9, Ta);
Nl(Gs, 1, "getLocale", Z9, Ta);
Nl(Gs, 1, "getColor", X9, Ta);
Nl(Gs, 1, "getIsSnapMode", Y9, Ta);
Nl(Gs, 1, "getIsWrapMode", q9, Ta);
Nl(Gs, 1, "getIsDynamicResizeMode", G9, Ta);
Nl(Gs, 1, "getIsPasteAtCursorMode", W9, Ta);
ide(Gs, Ta);
const sde = {
  wheel: "onWheel",
  pointer_down: "onPointerDown",
  pointer_move: "onPointerMove",
  long_press: "onLongPress",
  pointer_up: "onPointerUp",
  right_click: "onRightClick",
  middle_click: "onMiddleClick",
  key_down: "onKeyDown",
  key_up: "onKeyUp",
  key_repeat: "onKeyRepeat",
  cancel: "onCancel",
  complete: "onComplete",
  interrupt: "onInterrupt",
  double_click: "onDoubleClick",
  triple_click: "onTripleClick",
  quadruple_click: "onQuadrupleClick",
  tick: "onTick"
}, ade = [
  "brushing",
  "cropping",
  "dragging",
  "dragging_handle",
  "drawing",
  "erasing",
  "lasering",
  "resizing",
  "rotating",
  "scribble_brushing",
  "translating"
];
class Et {
  constructor(e, t) {
    U(this, "performanceTracker");
    U(this, "id");
    U(this, "type");
    U(this, "shapeType");
    U(this, "initial");
    U(this, "children");
    U(this, "isLockable");
    U(this, "parent");
    U(this, "_path");
    U(this, "_current");
    U(this, "_isActive");
    /**
     * This is a hack / escape hatch that will tell the editor to
     * report a different state as active (in `getCurrentToolId()`) when
     * this state is active. This is usually used when a tool transitions
     * to a child of a different state for a certain interaction and then
     * returns to the original tool when that interaction completes; and
     * where we would want to show the original tool as active in the UI.
     *
     * @public
     */
    U(this, "_currentToolIdMask", mi("curent tool id mask", void 0));
    this.editor = e;
    const { id: r, children: i, initial: s, isLockable: l } = this.constructor;
    this.id = r, this._isActive = mi("toolIsActive" + this.id, !1), this._current = mi("toolState" + this.id, void 0), this._path = Le("toolPath" + this.id, () => {
      const c = this.getCurrent();
      return this.id + (c ? `.${c.getPath()}` : "");
    }), this.parent = t ?? {}, this.parent ? i && s ? (this.type = "branch", this.initial = s, this.children = Object.fromEntries(
      i().map((c) => [c.id, new c(this.editor, this)])
    ), this._current.set(this.children[this.initial])) : this.type = "leaf" : (this.type = "root", i && s && (this.initial = s, this.children = Object.fromEntries(
      i().map((c) => [c.id, new c(this.editor, this)])
    ), this._current.set(this.children[this.initial]))), this.isLockable = l, this.performanceTracker = new z$();
  }
  /**
   * This node's path of active state nodes
   *
   * @public
   */
  getPath() {
    return this._path.get();
  }
  /**
   * This node's current active child node, if any.
   *
   * @public
   */
  getCurrent() {
    return this._current.get();
  }
  /**
   * Whether this node is active.
   *
   * @public
   */
  getIsActive() {
    return this._isActive.get();
  }
  /**
   * Transition to a new active child state node.
   *
   * @example
   * ```ts
   * parentState.transition('childStateA')
   * parentState.transition('childStateB', { myData: 4 })
   *```
   *
   * @param id - The id of the child state node to transition to.
   * @param info - Any data to pass to the `onEnter` and `onExit` handlers.
   *
   * @public
   */
  transition(e, t = {}) {
    var s;
    const r = e.split(".");
    let i = this;
    for (let l = 0; l < r.length; l++) {
      const c = r[l], d = i.getCurrent(), h = (s = i.children) == null ? void 0 : s[c];
      if (!h)
        throw Error(`${i.id} - no child state exists with the id ${c}.`);
      if ((d == null ? void 0 : d.id) !== h.id && (d == null || d.exit(t, c), i._current.set(h), h.enter(t, (d == null ? void 0 : d.id) || "initial"), !h.getIsActive()))
        break;
      i = h;
    }
    return this;
  }
  handleEvent(e) {
    var i;
    const t = sde[e.name], r = this._current.__unsafe__getWithoutCapture();
    (i = this[t]) == null || i.call(this, e), this._isActive.__unsafe__getWithoutCapture() && r && r === this._current.__unsafe__getWithoutCapture() && r.handleEvent(e);
  }
  // todo: move this logic into transition
  enter(e, t) {
    var r;
    if (Ei.measurePerformance.get() && ade.includes(this.id) && this.performanceTracker.start(this.id), this._isActive.set(!0), (r = this.onEnter) == null || r.call(this, e, t), this.children && this.initial && this.getIsActive()) {
      const i = this.children[this.initial];
      this._current.set(i), i.enter(e, t);
    }
  }
  // todo: move this logic into transition
  exit(e, t) {
    var r, i;
    Ei.measurePerformance.get() && this.performanceTracker.isStarted() && this.performanceTracker.stop(), this._isActive.set(!1), (r = this.onExit) == null || r.call(this, e, t), this.getIsActive() || (i = this.getCurrent()) == null || i.exit(e, t);
  }
  getCurrentToolIdMask() {
    return this._currentToolIdMask.get();
  }
  setCurrentToolIdMask(e) {
    this._currentToolIdMask.set(e);
  }
}
U(Et, "id"), U(Et, "initial"), U(Et, "children"), U(Et, "isLockable", !0);
class nD extends Et {
  static children() {
    return [];
  }
  onKeyDown(e) {
    var t;
    switch (e.code) {
      case "KeyZ": {
        if (!(e.shiftKey || e.ctrlKey)) {
          const r = this.getCurrent();
          r && ((t = r.getCurrent()) == null ? void 0 : t.id) === "idle" && this.children.zoom && this.editor.setCurrentTool("zoom", { ...e, onInteractionEnd: r.id });
        }
        break;
      }
    }
  }
}
U(nD, "id", "root"), U(nD, "initial", "");
var lde = Object.create, i7 = Object.defineProperty, cde = Object.getOwnPropertyDescriptor, o7 = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), s7 = (n) => {
  throw TypeError(n);
}, a7 = (n, e, t) => e in n ? i7(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, ude = (n) => [, , , lde((n == null ? void 0 : n[o7("metadata")]) ?? null)], l7 = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], c7 = (n) => n !== void 0 && typeof n != "function" ? s7("Function expected") : n, dde = (n, e, t, r, i) => ({ kind: l7[n], name: e, metadata: r, addInitializer: (s) => t._ ? s7("Already initialized") : i.push(c7(s || null)) }), fde = (n, e) => a7(e, o7("metadata"), n[3]), hde = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, ht = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = l7[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, cde(i, t)), I = r.length - 1; I >= 0; I--)
    d = dde(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, c7(l) && (P[C] = l);
  return P && i7(i, t, P), i;
}, jt = (n, e, t) => a7(n, typeof e != "symbol" ? e + "" : e, t), u7, d7, f7, h7, p7, g7, m7, y7, v7, S7, x7, w7, b7, C7, E7, _7, P7, T7, I7, k7, R7, M7, A7, D7, O7, j7, L7, N7, F7, z7, U7, $7, B7, H7, V7, K7, W7, G7, q7, Y7, X7, Z7, Q7, J7, eH, tH, nH, rH, iH, oH, sH, aH, lH, cH, uH, dH, fH, hH, pH, gH, mH, yH, vH, SH, xH, wH, bH, CH, EH, _H, PH, TH, rD, ct;
class at extends (rD = Ale, TH = [Le], PH = [Le], _H = [Le], EH = [Le], CH = [Le], bH = [Le], wH = [Le], xH = [Le], SH = [Le], vH = [Le], yH = [Le], mH = [Le], gH = [Le], pH = [Le], hH = [Le], fH = [Le], dH = [Le], uH = [Le], cH = [Le], lH = [Le], aH = [Le], sH = [Le], oH = [Le], iH = [Le], rH = [Le], nH = [Le], tH = [Le], eH = [Le], J7 = [Le], Q7 = [Le], Z7 = [Le], X7 = [Le], Y7 = [Le], q7 = [Le], G7 = [Le], W7 = [Le], K7 = [Le], V7 = [Le], H7 = [Le], B7 = [Le], $7 = [Le], U7 = [Le], z7 = [Le], F7 = [Le], N7 = [Le], L7 = [Le], j7 = [Le], O7 = [Le], D7 = [Le], A7 = [Le], M7 = [Le], R7 = [Le], k7 = [Le], I7 = [Le], T7 = [Le], P7 = [Le], _7 = [Le], E7 = [Le], C7 = [Le], b7 = [Le], w7 = [Le], x7 = [Le], S7 = [Le], v7 = [Le], y7 = [Le({ isEqual: (e, t) => e.equals(t) })], m7 = [Le], g7 = [Le], p7 = [Le], h7 = [Ca], f7 = [Ca], d7 = [Ca], u7 = [Ca], rD) {
  constructor({
    store: e,
    user: t,
    shapeUtils: r,
    bindingUtils: i,
    tools: s,
    getContainer: l,
    cameraOptions: c,
    initialState: d,
    autoFocus: h,
    inferDarkMode: g,
    options: y,
    isShapeHidden: v
  }) {
    var re;
    super(), hde(ct, 5, this), jt(this, "_isShapeHiddenPredicate"), jt(this, "options"), jt(this, "contextId", or()), jt(this, "store"), jt(this, "root"), jt(this, "disposables", /* @__PURE__ */ new Set()), jt(this, "isDisposed", !1), jt(this, "_tickManager"), jt(this, "snaps"), jt(this, "timers", eD.forContext(this.contextId)), jt(this, "user"), jt(this, "textMeasure"), jt(this, "environment", Er), jt(this, "scribbles"), jt(this, "sideEffects"), jt(this, "edgeScrollManager"), jt(this, "focusManager"), jt(this, "getContainer"), jt(this, "shapeUtils"), jt(this, "styleProps"), jt(this, "bindingUtils"), jt(this, "history"), jt(this, "_shouldIgnoreShapeLock", !1), jt(this, "_crashingError", null), jt(this, "_isChangingStyleTimeout", -1), jt(this, "menus", gc.forContext(this.contextId)), jt(this, "_cameraOptions", mi("camera options", S4)), jt(this, "_viewportAnimation", null), jt(this, "_willSetInitialBounds", !0), jt(this, "_isLockedOnFollowingUser", mi("isLockedOnFollowingUser", !1)), jt(this, "_cameraState", mi("camera state", "idle")), jt(this, "_cameraStateTimeoutRemaining", 0), jt(this, "_currentPageShapeIds"), jt(this, "_parentIdsToChildIds"), jt(this, "animatingShapes", /* @__PURE__ */ new Map()), jt(this, "externalAssetContentHandlers", {
      file: null,
      url: null
    }), jt(this, "temporaryAssetPreview", /* @__PURE__ */ new Map()), jt(this, "externalContentHandlers", {
      text: null,
      files: null,
      embed: null,
      "svg-text": null,
      url: null
    }), jt(this, "inputs", {
      /** The most recent pointer down's position in the current page space. */
      originPagePoint: new R(),
      /** The most recent pointer down's position in screen space. */
      originScreenPoint: new R(),
      /** The previous pointer position in the current page space. */
      previousPagePoint: new R(),
      /** The previous pointer position in screen space. */
      previousScreenPoint: new R(),
      /** The most recent pointer position in the current page space. */
      currentPagePoint: new R(),
      /** The most recent pointer position in screen space. */
      currentScreenPoint: new R(),
      /** A set containing the currently pressed keys. */
      keys: /* @__PURE__ */ new Set(),
      /** A set containing the currently pressed buttons. */
      buttons: /* @__PURE__ */ new Set(),
      /** Whether the input is from a pe. */
      isPen: !1,
      /** Whether the shift key is currently pressed. */
      shiftKey: !1,
      /** Whether the meta key is currently pressed. */
      metaKey: !1,
      /** Whether the control or command key is currently pressed. */
      ctrlKey: !1,
      /** Whether the alt or option key is currently pressed. */
      altKey: !1,
      /** Whether the user is dragging. */
      isDragging: !1,
      /** Whether the user is pointing. */
      isPointing: !1,
      /** Whether the user is pinching. */
      isPinching: !1,
      /** Whether the user is editing. */
      isEditing: !1,
      /** Whether the user is panning. */
      isPanning: !1,
      /** Whether the user is spacebar panning. */
      isSpacebarPanning: !1,
      /** Velocity of mouse pointer, in pixels per millisecond */
      pointerVelocity: new R()
    }), jt(this, "_clickManager", new l_(this)), jt(this, "_prevCursor", "default"), jt(this, "_shiftKeyTimeout", -1), jt(this, "_altKeyTimeout", -1), jt(this, "_ctrlKeyTimeout", -1), jt(this, "_metaKeyTimeout", -1), jt(this, "_restoreToolId", "select"), jt(this, "_pinchStart", 1), jt(this, "_didPinch", !1), jt(this, "_selectedShapeIdsAtPointerDown", []), jt(this, "_longPressTimeout", -1), jt(this, "capturedPointerId", null), jt(this, "performanceTracker"), jt(this, "performanceTrackerTimeout", -1), jt(this, "_pendingEventsForNextTick", []), this._isShapeHiddenPredicate = v, this.options = { ...Lce, ...y }, this.store = e, this.disposables.add(this.store.dispose.bind(this.store)), this.history = new uue({
      store: e,
      annotateError: (q) => {
        this.annotateError(q, { origin: "history.batch", willCrashApp: !0 }), this.crash(q);
      }
    }), this.snaps = new Ew(this), this.disposables.add(this.timers.dispose), this._cameraOptions.set({ ...S4, ...c }), this.user = new Ta(t ?? PB(), g ?? !1), this.disposables.add(() => this.user.dispose()), this.getContainer = l, this.textMeasure = new Vue(this), this._tickManager = new d_(this);
    class w extends nD {
    }
    U(w, "initial", d ?? ""), this.root = new w(this), this.root.children = {};
    const C = DB(r), E = {}, P = {}, I = /* @__PURE__ */ new Map();
    for (const q of C) {
      const J = new q(this);
      E[q.type] = J;
      const ie = R6(q.props ?? {});
      P[q.type] = ie;
      for (const W of ie.keys())
        if (!I.has(W.id))
          I.set(W.id, W);
        else if (I.get(W.id) !== W)
          throw Error(
            `Multiple style props with id "${W.id}" in use. Style prop IDs must be unique.`
          );
    }
    this.shapeUtils = E, this.styleProps = P;
    const k = MB(i), L = {};
    for (const q of k) {
      const J = new q(this);
      L[q.type] = J;
    }
    this.bindingUtils = L;
    for (const q of [...s]) {
      if (xc(this.root.children, q.id))
        throw Error(`Can't override tool with id "${q.id}"`);
      this.root.children[q.id] = new q(this, this.root);
    }
    this.scribbles = new hue(this);
    const O = (q, J) => {
      let ie = null;
      const W = q.selectedShapeIds.filter(
        (le) => !J.has(le)
      );
      W.length !== q.selectedShapeIds.length && (ie || (ie = { ...q }), ie.selectedShapeIds = W);
      const Y = q.erasingShapeIds.filter(
        (le) => !J.has(le)
      );
      Y.length !== q.erasingShapeIds.length && (ie || (ie = { ...q }), ie.erasingShapeIds = Y), q.hoveredShapeId && J.has(q.hoveredShapeId) && (ie || (ie = { ...q }), ie.hoveredShapeId = null), q.editingShapeId && J.has(q.editingShapeId) && (ie || (ie = { ...q }), ie.editingShapeId = null);
      const oe = q.hintingShapeIds.filter(
        (le) => !J.has(le)
      );
      return oe.length !== q.hintingShapeIds.length && (ie || (ie = { ...q }), ie.hintingShapeIds = oe), q.focusedGroupId && J.has(q.focusedGroupId) && (ie || (ie = { ...q }), ie.focusedGroupId = null), ie;
    };
    this.sideEffects = this.store.sideEffects;
    let z = /* @__PURE__ */ new Map();
    const F = /* @__PURE__ */ new Set(), H = /* @__PURE__ */ new Set();
    let V = /* @__PURE__ */ new Set();
    if (this.disposables.add(
      this.sideEffects.registerOperationCompleteHandler(() => {
        var q, J, ie, W;
        F.clear();
        for (const Y of H) {
          H.delete(Y);
          const oe = this.getShape(Y);
          if (!oe) continue;
          const le = this.getShapeUtil(oe), ce = (q = le.onChildrenChange) == null ? void 0 : q.call(le, oe);
          ce != null && ce.length && this.updateShapes(ce);
        }
        if (V.size) {
          const Y = V;
          V = /* @__PURE__ */ new Set();
          for (const oe of Y) {
            const le = this.getBindingUtil(oe);
            (J = le.onOperationComplete) == null || J.call(le);
          }
        }
        if (z.size) {
          const Y = z;
          z = /* @__PURE__ */ new Map();
          for (const oe of Y.values())
            (W = (ie = this.getBindingUtil(oe.binding)).onAfterDelete) == null || W.call(ie, oe);
        }
        this.emit("update");
      })
    ), this.disposables.add(
      this.sideEffects.register({
        shape: {
          afterChange: (q, J) => {
            var ie, W, Y, oe;
            for (const le of this.getBindingsInvolvingShape(J))
              V.add(le.type), le.fromId === J.id && ((W = (ie = this.getBindingUtil(le)).onAfterChangeFromShape) == null || W.call(ie, {
                binding: le,
                shapeBefore: q,
                shapeAfter: J
              })), le.toId === J.id && ((oe = (Y = this.getBindingUtil(le)).onAfterChangeToShape) == null || oe.call(Y, {
                binding: le,
                shapeBefore: q,
                shapeAfter: J
              }));
            if (q.parentId !== J.parentId) {
              const le = (ce) => {
                var he, ke, te, me;
                const Q = this.getShape(ce);
                if (Q)
                  for (const Oe of this.getBindingsInvolvingShape(Q))
                    V.add(Oe.type), Oe.fromId === Q.id && ((ke = (he = this.getBindingUtil(Oe)).onAfterChangeFromShape) == null || ke.call(he, {
                      binding: Oe,
                      shapeBefore: Q,
                      shapeAfter: Q
                    })), Oe.toId === Q.id && ((me = (te = this.getBindingUtil(Oe)).onAfterChangeToShape) == null || me.call(te, {
                      binding: Oe,
                      shapeBefore: Q,
                      shapeAfter: Q
                    }));
              };
              le(J.id), this.visitDescendants(J.id, le);
            }
            if (q.parentId !== J.parentId && ga(J.parentId)) {
              const le = /* @__PURE__ */ new Set([q.id]);
              this.visitDescendants(q.id, (ce) => {
                le.add(ce);
              });
              for (const ce of this.getPageStates()) {
                if (ce.pageId === J.parentId) continue;
                const Q = O(ce, le);
                Q && this.store.put([Q]);
              }
            }
            q.parentId && va(q.parentId) && H.add(q.parentId), J.parentId !== q.parentId && va(J.parentId) && H.add(J.parentId);
          },
          beforeDelete: (q) => {
            var Y, oe, le, ce;
            if (F.has(q.id)) return;
            q.parentId && va(q.parentId) && H.add(q.parentId), F.add(q.id);
            const J = [];
            for (const Q of this.getBindingsInvolvingShape(q)) {
              V.add(Q.type), J.push(Q.id);
              const he = this.getBindingUtil(Q);
              Q.fromId === q.id ? ((Y = he.onBeforeIsolateToShape) == null || Y.call(he, { binding: Q, removedShape: q }), (oe = he.onBeforeDeleteFromShape) == null || oe.call(he, { binding: Q, shape: q })) : ((le = he.onBeforeIsolateFromShape) == null || le.call(he, { binding: Q, removedShape: q }), (ce = he.onBeforeDeleteToShape) == null || ce.call(he, { binding: Q, shape: q }));
            }
            J.length && this.deleteBindings(J);
            const ie = /* @__PURE__ */ new Set([q.id]), W = rn(
              this.getPageStates().map((Q) => O(Q, ie))
            );
            W.length && this.store.put(W);
          }
        },
        binding: {
          beforeCreate: (q) => {
            var ie, W;
            const J = (W = (ie = this.getBindingUtil(q)).onBeforeCreate) == null ? void 0 : W.call(ie, { binding: q });
            return J || q;
          },
          afterCreate: (q) => {
            var J, ie;
            V.add(q.type), (ie = (J = this.getBindingUtil(q)).onAfterCreate) == null || ie.call(J, { binding: q });
          },
          beforeChange: (q, J) => {
            var W, Y;
            const ie = (Y = (W = this.getBindingUtil(J)).onBeforeChange) == null ? void 0 : Y.call(W, {
              bindingBefore: q,
              bindingAfter: J
            });
            return ie || J;
          },
          afterChange: (q, J) => {
            var ie, W;
            V.add(J.type), (W = (ie = this.getBindingUtil(J)).onAfterChange) == null || W.call(ie, { bindingBefore: q, bindingAfter: J });
          },
          beforeDelete: (q) => {
            var J, ie;
            (ie = (J = this.getBindingUtil(q)).onBeforeDelete) == null || ie.call(J, { binding: q });
          },
          afterDelete: (q) => {
            var J, ie;
            (ie = (J = this.getBindingUtil(q)).onAfterDelete) == null || ie.call(J, { binding: q }), V.add(q.type);
          }
        },
        page: {
          afterCreate: (q) => {
            const J = vc.createId(q.id), ie = Ml.createId(q.id);
            this.store.has(J) || this.store.put([vc.create({ id: J })]), this.store.has(ie) || this.store.put([
              Ml.create({ id: ie, pageId: q.id })
            ]);
          },
          afterDelete: (q, J) => {
            var Y, oe;
            if (((Y = this.getInstanceState()) == null ? void 0 : Y.currentPageId) === q.id) {
              const le = (oe = this.getPages().find((ce) => ce.id !== q.id)) == null ? void 0 : oe.id;
              le ? this.store.put([{ ...this.getInstanceState(), currentPageId: le }]) : J === "user" && this.store.ensureStoreIsUsable();
            }
            const ie = vc.createId(q.id), W = Ml.createId(q.id);
            this.store.remove([ie, W]);
          }
        },
        instance: {
          afterChange: (q, J, ie) => {
            var W;
            if (!this.store.has(J.currentPageId)) {
              const Y = this.store.has(q.currentPageId) ? q.currentPageId : (W = this.getPages()[0]) == null ? void 0 : W.id;
              Y ? this.store.update(J.id, (oe) => ({
                ...oe,
                currentPageId: Y
              })) : ie === "user" && this.store.ensureStoreIsUsable();
            }
          }
        },
        instance_page_state: {
          afterChange: (q, J) => {
            if ((q == null ? void 0 : q.selectedShapeIds) !== (J == null ? void 0 : J.selectedShapeIds)) {
              const ie = J.selectedShapeIds.filter((Y) => {
                var le, ce;
                let oe = (le = this.getShape(Y)) == null ? void 0 : le.parentId;
                for (; va(oe); ) {
                  if (J.selectedShapeIds.includes(oe))
                    return !1;
                  oe = (ce = this.getShape(oe)) == null ? void 0 : ce.parentId;
                }
                return !0;
              });
              let W = null;
              if (ie.length > 0) {
                const Y = this.findCommonAncestor(
                  rn(ie.map((oe) => this.getShape(oe))),
                  (oe) => this.isShapeOfType(oe, "group")
                );
                Y && (W = Y);
              } else
                J != null && J.focusedGroupId && (W = J.focusedGroupId);
              (ie.length !== J.selectedShapeIds.length || W !== J.focusedGroupId) && this.store.put([
                {
                  ...J,
                  selectedShapeIds: ie,
                  focusedGroupId: W ?? null
                }
              ]);
            }
          }
        }
      })
    ), this._currentPageShapeIds = Zce(
      this.store,
      () => this.getCurrentPageId()
    ), this._parentIdsToChildIds = Xce(this.store), this.disposables.add(
      this.store.listen((q) => {
        this.emit("change", q);
      })
    ), this.disposables.add(this.history.dispose), this.run(
      () => {
        this.store.ensureStoreIsUsable(), this._updateCurrentPageState({
          editingShapeId: null,
          hoveredShapeId: null,
          erasingShapeIds: []
        });
      },
      { history: "ignore" }
    ), d && this.root.children[d] === void 0)
      throw Error(`No state found for initialState "${d}".`);
    if (this.root.enter(void 0, "initial"), this.edgeScrollManager = new sue(this), this.focusManager = new aue(this, h), this.disposables.add(this.focusManager.dispose.bind(this.focusManager)), this.getInstanceState().followingUserId && this.stopFollowingUser(), this.on("tick", this._flushEventsForTick), this.timers.requestAnimationFrame(() => {
      this._tickManager.start();
    }), this.performanceTracker = new z$(), (re = this.store.props.collaboration) != null && re.mode) {
      const q = this.store.props.collaboration.mode;
      this.disposables.add(
        wc("update collaboration mode", () => {
          this.store.put([{ ...this.getInstanceState(), isReadonly: q.get() === "readonly" }]);
        })
      );
    }
  }
  getIsShapeHiddenCache() {
    return this._isShapeHiddenPredicate ? this.store.createComputedCache("isShapeHidden", (e) => this.findShapeAncestor(e, (r) => this.isShapeHidden(r)) ? !0 : this._isShapeHiddenPredicate(e, this) ?? !1) : null;
  }
  isShapeHidden(e) {
    return this._isShapeHiddenPredicate ? !!this.getIsShapeHiddenCache().get(
      typeof e == "string" ? e : e.id
    ) : !1;
  }
  /**
   * Dispose the editor.
   *
   * @public
   */
  dispose() {
    this.disposables.forEach((e) => e()), this.disposables.clear(), this.isDisposed = !0;
  }
  getShapeUtil(e) {
    const t = typeof e == "string" ? e : e.type, r = ys(this.shapeUtils, t);
    return on(r, `No shape util found for type "${t}"`), r;
  }
  getBindingUtil(e) {
    const t = typeof e == "string" ? e : e.type, r = ys(this.bindingUtils, t);
    return on(r, `No binding util found for type "${t}"`), r;
  }
  /**
   * Undo to the last mark.
   *
   * @example
   * ```ts
   * editor.undo()
   * ```
   *
   * @public
   */
  undo() {
    return this._flushEventsForTick(0), this.complete(), this.history.undo(), this;
  }
  getCanUndo() {
    return this.history.getNumUndos() > 0;
  }
  /**
   * Redo to the next mark.
   *
   * @example
   * ```ts
   * editor.redo()
   * ```
   *
   * @public
   */
  redo() {
    return this._flushEventsForTick(0), this.complete(), this.history.redo(), this;
  }
  clearHistory() {
    return this.history.clear(), this;
  }
  getCanRedo() {
    return this.history.getNumRedos() > 0;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos.
   *
   * @example
   * ```ts
   * editor.mark()
   * editor.mark('flip shapes')
   * ```
   *
   * @param markId - The mark's id, usually the reason for adding the mark.
   *
   * @public
   * @deprecated use {@link Editor.markHistoryStoppingPoint} instead
   */
  mark(e) {
    return console.warn(
      typeof e == "string" ? `[tldraw] \`editor.history.mark("${e}")\` is deprecated. Please use \`const myMarkId = editor.markHistoryStoppingPoint()\` instead.` : "[tldraw] `editor.mark()` is deprecated. Use `editor.markHistoryStoppingPoint()` instead."
    ), this.history._mark(e ?? or()), this;
  }
  /**
   * Create a new "mark", or stopping point, in the undo redo history. Creating a mark will clear
   * any redos. You typically want to do this just before a user interaction begins or is handled.
   *
   * @example
   * ```ts
   * editor.markHistoryStoppingPoint()
   * editor.flipShapes(editor.getSelectedShapes())
   * ```
   * @example
   * ```ts
   * const beginRotateMark = editor.markHistoryStoppingPoint()
   * // if the use cancels the rotation, you can bail back to this mark
   * editor.bailToMark(beginRotateMark)
   * ```
   *
   * @public
   * @param name - The name of the mark, useful for debugging the undo/redo stacks
   * @returns a unique id for the mark that can be used with `squashToMark` or `bailToMark`.
   */
  markHistoryStoppingPoint(e) {
    const t = `[${e ?? "stop"}]_${or()}`;
    return this.history._mark(t), t;
  }
  /**
   * @internal this is only used to implement some backwards-compatibility logic. Should be fine to delete after 6 months or whatever.
   */
  getMarkIdMatching(e) {
    return this.history.getMarkIdMatching(e);
  }
  /**
   * Coalesces all changes since the given mark into a single change, removing any intermediate marks.
   *
   * This is useful if you need to 'compress' the recent history to simplify the undo/redo experience of a complex interaction.
   *
   * @example
   * ```ts
   * const bumpShapesMark = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.squashToMark(bumpShapesMark)
   * ```
   *
   * @param markId - The mark id to squash to.
   */
  squashToMark(e) {
    return this.history.squashToMark(e), this;
  }
  /**
   * Undo to the closest mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * editor.bail()
   * ```
   *
   * @public
   */
  bail() {
    return this.history.bail(), this;
  }
  /**
   * Undo to the given mark, discarding the changes so they cannot be redone.
   *
   * @example
   * ```ts
   * const beginDrag = editor.markHistoryStoppingPoint()
   * // ... some changes
   * editor.bailToMark(beginDrag)
   * ```
   *
   * @public
   */
  bailToMark(e) {
    return this.history.bailToMark(e), this;
  }
  /**
   * Run a function in a transaction with optional options for context.
   * You can use the options to change the way that history is treated
   * or allow changes to locked shapes.
   *
   * @example
   * ```ts
   * // updating with
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * }, { history: "ignore" })
   *
   * // forcing changes / deletions for locked shapes
   * editor.toggleLock([myShape])
   * editor.run(() => {
   * 	editor.updateShape({ ...myShape, x: 100 })
   * 	editor.deleteShape(myShape)
   * }, { ignoreShapeLock: true }, )
   * ```
   *
   * @param fn - The callback function to run.
   * @param opts - The options for the batch.
   *
   *
   * @public
   */
  run(e, t) {
    const r = this._shouldIgnoreShapeLock;
    this._shouldIgnoreShapeLock = (t == null ? void 0 : t.ignoreShapeLock) ?? r;
    try {
      this.history.batch(e, t);
    } finally {
      this._shouldIgnoreShapeLock = r;
    }
    return this;
  }
  /**
   * @deprecated Use `Editor.run` instead.
   */
  batch(e, t) {
    return this.run(e, t);
  }
  /* --------------------- Errors --------------------- */
  /** @internal */
  annotateError(e, {
    origin: t,
    willCrashApp: r,
    tags: i,
    extras: s
  }) {
    const l = this.createErrorAnnotations(t, r);
    return qD(e, {
      tags: { ...l.tags, ...i },
      extras: { ...l.extras, ...s }
    }), r && this.store.markAsPossiblyCorrupted(), this;
  }
  /** @internal */
  createErrorAnnotations(e, t) {
    try {
      const r = this.getEditingShapeId();
      return {
        tags: {
          origin: e,
          willCrashApp: t
        },
        extras: {
          activeStateNode: this.root.getPath(),
          selectedShapes: this.getSelectedShapes(),
          editingShape: r ? this.getShape(r) : void 0,
          inputs: this.inputs
        }
      };
    } catch {
      return {
        tags: {
          origin: e,
          willCrashApp: t
        },
        extras: {}
      };
    }
  }
  /**
   * We can't use an `atom` here because there's a chance that when `crashAndReportError` is called,
   * we're in a transaction that's about to be rolled back due to the same error we're currently
   * reporting.
   *
   * Instead, to listen to changes to this value, you need to listen to app's `crash` event.
   *
   * @internal
   */
  getCrashingError() {
    return this._crashingError;
  }
  /** @internal */
  crash(e) {
    return this._crashingError = e, this.store.markAsPossiblyCorrupted(), this.emit("crash", { error: e }), this;
  }
  getPath() {
    return this.root.getPath().split("root.")[1];
  }
  /**
   * Get whether a certain tool (or other state node) is currently active.
   *
   * @example
   * ```ts
   * editor.isIn('select')
   * editor.isIn('select.brushing')
   * ```
   *
   * @param path - The path of active states, separated by periods.
   *
   * @public
   */
  isIn(e) {
    const t = e.split(".").reverse();
    let r = this.root;
    for (; t.length > 0; ) {
      const i = t.pop();
      if (!i) return !0;
      const s = r.getCurrent();
      if ((s == null ? void 0 : s.id) === i) {
        if (t.length === 0) return !0;
        r = s;
        continue;
      } else return !1;
    }
    return !1;
  }
  /**
   * Get whether the state node is in any of the given active paths.
   *
   * @example
   * ```ts
   * state.isInAny('select', 'erase')
   * state.isInAny('select.brushing', 'erase.idle')
   * ```
   *
   * @public
   */
  isInAny(...e) {
    return e.some((t) => this.isIn(t));
  }
  /**
   * Set the selected tool.
   *
   * @example
   * ```ts
   * editor.setCurrentTool('hand')
   * editor.setCurrentTool('hand', { date: Date.now() })
   * ```
   *
   * @param id - The id of the tool to select.
   * @param info - Arbitrary data to pass along into the transition.
   *
   * @public
   */
  setCurrentTool(e, t = {}) {
    return this.root.transition(e, t), this;
  }
  getCurrentTool() {
    return this.root.getCurrent();
  }
  getCurrentToolId() {
    const e = this.getCurrentTool();
    return e ? e.getCurrentToolIdMask() ?? e.id : "";
  }
  /**
   * Get a descendant by its path.
   *
   * @example
   * ```ts
   * state.getStateDescendant('select')
   * state.getStateDescendant('select.brushing')
   * ```
   *
   * @param path - The descendant's path of state ids, separated by periods.
   *
   * @public
   */
  getStateDescendant(e) {
    var i;
    const t = e.split(".").reverse();
    let r = this.root;
    for (; t.length > 0; ) {
      const s = t.pop();
      if (!s) return r;
      const l = (i = r.children) == null ? void 0 : i[s];
      if (!l) return;
      r = l;
    }
    return r;
  }
  getDocumentSettings() {
    return this.store.get($A);
  }
  /**
   * Update the global document settings that apply to all users.
   *
   * @public
   **/
  updateDocumentSettings(e) {
    return this.run(
      () => {
        this.store.put([{ ...this.getDocumentSettings(), ...e }]);
      },
      { history: "ignore" }
    ), this;
  }
  getInstanceState() {
    return this.store.get(hs);
  }
  /**
   * Update the instance's state.
   *
   * @param partial - A partial object to update the instance state with.
   * @param historyOptions - History batch options.
   *
   * @public
   */
  updateInstanceState(e, t) {
    return this._updateInstanceState(e, { history: "ignore", ...t }), e.isChangingStyle !== void 0 && (clearTimeout(this._isChangingStyleTimeout), e.isChangingStyle === !0 && (this._isChangingStyleTimeout = this.timers.setTimeout(() => {
      this._updateInstanceState({ isChangingStyle: !1 }, { history: "ignore" });
    }, 2e3))), this;
  }
  /** @internal */
  _updateInstanceState(e, t) {
    this.run(() => {
      this.store.put([
        {
          ...this.getInstanceState(),
          ...e
        }
      ]);
    }, t);
  }
  getOpenMenus() {
    return this.menus.getOpenMenus();
  }
  /**
   * @deprecated Use `editor.menus.addOpenMenu` instead.
   *
   * @public
   */
  addOpenMenu(e) {
    return this.menus.addOpenMenu(e), this;
  }
  /**
   * @deprecated Use `editor.menus.deleteOpenMenu` instead.
   *
   * @public
   */
  deleteOpenMenu(e) {
    return this.menus.deleteOpenMenu(e), this;
  }
  /**
   * @deprecated Use `editor.menus.clearOpenMenus` instead.
   *
   * @public
   */
  clearOpenMenus() {
    return this.menus.clearOpenMenus(), this;
  }
  getIsMenuOpen() {
    return this.menus.hasAnyOpenMenus();
  }
  /* --------------------- Cursor --------------------- */
  /**
   * Set the cursor.
   *
   * @param cursor - The cursor to set.
   * @public
   */
  setCursor(e) {
    return this.updateInstanceState({ cursor: { ...this.getInstanceState().cursor, ...e } }), this;
  }
  getPageStates() {
    return this._getPageStatesQuery().get();
  }
  _getPageStatesQuery() {
    return this.store.query.records("instance_page_state");
  }
  getCurrentPageState() {
    return this.store.get(this._getCurrentPageStateId());
  }
  _getCurrentPageStateId() {
    return Ml.createId(this.getCurrentPageId());
  }
  /**
   * Update this instance's page state.
   *
   * @example
   * ```ts
   * editor.updateCurrentPageState({ id: 'page1', editingShapeId: 'shape:123' })
   * ```
   *
   * @param partial - The partial of the page state object containing the changes.
   *
   * @public
   */
  updateCurrentPageState(e) {
    return this._updateCurrentPageState(e), this;
  }
  _updateCurrentPageState(e) {
    this.store.update(e.id ?? this.getCurrentPageState().id, (t) => ({
      ...t,
      ...e
    }));
  }
  getSelectedShapeIds() {
    return this.getCurrentPageState().selectedShapeIds;
  }
  getSelectedShapes() {
    const { selectedShapeIds: e } = this.getCurrentPageState();
    return rn(e.map((t) => this.store.get(t)));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.setSelectedShapes(['id1'])
   * editor.setSelectedShapes(['id1', 'id2'])
   * ```
   *
   * @param shapes - The shape (or shape ids) to select.
   *
   * @public
   */
  setSelectedShapes(e) {
    return this.run(
      () => {
        const t = e.map((s) => typeof s == "string" ? s : s.id), { selectedShapeIds: r } = this.getCurrentPageState(), i = new Set(r);
        if (t.length === i.size && t.every((s) => i.has(s))) return null;
        this.store.put([{ ...this.getCurrentPageState(), selectedShapeIds: t }]);
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Determine whether or not any of a shape's ancestors are selected.
   *
   * @param shape - The shape (or shape id) of the shape to check.
   *
   * @public
   */
  isAncestorSelected(e) {
    const t = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null, r = this.getShape(t);
    if (!r) return !1;
    const i = this.getSelectedShapeIds();
    return !!this.findShapeAncestor(r, (s) => i.includes(s.id));
  }
  /**
   * Select one or more shapes.
   *
   * @example
   * ```ts
   * editor.select('id1')
   * editor.select('id1', 'id2')
   * ```
   *
   * @param shapes - The shape (or the shape ids) to select.
   *
   * @public
   */
  select(...e) {
    const t = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return this.setSelectedShapes(t), this;
  }
  /**
   * Remove a shape from the existing set of selected shapes.
   *
   * @example
   * ```ts
   * editor.deselect(shape.id)
   * ```
   *
   * @public
   */
  deselect(...e) {
    const t = typeof e[0] == "string" ? e : e.map((i) => i.id), r = this.getSelectedShapeIds();
    return r.length > 0 && t.length > 0 && this.setSelectedShapes(r.filter((i) => !t.includes(i))), this;
  }
  /**
   * Select all direct children of the current page.
   *
   * @example
   * ```ts
   * editor.selectAll()
   * ```
   *
   * @public
   */
  selectAll() {
    const e = this.getSortedChildIdsForParent(this.getCurrentPageId());
    return e.length <= 0 ? this : (this.setSelectedShapes(this._getUnlockedShapeIds(e)), this);
  }
  /**
   * Clear the selection.
   *
   * @example
   * ```ts
   * editor.selectNone()
   * ```
   *
   * @public
   */
  selectNone() {
    return this.getSelectedShapeIds().length > 0 && this.setSelectedShapes([]), this;
  }
  getOnlySelectedShapeId() {
    var e;
    return ((e = this.getOnlySelectedShape()) == null ? void 0 : e.id) ?? null;
  }
  getOnlySelectedShape() {
    const e = this.getSelectedShapes();
    return e.length === 1 ? e[0] : null;
  }
  /**
   * @internal
   */
  getShapesPageBounds(e) {
    const t = rn(e.map((r) => this.getShapePageBounds(r)));
    return t.length === 0 ? null : Xe.Common(t);
  }
  getSelectionPageBounds() {
    return this.getShapesPageBounds(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesSharedRotation(e) {
    let t = !1, r = 0;
    for (let i = 0, s = e.length; i < s; i++) {
      const l = this.getShapePageTransform(e[i]);
      if (l)
        if (t) {
          if (l.rotation() !== r)
            return 0;
        } else
          t = !0, r = l.rotation();
    }
    return r;
  }
  getSelectionRotation() {
    return this.getShapesSharedRotation(this.getSelectedShapeIds());
  }
  /**
   * @internal
   */
  getShapesRotatedPageBounds(e) {
    if (e.length === 0)
      return;
    const t = this.getShapesSharedRotation(e);
    if (t === 0)
      return this.getShapesPageBounds(e) ?? void 0;
    if (e.length === 1) {
      const i = this.getShapeGeometry(e[0]).bounds.clone(), s = this.getShapePageTransform(e[0]);
      return i.point = s.applyToPoint(i.point), i;
    }
    const r = Xe.FromPoints(
      e.flatMap((i) => {
        const s = this.getShapePageTransform(i);
        return s ? s.applyToPoints(this.getShapeGeometry(i).bounds.corners) : [];
      }).map((i) => i.rot(-t))
    );
    return r.point = r.point.rot(t), r;
  }
  getSelectionRotatedPageBounds() {
    return this.getShapesRotatedPageBounds(this.getSelectedShapeIds());
  }
  getSelectionRotatedScreenBounds() {
    const e = this.getSelectionRotatedPageBounds();
    if (!e) return;
    const { x: t, y: r } = this.pageToScreen(e.point), i = this.getZoomLevel();
    return new Xe(t, r, e.width * i, e.height * i);
  }
  getFocusedGroupId() {
    return this.getCurrentPageState().focusedGroupId ?? this.getCurrentPageId();
  }
  getFocusedGroup() {
    const e = this.getFocusedGroupId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current focused group shape.
   *
   * @param shape - The group shape id (or group shape's id) to set as the focused group shape.
   *
   * @public
   */
  setFocusedGroup(e) {
    const t = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    if (t !== null) {
      const r = this.getShape(t);
      if (!r)
        throw Error(`Editor.setFocusedGroup: Shape with id ${t} does not exist`);
      if (!this.isShapeOfType(r, "group"))
        throw Error(
          `Editor.setFocusedGroup: Cannot set focused group to shape of type ${r.type}`
        );
    }
    return t === this.getFocusedGroupId() ? this : this.run(
      () => {
        this.store.update(this.getCurrentPageState().id, (r) => ({ ...r, focusedGroupId: t }));
      },
      { history: "record-preserveRedoStack" }
    );
  }
  /**
   * Exit the current focused group, moving up to the next parent group if there is one.
   *
   * @public
   */
  popFocusedGroupId() {
    const e = this.getFocusedGroup();
    if (e) {
      const t = this.findShapeAncestor(
        e,
        (r) => this.isShapeOfType(r, "group")
      );
      this.setFocusedGroup((t == null ? void 0 : t.id) ?? null), this.select(e.id);
    } else
      this.setFocusedGroup(null), this.selectNone();
    return this;
  }
  getEditingShapeId() {
    return this.getCurrentPageState().editingShapeId;
  }
  getEditingShape() {
    const e = this.getEditingShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the current editing shape.
   *
   * @example
   * ```ts
   * editor.setEditingShape(myShape)
   * editor.setEditingShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as editing.
   *
   * @public
   */
  setEditingShape(e) {
    const t = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    if (t !== this.getEditingShapeId()) {
      if (t) {
        const r = this.getShape(t);
        if (r && this.getShapeUtil(r).canEdit(r))
          return this.run(
            () => {
              this._updateCurrentPageState({ editingShapeId: t });
            },
            { history: "ignore" }
          ), this;
      }
      this.run(
        () => {
          this._updateCurrentPageState({ editingShapeId: null });
        },
        { history: "ignore" }
      );
    }
    return this;
  }
  getHoveredShapeId() {
    return this.getCurrentPageState().hoveredShapeId;
  }
  getHoveredShape() {
    const e = this.getHoveredShapeId();
    return e ? this.getShape(e) : void 0;
  }
  /**
   * Set the editor's current hovered shape.
   *
   * @example
   * ```ts
   * editor.setHoveredShape(myShape)
   * editor.setHoveredShape(myShape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to set as hovered.
   *
   * @public
   */
  setHoveredShape(e) {
    const t = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return t === this.getHoveredShapeId() ? this : (this.run(
      () => {
        this.updateCurrentPageState({ hoveredShapeId: t });
      },
      { history: "ignore" }
    ), this);
  }
  getHintingShapeIds() {
    return this.getCurrentPageState().hintingShapeIds;
  }
  getHintingShape() {
    const e = this.getHintingShapeIds();
    return rn(e.map((t) => this.getShape(t)));
  }
  /**
   * Set the editor's current hinting shapes.
   *
   * @example
   * ```ts
   * editor.setHintingShapes([myShape])
   * editor.setHintingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setHintingShapes(e) {
    const t = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return this.run(
      () => {
        this._updateCurrentPageState({ hintingShapeIds: GD(t) });
      },
      { history: "ignore" }
    ), this;
  }
  getErasingShapeIds() {
    return this.getCurrentPageState().erasingShapeIds;
  }
  getErasingShapes() {
    const e = this.getErasingShapeIds();
    return rn(e.map((t) => this.getShape(t)));
  }
  /**
   * Set the editor's current erasing shapes.
   *
   * @example
   * ```ts
   * editor.setErasingShapes([myShape])
   * editor.setErasingShapes([myShape.id])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to set as hinting.
   *
   * @public
   */
  setErasingShapes(e) {
    const t = typeof e[0] == "string" ? e : e.map((i) => i.id);
    t.sort();
    const r = this.getErasingShapeIds();
    return this.run(
      () => {
        if (t.length === r.length) {
          for (let i = 0; i < t.length; i++)
            if (t[i] !== r[i]) {
              this._updateCurrentPageState({ erasingShapeIds: t });
              break;
            }
        } else
          this._updateCurrentPageState({ erasingShapeIds: t });
      },
      { history: "ignore" }
    ), this;
  }
  // Cropping
  /**
   * The current cropping shape's id.
   *
   * @public
   */
  getCroppingShapeId() {
    return this.getCurrentPageState().croppingShapeId;
  }
  /**
   * Set the current cropping shape.
   *
   * @example
   * ```ts
   * editor.setCroppingShape(myShape)
   * editor.setCroppingShape(myShape.id)
   * ```
   *
   *
   * @param shape - The shape (or shape id) to set as cropping.
   *
   * @public
   */
  setCroppingShape(e) {
    const t = typeof e == "string" ? e : (e == null ? void 0 : e.id) ?? null;
    return t !== this.getCroppingShapeId() && this.run(
      () => {
        if (!t)
          this.updateCurrentPageState({ croppingShapeId: null });
        else {
          const r = this.getShape(t), i = this.getShapeUtil(r);
          r && i.canCrop(r) && this.updateCurrentPageState({ croppingShapeId: t });
        }
      },
      { history: "ignore" }
    ), this;
  }
  _unsafe_getCameraId() {
    return vc.createId(this.getCurrentPageId());
  }
  getCamera() {
    const e = this.store.get(this._unsafe_getCameraId());
    if (this._isLockedOnFollowingUser.get()) {
      const t = this.getCameraForFollowing();
      if (t)
        return { ...e, ...t };
    }
    return e;
  }
  getViewportPageBoundsForFollowing() {
    const e = this.getInstanceState().followingUserId;
    if (!e) return null;
    const t = this.getCollaborators().find((y) => y.userId === e);
    if (!t || !t.camera || !t.screenBounds) return null;
    const { w: r, h: i } = t.screenBounds, { x: s, y: l, z: c } = t.camera, d = new Xe(-s, -l, r / c, i / c), h = this.getViewportScreenBounds().clone(), g = h.width / h.height;
    return h.width = d.width, h.height = h.width / g, h.height < d.height && (h.height = d.height, h.width = h.height * g), h.center = d.center, h;
  }
  getCameraForFollowing() {
    const e = this.getViewportPageBoundsForFollowing();
    return e ? {
      x: -e.x,
      y: -e.y,
      z: this.getViewportScreenBounds().w / e.width
    } : null;
  }
  getZoomLevel() {
    return this.getCamera().z;
  }
  /**
   * Get the camera's initial or reset zoom level.
   *
   * @example
   * ```ts
   * editor.getInitialZoom()
   * ```
   *
   * @public */
  getInitialZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.initialZoom === "default") return 1;
    const { zx: t, zy: r } = iU(this, e);
    switch (e.constraints.initialZoom) {
      case "fit-min":
        return Math.max(t, r);
      case "fit-max":
        return Math.min(t, r);
      case "fit-x":
        return t;
      case "fit-y":
        return r;
      case "fit-min-100":
        return Math.min(1, Math.max(t, r));
      case "fit-max-100":
        return Math.min(1, Math.min(t, r));
      case "fit-x-100":
        return Math.min(1, t);
      case "fit-y-100":
        return Math.min(1, r);
      default:
        throw ro(e.constraints.initialZoom);
    }
  }
  /**
   * Get the camera's base level for calculating actual zoom levels based on the zoom steps.
   *
   * @example
   * ```ts
   * editor.getBaseZoom()
   * ```
   *
   * @public */
  getBaseZoom() {
    const e = this.getCameraOptions();
    if (!e.constraints || e.constraints.baseZoom === "default") return 1;
    const { zx: t, zy: r } = iU(this, e);
    switch (e.constraints.baseZoom) {
      case "fit-min":
        return Math.max(t, r);
      case "fit-max":
        return Math.min(t, r);
      case "fit-x":
        return t;
      case "fit-y":
        return r;
      case "fit-min-100":
        return Math.min(1, Math.max(t, r));
      case "fit-max-100":
        return Math.min(1, Math.min(t, r));
      case "fit-x-100":
        return Math.min(1, t);
      case "fit-y-100":
        return Math.min(1, r);
      default:
        throw ro(e.constraints.baseZoom);
    }
  }
  /**
   * Get the current camera options.
   *
   * @example
   * ```ts
   * editor.getCameraOptions()
   * ```
   *
   *  @public */
  getCameraOptions() {
    return this._cameraOptions.get();
  }
  /**
   * Set the camera options. Changing the options won't immediately change the camera itself, so you may want to call `setCamera` after changing the options.
   *
   * @example
   * ```ts
   * editor.setCameraOptions(myCameraOptions)
   * editor.setCamera(editor.getCamera())
   * ```
   *
   * @param opts - The camera options to set.
   *
   * @public */
  setCameraOptions(e) {
    var r;
    const t = $r({
      ...this._cameraOptions.__unsafe__getWithoutCapture(),
      ...e
    });
    return ((r = t.zoomSteps) == null ? void 0 : r.length) < 1 && (t.zoomSteps = [1]), this._cameraOptions.set(t), this.setCamera(this.getCamera()), this;
  }
  /** @internal */
  getConstrainedCamera(e, t) {
    const r = this.getCamera();
    let { x: i, y: s, z: l = r.z } = e;
    if (!(t != null && t.force)) {
      const c = this.getCameraOptions(), d = c.zoomSteps[0], h = jo(c.zoomSteps), g = this.getViewportScreenBounds();
      if (c.constraints) {
        const { constraints: y } = c, v = Math.min(y.padding.y, g.w / 2), w = Math.min(y.padding.x, g.h / 2), C = Xe.From(c.constraints.bounds), E = (g.w - w * 2) / C.w, P = (g.h - v * 2) / C.h, I = this.getBaseZoom(), k = h * I, L = d * I;
        if (t != null && t.reset && (l = this.getInitialZoom()), l < L || l > k) {
          const { x: ie, y: W, z: Y } = r, oe = -ie + g.w / Y / 2, le = -W + g.h / Y / 2;
          l = Do(l, L, k);
          const ce = -ie + g.w / l / 2, Q = -W + g.h / l / 2;
          i = ie + ce - oe, s = W + Q - le;
        }
        const O = w / l - C.x, z = v / l - C.y, F = (g.w - w * 2) / l - C.w, H = (g.h - v * 2) / l - C.h, V = O + F * y.origin.x, re = z + H * y.origin.y, q = typeof y.behavior == "string" ? y.behavior : y.behavior.x, J = typeof y.behavior == "string" ? y.behavior : y.behavior.y;
        if (t != null && t.reset)
          i = V, s = re;
        else {
          switch (q) {
            case "fixed": {
              i = V;
              break;
            }
            case "contain": {
              l < E ? i = V : i = Do(i, O + F, O);
              break;
            }
            case "inside": {
              l < E ? i = Do(i, O, (g.w - w) / l - C.w) : i = Do(i, O + F, O);
              break;
            }
            case "outside": {
              i = Do(i, w / l - C.w, (g.w - w) / l);
              break;
            }
            case "free":
              break;
            default:
              throw ro(q);
          }
          switch (J) {
            case "fixed": {
              s = re;
              break;
            }
            case "contain": {
              l < P ? s = re : s = Do(s, z + H, z);
              break;
            }
            case "inside": {
              l < P ? s = Do(s, z, (g.h - v) / l - C.h) : s = Do(s, z + H, z);
              break;
            }
            case "outside": {
              s = Do(s, v / l - C.h, (g.h - v) / l);
              break;
            }
            case "free":
              break;
            default:
              throw ro(J);
          }
        }
      } else if (l > h || l < d) {
        const { x: y, y: v, z: w } = r;
        l = Do(l, d, h), i = y + (-y + g.w / l / 2) - (-y + g.w / w / 2), s = v + (-v + g.h / l / 2) - (-v + g.h / w / 2);
      }
    }
    return { x: i, y: s, z: l };
  }
  /** @internal */
  _setCamera(e, t) {
    const r = this.getCamera(), { x: i, y: s, z: l } = this.getConstrainedCamera(e, t);
    return r.x === i && r.y === s && r.z === l ? this : (Dl(() => {
      const c = { ...r, x: i, y: s, z: l };
      this.run(
        () => {
          this.store.put([c]);
        },
        { history: "ignore" }
      );
      const { currentScreenPoint: d, currentPagePoint: h } = this.inputs, { screenBounds: g } = this.store.unsafeGetWithoutCapture(hs);
      if (d.x / l - i !== h.x || d.y / l - s !== h.y) {
        const y = {
          type: "pointer",
          target: "canvas",
          name: "pointer_move",
          // weird but true: we need to put the screen point back into client space
          point: R.AddXY(d, g.x, g.y),
          pointerId: x4.CAMERA_MOVE,
          ctrlKey: this.inputs.ctrlKey,
          altKey: this.inputs.altKey,
          shiftKey: this.inputs.shiftKey,
          metaKey: this.inputs.metaKey,
          accelKey: ms(this.inputs),
          button: 0,
          isPen: this.getInstanceState().isPenMode ?? !1
        };
        t != null && t.immediate ? this._flushEventForTick(y) : this.dispatch(y);
      }
      this._tickCameraState();
    }), this);
  }
  /**
   * Set the current camera.
   *
   * @example
   * ```ts
   * editor.setCamera({ x: 0, y: 0})
   * editor.setCamera({ x: 0, y: 0, z: 1.5})
   * editor.setCamera({ x: 0, y: 0, z: 1.5}, { animation: { duration: 1000, easing: (t) => t * t } })
   * ```
   *
   * @param point - The new camera position.
   * @param opts - The camera move options.
   *
   * @public
   */
  setCamera(e, t) {
    const { isLocked: r } = this._cameraOptions.__unsafe__getWithoutCapture();
    if (r && !(t != null && t.force)) return this;
    this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser();
    const i = R.Cast(e);
    Number.isFinite(i.x) || (i.x = 0), Number.isFinite(i.y) || (i.y = 0), (i.z === void 0 || !Number.isFinite(i.z)) && (e.z = this.getZoomLevel());
    const s = this.getConstrainedCamera(i, t);
    if (t != null && t.animation) {
      const { width: l, height: c } = this.getViewportScreenBounds();
      this._animateToViewport(
        new Xe(-s.x, -s.y, l / s.z, c / s.z),
        t
      );
    } else
      this._setCamera(s, {
        ...t,
        // we already did the constraining, so we don't need to do it again
        force: !0
      });
    return this;
  }
  /**
   * Center the camera on a point (in the current page space).
   *
   * @example
   * ```ts
   * editor.centerOnPoint({ x: 100, y: 100 })
   * editor.centerOnPoint({ x: 100, y: 100 }, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The point in the current page space to center on.
   * @param opts - The camera move options.
   *
   * @public
   */
  centerOnPoint(e, t) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(t != null && t.force)) return this;
    const { width: i, height: s } = this.getViewportPageBounds();
    return this.setCamera(new R(-(e.x - i / 2), -(e.y - s / 2), this.getCamera().z), t), this;
  }
  /**
   * Zoom the camera to fit the current page's content in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToFit()
   * editor.zoomToFit({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToFit(e) {
    const t = [...this.getCurrentPageShapeIds()];
    if (t.length <= 0) return this;
    const r = Xe.Common(rn(t.map((i) => this.getShapePageBounds(i))));
    return this.zoomToBounds(r, e), this;
  }
  /**
   * Set the zoom back to 100%.
   *
   * @example
   * ```ts
   * editor.resetZoom()
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.resetZoom(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  resetZoom(e = this.getViewportScreenCenter(), t) {
    const { isLocked: r, constraints: i } = this.getCameraOptions();
    if (r && !(t != null && t.force)) return this;
    const s = this.getCamera(), { x: l, y: c, z: d } = s, { x: h, y: g } = e;
    let y = 1;
    if (i) {
      const v = this.getInitialZoom();
      d !== v && (y = v);
    }
    return this.setCamera(
      new R(l + (h / y - h) - (h / d - h), c + (g / y - g) - (g / d - g), y),
      t
    ), this;
  }
  /**
   * Zoom the camera in.
   *
   * @example
   * ```ts
   * editor.zoomIn()
   * editor.zoomIn(editor.getViewportScreenCenter(), { animation: { duration: 200 } })
   * editor.zoomIn(editor.inputs.currentScreenPoint, { animation: { duration: 200 } })
   * ```
   *
   * @param point - The screen point to zoom in on. Defaults to the screen center
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomIn(e = this.getViewportScreenCenter(), t) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(t != null && t.force)) return this;
    const { x: i, y: s, z: l } = this.getCamera(), { zoomSteps: c } = this.getCameraOptions();
    if (c !== null && c.length > 1) {
      const d = this.getBaseZoom();
      let h = jo(c) * d;
      for (let g = 1; g < c.length; g++) {
        const y = c[g - 1] * d, v = c[g] * d;
        if (!(v - l <= (v - y) / 2)) {
          h = v;
          break;
        }
      }
      this.setCamera(
        new R(
          i + (e.x / h - e.x) - (e.x / l - e.x),
          s + (e.y / h - e.y) - (e.y / l - e.y),
          h
        ),
        t
      );
    }
    return this;
  }
  /**
   * Zoom the camera out.
   *
   * @example
   * ```ts
   * editor.zoomOut()
   * editor.zoomOut(editor.getViewportScreenCenter(), { animation: { duration: 120 } })
   * editor.zoomOut(editor.inputs.currentScreenPoint, { animation: { duration: 120 } })
   * ```
   *
   * @param point - The point to zoom out on. Defaults to the viewport screen center.
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomOut(e = this.getViewportScreenCenter(), t) {
    const { isLocked: r } = this.getCameraOptions();
    if (r && !(t != null && t.force)) return this;
    const { zoomSteps: i } = this.getCameraOptions();
    if (i !== null && i.length > 1) {
      const s = this.getBaseZoom(), { x: l, y: c, z: d } = this.getCamera();
      let h = i[0] * s;
      for (let g = i.length - 1; g > 0; g--) {
        const y = i[g - 1] * s, v = i[g] * s;
        if (!(v - d >= (v - y) / 2)) {
          h = y;
          break;
        }
      }
      this.setCamera(
        new R(
          l + (e.x / h - e.x) - (e.x / d - e.x),
          c + (e.y / h - e.y) - (e.y / d - e.y),
          h
        ),
        t
      );
    }
    return this;
  }
  /**
   * Zoom the camera to fit the current selection in the viewport.
   *
   * @example
   * ```ts
   * editor.zoomToSelection()
   * editor.zoomToSelection({ animation: { duration: 200 } })
   * ```
   *
   * @param opts - The camera move options.
   *
   * @public
   */
  zoomToSelection(e) {
    const { isLocked: t } = this.getCameraOptions();
    if (t && !(e != null && e.force)) return this;
    const r = this.getSelectionPageBounds();
    return r && this.zoomToBounds(r, {
      targetZoom: Math.max(1, this.getZoomLevel()),
      ...e
    }), this;
  }
  /**
   * Zoom the camera to fit a bounding box (in the current page space).
   *
   * @example
   * ```ts
   * editor.zoomToBounds(myBounds)
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 } })
   * editor.zoomToBounds(myBounds, { animation: { duration: 200 }, inset: 0, targetZoom: 1 })
   * ```
   *
   * @param bounds - The bounding box.
   * @param opts - The camera move options, target zoom, or custom inset amount.
   *
   * @public
   */
  zoomToBounds(e, t) {
    const r = this._cameraOptions.__unsafe__getWithoutCapture();
    if (r.isLocked && !(t != null && t.force)) return this;
    const i = this.getViewportScreenBounds(), s = (t == null ? void 0 : t.inset) ?? Math.min(cse, i.width * 0.28), l = this.getBaseZoom(), c = r.zoomSteps[0], d = jo(r.zoomSteps);
    let h = Do(
      Math.min(
        (i.width - s) / e.w,
        (i.height - s) / e.h
      ),
      c * l,
      d * l
    );
    return (t == null ? void 0 : t.targetZoom) !== void 0 && (h = Math.min(t.targetZoom, h)), this.setCamera(
      new R(
        -e.x + (i.width - e.w * h) / 2 / h,
        -e.y + (i.height - e.h * h) / 2 / h,
        h
      ),
      t
    ), this;
  }
  /**
   * Stop the current camera animation, if any.
   *
   * @example
   * ```ts
   * editor.stopCameraAnimation()
   * ```
   *
   * @public
   */
  stopCameraAnimation() {
    return this.emit("stop-camera-animation"), this;
  }
  /** @internal */
  _animateViewport(e) {
    if (!this._viewportAnimation) return;
    this._viewportAnimation.elapsed += e;
    const { elapsed: t, easing: r, duration: i, start: s, end: l } = this._viewportAnimation;
    if (t > i) {
      this.off("tick", this._animateViewport), this._viewportAnimation = null, this._setCamera(new R(-l.x, -l.y, this.getViewportScreenBounds().width / l.width));
      return;
    }
    const c = i - t, d = r(1 - c / i), h = s.minX + (l.minX - s.minX) * d, g = s.minY + (l.minY - s.minY) * d, y = s.maxX + (l.maxX - s.maxX) * d;
    this._setCamera(new R(-h, -g, this.getViewportScreenBounds().width / (y - h)), {
      force: !0
    });
  }
  /** @internal */
  _animateToViewport(e, t = { animation: CM }) {
    const { animation: r, ...i } = t;
    if (!r) return;
    const { duration: s = 0, easing: l = po.easeInOutCubic } = r, c = this.user.getAnimationSpeed(), d = this.getViewportPageBounds();
    return this.stopCameraAnimation(), this.getInstanceState().followingUserId && this.stopFollowingUser(), s === 0 || c === 0 ? this._setCamera(
      new R(
        -e.x,
        -e.y,
        this.getViewportScreenBounds().width / e.width
      ),
      { ...i }
    ) : (this._viewportAnimation = {
      elapsed: 0,
      duration: s / c,
      easing: l,
      start: d.clone(),
      end: e.clone()
    }, this.once("stop-camera-animation", () => {
      this.off("tick", this._animateViewport), this._viewportAnimation = null;
    }), this.on("tick", this._animateViewport), this);
  }
  /**
   * Slide the camera in a certain direction.
   *
   * @example
   * ```ts
   * editor.slideCamera({ speed: 1, direction: { x: 1, y: 0 }, friction: 0.1 })
   * ```
   *
   * @param opts - Options for the slide
   * @public
   */
  slideCamera(e = {}) {
    const { isLocked: t } = this.getCameraOptions();
    if (t && !(e != null && e.force)) return this;
    if (this.user.getAnimationSpeed() === 0) return this;
    this.stopCameraAnimation();
    const {
      speed: i,
      friction: s = this.options.cameraSlideFriction,
      direction: l,
      speedThreshold: c = 0.01
    } = e;
    let d = Math.min(i, 1);
    const h = () => {
      this.off("tick", g), this.off("stop-camera-animation", h);
    };
    this.once("stop-camera-animation", h);
    const g = (y) => {
      const { x: v, y: w, z: C } = this.getCamera(), E = R.Mul(l, d * y / C);
      d *= 1 - s, d < c ? h() : this._setCamera(new R(v + E.x, w + E.y, C));
    };
    return this.on("tick", g), this;
  }
  /**
   * Animate the camera to a user's cursor position. This also briefly show the user's cursor if it's not currently visible.
   *
   * @example
   * ```ts
   * editor.zoomToUser(myUserId)
   * editor.zoomToUser(myUserId, { animation: { duration: 200 } })
   * ```
   *
   * @param userId - The id of the user to animate to.
   * @param opts - The camera move options.
   * @public
   */
  zoomToUser(e, t = { animation: { duration: 500 } }) {
    const r = this.getCollaborators().find((s) => s.userId === e);
    if (!r) return this;
    const i = r.cursor;
    return i ? (this.run(() => {
      this.getInstanceState().followingUserId !== null && this.stopFollowingUser();
      const s = r.currentPageId === this.getCurrentPageId();
      s || this.setCurrentPage(r.currentPageId), t && t.animation && !s && (t.animation = void 0), this.centerOnPoint(i, t);
      const { highlightedUserIds: l } = this.getInstanceState();
      this.updateInstanceState({ highlightedUserIds: [...l, e] }), this.timers.setTimeout(() => {
        const c = [...this.getInstanceState().highlightedUserIds], d = c.indexOf(e);
        d < 0 || (c.splice(d, 1), this.updateInstanceState({ highlightedUserIds: c }));
      }, this.options.collaboratorIdleTimeoutMs);
    }), this) : this;
  }
  /**
   * Update the viewport. The viewport will measure the size and screen position of its container
   * element. This should be done whenever the container's position on the screen changes.
   *
   * @example
   * ```ts
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024))
   * editor.updateViewportScreenBounds(new Box(0, 0, 1280, 1024), true)
   * ```
   *
   * @param screenBounds - The new screen bounds of the viewport.
   * @param center - Whether to preserve the viewport page center as the viewport changes.
   *
   * @public
   */
  updateViewportScreenBounds(e, t = !1) {
    if (e instanceof HTMLElement) {
      const c = e.getBoundingClientRect();
      e = new Xe(
        c.left || c.x,
        c.top || c.y,
        Math.max(c.width, 1),
        Math.max(c.height, 1)
      );
    } else
      e.width = Math.max(e.width, 1), e.height = Math.max(e.height, 1);
    const r = [
      // top
      e.minY !== 0,
      // right
      !fh(document.body.scrollWidth, e.maxX, 1),
      // bottom
      !fh(document.body.scrollHeight, e.maxY, 1),
      // left
      e.minX !== 0
    ], { _willSetInitialBounds: i } = this;
    this._willSetInitialBounds = !1;
    const { screenBounds: s, insets: l } = this.getInstanceState();
    if (e.equals(s) && r.every((c, d) => c === l[d]))
      return this;
    if (i)
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this.setCamera(this.getCamera());
    else if (t && !this.getInstanceState().followingUserId) {
      const c = this.getViewportPageBounds().center;
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this.centerOnPoint(c);
    } else
      this.updateInstanceState({ screenBounds: e.toJson(), insets: r }), this._setCamera(R.From({ ...this.getCamera() }));
    return this._tickCameraState(), this;
  }
  getViewportScreenBounds() {
    const { x: e, y: t, w: r, h: i } = this.getInstanceState().screenBounds;
    return new Xe(e, t, r, i);
  }
  getViewportScreenCenter() {
    const e = this.getViewportScreenBounds();
    return new R(
      e.midX - e.minX,
      e.midY - e.minY
    );
  }
  getViewportPageBounds() {
    const { w: e, h: t } = this.getViewportScreenBounds(), { x: r, y: i, z: s } = this.getCamera();
    return new Xe(-r, -i, e / s, t / s);
  }
  /**
   * Convert a point in screen space to a point in the current page space.
   *
   * @example
   * ```ts
   * editor.screenToPage({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in screen space.
   *
   * @public
   */
  screenToPage(e) {
    const { screenBounds: t } = this.store.unsafeGetWithoutCapture(hs), { x: r, y: i, z: s = 1 } = this.getCamera();
    return new R(
      (e.x - t.x) / s - r,
      (e.y - t.y) / s - i,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current screen space.
   *
   * @example
   * ```ts
   * editor.pageToScreen({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToScreen(e) {
    const { screenBounds: t } = this.store.unsafeGetWithoutCapture(hs), { x: r, y: i, z: s = 1 } = this.getCamera();
    return new R(
      (e.x + r) * s + t.x,
      (e.y + i) * s + t.y,
      e.z ?? 0.5
    );
  }
  /**
   * Convert a point in the current page space to a point in current viewport space.
   *
   * @example
   * ```ts
   * editor.pageToViewport({ x: 100, y: 100 })
   * ```
   *
   * @param point - The point in page space.
   *
   * @public
   */
  pageToViewport(e) {
    const { x: t, y: r, z: i = 1 } = this.getCamera();
    return new R((e.x + t) * i, (e.y + r) * i, e.z ?? 0.5);
  }
  _getCollaboratorsQuery() {
    return this.store.query.records("instance_presence", () => ({
      userId: { neq: this.user.getId() }
    }));
  }
  getCollaborators() {
    const e = this._getCollaboratorsQuery().get();
    return e.length ? [...new Set(e.map((r) => r.userId))].sort().map((r) => Lte(
      e.filter((s) => s.userId === r),
      (s) => s.lastActivityTimestamp ?? 0
    )) : Fd;
  }
  getCollaboratorsOnCurrentPage() {
    const e = this.getCurrentPageId();
    return this.getCollaborators().filter((t) => t.currentPageId === e);
  }
  /**
   * Start viewport-following a user.
   *
   * @example
   * ```ts
   * editor.startFollowingUser(myUserId)
   * ```
   *
   * @param userId - The id of the user to follow.
   *
   * @public
   */
  startFollowingUser(e) {
    this.stopFollowingUser();
    const t = this._getCollaboratorsQuery().get().filter((s) => s.userId === e);
    if (!t.length)
      return console.warn("User not found"), this;
    const r = this.user.getId();
    if (r || console.warn("You should set the userId for the current instance before following a user"), t.some((s) => s.followingUserId === r))
      return this;
    const i = Le("latestLeaderPresence", () => this.getCollaborators().find((s) => s.userId === e));
    return Dl(() => {
      this.updateInstanceState({ followingUserId: e }, { history: "ignore" });
      const s = wc("update current page", () => {
        const d = i.get();
        if (!d) {
          this.stopFollowingUser();
          return;
        }
        d.currentPageId !== this.getCurrentPageId() && this.getPage(d.currentPageId) && this.run(
          () => {
            this.store.put([
              { ...this.getInstanceState(), currentPageId: d.currentPageId }
            ]), this._isLockedOnFollowingUser.set(!0);
          },
          { history: "ignore" }
        );
      }), l = () => {
        s(), this._isLockedOnFollowingUser.set(!1), this.off("frame", c), this.off("stop-following", l);
      }, c = () => {
        if (!i.get()) {
          this.stopFollowingUser();
          return;
        }
        if (this._isLockedOnFollowingUser.get()) return;
        const h = this.user.getAnimationSpeed();
        if (h === 0) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const g = this.getViewportPageBoundsForFollowing();
        if (!g) {
          this.stopFollowingUser();
          return;
        }
        const y = this.getViewportPageBounds(), v = Math.abs(g.minX - y.minX) + Math.abs(g.maxX - y.maxX), w = Math.abs(g.minY - y.minY) + Math.abs(g.maxY - y.maxY);
        if (v < this.options.followChaseViewportSnap && w < this.options.followChaseViewportSnap) {
          this._isLockedOnFollowingUser.set(!0);
          return;
        }
        const C = Do(h * 0.5, 0.1, 0.8), E = new Xe(
          jn(y.minX, g.minX, C),
          jn(y.minY, g.minY, C),
          jn(y.width, g.width, C),
          jn(y.height, g.height, C)
        ), P = new R(
          -E.x,
          -E.y,
          this.getViewportScreenBounds().width / E.width
        );
        this.stopCameraAnimation(), this._setCamera(P);
      };
      this.once("stop-following", l), this.addListener("frame", c), c();
    }), this;
  }
  /**
   * Stop viewport-following a user.
   *
   * @example
   * ```ts
   * editor.stopFollowingUser()
   * ```
   * @public
   */
  stopFollowingUser() {
    return this.run(
      () => {
        this.store.put([this.getCamera()]), this._isLockedOnFollowingUser.set(!1), this.updateInstanceState({ followingUserId: null }), this.emit("stop-following");
      },
      { history: "ignore" }
    ), this;
  }
  /** @internal */
  getUnorderedRenderingShapes(e) {
    const t = [];
    let r = this.options.maxShapesPerPage * 2, i = this.options.maxShapesPerPage;
    const s = this.getErasingShapeIds(), l = (d, h, g) => {
      const y = this.getShape(d);
      if (!y || this.isShapeHidden(y)) return;
      h *= y.opacity;
      let v = !1;
      const w = this.getShapeUtil(y);
      e && (v = !g && s.includes(d), v && (h *= 0.32)), t.push({
        id: d,
        shape: y,
        util: w,
        index: r,
        backgroundIndex: i,
        opacity: h
      }), r += 1, i += 1;
      const C = this.getSortedChildIdsForParent(d);
      if (!C.length) return;
      let E = null;
      w.providesBackgroundForChildren(y) && (E = i, i = r, r += this.options.maxShapesPerPage);
      for (const P of C)
        l(P, h, g || v);
      E !== null && (i = E);
    }, c = e ? [this.getCurrentPage()] : this.getPages();
    for (const d of c)
      for (const h of this.getSortedChildIdsForParent(d.id))
        l(h, 1, !1);
    return t;
  }
  _decayCameraStateTimeout(e) {
    this._cameraStateTimeoutRemaining -= e, !(this._cameraStateTimeoutRemaining > 0) && (this.off("tick", this._decayCameraStateTimeout), this._cameraState.set("idle"));
  }
  _tickCameraState() {
    this._cameraStateTimeoutRemaining = this.options.cameraMovingTimeoutMs, this._cameraState.__unsafe__getWithoutCapture() === "idle" && (this._cameraState.set("moving"), this.on("tick", this._decayCameraStateTimeout));
  }
  /**
   * Whether the camera is moving or idle.
   *
   * @example
   * ```ts
   * editor.getCameraState()
   * ```
   *
   * @public
   */
  getCameraState() {
    return this._cameraState.get();
  }
  getRenderingShapes() {
    return this.getUnorderedRenderingShapes(!0).sort(fne);
  }
  _getAllPagesQuery() {
    return this.store.query.records("page");
  }
  getPages() {
    return Array.from(this._getAllPagesQuery().get()).sort(gs);
  }
  /**
   * The current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPage()
   * ```
   *
   * @public
   */
  getCurrentPage() {
    return this.getPage(this.getCurrentPageId());
  }
  getCurrentPageId() {
    return this.getInstanceState().currentPageId;
  }
  /**
   * Get a page.
   *
   * @example
   * ```ts
   * editor.getPage(myPage.id)
   * editor.getPage(myPage)
   * ```
   *
   * @param page - The page (or the page id) to get.
   *
   * @public
   */
  getPage(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  /**
   * An array of all of the shapes on the current page.
   *
   * @example
   * ```ts
   * editor.getCurrentPageIds()
   * ```
   *
   * @public
   */
  getCurrentPageShapeIds() {
    return this._currentPageShapeIds.get();
  }
  getCurrentPageShapeIdsSorted() {
    return Array.from(this.getCurrentPageShapeIds()).sort();
  }
  /**
   * Get the ids of shapes on a page.
   *
   * @example
   * ```ts
   * const idsOnPage1 = editor.getPageShapeIds('page1')
   * const idsOnPage2 = editor.getPageShapeIds(myPage2)
   * ```
   *
   * @param page - The page (or the page id) to get the shape ids for.
   *
   * @public
   **/
  getPageShapeIds(e) {
    const t = typeof e == "string" ? e : e.id, r = this.store.query.exec("shape", { parentId: { eq: t } });
    return this.getShapeAndDescendantIds(r.map((i) => i.id));
  }
  /**
   * Set the current page.
   *
   * @example
   * ```ts
   * editor.setCurrentPage('page1')
   * editor.setCurrentPage(myPage1)
   * ```
   *
   * @param page - The page (or the page id) to set as the current page.
   *
   * @public
   */
  setCurrentPage(e) {
    const t = typeof e == "string" ? e : e.id;
    return this.store.has(t) ? (this.stopFollowingUser(), this.complete(), this.run(
      () => {
        this.store.put([{ ...this.getInstanceState(), currentPageId: t }]), this.setCamera(this.getCamera());
      },
      { history: "record-preserveRedoStack" }
    )) : (console.error("Tried to set the current page id to a page that doesn't exist."), this);
  }
  /**
   * Update a page.
   *
   * @example
   * ```ts
   * editor.updatePage({ id: 'page2', name: 'Page 2' })
   * ```
   *
   * @param partial - The partial of the shape to update.
   *
   * @public
   */
  updatePage(e) {
    return this.getIsReadonly() ? this : this.getPage(e.id) ? this.run(() => this.store.update(e.id, (r) => ({ ...r, ...e }))) : this;
  }
  /**
   * Create a page.
   *
   * @example
   * ```ts
   * editor.createPage(myPage)
   * editor.createPage({ name: 'Page 2' })
   * ```
   *
   * @param page - The page (or page partial) to create.
   *
   * @public
   */
  createPage(e) {
    return this.run(() => {
      if (this.getIsReadonly() || this.getPages().length >= this.options.maxPages) return;
      const t = this.getPages(), r = Bce(
        e.name ?? "Page 1",
        t.map((l) => l.name)
      );
      let i = e.index;
      (!i || t.some((l) => l.index === i)) && (i = vu(t[t.length - 1].index));
      const s = rl.create({
        meta: {},
        ...e,
        name: r,
        index: i
      });
      this.store.put([s]);
    }), this;
  }
  /**
   * Delete a page.
   *
   * @example
   * ```ts
   * editor.deletePage('page1')
   * ```
   *
   * @param page - The page (or the page id) to delete.
   *
   * @public
   */
  deletePage(e) {
    const t = typeof e == "string" ? e : e.id;
    return this.run(() => {
      if (this.getIsReadonly()) return;
      const r = this.getPages();
      if (r.length === 1) return;
      const i = this.getPage(t);
      if (i) {
        if (t === this.getCurrentPageId()) {
          const s = r.findIndex((c) => c.id === t), l = r[s - 1] ?? r[s + 1];
          this.setCurrentPage(l.id);
        }
        this.store.remove([i.id]);
      }
    }), this;
  }
  /**
   * Duplicate a page.
   *
   * @param page - The page (or the page id) to duplicate. Defaults to the current page.
   * @param createId - The id of the new page. Defaults to a new id.
   *
   * @public
   */
  duplicatePage(e, t = rl.createId()) {
    if (this.getPages().length >= this.options.maxPages) return this;
    const r = typeof e == "string" ? e : e.id, i = this.getPage(r);
    if (!i) return this;
    const s = { ...this.getCamera() }, l = this.getContentFromCurrentPage(this.getSortedChildIdsForParent(i.id));
    return this.run(() => {
      var h;
      const c = this.getPages(), d = Hx(i.index, (h = c[c.indexOf(i) + 1]) == null ? void 0 : h.index);
      if (this.createPage({ name: i.name + " Copy", id: t, index: d }), this.setCurrentPage(t), this.setCamera(s), l)
        return this.putContentOntoCurrentPage(l);
    }), this;
  }
  /**
   * Rename a page.
   *
   * @example
   * ```ts
   * editor.renamePage('page1', 'My Page')
   * ```
   *
   * @param page - The page (or the page id) to rename.
   * @param name - The new name.
   *
   * @public
   */
  renamePage(e, t) {
    const r = typeof e == "string" ? e : e.id;
    return this.getIsReadonly() ? this : (this.updatePage({ id: r, name: t }), this);
  }
  _getAllAssetsQuery() {
    return this.store.query.records("asset");
  }
  /**
   * Get all assets in the editor.
   *
   * @public
   */
  getAssets() {
    return this._getAllAssetsQuery().get();
  }
  /**
   * Create one or more assets.
   *
   * @example
   * ```ts
   * editor.createAssets([...myAssets])
   * ```
   *
   * @param assets - The assets to create.
   *
   * @public
   */
  createAssets(e) {
    return this.getIsReadonly() ? this : e.length <= 0 ? this : (this.run(() => this.store.put(e), { history: "ignore" }), this);
  }
  /**
   * Update one or more assets.
   *
   * @example
   * ```ts
   * editor.updateAssets([{ id: 'asset1', name: 'New name' }])
   * ```
   *
   * @param assets - The assets to update.
   *
   * @public
   */
  updateAssets(e) {
    return this.getIsReadonly() ? this : e.length <= 0 ? this : (this.run(
      () => {
        this.store.put(
          e.map((t) => ({
            ...this.store.get(t.id),
            ...t
          }))
        );
      },
      { history: "ignore" }
    ), this);
  }
  /**
   * Delete one or more assets.
   *
   * @example
   * ```ts
   * editor.deleteAssets(['asset1', 'asset2'])
   * ```
   *
   * @param assets - The assets (or asset ids) to delete.
   *
   * @public
   */
  deleteAssets(e) {
    if (this.getIsReadonly()) return this;
    const t = typeof e[0] == "string" ? e : e.map((r) => r.id);
    return t.length <= 0 ? this : (this.run(() => this.store.remove(t), { history: "ignore" }), this);
  }
  /**
   * Get an asset by its id.
   *
   * @example
   * ```ts
   * editor.getAsset('asset1')
   * ```
   *
   * @param asset - The asset (or asset id) to get.
   *
   * @public
   */
  getAsset(e) {
    return this.store.get(typeof e == "string" ? e : e.id);
  }
  async resolveAssetUrl(e, t) {
    if (!e) return null;
    const r = this.getAsset(e);
    if (!r) return null;
    const { screenScale: i = 1, shouldResolveToOriginal: s = !1 } = t, c = Math.max(0.125, ((g) => Math.pow(2, Math.ceil(Math.log2(g))))(i)), d = "connection" in navigator ? navigator.connection.effectiveType : null, h = this.getInstanceState().devicePixelRatio;
    return await this.store.props.assets.resolve(r, {
      screenScale: i || 1,
      steppedScreenScale: c,
      dpr: h,
      networkEffectiveType: d,
      shouldResolveToOriginal: s
    });
  }
  /**
   * Upload an asset to the store's asset service, returning a URL that can be used to resolve the
   * asset.
   */
  async uploadAsset(e, t, r) {
    return await this.store.props.assets.upload(e, t, r);
  }
  _getShapeGeometryCache() {
    return this.store.createComputedCache(
      "bounds",
      (e) => this.getShapeUtil(e).getGeometry(e),
      (e, t) => e.props === t.props
    );
  }
  /**
   * Get the geometry of a shape.
   *
   * @example
   * ```ts
   * editor.getShapeGeometry(myShape)
   * editor.getShapeGeometry(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the geometry for.
   *
   * @public
   */
  getShapeGeometry(e) {
    return this._getShapeGeometryCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeHandlesCache() {
    return this.store.createComputedCache("handles", (e) => {
      var t, r;
      return (r = (t = this.getShapeUtil(e)).getHandles) == null ? void 0 : r.call(t, e);
    });
  }
  /**
   * Get the handles (if any) for a shape.
   *
   * @example
   * ```ts
   * editor.getShapeHandles(myShape)
   * editor.getShapeHandles(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the handles for.
   * @public
   */
  getShapeHandles(e) {
    return this._getShapeHandlesCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the local transform for a shape as a matrix model. This transform reflects both its
   * translation (x, y) from from either its parent's top left corner, if the shape's parent is
   * another shape, or else from the 0,0 of the page, if the shape's parent is the page; and the
   * shape's rotation.
   *
   * @example
   * ```ts
   * editor.getShapeLocalTransform(myShape)
   * ```
   *
   * @param shape - The shape to get the local transform for.
   *
   * @public
   */
  getShapeLocalTransform(e) {
    const t = typeof e == "string" ? e : e.id, r = this.getShape(t);
    if (!r) throw Error("Editor.getTransform: shape not found");
    return qe.Identity().translate(r.x, r.y).rotate(r.rotation);
  }
  _getShapePageTransformCache() {
    return this.store.createComputedCache("pageTransformCache", (e) => {
      if (ga(e.parentId))
        return this.getShapeLocalTransform(e);
      const t = this._getShapePageTransformCache().get(e.parentId) ?? qe.Identity();
      return qe.Compose(t, this.getShapeLocalTransform(e));
    });
  }
  /**
   * Get the local transform of a shape's parent as a matrix model.
   *
   * @example
   * ```ts
   * editor.getShapeParentTransform(myShape)
   * ```
   *
   * @param shape - The shape (or shape id) to get the parent transform for.
   *
   * @public
   */
  getShapeParentTransform(e) {
    const t = typeof e == "string" ? e : e.id, r = this.getShape(t);
    return !r || ga(r.parentId) ? qe.Identity() : this._getShapePageTransformCache().get(r.parentId) ?? qe.Identity();
  }
  /**
   * Get the transform of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageTransform(myShape)
   * editor.getShapePageTransform(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the page transform for.
   *
   * @public
   */
  getShapePageTransform(e) {
    const t = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(t) ?? qe.Identity();
  }
  _getShapePageBoundsCache() {
    return this.store.createComputedCache("pageBoundsCache", (e) => {
      const t = this._getShapePageTransformCache().get(e.id);
      return t ? Xe.FromPoints(
        qe.applyToPoints(t, this.getShapeGeometry(e).vertices)
      ) : new Xe();
    });
  }
  /**
   * Get the bounds of a shape in the current page space.
   *
   * @example
   * ```ts
   * editor.getShapePageBounds(myShape)
   * editor.getShapePageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the bounds for.
   *
   * @public
   */
  getShapePageBounds(e) {
    return this._getShapePageBoundsCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeClipPathCache() {
    return this.store.createComputedCache("clipPathCache", (e) => {
      const t = this._getShapeMaskCache().get(e.id);
      if (!t) return;
      if (t.length === 0)
        return "polygon(0px 0px, 0px 0px, 0px 0px)";
      const r = this._getShapePageTransformCache().get(e.id);
      return r ? `polygon(${qe.applyToPoints(qe.Inverse(r), t).map((s) => `${s.x}px ${s.y}px`).join(",")})` : void 0;
    });
  }
  /**
   * Get the clip path for a shape.
   *
   * @example
   * ```ts
   * const clipPath = editor.getShapeClipPath(shape)
   * const clipPath = editor.getShapeClipPath(shape.id)
   * ```
   *
   * @param shape - The shape (or shape id) to get the clip path for.
   *
   * @returns The clip path or undefined.
   *
   * @public
   */
  getShapeClipPath(e) {
    return this._getShapeClipPathCache().get(typeof e == "string" ? e : e.id);
  }
  _getShapeMaskCache() {
    return this.store.createComputedCache("pageMaskCache", (e) => {
      if (ga(e.parentId)) return;
      const t = this.getShapeAncestors(e.id).filter(
        (i) => this.isShapeOfType(i, "frame")
      );
      return t.length === 0 ? void 0 : t.map(
        (i) => (
          // Apply the frame transform to the frame outline to get the frame outline in the current page space
          this._getShapePageTransformCache().get(i.id).applyToPoints(this.getShapeGeometry(i).vertices)
        )
      ).reduce((i, s) => {
        if (!(s && i)) return;
        const l = B4(i, s);
        return l ? l.map(R.Cast) : [];
      });
    });
  }
  /**
   * Get the mask (in the current page space) for a shape.
   *
   * @example
   * ```ts
   * const pageMask = editor.getShapeMask(shape.id)
   * ```
   *
   * @param shape - The shape (or the shape id) of the shape to get the mask for.
   *
   * @returns The mask for the shape.
   *
   * @public
   */
  getShapeMask(e) {
    return this._getShapeMaskCache().get(typeof e == "string" ? e : e.id);
  }
  /**
   * Get the bounds of a shape in the current page space, incorporating any masks. For example, if the
   * shape were the child of a frame and was half way out of the frame, the bounds would be the half
   * of the shape that was in the frame.
   *
   * @example
   * ```ts
   * editor.getShapeMaskedPageBounds(myShape)
   * editor.getShapeMaskedPageBounds(myShapeId)
   * ```
   *
   * @param shape - The shape to get the masked bounds for.
   *
   * @public
   */
  getShapeMaskedPageBounds(e) {
    return typeof e != "string" && (e = e.id), this._getShapeMaskedPageBoundsCache().get(e);
  }
  _getShapeMaskedPageBoundsCache() {
    return this.store.createComputedCache("shapeMaskedPageBoundsCache", (e) => {
      const t = this._getShapePageBoundsCache().get(e.id);
      if (!t) return;
      const r = this._getShapeMaskCache().get(e.id);
      if (r) {
        if (r.length === 0) return;
        const { corners: i } = t;
        if (i.every((l, c) => l && R.Equals(l, r[c]))) return t.clone();
        const s = B4(r, i);
        return s ? Xe.FromPoints(s) : void 0;
      }
      return t;
    });
  }
  /**
   * Get the ancestors of a shape.
   *
   * @example
   * ```ts
   * const ancestors = editor.getShapeAncestors(myShape)
   * const ancestors = editor.getShapeAncestors(myShapeId)
   * ```
   *
   * @param shape - The shape (or shape id) to get the ancestors for.
   * @param acc - The accumulator.
   *
   * @public
   */
  getShapeAncestors(e, t = []) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    if (!i) return t;
    const s = i.parentId;
    if (ga(s))
      return t.reverse(), t;
    const l = this.store.get(s);
    return l ? (t.push(l), this.getShapeAncestors(l, t)) : t;
  }
  /**
   * Find the first ancestor matching the given predicate
   *
   * @example
   * ```ts
   * const ancestor = editor.findShapeAncestor(myShape)
   * const ancestor = editor.findShapeAncestor(myShape.id)
   * const ancestor = editor.findShapeAncestor(myShape.id, (shape) => shape.type === 'frame')
   * ```
   *
   * @param shape - The shape to check the ancestors for.
   * @param predicate - The predicate to match.
   *
   * @public
   */
  findShapeAncestor(e, t) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    if (!i) return;
    const s = i.parentId;
    if (ga(s)) return;
    const l = this.getShape(s);
    if (l)
      return t(l) ? l : this.findShapeAncestor(l, t);
  }
  /**
   * Returns true if the the given shape has the given ancestor.
   *
   * @param shape - The shape.
   * @param ancestorId - The id of the ancestor.
   *
   * @public
   */
  hasAncestor(e, t) {
    const r = typeof e == "string" ? e : e == null ? void 0 : e.id, i = r && this.getShape(r);
    return i ? i.parentId === t ? !0 : this.hasAncestor(this.getShapeParent(i), t) : !1;
  }
  /**
   * Get the common ancestor of two or more shapes that matches a predicate.
   *
   * @param shapes - The shapes (or shape ids) to check.
   * @param predicate - The predicate to match.
   */
  findCommonAncestor(e, t) {
    var d;
    if (e.length === 0)
      return;
    const r = typeof e[0] == "string" ? e : e.map((h) => h.id), i = rn(r.map((h) => this.getShape(h)));
    if (i.length === 1) {
      const h = i[0].parentId;
      return ga(h) ? void 0 : t ? (d = this.findShapeAncestor(i[0], t)) == null ? void 0 : d.id : h;
    }
    const [s, ...l] = i;
    let c = this.getShapeParent(s);
    for (; c; ) {
      if (t && !t(c)) {
        c = this.getShapeParent(c);
        continue;
      }
      if (l.every((h) => this.hasAncestor(h, c.id)))
        return c.id;
      c = this.getShapeParent(c);
    }
  }
  isShapeOrAncestorLocked(e) {
    const t = typeof e == "string" ? this.getShape(e) : e;
    return t === void 0 ? !1 : t.isLocked ? !0 : this.isShapeOrAncestorLocked(this.getShapeParent(t));
  }
  _notVisibleShapes() {
    return Yce(this);
  }
  getCulledShapes() {
    const e = this._notVisibleShapes().get(), t = this.getSelectedShapeIds(), r = this.getEditingShapeId(), i = new Set(e);
    return r && i.delete(r), t.forEach((s) => {
      i.delete(s);
    }), i;
  }
  getCurrentPageBounds() {
    let e;
    return this.getCurrentPageShapeIdsSorted().forEach((t) => {
      const r = this.getShapeMaskedPageBounds(t);
      r && (e ? e = e.expand(r) : e = r.clone());
    }), e;
  }
  /**
   * Get the top-most selected shape at the given point, ignoring groups.
   *
   * @param point - The point to check.
   *
   * @returns The top-most selected shape at the given point, or undefined if there is no shape at the point.
   */
  getSelectedShapeAtPoint(e) {
    const t = this.getSelectedShapeIds();
    return this.getCurrentPageShapesSorted().filter((r) => r.type !== "group" && t.includes(r.id)).reverse().find((r) => this.isPointInShape(r, e, { hitInside: !0, margin: 0 }));
  }
  /**
   * Get the shape at the current point.
   *
   * @param point - The point to check.
   * @param opts - Options for the check: `hitInside` to check if the point is inside the shape, `margin` to check if the point is within a margin of the shape, `hitFrameInside` to check if the point is inside the frame, and `filter` to filter the shapes to check.
   *
   * @returns The shape at the given point, or undefined if there is no shape at the point.
   */
  getShapeAtPoint(e, t = {}) {
    const r = this.getZoomLevel(), i = this.getViewportPageBounds(), {
      filter: s,
      margin: l = 0,
      hitLocked: c = !1,
      hitLabels: d = !1,
      hitInside: h = !1,
      hitFrameInside: g = !1
    } = t;
    let y = 1 / 0, v = null, w = 1 / 0, C = null;
    const E = (t.renderingOnly ? this.getCurrentPageRenderingShapesSorted() : this.getCurrentPageShapesSorted()).filter((P) => {
      if (P.isLocked && !c || this.isShapeHidden(P) || this.isShapeOfType(P, "group"))
        return !1;
      const I = this.getShapeMask(P);
      return I && !Ja(e, I) ? !1 : s ? s(P) : !0;
    });
    for (let P = E.length - 1; P >= 0; P--) {
      const I = E[P], k = this.getShapeGeometry(I), L = k instanceof jl, O = this.getPointInShapeSpace(I, e);
      if (this.isShapeOfType(I, "frame") || (this.isShapeOfType(I, "arrow") || this.isShapeOfType(I, "geo") && I.props.fill === "none") && I.props.text.trim()) {
        for (const F of k.children)
          if (F.isLabel && F.isPointInBounds(O))
            return I;
      }
      if (this.isShapeOfType(I, "frame")) {
        const F = k.distanceToPoint(O, h);
        if (Math.abs(F) <= l)
          return C || I;
        if (k.hitTestPoint(O, 0, !0))
          return C || v || (g ? I : void 0);
        continue;
      }
      let z;
      if (L) {
        let F = 1 / 0;
        for (const H of k.children) {
          if (H.isLabel && !d) continue;
          const V = H.distanceToPoint(O, h);
          V < F && (F = V);
        }
        z = F;
      } else
        l === 0 && (k.bounds.w < 1 || k.bounds.h < 1) || k.bounds.containsPoint(O, l) ? z = k.distanceToPoint(O, h) : z = 1 / 0;
      if (k.isClosed) {
        if (z <= l) {
          if (k.isFilled || L && k.children[0].isFilled)
            return C || I;
          if (this.getShapePageBounds(I).contains(i)) continue;
          if (Math.abs(z) < l)
            Math.abs(z) < w && (w = Math.abs(z), C = I);
          else if (!C) {
            const { area: F } = k;
            F < y && (y = F, v = I);
          }
        }
      } else if (z < this.options.hitTestMargin / r)
        return I;
    }
    return C || v || void 0;
  }
  /**
   * Get the shapes, if any, at a given page point.
   *
   * @example
   * ```ts
   * editor.getShapesAtPoint({ x: 100, y: 100 })
   * editor.getShapesAtPoint({ x: 100, y: 100 }, { hitInside: true, exact: true })
   * ```
   *
   * @param point - The page point to test.
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  getShapesAtPoint(e, t = {}) {
    return this.getCurrentPageShapes().filter(
      (r) => !this.isShapeHidden(r) && this.isPointInShape(r, e, t)
    );
  }
  /**
   * Test whether a point (in the current page space) will will a shape. This method takes into account masks,
   * such as when a shape is the child of a frame and is partially clipped by the frame.
   *
   * @example
   * ```ts
   * editor.isPointInShape({ x: 100, y: 100 }, myShape)
   * ```
   *
   * @param shape - The shape to test against.
   * @param point - The page point to test (in the current page space).
   * @param opts - The options for the hit point testing.
   *
   * @public
   */
  isPointInShape(e, t, r = {}) {
    const { hitInside: i = !1, margin: s = 0 } = r, l = typeof e == "string" ? e : e.id, c = this.getShapeMask(l);
    return c && !Ja(t, c) ? !1 : this.getShapeGeometry(l).hitTestPoint(
      this.getPointInShapeSpace(e, t),
      s,
      i
    );
  }
  /**
   * Convert a point in the current page space to a point in the local space of a shape. For example, if a
   * shape's page point were `{ x: 100, y: 100 }`, a page point at `{ x: 110, y: 110 }` would be at
   * `{ x: 10, y: 10 }` in the shape's local space.
   *
   * @example
   * ```ts
   * editor.getPointInShapeSpace(myShape, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInShapeSpace(e, t) {
    const r = typeof e == "string" ? e : e.id;
    return this._getShapePageTransformCache().get(r).clone().invert().applyToPoint(t);
  }
  /**
   * Convert a delta in the current page space to a point in the local space of a shape's parent.
   *
   * @example
   * ```ts
   * editor.getPointInParentSpace(myShape.id, { x: 100, y: 100 })
   * ```
   *
   * @param shape - The shape to get the point in the local space of.
   * @param point - The page point to get in the local space of the shape.
   *
   * @public
   */
  getPointInParentSpace(e, t) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    if (!i) return new R(0, 0);
    if (ga(i.parentId)) return R.From(t);
    const s = this.getShapePageTransform(i.parentId);
    return s ? s.clone().invert().applyToPoint(t) : R.From(t);
  }
  getCurrentPageShapes() {
    return Array.from(this.getCurrentPageShapeIds(), (e) => this.store.get(e));
  }
  getCurrentPageShapesSorted() {
    const e = [], t = this.getSortedChildIdsForParent(this.getCurrentPageId());
    for (let r = 0, i = t.length; r < i; r++)
      IH(this, t[r], e);
    return e;
  }
  getCurrentPageRenderingShapesSorted() {
    const e = this.getCulledShapes();
    return this.getCurrentPageShapesSorted().filter(
      ({ id: t }) => !e.has(t) && !this.isShapeHidden(t)
    );
  }
  isShapeOfType(e, t) {
    const r = typeof e == "string" ? this.getShape(e) : e;
    return r ? r.type === t : !1;
  }
  /**
   * Get a shape by its id.
   *
   * @example
   * ```ts
   * editor.getShape('box1')
   * ```
   *
   * @param shape - The shape (or the id of the shape) to get.
   *
   * @public
   */
  getShape(e) {
    const t = typeof e == "string" ? e : e.id;
    if (va(t))
      return this.store.get(t);
  }
  /**
   * Get the parent shape for a given shape. Returns undefined if the shape is the direct child of
   * the page.
   *
   * @example
   * ```ts
   * editor.getShapeParent(myShape)
   * ```
   *
   * @public
   */
  getShapeParent(e) {
    const t = typeof e == "string" ? e : e == null ? void 0 : e.id;
    if (!t) return;
    const r = this.getShape(t);
    if (!(r === void 0 || !va(r.parentId)))
      return this.store.get(r.parentId);
  }
  /**
   * If siblingShape and targetShape are siblings, this returns targetShape. If targetShape has an
   * ancestor who is a sibling of siblingShape, this returns that ancestor. Otherwise, this returns
   * undefined.
   *
   * @internal
   */
  getShapeNearestSibling(e, t) {
    return t ? t.parentId === e.parentId ? t : this.findShapeAncestor(
      t,
      (i) => i.parentId === e.parentId
    ) : void 0;
  }
  /**
   * Get whether the given shape is the descendant of the given page.
   *
   * @example
   * ```ts
   * editor.isShapeInPage(myShape)
   * editor.isShapeInPage(myShape, 'page1')
   * ```
   *
   * @param shape - The shape to check.
   * @param pageId - The id of the page to check against. Defaults to the current page.
   *
   * @public
   */
  isShapeInPage(e, t = this.getCurrentPageId()) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    if (!i) return !1;
    let s = !1;
    if (i.parentId === t)
      s = !0;
    else {
      let l = this.getShape(i.parentId);
      e: for (; l; ) {
        if (l.parentId === t) {
          s = !0;
          break e;
        }
        l = this.getShape(l.parentId);
      }
    }
    return s;
  }
  /**
   * Get the id of the containing page for a given shape.
   *
   * @param shape - The shape to get the page id for.
   *
   * @returns The id of the page that contains the shape, or undefined if the shape is undefined.
   *
   * @public
   */
  getAncestorPageId(e) {
    const t = typeof e == "string" ? e : e == null ? void 0 : e.id, r = t && this.getShape(t);
    if (r)
      return ga(r.parentId) ? r.parentId : this.getAncestorPageId(this.getShape(r.parentId));
  }
  /**
   * Reparent shapes to a new parent. This operation preserves the shape's current page positions /
   * rotations.
   *
   * @example
   * ```ts
   * editor.reparentShapes([box1, box2], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1')
   * editor.reparentShapes([box1.id, box2.id], 'frame1', 4)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to reparent.
   * @param parentId - The id of the new parent shape.
   * @param insertIndex - The index to insert the children.
   *
   * @public
   */
  reparentShapes(e, t, r) {
    const i = typeof e[0] == "string" ? e : e.map((v) => v.id);
    if (i.length === 0) return this;
    const s = [], l = ga(t) ? qe.Identity() : this.getShapePageTransform(t), c = l.rotation();
    let d = [];
    const h = rn(this.getSortedChildIdsForParent(t).map((v) => this.getShape(v)));
    if (r) {
      const v = h.find((w) => w.index === r);
      if (v) {
        const w = h[h.indexOf(v) + 1];
        w ? d = My(r, w.index, i.length) : d = Sk(r, i.length);
      } else {
        const w = h.sort(gs).find((C) => C.index > r);
        w ? d = My(r, w.index, i.length) : d = Sk(r, i.length);
      }
    } else {
      const v = h.length && h[h.length - 1];
      d = v ? Sk(v.index, i.length) : Vx(i.length);
    }
    const g = l.clone().invert(), y = rn(i.map((v) => this.getShape(v)));
    return this.run(
      () => {
        for (let v = 0; v < y.length; v++) {
          const w = y[v], C = this.getShapePageTransform(w);
          if (!C) continue;
          const E = C.point();
          if (!E) continue;
          const P = g.applyToPoint(E), I = C.rotation() - c;
          s.push({
            id: w.id,
            type: w.type,
            parentId: t,
            x: P.x,
            y: P.y,
            rotation: I,
            index: d[v]
          });
        }
        this.updateShapes(s);
      },
      { ignoreShapeLock: !0 }
    ), this;
  }
  /**
   * Get the index above the highest child of a given parent.
   *
   * @param parent - The parent (or the id) of the parent.
   *
   * @returns The index.
   *
   * @public
   */
  getHighestIndexForParent(e) {
    const t = typeof e == "string" ? e : e.id, r = this._parentIdsToChildIds.get()[t];
    if (!r || r.length === 0)
      return "a1";
    const i = this.getShape(r[r.length - 1]);
    return vu(i.index);
  }
  /**
   * Get an array of all the children of a shape.
   *
   * @example
   * ```ts
   * editor.getSortedChildIdsForParent('frame1')
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   *
   * @public
   */
  getSortedChildIdsForParent(e) {
    const t = typeof e == "string" ? e : e.id, r = this._parentIdsToChildIds.get()[t];
    return r || Fd;
  }
  /**
   * Run a visitor function for all descendants of a shape.
   *
   * @example
   * ```ts
   * editor.visitDescendants('frame1', myCallback)
   * ```
   *
   * @param parent - The parent (or the id) of the parent shape.
   * @param visitor - The visitor function.
   *
   * @public
   */
  visitDescendants(e, t) {
    const r = typeof e == "string" ? e : e.id, i = this.getSortedChildIdsForParent(r);
    for (const s of i)
      t(s) !== !1 && this.visitDescendants(s, t);
    return this;
  }
  /**
   * Get the shape ids of all descendants of the given shapes (including the shapes themselves). IDs are returned in z-index order.
   *
   * @param ids - The ids of the shapes to get descendants of.
   *
   * @returns The descendant ids.
   *
   * @public
   */
  getShapeAndDescendantIds(e) {
    const t = /* @__PURE__ */ new Set();
    for (const r of e.map((i) => this.getShape(i)).sort(gs))
      t.add(r.id), this.visitDescendants(r, (i) => {
        t.add(i);
      });
    return t;
  }
  /**
   * Get the shape that some shapes should be dropped on at a given point.
   *
   * @param point - The point to find the parent for.
   * @param droppingShapes - The shapes that are being dropped.
   *
   * @returns The shape to drop on.
   *
   * @public
   */
  getDroppingOverShape(e, t = []) {
    const r = this.getCurrentPageShapesSorted();
    for (let i = r.length - 1; i >= 0; i--) {
      const s = r[i];
      if (
        // ignore hidden shapes
        this.isShapeHidden(s) || // don't allow dropping on selected shapes
        this.getSelectedShapeIds().includes(s.id) || // only allow shapes that can receive children
        !this.getShapeUtil(s).canDropShapes(s, t) || // don't allow dropping a shape on itself or one of it's children
        t.find((c) => c.id === s.id || this.hasAncestor(s, c.id))
      )
        continue;
      const l = this.getShapeMaskedPageBounds(s.id);
      if (l && l.containsPoint(e) && this.getShapeGeometry(s).hitTestPoint(this.getPointInShapeSpace(s, e), 0, !0))
        return s;
    }
  }
  /**
   * Get the shape that should be selected when you click on a given shape, assuming there is
   * nothing already selected. It will not return anything higher than or including the current
   * focus layer.
   *
   * @param shape - The shape to get the outermost selectable shape for.
   * @param filter - A function to filter the selectable shapes.
   *
   * @returns The outermost selectable shape.
   *
   * @public
   */
  getOutermostSelectableShape(e, t) {
    const r = typeof e == "string" ? e : e.id, i = this.getShape(r);
    let s = i, l = i;
    const c = this.getFocusedGroup();
    for (; l; ) {
      if (this.isShapeOfType(l, "group") && (c == null ? void 0 : c.id) !== l.id && !this.hasAncestor(c, l.id) && ((t == null ? void 0 : t(l)) ?? !0))
        s = l;
      else if ((c == null ? void 0 : c.id) === l.id)
        break;
      l = this.getShapeParent(l);
    }
    return s;
  }
  _getBindingsIndexCache() {
    const e = Gce(this);
    return this.store.createComputedCache("bindingsIndex", (t) => e.get().get(t.id));
  }
  /**
   * Get a binding from the store by its ID if it exists.
   */
  getBinding(e) {
    return this.store.get(e);
  }
  /**
   * Get all bindings of a certain type _from_ a particular shape. These are the bindings whose
   * `fromId` matched the shape's ID.
   */
  getBindingsFromShape(e, t) {
    const r = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(r).filter(
      (i) => i.fromId === r && i.type === t
    );
  }
  /**
   * Get all bindings of a certain type _to_ a particular shape. These are the bindings whose
   * `toId` matches the shape's ID.
   */
  getBindingsToShape(e, t) {
    const r = typeof e == "string" ? e : e.id;
    return this.getBindingsInvolvingShape(r).filter(
      (i) => i.toId === r && i.type === t
    );
  }
  /**
   * Get all bindings involving a particular shape. This includes bindings where the shape is the
   * `fromId` or `toId`. If a type is provided, only bindings of that type are returned.
   */
  getBindingsInvolvingShape(e, t) {
    const r = typeof e == "string" ? e : e.id, i = this._getBindingsIndexCache().get(r) ?? Fd;
    return t ? i.filter((s) => s.type === t) : i;
  }
  /**
   * Create bindings from a list of partial bindings. You can omit the ID and most props of a
   * binding, but the `type`, `toId`, and `fromId` must all be provided.
   */
  createBindings(e) {
    const t = [];
    for (const r of e) {
      const i = this.getShape(r.fromId), s = this.getShape(r.toId);
      if (!i || !s || !this.canBindShapes({ fromShape: i, toShape: s, binding: r })) continue;
      const c = this.getBindingUtil(r.type).getDefaultProps(), d = this.store.schema.types.binding.create({
        ...r,
        id: r.id ?? qp(),
        props: {
          ...c,
          ...r.props
        }
      });
      t.push(d);
    }
    return this.store.put(t), this;
  }
  /**
   * Create a single binding from a partial. You can omit the ID and most props of a binding, but
   * the `type`, `toId`, and `fromId` must all be provided.
   */
  createBinding(e) {
    return this.createBindings([e]);
  }
  /**
   * Update bindings from a list of partial bindings. Each partial must include an ID, which will
   * be used to match the binding to it's existing record. If there is no existing record, that
   * binding is skipped. The changes from the partial are merged into the existing record.
   */
  updateBindings(e) {
    const t = [];
    for (const r of e) {
      if (!r) continue;
      const i = this.getBinding(r.id);
      if (!i) continue;
      const s = hu(i, r);
      if (s === i) continue;
      const l = this.getShape(s.fromId), c = this.getShape(s.toId);
      !l || !c || this.canBindShapes({ fromShape: l, toShape: c, binding: s }) && t.push(s);
    }
    return this.store.put(t), this;
  }
  /**
   * Update a binding from a partial binding. Each partial must include an ID, which will be used
   * to match the binding to it's existing record. If there is no existing record, that binding is
   * skipped. The changes from the partial are merged into the existing record.
   */
  updateBinding(e) {
    return this.updateBindings([e]);
  }
  /**
   * Delete several bindings by their IDs. If a binding ID doesn't exist, it's ignored.
   */
  deleteBindings(e, { isolateShapes: t = !1 } = {}) {
    const r = e.map((i) => typeof i == "string" ? i : i.id);
    return t ? this.store.atomic(() => {
      var i, s;
      for (const l of r) {
        const c = this.getBinding(l);
        if (!c) continue;
        const d = this.getBindingUtil(c);
        (i = d.onBeforeIsolateFromShape) == null || i.call(d, { binding: c, removedShape: this.getShape(c.toId) }), (s = d.onBeforeIsolateToShape) == null || s.call(d, { binding: c, removedShape: this.getShape(c.fromId) }), this.store.remove([l]);
      }
    }) : this.store.remove(r), this;
  }
  /**
   * Delete a binding by its ID. If the binding doesn't exist, it's ignored.
   */
  deleteBinding(e, t) {
    return this.deleteBindings([e], t);
  }
  canBindShapes({
    fromShape: e,
    toShape: t,
    binding: r
  }) {
    const i = typeof e == "string" ? e : e.type, s = typeof t == "string" ? t : t.type, l = typeof r == "string" ? r : r.type, c = { fromShapeType: i, toShapeType: s, bindingType: l };
    return i === s ? this.getShapeUtil(i).canBind(c) : this.getShapeUtil(i).canBind(c) && this.getShapeUtil(s).canBind(c);
  }
  /* -------------------- Commands -------------------- */
  /**
   * Rotate shapes by a delta in radians.
   *
   * @example
   * ```ts
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI)
   * editor.rotateShapesBy(editor.getSelectedShapeIds(), Math.PI / 2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param delta - The delta in radians to apply to the selection rotation.
   * @param opts - The options for the rotation.
   */
  rotateShapesBy(e, t, r) {
    const i = typeof e[0] == "string" ? e : e.map((l) => l.id);
    if (i.length <= 0) return this;
    const s = t9({ editor: this, ids: i });
    return s ? (bC({
      delta: t,
      snapshot: s,
      editor: this,
      stage: "one-off",
      centerOverride: r == null ? void 0 : r.center
    }), this) : this;
  }
  getChangesToTranslateShape(e, t) {
    var s, l, c;
    let r = e;
    const i = this.getShapeUtil(e);
    return r = hu(
      r,
      ((s = i.onTranslateStart) == null ? void 0 : s.call(i, r)) ?? void 0
    ), r = hu(r, {
      id: e.id,
      type: e.type,
      x: t.x,
      y: t.y
    }), r = hu(
      r,
      ((l = i.onTranslate) == null ? void 0 : l.call(i, e, r)) ?? void 0
    ), r = hu(
      r,
      ((c = i.onTranslateEnd) == null ? void 0 : c.call(i, e, r)) ?? void 0
    ), r;
  }
  /**
   * Move shapes by a delta.
   *
   * @example
   * ```ts
   * editor.nudgeShapes(['box1', 'box2'], { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param offset - The offset to apply to the shapes.
   */
  nudgeShapes(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id);
    if (r.length <= 0) return this;
    const i = [];
    for (const s of r) {
      const l = this.getShape(s), c = R.From(t), d = this.getShapeParentTransform(l);
      d && c.rot(-d.rotation()), i.push(this.getChangesToTranslateShape(l, c.add(l)));
    }
    return this.updateShapes(i), this;
  }
  /**
   * Duplicate shapes.
   *
   * @example
   * ```ts
   * editor.duplicateShapes(['box1', 'box2'], { x: 8, y: 8 })
   * editor.duplicateShapes(editor.getSelectedShapes(), { x: 8, y: 8 })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to duplicate.
   * @param offset - The offset (in pixels) to apply to the duplicated shapes.
   *
   * @public
   */
  duplicateShapes(e, t) {
    return this.run(() => {
      const r = typeof e[0] == "string" ? e : e.map((v) => v.id);
      if (r.length <= 0) return this;
      const i = new Set(r), s = this.getShapeAndDescendantIds(r), l = [...s].reverse(), c = /* @__PURE__ */ new Map();
      for (const v of s)
        c.set(v, Sr());
      const { shapesToCreateWithOriginals: d, bindingsToCreate: h } = rU(
        this,
        s,
        (v) => {
          const w = [];
          for (const E of v) {
            const P = this.getBinding(E);
            if (!P) continue;
            const I = qp();
            w.push({
              ...P,
              id: I,
              fromId: Sa(c.get(P.fromId)),
              toId: Sa(c.get(P.toId))
            });
          }
          const C = [];
          for (const E of l) {
            const P = Sa(c.get(E)), I = this.getShape(E);
            if (!I) continue;
            let k = 0, L = 0;
            if (t && i.has(E)) {
              const O = this.getShapeParentTransform(I), z = new R(t.x, t.y).rot(-O.rotation());
              k = z.x, L = z.y;
            }
            C.push({
              shape: {
                ...I,
                id: P,
                x: I.x + k,
                y: I.y + L,
                // Use a dummy index for now, it will get updated outside of the `withIsolatedShapes`
                index: "a1",
                parentId: c.get(I.parentId) ?? I.parentId
              },
              originalShape: I
            });
          }
          return { shapesToCreateWithOriginals: C, bindingsToCreate: w };
        }
      );
      d.forEach(({ shape: v, originalShape: w }) => {
        const C = w.parentId, E = this.getSortedChildIdsForParent(C), P = E.indexOf(w.id), I = E[P + 1], k = I ? this.getShape(I) : void 0, L = Hx(w.index, k == null ? void 0 : k.index);
        v.index = L;
      });
      const g = d.map(({ shape: v }) => v);
      if (g.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage) {
        G1(this);
        return;
      }
      if (this.createShapes(g), this.createBindings(h), this.setSelectedShapes(rn(r.map((v) => c.get(v)))), t !== void 0) {
        const v = this.getSelectionPageBounds(), w = this.getViewportPageBounds();
        v && !w.contains(v) && this.centerOnPoint(v.center, {
          animation: { duration: this.options.animationMediumMs }
        });
      }
    }), this;
  }
  /**
   * Move shapes to page.
   *
   * @example
   * ```ts
   * editor.moveShapesToPage(['box1', 'box2'], 'page1')
   * ```
   *
   * @param shapes - The shapes (or shape ids) of the shapes to move.
   * @param pageId - The id of the page where the shapes will be moved.
   *
   * @public
   */
  moveShapesToPage(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((c) => c.id);
    if (r.length === 0) return this;
    if (this.getIsReadonly()) return this;
    const i = this.getCurrentPageId();
    if (t === i) return this;
    if (!this.store.has(t)) return this;
    const s = this.getContentFromCurrentPage(r);
    if (!s) return this;
    if (this.getPageShapeIds(t).size + s.shapes.length > this.options.maxShapesPerPage)
      return G1(this, t), this;
    const l = this.getCamera().z;
    return this.run(() => {
      this.deleteShapes(r), this.setCurrentPage(t), this.setFocusedGroup(null), this.selectNone(), this.putContentOntoCurrentPage(s, {
        select: !0,
        preserveIds: !0,
        preservePosition: !0
      }), this.setCamera({ ...this.getCamera(), z: l }), this.centerOnPoint(this.getSelectionRotatedPageBounds().center);
    }), this;
  }
  /**
   * Toggle the lock state of one or more shapes. If there is a mix of locked and unlocked shapes, all shapes will be locked.
   *
   * @param shapes - The shapes (or shape ids) to toggle.
   *
   * @public
   */
  toggleLock(e) {
    const t = typeof e[0] == "string" ? e : e.map((l) => l.id);
    if (this.getIsReadonly() || t.length === 0) return this;
    let r = !0, i = !0;
    const s = [];
    for (const l of t) {
      const c = this.getShape(l);
      c && (s.push(c), c.isLocked ? i = !1 : r = !1);
    }
    return this.run(() => {
      i ? (this.updateShapes(
        s.map((l) => ({ id: l.id, type: l.type, isLocked: !0 }))
      ), this.setSelectedShapes([])) : r ? this.updateShapes(
        s.map((l) => ({ id: l.id, type: l.type, isLocked: !1 }))
      ) : this.updateShapes(
        s.map((l) => ({ id: l.id, type: l.type, isLocked: !0 }))
      );
    }), this;
  }
  /**
   * Send shapes to the back of the page's object list.
   *
   * @example
   * ```ts
   * editor.sendToBack(['id1', 'id2'])
   * editor.sendToBack(box1, box2)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  sendToBack(e) {
    const t = typeof e[0] == "string" ? e : e.map((i) => i.id), r = K1(this, "toBack", t, {
      considerAllShapes: !0
    });
    return r && this.updateShapes(r), this;
  }
  /**
   * Send shapes backward in the page's object list.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'])
   * editor.sendBackward([box1, box2])
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.sendBackward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the backward operation.
   *
   * @public
   */
  sendBackward(e, t = {}) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = K1(this, "backward", r, t);
    return i && this.updateShapes(i), this;
  }
  /**
   * Bring shapes forward in the page's object list.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'])
   * editor.bringForward(box1,  box2)
   * ```
   *
   * By default, the operation will only consider overlapping shapes.
   * To consider all shapes, pass `{ considerAllShapes: true }` in the options.
   *
   * @example
   * ```ts
   * editor.bringForward(['id1', 'id2'], { considerAllShapes: true })
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   * @param opts - The options for the forward operation.
   *
   * @public
   */
  bringForward(e, t = {}) {
    const r = typeof e[0] == "string" ? e : e.map((s) => s.id), i = K1(this, "forward", r, t);
    return i && this.updateShapes(i), this;
  }
  /**
   * Bring shapes to the front of the page's object list.
   *
   * @example
   * ```ts
   * editor.bringToFront(['id1', 'id2'])
   * editor.bringToFront([box1, box2])
   * ```
   *
   * @param shapes - The shapes (or shape ids) to move.
   *
   * @public
   */
  bringToFront(e) {
    const t = typeof e[0] == "string" ? e : e.map((i) => i.id), r = K1(this, "toFront", t);
    return r && this.updateShapes(r), this;
  }
  /**
   * Flip shape positions.
   *
   * @example
   * ```ts
   * editor.flipShapes([box1, box2], 'horizontal', 32)
   * editor.flipShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The ids of the shapes to flip.
   * @param operation - Whether to flip horizontally or vertically.
   *
   * @public
   */
  flipShapes(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((l) => l.id);
    if (this.getIsReadonly()) return this;
    let i = rn(r.map((l) => this.getShape(l)));
    if (!i.length) return this;
    i = rn(
      i.map((l) => this.isShapeOfType(l, "group") ? this.getSortedChildIdsForParent(l.id).map((c) => this.getShape(c)) : l).flat()
    );
    const s = Xe.Common(
      rn(i.map((l) => this.getShapePageBounds(l)))
    ).center;
    return this.run(() => {
      for (const l of i) {
        const c = this.getShapeGeometry(l).bounds, d = this.getShapePageTransform(l.id);
        d && this.resizeShape(
          l.id,
          { x: t === "horizontal" ? -1 : 1, y: t === "vertical" ? -1 : 1 },
          {
            initialBounds: c,
            initialPageTransform: d,
            initialShape: l,
            mode: "scale_shape",
            isAspectRatioLocked: this.getShapeUtil(l).isAspectRatioLocked(l),
            scaleOrigin: s,
            scaleAxisRotation: 0
          }
        );
      }
    }), this;
  }
  /**
   * Stack shape.
   *
   * @example
   * ```ts
   * editor.stackShapes([box1, box2], 'horizontal', 32)
   * editor.stackShapes(editor.getSelectedShapeIds(), 'horizontal', 32)
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stack.
   * @param operation - Whether to stack horizontally or vertically.
   * @param gap - The gap to leave between shapes.
   *
   * @public
   */
  stackShapes(e, t, r) {
    const i = typeof e[0] == "string" ? e : e.map((E) => E.id);
    if (this.getIsReadonly()) return this;
    const s = i.map((E) => this.getShape(E)).filter((E) => E ? this.getShapeUtil(E).canBeLaidOut(E) : !1), l = s.length;
    if (r === 0 && l < 3 || l < 2) return this;
    const c = Object.fromEntries(
      s.map((E) => [E.id, this.getShapePageBounds(E)])
    );
    let d, h, g, y;
    t === "horizontal" ? (d = "x", h = "minX", g = "maxX", y = "width") : (d = "y", h = "minY", g = "maxY", y = "height");
    let v;
    if (r === 0) {
      const E = [];
      s.sort((I, k) => c[I.id][h] - c[k.id][h]);
      for (let I = 0; I < l - 1; I++) {
        const k = s[I], L = s[I + 1], O = c[k.id], F = c[L.id][h] - O[g], H = E.find((V) => V.gap === F);
        H ? H.count++ : E.push({ gap: F, count: 1 });
      }
      let P = 0;
      E.forEach((I) => {
        I.count > P && (P = I.count, v = I.gap);
      }), P === 1 && (v = Math.max(0, E.reduce((I, k) => I + k.gap * k.count, 0) / (l - 1)));
    } else
      v = r;
    const w = [];
    let C = c[s[0].id][g];
    return s.forEach((E, P) => {
      var z, F;
      if (P === 0) return;
      const I = { x: 0, y: 0 };
      I[d] = C + v - c[E.id][d];
      const k = this.getShapeParent(E), L = k ? R.Rot(I, -this.getShapePageTransform(k).decompose().rotation) : I, O = (F = (z = this.getShapeUtil(E)).onTranslateStart) == null ? void 0 : F.call(z, E);
      w.push(
        O ? {
          ...O,
          [d]: E[d] + L[d]
        } : {
          id: E.id,
          type: E.type,
          [d]: E[d] + L[d]
        }
      ), C += c[E.id][y] + v;
    }), this.updateShapes(w), this;
  }
  /**
   * Pack shapes into a grid centered on their current position. Based on potpack (https://github.com/mapbox/potpack).
   *
   * @example
   * ```ts
   * editor.packShapes([box1, box2], 32)
   * editor.packShapes(editor.getSelectedShapeIds(), 32)
   * ```
   *
   *
   * @param shapes - The shapes (or shape ids) to pack.
   * @param gap - The padding to apply to the packed shapes. Defaults to 16.
   */
  packShapes(e, t) {
    var F, H;
    const r = typeof e[0] == "string" ? e : e.map((V) => V.id);
    if (this.getIsReadonly()) return this;
    if (r.length < 2) return this;
    const i = r.map((V) => this.getShape(V)).filter((V) => V ? this.getShapeUtil(V).canBeLaidOut(V) : !1), s = {}, l = {};
    let c, d, h = 0;
    for (let V = 0; V < i.length; V++)
      c = i[V], d = this.getShapePageBounds(c), s[c.id] = d, l[c.id] = d.clone(), h += d.width * d.height;
    const g = Xe.Common(rn(Object.values(s))), y = g.width;
    i.sort((V, re) => s[re.id].height - s[V.id].height);
    const v = Math.max(Math.ceil(Math.sqrt(h / 0.95)), y), w = [new Xe(g.x, g.y, v, 1 / 0)];
    let C = 0, E = 0, P, I;
    for (let V = 0; V < i.length; V++) {
      c = i[V], d = l[c.id];
      for (let re = w.length - 1; re >= 0; re--)
        if (P = w[re], !(d.width > P.width || d.height > P.height)) {
          d.x = P.x, d.y = P.y, E = Math.max(E, d.maxY), C = Math.max(C, d.maxX), d.width === P.width && d.height === P.height ? (I = w.pop(), re < w.length && (w[re] = I)) : d.height === P.height ? (P.x += d.width + t, P.width -= d.width + t) : d.width === P.width ? (P.y += d.height + t, P.height -= d.height + t) : (w.push(
            new Xe(
              P.x + (d.width + t),
              P.y,
              P.width - (d.width + t),
              d.height
            )
          ), P.y += d.height + t, P.height -= d.height + t);
          break;
        }
    }
    const k = Xe.Common(Object.values(l)), L = R.Sub(g.center, k.center);
    let O;
    const z = [];
    for (let V = 0; V < i.length; V++) {
      c = i[V], d = s[c.id], O = l[c.id];
      const re = R.Sub(O.point, d.point).add(L), q = this.getShapeParentTransform(c);
      q && re.rot(-q.rotation());
      const J = {
        id: c.id,
        type: c.type,
        x: c.x + re.x,
        y: c.y + re.y
      }, ie = (H = (F = this.getShapeUtil(c)).onTranslateStart) == null ? void 0 : H.call(F, {
        ...c,
        ...J
      });
      ie ? z.push({ ...J, ...ie }) : z.push(J);
    }
    return z.length && this.updateShapes(z), this;
  }
  /**
   * Align shape positions.
   *
   * @example
   * ```ts
   * editor.alignShapes([box1, box2], 'left')
   * editor.alignShapes(editor.getSelectedShapeIds(), 'left')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to align.
   * @param operation - The align operation to apply.
   *
   * @public
   */
  alignShapes(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((d) => d.id);
    if (this.getIsReadonly()) return this;
    if (r.length < 2) return this;
    const i = rn(r.map((d) => this.getShape(d))), s = Object.fromEntries(
      i.map((d) => [d.id, this.getShapePageBounds(d)])
    ), l = Xe.Common(rn(Object.values(s))), c = [];
    return i.forEach((d) => {
      const h = s[d.id];
      if (!h) return;
      const g = { x: 0, y: 0 };
      switch (t) {
        case "top": {
          g.y = l.minY - h.minY;
          break;
        }
        case "center-vertical": {
          g.y = l.midY - h.minY - h.height / 2;
          break;
        }
        case "bottom": {
          g.y = l.maxY - h.minY - h.height;
          break;
        }
        case "left": {
          g.x = l.minX - h.minX;
          break;
        }
        case "center-horizontal": {
          g.x = l.midX - h.minX - h.width / 2;
          break;
        }
        case "right": {
          g.x = l.maxX - h.minX - h.width;
          break;
        }
      }
      const y = this.getShapeParent(d), v = y ? R.Rot(g, -this.getShapePageTransform(y).decompose().rotation) : g;
      c.push(this.getChangesToTranslateShape(d, R.Add(d, v)));
    }), this.updateShapes(c), this;
  }
  /**
   * Distribute shape positions.
   *
   * @example
   * ```ts
   * editor.distributeShapes([box1, box2], 'horizontal')
   * editor.distributeShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to distribute.
   * @param operation - Whether to distribute shapes horizontally or vertically.
   *
   * @public
   */
  distributeShapes(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((k) => k.id);
    if (this.getIsReadonly()) return this;
    if (r.length < 3) return this;
    const i = r.length, s = rn(r.map((k) => this.getShape(k))), l = Object.fromEntries(
      s.map((k) => [k.id, this.getShapePageBounds(k)])
    );
    let c, d, h, g, y;
    t === "horizontal" ? (c = "x", d = "minX", h = "maxX", g = "midX", y = "width") : (c = "y", d = "minY", h = "maxY", g = "midY", y = "height");
    const v = [], w = s.sort(
      (k, L) => l[k.id][d] - l[L.id][d]
    )[0], C = s.sort((k, L) => l[L.id][h] - l[k.id][h])[0], E = l[w.id][g], P = (l[C.id][g] - E) / (i - 1), I = E + P;
    return s.filter((k) => k !== w && k !== C).sort((k, L) => l[k.id][g] - l[L.id][g]).forEach((k, L) => {
      const O = { x: 0, y: 0 };
      O[c] = I + P * L - l[k.id][y] / 2 - l[k.id][c];
      const z = this.getShapeParent(k), F = z ? R.Rot(O, -this.getShapePageTransform(z).rotation()) : O;
      v.push(this.getChangesToTranslateShape(k, R.Add(k, F)));
    }), this.updateShapes(v), this;
  }
  /**
   * Stretch shape sizes and positions to fill their common bounding box.
   *
   * @example
   * ```ts
   * editor.stretchShapes([box1, box2], 'horizontal')
   * editor.stretchShapes(editor.getSelectedShapeIds(), 'horizontal')
   * ```
   *
   * @param shapes - The shapes (or shape ids) to stretch.
   * @param operation - Whether to stretch shapes horizontally or vertically.
   *
   * @public
   */
  stretchShapes(e, t) {
    const r = typeof e[0] == "string" ? e : e.map((d) => d.id);
    if (this.getIsReadonly()) return this;
    if (r.length < 2) return this;
    const i = rn(r.map((d) => this.getShape(d))), s = Object.fromEntries(r.map((d) => [d, this.getShapeGeometry(d).bounds])), l = Object.fromEntries(r.map((d) => [d, this.getShapePageBounds(d)])), c = Xe.Common(rn(Object.values(l)));
    switch (t) {
      case "vertical": {
        this.run(() => {
          for (const d of i) {
            if (this.getShapePageTransform(d).rotation() % hr) continue;
            const g = s[d.id], y = l[d.id], v = new R(0, c.minY - y.minY), w = this.getShapeParentTransform(d);
            w && v.rot(-w.rotation());
            const { x: C, y: E } = R.Add(v, d);
            this.updateShapes([{ id: d.id, type: d.type, x: C, y: E }]);
            const P = new R(1, c.height / y.height);
            this.resizeShape(d.id, P, {
              initialBounds: g,
              scaleOrigin: new R(y.center.x, c.minY),
              isAspectRatioLocked: this.getShapeUtil(d).isAspectRatioLocked(d),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
      case "horizontal": {
        this.run(() => {
          for (const d of i) {
            const h = s[d.id], g = l[d.id];
            if (this.getShapePageTransform(d).rotation() % hr) continue;
            const v = new R(c.minX - g.minX, 0), w = this.getShapeParentTransform(d);
            w && v.rot(-w.rotation());
            const { x: C, y: E } = R.Add(v, d);
            this.updateShapes([{ id: d.id, type: d.type, x: C, y: E }]);
            const P = new R(c.width / g.width, 1);
            this.resizeShape(d.id, P, {
              initialBounds: h,
              scaleOrigin: new R(c.minX, g.center.y),
              isAspectRatioLocked: this.getShapeUtil(d).isAspectRatioLocked(d),
              scaleAxisRotation: 0
            });
          }
        });
        break;
      }
    }
    return this;
  }
  /**
   * Resize a shape.
   *
   * @param shape - The shape (or the shape id of the shape) to resize.
   * @param scale - The scale factor to apply to the shape.
   * @param opts - Additional options.
   *
   * @public
   */
  resizeShape(e, t, r = {}) {
    var w, C, E;
    const i = typeof e == "string" ? e : e.id;
    if (this.getIsReadonly()) return this;
    Number.isFinite(t.x) || (t = new R(1, t.y)), Number.isFinite(t.y) || (t = new R(t.x, 1));
    const s = r.initialShape ?? this.getShape(i);
    if (!s) return this;
    const l = r.scaleOrigin ?? ((w = this.getShapePageBounds(i)) == null ? void 0 : w.center);
    if (!l) return this;
    const c = r.initialPageTransform ? qe.Cast(r.initialPageTransform) : this.getShapePageTransform(i);
    if (!c) return this;
    const d = c.rotation();
    if (d == null) return this;
    const h = r.scaleAxisRotation ?? d, g = r.initialBounds ?? this.getShapeGeometry(i).bounds;
    if (!g) return this;
    const y = r.isAspectRatioLocked ?? this.getShapeUtil(s).isAspectRatioLocked(s);
    if (!Y8(d, h))
      return this._resizeUnalignedShape(i, t, {
        ...r,
        initialBounds: g,
        scaleOrigin: l,
        scaleAxisRotation: h,
        initialPageTransform: c,
        isAspectRatioLocked: y,
        initialShape: s
      });
    const v = this.getShapeUtil(s);
    if (y && (Math.abs(t.x) > Math.abs(t.y) ? t = new R(t.x, Math.sign(t.y) * Math.abs(t.x)) : t = new R(Math.sign(t.x) * Math.abs(t.y), t.y)), v.onResize && v.canResize(s)) {
      const P = this._scalePagePoint(
        qe.applyToPoint(c, new R(0, 0)),
        l,
        t,
        h
      ), I = this.getPointInParentSpace(s.id, P), k = new R(t.x, t.y), L = fh(
        (d - h) % Math.PI,
        0
      );
      k.x = L ? t.x : t.y, k.y = L ? t.y : t.x;
      const O = qe.applyToPoint(c, new R()), { x: z, y: F } = this.getPointInParentSpace(s.id, O);
      let H = s;
      r.skipStartAndEndCallbacks || (H = hu(
        s,
        ((C = v.onResizeStart) == null ? void 0 : C.call(v, s)) ?? void 0
      )), H = hu(H, {
        id: i,
        type: s.type,
        x: I.x,
        y: I.y,
        ...v.onResize(
          { ...s, x: z, y: F },
          {
            newPoint: I,
            handle: r.dragHandle ?? "bottom_right",
            // don't set isSingle to true for children
            mode: r.mode ?? "scale_shape",
            scaleX: k.x,
            scaleY: k.y,
            initialBounds: g,
            initialShape: s
          }
        )
      }), r.skipStartAndEndCallbacks || (H = hu(
        H,
        ((E = v.onResizeEnd) == null ? void 0 : E.call(v, s, H)) ?? void 0
      )), this.updateShapes([H]);
    } else {
      const P = qe.applyToPoint(c, g.center), I = this._scalePagePoint(
        P,
        l,
        t,
        h
      ), k = this.getPointInParentSpace(
        s.id,
        P
      ), L = this.getPointInParentSpace(s.id, I), O = R.Sub(L, k);
      this.updateShapes([
        {
          id: i,
          type: s.type,
          x: s.x + O.x,
          y: s.y + O.y
        }
      ]);
    }
    return this;
  }
  /** @internal */
  _scalePagePoint(e, t, r, i) {
    const s = R.RotWith(e, t, -i).sub(t), l = R.MulV(s, r);
    return R.Add(l, t).rotWith(
      t,
      i
    );
  }
  /** @internal */
  _resizeUnalignedShape(e, t, r) {
    const { type: i } = r.initialShape, s = new R(t.x, t.y);
    if (Math.abs(t.x) > Math.abs(t.y) ? s.x = Math.sign(t.x) * Math.abs(t.y) : s.y = Math.sign(t.y) * Math.abs(t.x), this.resizeShape(e, s, {
      initialShape: r.initialShape,
      initialBounds: r.initialBounds,
      isAspectRatioLocked: r.isAspectRatioLocked
    }), Math.sign(t.x) * Math.sign(t.y) < 0) {
      let { rotation: P } = qe.Decompose(r.initialPageTransform);
      P -= 2 * P, this.updateShapes([{ id: e, type: i, rotation: P }]);
    }
    const l = qe.applyToPoint(
      r.initialPageTransform,
      r.initialBounds.center
    ), c = this._scalePagePoint(
      l,
      r.scaleOrigin,
      t,
      r.scaleAxisRotation
    ), d = this.getShapePageBounds(e), h = this.getShapePageTransform(e), g = d.center, y = h.point();
    if (!g || !y) return this;
    const v = R.Sub(c, g), w = R.Add(y, v), { x: C, y: E } = this.getPointInParentSpace(e, w);
    return this.updateShapes([{ id: e, type: i, x: C, y: E }]), this;
  }
  /**
   * Get the initial meta value for a shape.
   *
   * @example
   * ```ts
   * editor.getInitialMetaForShape = (shape) => {
   *   if (shape.type === 'note') {
   *     return { createdBy: myCurrentUser.id }
   *   }
   * }
   * ```
   *
   * @param shape - The shape to get the initial meta for.
   *
   * @public
   */
  getInitialMetaForShape(e) {
    return {};
  }
  /**
   * Create a single shape.
   *
   * @example
   * ```ts
   * editor.createShape(myShape)
   * editor.createShape({ id: 'box1', type: 'text', props: { text: "ok" } })
   * ```
   *
   * @param shape - The shape (or shape partial) to create.
   *
   * @public
   */
  createShape(e) {
    return this.createShapes([e]), this;
  }
  /**
   * Create shapes.
   *
   * @example
   * ```ts
   * editor.createShapes([myShape])
   * editor.createShapes([{ id: 'box1', type: 'text', props: { text: "ok" } }])
   * ```
   *
   * @param shapes - The shapes (or shape partials) to create.
   *
   * @public
   */
  createShapes(e) {
    if (!Array.isArray(e))
      throw Error("Editor.createShapes: must provide an array of shapes or shape partials");
    if (this.getIsReadonly()) return this;
    if (e.length <= 0) return this;
    const t = this.getCurrentPageShapeIds();
    if (e.length + t.size > this.options.maxShapesPerPage)
      return G1(this), this;
    const i = this.getFocusedGroupId();
    return this.run(() => {
      var g, y;
      const s = this.getCurrentPageShapesSorted(), l = e.map((v) => {
        if (v.id || (v = { id: Sr(), ...v }), !v.parentId || !(this.store.has(v.parentId) || e.some((w) => w.id === v.parentId))) {
          let w = this.getFocusedGroupId();
          for (let E = s.length - 1; E >= 0; E--) {
            const P = s[E];
            if (!this.isShapeHidden(P) && this.getShapeUtil(P).canReceiveNewChildrenOfType(P, v.type) && this.isPointInShape(
              P,
              // If no parent is provided, then we can treat the
              // shape's provided x/y as being in the page's space.
              { x: v.x ?? 0, y: v.y ?? 0 },
              {
                margin: 0,
                hitInside: !0
              }
            )) {
              w = P.id;
              break;
            }
          }
          const C = v.parentId;
          if (w === v.id && (w = i), w !== C && (v = { ...v }, v.parentId = w, va(w))) {
            const E = this.getPointInShapeSpace(this.getShape(w), {
              x: v.x ?? 0,
              y: v.y ?? 0
            });
            v.x = E.x, v.y = E.y, v.rotation = -this.getShapePageTransform(w).rotation() + (v.rotation ?? 0);
          }
        }
        return v;
      }), c = /* @__PURE__ */ new Map(), d = [], { opacityForNextShape: h } = this.getInstanceState();
      for (const v of l) {
        const w = this.getShapeUtil(v);
        let C = v.index;
        if (!C) {
          const k = v.parentId ?? i;
          c.has(k) || c.set(k, this.getHighestIndexForParent(k)), C = c.get(k), c.set(k, vu(C));
        }
        const E = w.getDefaultProps();
        for (const [k, L] of this.styleProps[v.type])
          E[L] = this.getStyleForNextShape(k);
        let P = this.store.schema.types.shape.create({
          ...v,
          index: C,
          opacity: v.opacity ?? h,
          parentId: v.parentId ?? i,
          props: "props" in v ? { ...E, ...v.props } : E
        });
        if (P.index === void 0)
          throw Error("no index!");
        const I = (y = (g = this.getShapeUtil(P)).onBeforeCreate) == null ? void 0 : y.call(g, P);
        I && (P = I), d.push(P);
      }
      d.forEach((v) => {
        v.meta = {
          ...this.getInitialMetaForShape(v),
          ...v.meta
        };
      }), this.store.put(d);
    }), this;
  }
  /**
   * Animate a shape.
   *
   * @example
   * ```ts
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 })
   * editor.animateShape({ id: 'box1', type: 'box', x: 100, y: 100 }, { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partial - The shape partial to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShape(e, t = { animation: CM }) {
    return this.animateShapes([e], t);
  }
  /**
   * Animate shapes.
   *
   * @example
   * ```ts
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }])
   * editor.animateShapes([{ id: 'box1', type: 'box', x: 100, y: 100 }], { animation: { duration: 100, ease: t => t*t } })
   * ```
   *
   * @param partials - The shape partials to update.
   * @param opts - The animation's options.
   *
   * @public
   */
  animateShapes(e, t = { animation: CM }) {
    if (!t.animation) return this;
    const { duration: r = 500, easing: i = po.linear } = t.animation, s = or();
    let l = r, c;
    const d = [];
    let h, g;
    for (let v = 0, w = e.length; v < w; v++) {
      if (h = e[v], !h) continue;
      const C = this.getShape(h.id);
      C && (g = {
        start: $r(C),
        end: hu($r(C), h)
      }, d.push(g), this.animatingShapes.set(C.id, s));
    }
    const y = (v) => {
      var P, I;
      if (l -= v, l < 0) {
        const { animatingShapes: k } = this, L = e.filter(
          (O) => O && k.get(O.id) === s
        );
        L.length && this.updateShapes(L), this.off("tick", y);
        return;
      }
      c = i(1 - l / r);
      const { animatingShapes: w } = this, C = [];
      let E;
      for (let k = 0, L = d.length; k < L; k++) {
        const { start: O, end: z } = d[k];
        E = w.get(O.id), E === s && C.push({
          ...z,
          x: O.x + (z.x - O.x) * c,
          y: O.y + (z.y - O.y) * c,
          opacity: O.opacity + (z.opacity - O.opacity) * c,
          rotation: O.rotation + (z.rotation - O.rotation) * c,
          props: ((I = (P = this.getShapeUtil(z)).getInterpolatedProps) == null ? void 0 : I.call(P, O, z, c)) ?? z.props
        });
      }
      this._updateShapes(C);
    };
    return this.on("tick", y), this;
  }
  groupShapes(e, t = {}) {
    var C;
    const { groupId: r = Sr(), select: i = !0 } = t;
    if (!Array.isArray(e))
      throw Error("Editor.groupShapes: must provide an array of shapes or shape ids");
    if (this.getIsReadonly()) return this;
    const s = typeof e[0] == "string" ? e : e.map((E) => E.id);
    if (s.length <= 1) return this;
    const l = rn(
      (this._shouldIgnoreShapeLock ? s : this._getUnlockedShapeIds(s)).map(
        (E) => this.getShape(E)
      )
    ), c = l.sort(gs).map((E) => E.id), d = Xe.Common(rn(l.map((E) => this.getShapePageBounds(E)))), { x: h, y: g } = d.point, y = this.findCommonAncestor(l) ?? this.getCurrentPageId();
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const v = l.filter((E) => E.parentId === y).sort(gs), w = (C = v[v.length - 1]) == null ? void 0 : C.index;
    return this.run(() => {
      this.createShapes([
        {
          id: r,
          type: "group",
          parentId: y,
          index: w,
          x: h,
          y: g,
          opacity: 1,
          props: {}
        }
      ]), this.reparentShapes(c, r), i && this.select(r);
    }), this;
  }
  ungroupShapes(e, t = {}) {
    if (this.getIsReadonly()) return this;
    const { select: r = !0 } = t, i = typeof e[0] == "string" ? e : e.map((d) => d.id), s = rn(
      (this._shouldIgnoreShapeLock ? i : this._getUnlockedShapeIds(i)).map(
        (d) => this.getShape(d)
      )
    );
    if (s.length === 0) return this;
    if (this.getCurrentToolId() !== "select") return this;
    this.isIn("select.idle") || this.cancel();
    const l = /* @__PURE__ */ new Set(), c = [];
    return s.forEach((d) => {
      this.isShapeOfType(d, "group") ? c.push(d) : l.add(d.id);
    }), c.length === 0 ? this : (this.run(() => {
      let d;
      for (let h = 0, g = c.length; h < g; h++) {
        d = c[h];
        const y = this.getSortedChildIdsForParent(d.id);
        for (let v = 0, w = y.length; v < w; v++)
          l.add(y[v]);
        this.reparentShapes(y, d.parentId, d.index);
      }
      this.deleteShapes(c.map((h) => h.id)), r && this.select(...l);
    }), this);
  }
  /**
   * Update a shape using a partial of the shape.
   *
   * @example
   * ```ts
   * editor.updateShape({ id: 'box1', type: 'geo', props: { w: 100, h: 100 } })
   * ```
   *
   * @param partial - The shape partial to update.
   *
   * @public
   */
  updateShape(e) {
    return this.updateShapes([e]), this;
  }
  /**
   * Update shapes using partials of each shape.
   *
   * @example
   * ```ts
   * editor.updateShapes([{ id: 'box1', type: 'geo', props: { w: 100, h: 100 } }])
   * ```
   *
   * @param partials - The shape partials to update.
   *
   * @public
   */
  updateShapes(e) {
    const t = Array(e.length);
    for (let r = 0, i = e.length; r < i; r++) {
      const s = e[r];
      if (!s) continue;
      const l = this.getShape(s.id);
      if (l) {
        if (!this._shouldIgnoreShapeLock) {
          if (l.isLocked) {
            if (!(Object.hasOwn(s, "isLocked") && !s.isLocked))
              continue;
          } else if (this.isShapeOrAncestorLocked(l))
            continue;
        }
        this.animatingShapes.delete(s.id), t.push(s);
      }
    }
    return this._updateShapes(t), this;
  }
  /** @internal */
  _updateShapes(e) {
    this.getIsReadonly() || this.run(() => {
      var s, l;
      const t = [];
      let r, i;
      for (let c = 0, d = e.length; c < d; c++) {
        const h = e[c];
        h && (r = this.getShape(h.id), r && (i = hu(r, h), i !== r && (i = ((l = (s = this.getShapeUtil(r)).onBeforeUpdate) == null ? void 0 : l.call(s, r, i)) ?? i, t.push(i))));
      }
      this.store.put(t);
    });
  }
  /** @internal */
  _getUnlockedShapeIds(e) {
    return e.filter((t) => {
      var r;
      return !((r = this.getShape(t)) != null && r.isLocked);
    });
  }
  deleteShapes(e) {
    if (this.getIsReadonly()) return this;
    if (!Array.isArray(e))
      throw Error("Editor.deleteShapes: must provide an array of shapes or shapeIds");
    const t = typeof e[0] == "string" ? e : e.map((s) => s.id), r = this._shouldIgnoreShapeLock ? t : this._getUnlockedShapeIds(t);
    if (r.length === 0) return this;
    const i = new Set(r);
    for (const s of r)
      this.visitDescendants(s, (l) => {
        i.add(l);
      });
    return this.run(() => this.store.remove([...i]));
  }
  deleteShape(e) {
    return this.deleteShapes([typeof e == "string" ? e : e.id]), this;
  }
  /* --------------------- Styles --------------------- */
  /**
   * Get all the current styles among the users selected shapes
   *
   * @internal
   */
  _extractSharedStyles(e, t) {
    if (this.isShapeOfType(e, "group")) {
      const r = this._parentIdsToChildIds.get()[e.id];
      if (!r) return;
      for (let i = 0, s = r.length; i < s; i++)
        this._extractSharedStyles(this.getShape(r[i]), t);
    } else
      for (const [r, i] of this.styleProps[e.type])
        t.applyValue(r, ys(e.props, i));
  }
  _getSelectionSharedStyles() {
    const e = this.getSelectedShapes(), t = new tD();
    for (const r of e)
      this._extractSharedStyles(r, t);
    return t;
  }
  /**
   * Get the style for the next shape.
   *
   * @example
   * ```ts
   * const color = editor.getStyleForNextShape(DefaultColorStyle)
   * ```
   *
   * @param style - The style to get.
   *
   * @public */
  getStyleForNextShape(e) {
    const t = this.getInstanceState().stylesForNextShape[e.id];
    return t === void 0 ? e.defaultValue : t;
  }
  getShapeStyleIfExists(e, t) {
    const r = this.styleProps[e.type].get(t);
    if (r !== void 0)
      return ys(e.props, r);
  }
  getSharedStyles() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0)
      return this._getSelectionSharedStyles();
    const e = this.root.getCurrent(), t = new tD();
    if (!e) return t;
    if (e.shapeType)
      for (const r of this.styleProps[e.shapeType].keys())
        t.applyValue(r, this.getStyleForNextShape(r));
    return t;
  }
  getSharedOpacity() {
    if (this.isIn("select") && this.getSelectedShapeIds().length > 0) {
      const e = [], t = (i) => {
        const s = this.getShape(i);
        if (s)
          if (this.isShapeOfType(s, "group"))
            for (const l of this.getSortedChildIdsForParent(s.id))
              t(l);
          else
            e.push(s);
      };
      for (const i of this.getSelectedShapeIds())
        t(i);
      let r = null;
      for (const i of e)
        if (r === null)
          r = i.opacity;
        else if (r !== i.opacity)
          return { type: "mixed" };
      if (r !== null) return { type: "shared", value: r };
    }
    return { type: "shared", value: this.getInstanceState().opacityForNextShape };
  }
  /**
   * Set the opacity for the next shapes. This will effect subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForNextShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   * @param historyOptions - The history options for the change.
   */
  setOpacityForNextShapes(e, t) {
    return this.updateInstanceState({ opacityForNextShape: e }, t), this;
  }
  /**
   * Set the current opacity. This will effect any selected shapes.
   *
   * @example
   * ```ts
   * editor.setOpacityForSelectedShapes(0.5)
   * ```
   *
   * @param opacity - The opacity to set. Must be a number between 0 and 1 inclusive.
   */
  setOpacityForSelectedShapes(e) {
    const t = this.getSelectedShapes();
    if (t.length > 0) {
      const r = [], i = (s) => {
        if (this.isShapeOfType(s, "group")) {
          const l = this.getSortedChildIdsForParent(s);
          for (const c of l)
            i(this.getShape(c));
        } else
          r.push(s);
      };
      for (const s of t)
        i(s);
      this.updateShapes(
        r.map((s) => ({
          id: s.id,
          type: s.type,
          opacity: e
        }))
      );
    }
    return this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp} for the next shapes. This change will be applied to subsequently created shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red')
   * editor.setStyleForNextShapes(DefaultColorStyle, 'red', { ephemeral: true })
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   * @param historyOptions - The history options for the change.
   *
   * @public
   */
  setStyleForNextShapes(e, t, r) {
    const i = this.getInstanceState().stylesForNextShape;
    return this.updateInstanceState(
      { stylesForNextShape: { ...i, [e.id]: t } },
      r
    ), this;
  }
  /**
   * Set the value of a {@link @tldraw/tlschema#StyleProp}. This change will be applied to the currently selected shapes.
   *
   * @example
   * ```ts
   * editor.setStyleForSelectedShapes(DefaultColorStyle, 'red')
   * ```
   *
   * @param style - The style to set.
   * @param value - The value to set.
   *
   * @public
   */
  setStyleForSelectedShapes(e, t) {
    const r = this.getSelectedShapes();
    if (r.length > 0) {
      const i = [], s = (l) => {
        if (this.isShapeOfType(l, "group")) {
          const c = this.getSortedChildIdsForParent(l.id);
          for (const d of c)
            s(this.getShape(d));
        } else {
          const c = this.getShapeUtil(l), d = this.styleProps[l.type].get(e);
          if (d) {
            const h = {
              id: l.id,
              type: l.type,
              props: { [d]: t }
            };
            i.push({
              util: c,
              originalShape: l,
              updatePartial: h
            });
          }
        }
      };
      for (const l of r)
        s(l);
      this.updateShapes(i.map(({ updatePartial: l }) => l));
    }
    return this;
  }
  /**
   * Register an external asset handler. This handler will be called when the editor needs to
   * create an asset for some external content, like an image/video file or a bookmark URL. For
   * example, the 'file' type handler will be called when a user drops an image onto the canvas.
   *
   * The handler should extract any relevant metadata for the asset, upload it to blob storage
   * using {@link Editor.uploadAsset} if needed, and return the asset with the metadata & uploaded
   * URL.
   *
   * @example
   * ```ts
   * editor.registerExternalAssetHandler('file', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalAssetHandler(e, t) {
    return this.externalAssetContentHandlers[e] = t, this;
  }
  /**
   * Register a temporary preview of an asset. This is useful for showing a ghost image of
   * something that is being uploaded. Retrieve the placeholder with
   * {@link Editor.getTemporaryAssetPreview}. Placeholders last for 3 minutes by default, but this
   * can be configured using
   *
   * @example
   * ```ts
   * editor.createTemporaryAssetPreview(assetId, file)
   * ```
   *
   * @param assetId - The asset's id.
   * @param file - The raw file.
   *
   * @public
   */
  createTemporaryAssetPreview(e, t) {
    if (this.temporaryAssetPreview.has(e))
      return this.temporaryAssetPreview.get(e);
    const r = URL.createObjectURL(t);
    return this.temporaryAssetPreview.set(e, r), setTimeout(() => {
      this.temporaryAssetPreview.delete(e), URL.revokeObjectURL(r);
    }, this.options.temporaryAssetPreviewLifetimeMs), r;
  }
  /**
   * Get temporary preview of an asset. This is useful for showing a ghost
   * image of something that is being uploaded.
   *
   * @example
   * ```ts
   * editor.getTemporaryAssetPreview('someId')
   * ```
   *
   * @param assetId - The asset's id.
   *
   * @public
   */
  getTemporaryAssetPreview(e) {
    return this.temporaryAssetPreview.get(e);
  }
  /**
   * Get an asset for an external asset content type.
   *
   * @example
   * ```ts
   * const asset = await editor.getAssetForExternalContent({ type: 'file', file: myFile })
   * const asset = await editor.getAssetForExternalContent({ type: 'url', url: myUrl })
   * ```
   *
   * @param info - Info about the external content.
   * @returns The asset.
   */
  async getAssetForExternalContent(e) {
    var t, r;
    return await ((r = (t = this.externalAssetContentHandlers)[e.type]) == null ? void 0 : r.call(t, e));
  }
  hasExternalAssetHandler(e) {
    return !!this.externalAssetContentHandlers[e];
  }
  /**
   * Register an external content handler. This handler will be called when the editor receives
   * external content of the provided type. For example, the 'image' type handler will be called
   * when a user drops an image onto the canvas.
   *
   * @example
   * ```ts
   * editor.registerExternalContentHandler('text', myHandler)
   * ```
   * @example
   * ```ts
   * editor.registerExternalContentHandler<'embed', MyEmbedType>('embed', myHandler)
   * ```
   *
   * @param type - The type of external content.
   * @param handler - The handler to use for this content type.
   *
   * @public
   */
  registerExternalContentHandler(e, t) {
    return this.externalContentHandlers[e] = t, this;
  }
  /**
   * Handle external content, such as files, urls, embeds, or plain text which has been put into the app, for example by pasting external text or dropping external images onto canvas.
   *
   * @param info - Info about the external content.
   */
  async putExternalContent(e) {
    var t, r;
    return (r = (t = this.externalContentHandlers)[e.type]) == null ? void 0 : r.call(t, e);
  }
  /**
   * Get content that can be exported for the given shape ids.
   *
   * @param shapes - The shapes (or shape ids) to get content for.
   *
   * @returns The exported content.
   *
   * @public
   */
  getContentFromCurrentPage(e) {
    const t = typeof e[0] == "string" ? e : e.map((i) => i.id);
    if (!t || t.length === 0) return;
    const r = this.getShapeAndDescendantIds(t);
    return rU(this, r, (i) => {
      const s = [];
      for (const g of i) {
        const y = this.getBinding(g);
        y && s.push(y);
      }
      const l = [], c = [];
      for (const g of r) {
        const y = this.getShape(g);
        if (!y) continue;
        if (!r.has(y.parentId)) {
          const w = this.getShapePageTransform(y.id), C = w.point();
          c.push({
            ...y,
            x: C.x,
            y: C.y,
            rotation: w.rotation(),
            parentId: this.getCurrentPageId()
          }), l.push(y.id);
        } else
          c.push(y);
      }
      const d = [], h = /* @__PURE__ */ new Set();
      for (const g of c) {
        if (!("assetId" in g.props)) continue;
        const y = g.props.assetId;
        if (!y || h.has(y)) continue;
        h.add(y);
        const v = this.getAsset(y);
        v && d.push(v);
      }
      return {
        schema: this.store.schema.serialize(),
        shapes: c,
        rootShapeIds: l,
        bindings: s,
        assets: d
      };
    });
  }
  async resolveAssetsInContent(e) {
    if (!e) return;
    const t = [];
    return await Promise.allSettled(
      e.assets.map(async (r) => {
        var i, s, l;
        if ((r.type === "image" || r.type === "video") && !((i = r.props.src) != null && i.startsWith("data:image")) && !((s = r.props.src) != null && s.startsWith("data:video")) && !((l = r.props.src) != null && l.startsWith("http"))) {
          const c = $r(r), d = await this.store.props.assets.resolve(r, {
            screenScale: 1,
            steppedScreenScale: 1,
            dpr: 1,
            networkEffectiveType: null,
            shouldResolveToOriginal: !0
          });
          c.props.src = await yc.blobToDataUrl(
            await Eu(d).then((h) => h.blob())
          ), t.push(c);
        } else
          t.push(r);
      })
    ), e.assets = t, e;
  }
  /**
   * Place content into the editor.
   *
   * @param content - The content.
   * @param opts - Options for placing the content.
   *
   * @public
   */
  putContentOntoCurrentPage(e, t = {}) {
    var q, J, ie;
    if (this.getIsReadonly()) return this;
    if (!e.schema)
      throw Error(`Could not put content:
content is missing a schema.`);
    const { select: r = !1, preserveIds: i = !1, preservePosition: s = !1 } = t;
    let { point: l = void 0 } = t;
    const c = this.getCurrentPageId(), { rootShapeIds: d } = e, h = [], g = [], y = [], v = {
      store: {
        ...Object.fromEntries(e.assets.map((W) => [W.id, W])),
        ...Object.fromEntries(e.shapes.map((W) => [W.id, W])),
        ...Object.fromEntries(
          ((q = e.bindings) == null ? void 0 : q.map((W) => [W.id, W])) ?? []
        )
      },
      schema: e.schema
    }, w = this.store.schema.migrateStoreSnapshot(v);
    if (w.type === "error")
      throw Error("Could not put content: could not migrate content");
    for (const W of Object.values(w.value))
      switch (W.typeName) {
        case "asset": {
          h.push(W);
          break;
        }
        case "shape": {
          g.push(W);
          break;
        }
        case "binding": {
          y.push(W);
          break;
        }
      }
    const C = new Map(
      i ? g.map((W) => [W.id, W.id]) : g.map((W) => [W.id, Sr()])
    ), E = new Map(
      i ? y.map((W) => [W.id, W.id]) : y.map((W) => [W.id, qp()])
    );
    let P = this.getCurrentPageId(), I = 1 / 0, k = [];
    for (const W of this.getSelectedShapes()) {
      if (I === 0) break;
      const Y = this.isShapeOfType(W, "frame"), oe = this.getShapeAncestors(W);
      Y && oe.push(W);
      const le = Y ? oe.length + 1 : oe.length;
      if (le < I)
        I = le, k = oe, P = Y ? W.id : W.parentId;
      else if (le === I) {
        if (k.length !== oe.length)
          throw Error(`Ancestors: ${k.length} !== ${oe.length}`);
        if (k.length === 0) {
          P = c;
          break;
        } else {
          P = c;
          for (let ce = 0; ce < k.length && oe[ce] === k[ce]; ce++)
            P = oe[ce].id;
        }
      }
    }
    let L = !1;
    if (!ga(P)) {
      const W = this.getShape(P);
      if (W) {
        if (!this.getViewportPageBounds().includes(this.getShapePageBounds(W)))
          P = c;
        else if (d.length === 1) {
          const Y = g.find((oe) => oe.id === d[0]);
          this.isShapeOfType(W, "frame") && this.isShapeOfType(Y, "frame") && Y.props.w === (W == null ? void 0 : W.props.w) && Y.props.h === (W == null ? void 0 : W.props.h) && (L = !0);
        }
      } else
        P = c;
    }
    L || (L = C.has(P)), L && (P = this.getShape(P).parentId);
    let O = this.getHighestIndexForParent(P);
    const z = [], F = g.map((W) => {
      const Y = C.get(W.id), oe = { ...W, id: Y };
      return d.includes(W.id) && (oe.parentId = c, z.push(oe)), C.has(oe.parentId) ? oe.parentId = C.get(W.parentId) : (d.push(oe.id), oe.index = O, O = vu(O)), oe;
    });
    if (F.length + this.getCurrentPageShapeIds().size > this.options.maxShapesPerPage)
      return G1(this), this;
    const H = y.map(
      (W) => ({
        ...W,
        id: Sa(E.get(W.id)),
        fromId: Sa(C.get(W.fromId)),
        toId: Sa(C.get(W.toId))
      })
    ), V = [], re = [];
    for (const W of h)
      this.store.has(W.id) || ((W.type === "image" && ((J = W.props.src) != null && J.startsWith("data:image")) || W.type === "video" && ((ie = W.props.src) != null && ie.startsWith("data:video"))) && (re.push($r(W)), W.props.src = null), V.push(W));
    return Promise.allSettled(
      re.map(async (W) => {
        const Y = await Fce(
          W.props.src,
          W.props.name,
          W.props.mimeType ?? "image/png"
        ), oe = await this.getAssetForExternalContent({
          type: "file",
          file: Y,
          assetId: W.id
        });
        if (!oe) {
          this.deleteAssets([W.id]);
          return;
        }
        this.updateAssets([{ ...oe, id: W.id }]);
      })
    ), this.run(() => {
      V.length > 0 && this.createAssets(V), this.createShapes(F), this.createBindings(H), r && this.select(...z.map((ce) => ce.id)), P !== c && this.reparentShapes(
        z.map((ce) => ce.id),
        P
      );
      const W = F.map((ce) => this.getShape(ce.id)), Y = Xe.Common(W.map((ce) => this.getShapePageBounds(ce)));
      if (l === void 0)
        if (ga(P)) {
          const ce = this.getViewportPageBounds();
          s || ce.includes(Xe.From(Y)) ? l = Y.center : l = ce.center;
        } else {
          const ce = this.getShape(P);
          l = qe.applyToPoint(
            this.getShapePageTransform(ce),
            this.getShapeGeometry(ce).bounds.center
          );
        }
      if (z.length === 1) {
        const ce = z[0];
        if (this.isShapeOfType(ce, "frame"))
          for (; this.getShapesAtPoint(l).some(
            (Q) => this.isShapeOfType(Q, "frame") && Q.props.w === ce.props.w && Q.props.h === ce.props.h
          ); )
            l.x += Y.w + 16;
      }
      const oe = Xe.Common(
        rn(z.map(({ id: ce }) => this.getShapePageBounds(ce)))
      ).center, le = R.Sub(l, oe);
      this.updateShapes(
        z.map(({ id: ce }) => {
          const Q = this.getShape(ce), he = this.getShapeParentTransform(ce).decompose().rotation, ke = R.Rot(le, -he);
          return { id: Q.id, type: Q.type, x: Q.x + ke.x, y: Q.y + ke.y };
        })
      );
    }), this;
  }
  /**
   * Get an exported SVG element of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgElement(e, t = {}) {
    const r = typeof e[0] == "string" ? e : e.map((i) => i.id);
    if (r.length !== 0)
      return Oce(this, r, t);
  }
  /**
   * Get an exported SVG string of the given shapes.
   *
   * @param shapes - The shapes (or shape ids) to export.
   * @param opts - Options for the export.
   *
   * @returns The SVG element.
   *
   * @public
   */
  async getSvgString(e, t = {}) {
    const r = await this.getSvgElement(e, t);
    return r ? {
      svg: new XMLSerializer().serializeToString(r.svg),
      width: r.width,
      height: r.height
    } : void 0;
  }
  /** @deprecated Use {@link Editor.getSvgString} or {@link Editor.getSvgElement} instead. */
  async getSvg(e, t = {}) {
    const r = await this.getSvgElement(e, t);
    if (r)
      return r.svg;
  }
  /**
   * Update the input points from a pointer, pinch, or wheel event.
   *
   * @param info - The event info.
   */
  _updateInputsFromEvent(e) {
    const {
      pointerVelocity: t,
      previousScreenPoint: r,
      previousPagePoint: i,
      currentScreenPoint: s,
      currentPagePoint: l
    } = this.inputs, { screenBounds: c } = this.store.unsafeGetWithoutCapture(hs), { x: d, y: h, z: g } = A1(() => this.getCamera()), y = e.point.x - c.x, v = e.point.y - c.y, w = e.point.z ?? 0.5;
    r.setTo(s), i.setTo(l), s.set(y, v);
    const C = y / g - d, E = v / g - h;
    isFinite(C) && isFinite(E) && l.set(C, E, w), this.inputs.isPen = e.type === "pointer" && e.isPen, (e.name === "pointer_down" || this.inputs.isPinching) && (t.set(0, 0), this.inputs.originScreenPoint.setTo(s), this.inputs.originPagePoint.setTo(l)), this.run(
      () => {
        var P;
        this.store.put([
          {
            id: Gx,
            typeName: "pointer",
            x: l.x,
            y: l.y,
            lastActivityTimestamp: (
              // If our pointer moved only because we're following some other user, then don't
              // update our last activity timestamp; otherwise, update it to the current timestamp.
              e.type === "pointer" && e.pointerId === x4.CAMERA_MOVE ? ((P = this.store.unsafeGetWithoutCapture(Gx)) == null ? void 0 : P.lastActivityTimestamp) ?? this._tickManager.now : this._tickManager.now
            ),
            meta: {}
          }
        ]);
      },
      { history: "ignore" }
    );
  }
  /**
   * Dispatch a cancel event.
   *
   * @example
   * ```ts
   * editor.cancel()
   * ```
   *
   * @public
   */
  cancel() {
    return this.dispatch({ type: "misc", name: "cancel" }), this;
  }
  /**
   * Dispatch an interrupt event.
   *
   * @example
   * ```ts
   * editor.interrupt()
   * ```
   *
   * @public
   */
  interrupt() {
    return this.dispatch({ type: "misc", name: "interrupt" }), this;
  }
  /**
   * Dispatch a complete event.
   *
   * @example
   * ```ts
   * editor.complete()
   * ```
   *
   * @public
   */
  complete() {
    return this.dispatch({ type: "misc", name: "complete" }), this;
  }
  /**
   * Puts the editor into focused mode.
   *
   * This makes the editor eligible to receive keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.focus()
   * ```
   *
   * By default this also dispatches a 'focus' event to the container element. To prevent this, pass `focusContainer: false`.
   *
   * @example
   * ```ts
   * editor.focus({ focusContainer: false })
   * ```
   *
   * @public
   */
  focus({ focusContainer: e = !0 } = {}) {
    return this.getIsFocused() ? this : (e && this.focusManager.focus(), this.updateInstanceState({ isFocused: !0 }), this);
  }
  /**
   * Switches off the editor's focused mode.
   *
   * This makes the editor ignore keyboard events and some pointer events (move, wheel).
   *
   * @example
   * ```ts
   * editor.blur()
   * ```
   * By default this also dispatches a 'blur' event to the container element. To prevent this, pass `blurContainer: false`.
   *
   * @example
   * ```ts
   * editor.blur({ blurContainer: false })
   * ```
   *
   * @public
   */
  blur({ blurContainer: e = !0 } = {}) {
    return this.getIsFocused() ? (e ? this.focusManager.blur() : this.complete(), this.updateInstanceState({ isFocused: !1 }), this) : this;
  }
  getIsFocused() {
    return this.getInstanceState().isFocused;
  }
  getIsReadonly() {
    return this.getInstanceState().isReadonly;
  }
  /**
   * @public
   * @returns a snapshot of the store's UI and document state
   */
  getSnapshot() {
    return Nle(this.store);
  }
  /**
   * Loads a snapshot into the editor.
   * @param snapshot - The snapshot to load.
   * @param opts - The options for loading the snapshot.
   * @returns
   */
  loadSnapshot(e, t) {
    return kB(this.store, e, t), this;
  }
  _zoomToFitPageContentAt100Percent() {
    const e = this.getCurrentPageBounds();
    e && this.zoomToBounds(e, { immediate: !0, targetZoom: this.getBaseZoom() });
  }
  _navigateToDeepLink(e) {
    this.run(() => {
      switch (e.type) {
        case "page": {
          const t = this.getPage(e.pageId);
          t && this.setCurrentPage(t), this._zoomToFitPageContentAt100Percent();
          return;
        }
        case "shapes": {
          const t = rn(e.shapeIds.map((l) => this.getShape(l))), r = {};
          for (const l of t) {
            const c = this.getAncestorPageId(l);
            c && (r[c] ?? (r[c] = []), r[c].push(l));
          }
          const [i, s] = Object.entries(r).sort(
            ([l, c], [d, h]) => h.length - c.length
          )[0] ?? ["", []];
          if (!i || !s.length)
            this._zoomToFitPageContentAt100Percent();
          else {
            this.setCurrentPage(i);
            const l = Xe.Common(s.map((c) => this.getShapePageBounds(c)));
            this.zoomToBounds(l, { immediate: !0, targetZoom: this.getBaseZoom() });
          }
          return;
        }
        case "viewport": {
          if (e.pageId) {
            if (!this.getPage(e.pageId)) {
              this._zoomToFitPageContentAt100Percent();
              return;
            }
            this.setCurrentPage(e.pageId);
          }
          this.zoomToBounds(e.bounds, { immediate: !0, inset: 0 });
          return;
        }
        default:
          ro(e);
      }
    });
  }
  /**
   * Handles navigating to the content specified by the query param in the given URL.
   *
   * Use {@link Editor#createDeepLink} to create a URL with a deep link query param.
   *
   * If no URL is provided, it will look for the param in the current `window.location.href`.
   *
   * @example
   * ```ts
   * editor.navigateToDeepLink()
   * ```
   *
   * The default parameter name is 'd'. You can override this by providing the `param` option.
   *
   * @example
   * ```ts
   * // disable page parameter and change viewport parameter to 'c'
   * editor.navigateToDeepLink({
   *   param: 'x',
   *   url: 'https://my-app.com/my-document?x=200.12.454.23.xyz123',
   * })
   * ```
   *
   * @param opts - Options for loading the state from the URL.
   */
  navigateToDeepLink(e) {
    if (e && "type" in e)
      return this._navigateToDeepLink(e), this;
    const r = new URL((e == null ? void 0 : e.url) ?? window.location.href).searchParams.get((e == null ? void 0 : e.param) ?? "d");
    if (!r)
      return this._zoomToFitPageContentAt100Percent(), this;
    try {
      this._navigateToDeepLink($ce(r));
    } catch (i) {
      console.warn(i), this._zoomToFitPageContentAt100Percent();
    }
    return this;
  }
  /**
   * Turns the given URL into a deep link by adding a query parameter.
   *
   * e.g. `https://my-app.com/my-document?d=100.100.200.200.xyz123`
   *
   * If no URL is provided, it will use the current `window.location.href`.
   *
   * @example
   * ```ts
   * // create a deep link to the current page + viewport
   * navigator.clipboard.writeText(editor.createDeepLink())
   * ```
   *
   * You can link to a particular set of shapes by providing a `to` parameter.
   *
   * @example
   * ```ts
   * // create a deep link to the set of currently selected shapes
   * navigator.clipboard.writeText(editor.createDeepLink({
   *   to: { type: 'selection', shapeIds: editor.getSelectedShapeIds() }
   * }))
   * ```
   *
   * The default query param is 'd'. You can override this by providing a `param` parameter.
   *
   * @example
   * ```ts
   * // Use `x` as the param name instead
   * editor.createDeepLink({ param: 'x' })
   * ```
   *
   * @param opts - Options for adding the state to the URL.
   * @returns the updated URL
   */
  createDeepLink(e) {
    const t = new URL((e == null ? void 0 : e.url) ?? window.location.href);
    return t.searchParams.set(
      (e == null ? void 0 : e.param) ?? "d",
      Uce(
        (e == null ? void 0 : e.to) ?? {
          type: "viewport",
          pageId: this.options.maxPages === 1 ? void 0 : this.getCurrentPageId(),
          bounds: this.getViewportPageBounds()
        }
      )
    ), t;
  }
  /**
   * Register a listener for changes to a deep link for the current document.
   *
   * You'll typically want to use this indirectly via the {@link TldrawEditorBaseProps.deepLinks} prop on the `<Tldraw />` component.
   *
   * By default this will update `window.location` in place, but you can provide a custom callback
   * to handle state changes on your own.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   onChange(url) {
   *     window.history.replaceState({}, document.title, url.toString())
   *   }
   * })
   * ```
   *
   * You can also provide a custom URL to update, in which case you must also provide `onChange`.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({
   *   getUrl: () => `https://my-app.com/my-document`,
   *   onChange(url) {
   *     setShareUrl(url.toString())
   *   }
   * })
   * ```
   *
   * By default this will update with a debounce interval of 500ms, but you can provide a custom interval.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ debounceMs: 1000 })
   * ```
   * The default parameter name is `d`. You can override this by providing a `param` option.
   *
   * @example
   * ```ts
   * editor.registerDeepLinkListener({ param: 'x' })
   * ```
   * @param opts - Options for setting up the listener.
   * @returns a function that will stop the listener.
   */
  registerDeepLinkListener(e) {
    if (e != null && e.getUrl && !(e != null && e.onChange))
      throw Error(
        "[tldraw:urlStateSync] If you specify getUrl, you must also specify the onChange callback."
      );
    const t = Le("url with state", () => {
      var d, h;
      const l = ((d = e == null ? void 0 : e.getUrl) == null ? void 0 : d.call(e, this)) ?? window.location.href;
      return this.createDeepLink({
        param: e == null ? void 0 : e.param,
        url: l,
        to: (h = e == null ? void 0 : e.getTarget) == null ? void 0 : h.call(e, this)
      }).toString();
    }), r = (e == null ? void 0 : e.onChange) ?? (() => {
      var c;
      const l = this.createDeepLink({
        param: e == null ? void 0 : e.param,
        to: (c = e == null ? void 0 : e.getTarget) == null ? void 0 : c.call(e, this)
      });
      window.history.replaceState({}, document.title, l.toString());
    }), i = LE((l) => l(), (e == null ? void 0 : e.debounceMs) ?? 500), s = wc(
      "update url on state change",
      () => r(new URL(t.get()), this),
      { scheduleEffect: i }
    );
    return () => {
      s(), i.cancel();
    };
  }
  /**
   * Prevent a double click event from firing the next time the user clicks
   *
   * @public
   */
  cancelDoubleClick() {
    this._clickManager.cancelDoubleClickTimeout();
  }
  _setShiftKeyTimeout() {
    this.inputs.shiftKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Shift",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "ShiftLeft"
    });
  }
  _setAltKeyTimeout() {
    this.inputs.altKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Alt",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "AltLeft"
    });
  }
  _setCtrlKeyTimeout() {
    this.inputs.ctrlKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Ctrl",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "ControlLeft"
    });
  }
  _setMetaKeyTimeout() {
    this.inputs.metaKey = !1, this.dispatch({
      type: "keyboard",
      name: "key_up",
      key: "Meta",
      shiftKey: this.inputs.shiftKey,
      ctrlKey: this.inputs.ctrlKey,
      altKey: this.inputs.altKey,
      metaKey: this.inputs.metaKey,
      accelKey: ms(this.inputs),
      code: "MetaLeft"
    });
  }
  /**
   * Dispatch an event to the editor.
   *
   * @example
   * ```ts
   * editor.dispatch(myPointerEvent)
   * ```
   *
   * @param info - The event info.
   *
   * @public
   */
  dispatch(e) {
    return this._pendingEventsForNextTick.push(e), e.type === "pointer" && e.name === "pointer_move" || e.type === "wheel" || e.type === "pinch" || this._flushEventsForTick(0), this;
  }
  _flushEventsForTick(e) {
    this.run(() => {
      if (this._pendingEventsForNextTick.length > 0) {
        const t = [...this._pendingEventsForNextTick];
        this._pendingEventsForNextTick.length = 0;
        for (const r of t)
          this._flushEventForTick(r);
      }
      e > 0 && this.root.handleEvent({ type: "misc", name: "tick", elapsed: e }), this.scribbles.tick(e);
    });
  }
  _flushEventForTick(e) {
    if (this.getCrashingError()) return this;
    const { inputs: t } = this, { type: r } = e;
    if (e.type === "misc") {
      (e.name === "cancel" || e.name === "complete") && (this.inputs.isDragging = !1, this.inputs.isPanning && (this.inputs.isPanning = !1, this.inputs.isSpacebarPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 }))), this.root.handleEvent(e);
      return;
    }
    e.shiftKey ? (clearTimeout(this._shiftKeyTimeout), this._shiftKeyTimeout = -1, t.shiftKey = !0) : !e.shiftKey && t.shiftKey && this._shiftKeyTimeout === -1 && (this._shiftKeyTimeout = this.timers.setTimeout(this._setShiftKeyTimeout, 150)), e.altKey ? (clearTimeout(this._altKeyTimeout), this._altKeyTimeout = -1, t.altKey = !0) : !e.altKey && t.altKey && this._altKeyTimeout === -1 && (this._altKeyTimeout = this.timers.setTimeout(this._setAltKeyTimeout, 150)), e.ctrlKey ? (clearTimeout(this._ctrlKeyTimeout), this._ctrlKeyTimeout = -1, t.ctrlKey = !0) : !e.ctrlKey && t.ctrlKey && this._ctrlKeyTimeout === -1 && (this._ctrlKeyTimeout = this.timers.setTimeout(this._setCtrlKeyTimeout, 150)), e.metaKey ? (clearTimeout(this._metaKeyTimeout), this._metaKeyTimeout = -1, t.metaKey = !0) : !e.metaKey && t.metaKey && this._metaKeyTimeout === -1 && (this._metaKeyTimeout = this.timers.setTimeout(this._setMetaKeyTimeout, 150));
    const { originPagePoint: i, currentPagePoint: s } = t;
    t.isPointing || (t.isDragging = !1);
    const l = this.store.unsafeGetWithoutCapture(hs), c = this.store.get(this._getCurrentPageStateId()), d = this._cameraOptions.__unsafe__getWithoutCapture();
    switch (r) {
      case "pinch": {
        if (d.isLocked) return;
        switch (clearTimeout(this._longPressTimeout), this._updateInputsFromEvent(e), e.name) {
          case "pinch_start": {
            if (t.isPinching) return;
            t.isEditing || (this._pinchStart = this.getCamera().z, this._selectedShapeIdsAtPointerDown.length || (this._selectedShapeIdsAtPointerDown = [...c.selectedShapeIds]), this._didPinch = !0, t.isPinching = !0, this.interrupt());
            return;
          }
          case "pinch": {
            if (!t.isPinching) return;
            const {
              point: { z: h = 1 },
              delta: { x: g, y }
            } = e, { x: v, y: w } = R.SubXY(
              e.point,
              l.screenBounds.x,
              l.screenBounds.y
            );
            this.stopCameraAnimation(), l.followingUserId && this.stopFollowingUser();
            const { x: C, y: E, z: P } = A1(() => this.getCamera()), { panSpeed: I, zoomSpeed: k } = d;
            this._setCamera(
              new R(
                C + g * I / P - v / P + v / (h * k),
                E + y * I / P - w / P + w / (h * k),
                h * k
              ),
              { immediate: !0 }
            );
            return;
          }
          case "pinch_end": {
            if (!t.isPinching) return this;
            t.isPinching = !1;
            const { _selectedShapeIdsAtPointerDown: h } = this;
            this.setSelectedShapes(this._selectedShapeIdsAtPointerDown), this._selectedShapeIdsAtPointerDown = [], this._didPinch && (this._didPinch = !1, h.length > 0 && this.once("tick", () => {
              this._didPinch || this.setSelectedShapes(h);
            }));
            return;
          }
        }
      }
      case "wheel": {
        if (d.isLocked) return;
        this._updateInputsFromEvent(e);
        const { panSpeed: h, zoomSpeed: g, wheelBehavior: y } = d;
        if (y !== "none") {
          this.stopCameraAnimation(), l.followingUserId && this.stopFollowingUser();
          const { x: v, y: w, z: C } = A1(() => this.getCamera()), { x: E, y: P, z: I = 0 } = e.delta;
          let k = y;
          switch (t.ctrlKey && (k = y === "pan" ? "zoom" : "pan"), k) {
            case "zoom": {
              const { x: L, y: O } = this.inputs.currentScreenPoint;
              let z = I;
              y === "zoom" && (Math.abs(P) > 10 ? z = 10 * Math.sign(P) / 100 : z = P / 100);
              const F = C + (z ?? 0) * g * C;
              this._setCamera(
                new R(
                  v + (L / F - L) - (L / C - L),
                  w + (O / F - O) - (O / C - O),
                  F
                ),
                { immediate: !0 }
              ), this.maybeTrackPerformance("Zooming");
              return;
            }
            case "pan": {
              this._setCamera(new R(v + E * h / C, w + P * h / C, C), {
                immediate: !0
              }), this.maybeTrackPerformance("Panning");
              return;
            }
          }
        }
        break;
      }
      case "pointer": {
        if (t.isPinching) return;
        this._updateInputsFromEvent(e);
        const { isPen: h } = e, { isPenMode: g } = l;
        switch (e.name) {
          case "pointer_down": {
            if (g && !h) return;
            if (this.inputs.isPanning || (this._longPressTimeout = this.timers.setTimeout(() => {
              const y = this.getViewportScreenBounds();
              this.dispatch({
                ...e,
                // important! non-obvious!! the screenpoint was adjusted using the
                // viewport bounds, and will be again when this event is handled...
                // so we need to counter-adjust from the stored value so that the
                // new value is set correctly.
                point: this.inputs.originScreenPoint.clone().addXY(y.x, y.y),
                name: "long_press"
              });
            }, this.options.longPressDurationMs)), this._selectedShapeIdsAtPointerDown = this.getSelectedShapeIds(), e.button === w4 && (this.capturedPointerId = e.pointerId), t.buttons.add(e.button), t.isPointing = !0, t.isDragging = !1, !g && h && this.updateInstanceState({ isPenMode: !0 }), e.button === b4 ? (this._restoreToolId = this.getCurrentToolId(), this.complete(), this.setCurrentTool("eraser")) : e.button === $1 && (this.inputs.isPanning || (this._prevCursor = this.getInstanceState().cursor.type), this.inputs.isPanning = !0, clearTimeout(this._longPressTimeout)), this.inputs.isPanning)
              return this.stopCameraAnimation(), this.setCursor({ type: "grabbing", rotation: 0 }), this;
            break;
          }
          case "pointer_move": {
            if (!h && g) return;
            const { x: y, y: v, z: w } = A1(() => this.getCamera());
            if (this.inputs.isPanning && this.inputs.isPointing) {
              const { currentScreenPoint: C, previousScreenPoint: E } = this.inputs, { panSpeed: P } = d, I = R.Sub(C, E);
              this.setCamera(
                new R(y + I.x * P / w, v + I.y * P / w, w),
                { immediate: !0 }
              ), this.maybeTrackPerformance("Panning");
              return;
            }
            t.isPointing && !t.isDragging && R.Dist2(i, s) * this.getZoomLevel() > (l.isCoarsePointer ? this.options.coarseDragDistanceSquared : this.options.dragDistanceSquared) / w && (t.isDragging = !0, clearTimeout(this._longPressTimeout));
            break;
          }
          case "pointer_up": {
            if (t.isDragging = !1, t.isPointing = !1, clearTimeout(this._longPressTimeout), t.buttons.delete(e.button), l.isPenMode && !h) return;
            if (this.capturedPointerId === e.pointerId && (this.capturedPointerId = null, e.button = 0), t.isPanning) {
              t.keys.has("Space") || (t.isPanning = !1, t.isSpacebarPanning = !1);
              const y = this.inputs.pointerVelocity, v = Math.min(2, y.len());
              switch (e.button) {
                case w4: {
                  this.setCursor({ type: "grab", rotation: 0 });
                  break;
                }
                case $1:
                  this.inputs.keys.has(" ") ? this.setCursor({ type: "grab", rotation: 0 }) : this.setCursor({ type: this._prevCursor, rotation: 0 });
              }
              v > 0 && this.slideCamera({ speed: v, direction: y });
            } else
              e.button === b4 && (this.complete(), this.setCurrentTool(this._restoreToolId));
            break;
          }
        }
        break;
      }
      case "keyboard": {
        switch (e.key === "ShiftRight" && (e.key = "ShiftLeft"), e.key === "AltRight" && (e.key = "AltLeft"), e.code === "ControlRight" && (e.code = "ControlLeft"), e.code === "MetaRight" && (e.code = "MetaLeft"), e.name) {
          case "key_down": {
            if (t.keys.add(e.code), e.code === "Space" && !e.ctrlKey && (this.inputs.isPanning || (this._prevCursor = l.cursor.type), this.inputs.isPanning = !0, this.inputs.isSpacebarPanning = !0, clearTimeout(this._longPressTimeout), this.setCursor({ type: this.inputs.isPointing ? "grabbing" : "grab", rotation: 0 })), this.inputs.isSpacebarPanning) {
              let h;
              switch (e.code) {
                case "ArrowUp": {
                  h = new R(0, -1);
                  break;
                }
                case "ArrowRight": {
                  h = new R(1, 0);
                  break;
                }
                case "ArrowDown": {
                  h = new R(0, 1);
                  break;
                }
                case "ArrowLeft": {
                  h = new R(-1, 0);
                  break;
                }
              }
              if (h) {
                const g = this.getViewportPageBounds(), y = g.clone().translate(h.mulV({ x: g.w, y: g.h }));
                this._animateToViewport(y, { animation: { duration: 320 } });
              }
            }
            break;
          }
          case "key_up": {
            t.keys.delete(e.code), e.code === "Space" && (this.inputs.buttons.has($1) || (this.inputs.isPanning = !1, this.inputs.isSpacebarPanning = !1, this.setCursor({ type: this._prevCursor, rotation: 0 })));
            break;
          }
        }
        break;
      }
    }
    if (e.type === "pointer") {
      e.button === $1 ? e.name = "middle_click" : e.button === OO && (e.name = "right_click");
      const { isPenMode: h } = this.store.unsafeGetWithoutCapture(hs);
      if (e.isPen === h) {
        const g = this._clickManager.handlePointerEvent(e);
        if (e.name !== g.name) {
          this.root.handleEvent(e), this.emit("event", e), this.root.handleEvent(g), this.emit("event", g);
          return;
        }
      }
    }
    return this.root.handleEvent(e), this.emit("event", e), e.type === "pointer" && e.name === "pointer_down" && this.menus.clearOpenMenus(), this;
  }
  /** @internal */
  maybeTrackPerformance(e) {
    Ei.measurePerformance.get() && (this.performanceTracker.isStarted() ? clearTimeout(this.performanceTrackerTimeout) : this.performanceTracker.start(e), this.performanceTrackerTimeout = this.timers.setTimeout(() => {
      this.performanceTracker.stop();
    }, 50));
  }
}
ct = ude(rD);
ht(ct, 1, "getIsShapeHiddenCache", TH, at);
ht(ct, 1, "getCanUndo", PH, at);
ht(ct, 1, "getCanRedo", _H, at);
ht(ct, 1, "getPath", EH, at);
ht(ct, 1, "getCurrentTool", CH, at);
ht(ct, 1, "getCurrentToolId", bH, at);
ht(ct, 1, "getDocumentSettings", wH, at);
ht(ct, 1, "getInstanceState", xH, at);
ht(ct, 1, "getOpenMenus", SH, at);
ht(ct, 1, "getIsMenuOpen", vH, at);
ht(ct, 1, "getPageStates", yH, at);
ht(ct, 1, "_getPageStatesQuery", mH, at);
ht(ct, 1, "getCurrentPageState", gH, at);
ht(ct, 1, "_getCurrentPageStateId", pH, at);
ht(ct, 1, "getSelectedShapeIds", hH, at);
ht(ct, 1, "getSelectedShapes", fH, at);
ht(ct, 1, "getOnlySelectedShapeId", dH, at);
ht(ct, 1, "getOnlySelectedShape", uH, at);
ht(ct, 1, "getSelectionPageBounds", cH, at);
ht(ct, 1, "getSelectionRotation", lH, at);
ht(ct, 1, "getSelectionRotatedPageBounds", aH, at);
ht(ct, 1, "getSelectionRotatedScreenBounds", sH, at);
ht(ct, 1, "getFocusedGroupId", oH, at);
ht(ct, 1, "getFocusedGroup", iH, at);
ht(ct, 1, "getEditingShapeId", rH, at);
ht(ct, 1, "getEditingShape", nH, at);
ht(ct, 1, "getHoveredShapeId", tH, at);
ht(ct, 1, "getHoveredShape", eH, at);
ht(ct, 1, "getHintingShapeIds", J7, at);
ht(ct, 1, "getHintingShape", Q7, at);
ht(ct, 1, "getErasingShapeIds", Z7, at);
ht(ct, 1, "getErasingShapes", X7, at);
ht(ct, 1, "_unsafe_getCameraId", Y7, at);
ht(ct, 1, "getCamera", q7, at);
ht(ct, 1, "getViewportPageBoundsForFollowing", G7, at);
ht(ct, 1, "getCameraForFollowing", W7, at);
ht(ct, 1, "getZoomLevel", K7, at);
ht(ct, 1, "getViewportScreenBounds", V7, at);
ht(ct, 1, "getViewportScreenCenter", H7, at);
ht(ct, 1, "getViewportPageBounds", B7, at);
ht(ct, 1, "_getCollaboratorsQuery", $7, at);
ht(ct, 1, "getCollaborators", U7, at);
ht(ct, 1, "getCollaboratorsOnCurrentPage", z7, at);
ht(ct, 1, "getRenderingShapes", F7, at);
ht(ct, 1, "_getAllPagesQuery", N7, at);
ht(ct, 1, "getPages", L7, at);
ht(ct, 1, "getCurrentPageId", j7, at);
ht(ct, 1, "getCurrentPageShapeIdsSorted", O7, at);
ht(ct, 1, "_getAllAssetsQuery", D7, at);
ht(ct, 1, "_getShapeGeometryCache", A7, at);
ht(ct, 1, "_getShapeHandlesCache", M7, at);
ht(ct, 1, "_getShapePageTransformCache", R7, at);
ht(ct, 1, "_getShapePageBoundsCache", k7, at);
ht(ct, 1, "_getShapeClipPathCache", I7, at);
ht(ct, 1, "_getShapeMaskCache", T7, at);
ht(ct, 1, "_getShapeMaskedPageBoundsCache", P7, at);
ht(ct, 1, "_notVisibleShapes", _7, at);
ht(ct, 1, "getCulledShapes", E7, at);
ht(ct, 1, "getCurrentPageBounds", C7, at);
ht(ct, 1, "getCurrentPageShapes", b7, at);
ht(ct, 1, "getCurrentPageShapesSorted", w7, at);
ht(ct, 1, "getCurrentPageRenderingShapesSorted", x7, at);
ht(ct, 1, "_getBindingsIndexCache", S7, at);
ht(ct, 1, "_getSelectionSharedStyles", v7, at);
ht(ct, 1, "getSharedStyles", y7, at);
ht(ct, 1, "getSharedOpacity", m7, at);
ht(ct, 1, "getIsFocused", g7, at);
ht(ct, 1, "getIsReadonly", p7, at);
ht(ct, 1, "_setShiftKeyTimeout", h7, at);
ht(ct, 1, "_setAltKeyTimeout", f7, at);
ht(ct, 1, "_setCtrlKeyTimeout", d7, at);
ht(ct, 1, "_setMetaKeyTimeout", u7, at);
fde(ct, at);
function G1(n, e = n.getCurrentPageId()) {
  const t = n.getPage(e).name;
  n.emit("max-shapes", { name: t, pageId: e, count: n.options.maxShapesPerPage });
}
function hu(n, e) {
  if (!e) return n;
  let t = null;
  const r = Object.entries(e);
  for (let i = 0, s = r.length; i < s; i++) {
    const [l, c] = r[i];
    if (c !== void 0 && !(l === "id" || l === "type" || l === "typeName") && c !== n[l]) {
      if (t || (t = { ...n }), l === "props" || l === "meta") {
        t[l] = { ...n[l] };
        for (const [d, h] of Object.entries(c))
          t[l][d] = h;
        continue;
      }
      t[l] = c;
    }
  }
  return t || n;
}
function IH(n, e, t) {
  const r = n.getShape(e);
  if (!r) return;
  t.push(r);
  const i = n.getSortedChildIdsForParent(e);
  for (let s = 0, l = i.length; s < l; s++)
    IH(n, i[s], t);
}
function rU(n, e, t) {
  let r;
  if (n.run(
    () => {
      const i = n.store.extractingChanges(() => {
        const s = /* @__PURE__ */ new Set(), l = /* @__PURE__ */ new Set();
        for (const c of e)
          if (n.getShape(c))
            for (const h of n.getBindingsInvolvingShape(c)) {
              const g = e.has(h.fromId), y = e.has(h.toId);
              if (g && y) {
                s.add(h.id);
                continue;
              }
              (!g || !y) && l.add(h.id);
            }
        n.deleteBindings([...l], { isolateShapes: !0 });
        try {
          r = uh.ok(t(s));
        } catch (c) {
          r = uh.err(c);
        }
      });
      n.store.applyDiff(Kx(i));
    },
    { history: "ignore" }
  ), r.ok)
    return r.value;
  throw r.error;
}
function iU(n, e) {
  if (!e.constraints) throw Error("Should have constraints here");
  const {
    padding: { x: t, y: r }
  } = e.constraints, i = n.getViewportScreenBounds(), s = Xe.From(e.constraints.bounds), l = (i.w - t * 2) / s.w, c = (i.h - r * 2) / s.h;
  return { zx: l, zy: c };
}
function Pw() {
  const n = be(), e = bw();
  return Pe("isDarkMode", () => (e == null ? void 0 : e.isDarkMode) ?? n.user.getIsDarkMode(), [
    e,
    n
  ]);
}
const oU = "<path d='m19.7432 17.0869-4.072 4.068 2.829 2.828-8.473-.013-.013-8.47 2.841 2.842 4.075-4.068 1.414-1.415-2.844-2.842h8.486v8.484l-2.83-2.827z' fill='%23fff'/><path d='m18.6826 16.7334-4.427 4.424 1.828 1.828-5.056-.016-.014-5.054 1.842 1.841 4.428-4.422 2.474-2.475-1.844-1.843h5.073v5.071l-1.83-1.828z' fill='%23000'/>", sU = "<path d='m9 17.9907v.005l5.997 5.996.001-3.999h1.999 2.02v4l5.98-6.001-5.98-5.999.001 4.019-2.021.002h-2l.001-4.022zm1.411.003 3.587-3.588-.001 2.587h3.5 2.521v-2.585l3.565 3.586-3.564 3.585-.001-2.585h-2.521l-3.499-.001-.001 2.586z' fill='%23fff'/><path d='m17.4971 18.9932h2.521v2.586l3.565-3.586-3.565-3.585v2.605h-2.521-3.5v-2.607l-3.586 3.587 3.586 3.586v-2.587z' fill='%23000'/>", q1 = '<path d="M22.4789 9.45728L25.9935 12.9942L22.4789 16.5283V14.1032C18.126 14.1502 14.6071 17.6737 14.5675 22.0283H17.05L13.513 25.543L9.97889 22.0283H12.5674C12.6071 16.5691 17.0214 12.1503 22.4789 12.1031L22.4789 9.45728Z" fill="black"/><path fill-rule="evenodd" clip-rule="evenodd" d="M21.4789 7.03223L27.4035 12.9945L21.4789 18.9521V15.1868C18.4798 15.6549 16.1113 18.0273 15.649 21.0284H19.475L13.5128 26.953L7.55519 21.0284H11.6189C12.1243 15.8155 16.2679 11.6677 21.4789 11.1559L21.4789 7.03223ZM22.4789 12.1031C17.0214 12.1503 12.6071 16.5691 12.5674 22.0284H9.97889L13.513 25.543L17.05 22.0284H14.5675C14.5705 21.6896 14.5947 21.3558 14.6386 21.0284C15.1157 17.4741 17.9266 14.6592 21.4789 14.1761C21.8063 14.1316 22.1401 14.1069 22.4789 14.1032V16.5284L25.9935 12.9942L22.4789 9.45729L22.4789 12.1031Z" fill="white"/>';
function Jf(n, e, t, r, i, s = 16, l = 16) {
  const c = (-t - e) * (Xn / 180), d = Math.sin(c), h = Math.cos(c), g = 1 * h - 1 * d, y = 1 * d + 1 * h;
  return `url("data:image/svg+xml,<svg height='32' width='32' viewBox='0 0 32 32' xmlns='http://www.w3.org/2000/svg' style='color: ${i};'><defs><filter id='shadow' y='-40%' x='-40%' width='180px' height='180%' color-interpolation-filters='sRGB'><feDropShadow dx='${g}' dy='${y}' stdDeviation='1.2' flood-opacity='.5'/></filter></defs><g fill='none' transform='rotate(${e + t} 16 16)${r ? " scale(-1,-1) translate(0, -32)" : ""}' filter='url(%23shadow)'>` + n.replaceAll('"', "'") + `</g></svg>") ${s} ${l}, pointer`;
}
const pde = [
  "default",
  "pointer",
  "cross",
  "move",
  "grab",
  "grabbing",
  "text",
  "zoom-in",
  "zoom-out"
], gde = {
  none: () => "none",
  "ew-resize": (n, e, t) => Jf(sU, n, 0, e, t),
  "ns-resize": (n, e, t) => Jf(sU, n, 90, e, t),
  "nesw-resize": (n, e, t) => Jf(oU, n, 0, e, t),
  "nwse-resize": (n, e, t) => Jf(oU, n, 90, e, t),
  "nwse-rotate": (n, e, t) => Jf(q1, n, 0, e, t),
  "nesw-rotate": (n, e, t) => Jf(q1, n, 90, e, t),
  "senw-rotate": (n, e, t) => Jf(q1, n, 180, e, t),
  "swne-rotate": (n, e, t) => Jf(q1, n, 270, e, t)
};
function Wa(n, e = 0, t = "black") {
  return gde[n](ose(e), !1, t);
}
function mde() {
  const n = be(), e = io(), t = Pw();
  dh(
    "useCursor",
    () => {
      const { type: r, rotation: i } = n.getInstanceState().cursor;
      if (pde.includes(r)) {
        e.style.setProperty("--tl-cursor", `var(--tl-cursor-${r})`);
        return;
      }
      e.style.setProperty(
        "--tl-cursor",
        Wa(r, i, t ? "white" : "black")
      );
    },
    [n, e, t]
  );
}
function yde() {
  const n = be(), e = io(), t = Pw(), r = Pe(Ei.forceSrgb);
  Bt.useEffect(() => {
    t ? (e.setAttribute("data-color-mode", "dark"), e.classList.remove("tl-theme__light"), e.classList.add("tl-theme__dark")) : (e.setAttribute("data-color-mode", "light"), e.classList.remove("tl-theme__dark"), e.classList.add("tl-theme__light")), r ? e.classList.add("tl-theme__force-sRGB") : e.classList.remove("tl-theme__force-sRGB");
  }, [n, e, r, t]);
}
function vde() {
  const [n, e] = M.useState(0);
  M.useEffect(() => e((t) => t + 1), []);
}
const Sde = (n) => n.props.src, xde = {
  upload: (n, e) => yc.blobToDataUrl(e)
};
function iD(n) {
  return "schema" in n && n.schema ? n.schema : Pie({
    shapes: "shapeUtils" in n && n.shapeUtils ? aU(DB(n.shapeUtils)) : void 0,
    bindings: "bindingUtils" in n && n.bindingUtils ? aU(MB(n.bindingUtils)) : void 0,
    migrations: "migrations" in n ? n.migrations : void 0
  });
}
function Zx({
  initialData: n,
  defaultName: e = "",
  id: t,
  assets: r = xde,
  onMount: i,
  collaboration: s,
  ...l
} = {}) {
  const c = iD(l), d = new sO({
    id: t,
    schema: c,
    initialData: n,
    props: {
      defaultName: e,
      assets: {
        upload: r.upload,
        resolve: r.resolve ?? Sde
      },
      onMount: (h) => {
        on(h instanceof at), i == null || i(h);
      },
      collaboration: s
    }
  });
  if (l.snapshot) {
    if (n) throw new Error("Cannot provide both initialData and snapshot");
    kB(d, l.snapshot);
  }
  return d;
}
function aU(n) {
  return Object.fromEntries(
    n.map((e) => [
      e.type,
      {
        props: e.props,
        migrations: e.migrations
      }
    ])
  );
}
function wde() {
  window.alert(
    `Oops! We could not save changes to your browser's storage. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.
• If your hard disk is full, try clearing up some space and then reload the page.`
  );
}
function bde() {
  window.alert(
    `Oops! We could not access your browser's storage—and the app won't work correctly without that. We now need to reload the page and try again.

Keep seeing this message?
• If you're using tldraw in a private or "incognito" window, try loading tldraw in a regular window or in a different browser.`
  );
}
const Cde = 350, Ede = 1e4, lU = Symbol("UPDATE_INSTANCE_STATE"), _de = (n) => n;
class Pde {
  constructor(e) {
    U(this, "onmessage");
  }
  postMessage(e) {
  }
  close() {
  }
}
const Tde = typeof BroadcastChannel > "u" ? Pde : BroadcastChannel;
class Ide {
  constructor(e, {
    persistenceKey: t,
    sessionId: r = Xx,
    onLoad: i,
    onLoadError: s
  }, l = new Tde(`tldraw-tab-sync-${t}`)) {
    U(this, "disposables", /* @__PURE__ */ new Set());
    U(this, "diffQueue", []);
    U(this, "didDispose", !1);
    U(this, "shouldDoFullDBWrite", !0);
    U(this, "isReloading", !1);
    U(this, "persistenceKey");
    U(this, "sessionId");
    U(this, "serializedSchema");
    U(this, "isDebugging", !1);
    U(this, "documentTypes");
    U(this, "$sessionStateSnapshot");
    /** @internal */
    U(this, "db");
    U(this, "initTime", Date.now());
    U(this, "isPersisting", !1);
    U(this, "didLastWriteError", !1);
    // eslint-disable-next-line no-restricted-globals
    U(this, "scheduledPersistTimeout", null);
    this.store = e, this.channel = l, typeof window < "u" && (window.tlsync = this), this.persistenceKey = t, this.sessionId = r, this.db = new mE(t), this.disposables.add(() => this.db.close()), this.serializedSchema = this.store.schema.serialize(), this.$sessionStateSnapshot = HO(this.store), this.disposables.add(
      // Set up a subscription to changes from the store: When
      // the store changes (and if the change was made by the user)
      // then immediately send the diff to other tabs via postMessage
      // and schedule a persist.
      e.listen(
        ({ changes: c }) => {
          this.diffQueue.push(c), this.channel.postMessage(
            _de({
              type: "diff",
              storeId: this.store.id,
              changes: c,
              schema: this.serializedSchema
            })
          ), this.schedulePersist();
        },
        { source: "user", scope: "document" }
      )
    ), this.disposables.add(
      e.listen(
        () => {
          this.diffQueue.push(lU), this.schedulePersist();
        },
        { scope: "session" }
      )
    ), this.connect(i, s), this.documentTypes = new Set(
      Object.values(this.store.schema.types).filter((c) => c.scope === "document").map((c) => c.typeName)
    );
  }
  debug(...e) {
    this.isDebugging && console.debug(...e);
  }
  async connect(e, t) {
    this.debug("connecting");
    let r;
    try {
      r = await this.db.load({ sessionId: this.sessionId });
    } catch (i) {
      t(i), bde();
      return;
    }
    if (this.debug("loaded data from store", r, "didDispose", this.didDispose), !this.didDispose)
      try {
        if (r) {
          const i = Object.fromEntries(r.records.map((d) => [d.id, d])), s = r.sessionStateSnapshot ?? Lle(i), l = this.store.schema.migrateStoreSnapshot({
            store: i,
            // eslint-disable-next-line @typescript-eslint/no-deprecated
            schema: r.schema ?? this.store.schema.serializeEarliestVersion()
          });
          if (l.type === "error") {
            console.error("failed to migrate store", l), t(new Error(`Failed to migrate store: ${l.reason}`));
            return;
          }
          const c = Object.values(l.value).filter(
            (d) => this.documentTypes.has(d.typeName)
          );
          c.length > 0 && this.store.mergeRemoteChanges(() => {
            this.store.put(c, "initialize");
          }), s && XA(this.store, s);
        }
        this.channel.onmessage = ({ data: i }) => {
          var c, d;
          this.debug("got message", i);
          const s = i, l = this.store.schema.getMigrationsSince(s.schema);
          if (l.ok) {
            if (l.value.length > 0) {
              this.debug("telling them to reload"), this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.shouldDoFullDBWrite = !0, this.persistIfNeeded();
              return;
            }
          } else {
            if (Date.now() - this.initTime < 5e3) {
              t(new Error("Schema mismatch, please close other tabs and reload the page"));
              return;
            }
            this.debug("reloading"), this.isReloading = !0, (d = (c = window == null ? void 0 : window.location) == null ? void 0 : c.reload) == null || d.call(c);
            return;
          }
          s.type === "diff" && (this.debug("applying diff"), Dl(() => {
            this.store.mergeRemoteChanges(() => {
              this.store.applyDiff(s.changes);
            });
          }));
        }, this.channel.postMessage({ type: "announce", schema: this.serializedSchema }), this.disposables.add(() => {
          this.channel.close();
        }), e(this);
      } catch (i) {
        if (this.debug("error loading data from store", i), this.didDispose) return;
        t(i);
        return;
      }
  }
  close() {
    this.debug("closing"), this.didDispose = !0, this.disposables.forEach((e) => e());
  }
  /**
   * Schedule a persist. Persists don't happen immediately: they are throttled to avoid writing too
   * often, and will retry if failed.
   *
   * @internal
   */
  schedulePersist() {
    this.debug("schedulePersist", this.scheduledPersistTimeout), !this.scheduledPersistTimeout && (this.scheduledPersistTimeout = setTimeout(
      () => {
        this.scheduledPersistTimeout = null, this.persistIfNeeded();
      },
      this.didLastWriteError ? Ede : Cde
    ));
  }
  /**
   * Persist to IndexedDB only under certain circumstances:
   *
   * - If we're not already persisting
   * - If we're not reloading the page
   * - And we have something to persist (a full db write scheduled or changes in the diff queue)
   *
   * @internal
   */
  persistIfNeeded() {
    this.debug("persistIfNeeded", {
      isPersisting: this.isPersisting,
      isReloading: this.isReloading,
      shouldDoFullDBWrite: this.shouldDoFullDBWrite,
      diffQueueLength: this.diffQueue.length,
      storeIsPossiblyCorrupt: this.store.isPossiblyCorrupted()
    }), this.scheduledPersistTimeout && (clearTimeout(this.scheduledPersistTimeout), this.scheduledPersistTimeout = null), !this.isPersisting && (this.isReloading || this.store.isPossiblyCorrupted() || (this.shouldDoFullDBWrite || this.diffQueue.length > 0) && this.doPersist());
  }
  /**
   * Actually persist to IndexedDB. If the write fails, then we'll retry with a full db write after
   * a short delay.
   */
  async doPersist() {
    if (on(!this.isPersisting, "persist already in progress"), this.didDispose) return;
    this.isPersisting = !0, this.debug("doPersist start");
    const e = this.diffQueue;
    this.diffQueue = [];
    try {
      if (this.shouldDoFullDBWrite)
        this.shouldDoFullDBWrite = !1, await this.db.storeSnapshot({
          schema: this.store.schema,
          snapshot: this.store.serialize(),
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      else {
        const t = $E(
          e.filter((r) => r !== lU)
        );
        await this.db.storeChanges({
          changes: t,
          schema: this.store.schema,
          sessionId: this.sessionId,
          sessionStateSnapshot: this.$sessionStateSnapshot.get()
        });
      }
      this.didLastWriteError = !1;
    } catch (t) {
      this.shouldDoFullDBWrite = !0, this.didLastWriteError = !0, console.error("failed to store changes in indexed db", t), wde(), typeof window < "u" && window.location.reload();
    }
    this.isPersisting = !1, this.debug("doPersist end"), this.schedulePersist();
  }
}
function nj(n) {
  const e = M.useRef(n), [t, r] = M.useState(n);
  t !== e.current && r(e.current);
  const i = M.useCallback((s) => {
    typeof s == "function" ? e.current = s(e.current) : e.current = s, r(e.current);
  }, []);
  return [t, i];
}
function kde(n) {
  const [e, t] = nj({ status: "loading" });
  return n = fg(n), M.useEffect(() => {
    const { persistenceKey: r, sessionId: i, ...s } = n;
    if (!r) {
      t({
        status: "not-synced",
        store: Zx(s)
      });
      return;
    }
    t({ status: "loading" });
    const l = new Cu(), c = {
      upload: async (y, v) => (await g.db.storeAsset(y.id, v), y.id),
      resolve: async (y) => y.props.src ? y.props.src.startsWith("asset:") ? await l.get(y, async () => {
        const v = await g.db.getAsset(y.id);
        return v ? URL.createObjectURL(v) : null;
      }) : y.props.src : null,
      ...s.assets
    }, d = Zx({ ...s, assets: c });
    let h = !1;
    const g = new Ide(d, {
      sessionId: i,
      persistenceKey: r,
      onLoad() {
        h || t({ store: d, status: "synced-local" });
      },
      onLoadError(y) {
        h || t({ status: "error", error: y });
      }
    });
    return () => {
      h = !0, g.close();
    };
  }, [n, t]), e;
}
function Rde() {
  const n = be(), e = io();
  M.useEffect(() => {
    const t = (s) => e.style.setProperty("--tl-zoom", s.toString()), r = LE(t, 100), i = new Uy("useZoomCss", () => {
      n.getCurrentPageShapeIds().size < 300 ? t(n.getZoomLevel()) : r(n.getZoomLevel());
    });
    return i.attach(), i.execute(), () => {
      i.detach(), r.cancel();
    };
  }, [n, e]);
}
function oD(n) {
  const e = new ArrayBuffer(n.length), t = new Uint8Array(e);
  for (let r = 0, i = n.length; r < i; r++)
    t[r] = n.charCodeAt(r);
  return e;
}
function Mde(n) {
  const e = atob(n), t = oD(e);
  return crypto.subtle.importKey(
    "spki",
    new Uint8Array(t),
    {
      name: "ECDSA",
      namedCurve: "P-256"
    },
    !0,
    ["verify"]
  );
}
var Ade = {};
const Dde = 5, Cx = {
  ANNUAL_LICENSE: 1,
  PERPETUAL_LICENSE: 2,
  INTERNAL_LICENSE: 4,
  WITH_WATERMARK: 8
}, Ode = Math.max(...Object.values(Cx)), Ex = {
  ID: 0,
  HOSTS: 1,
  FLAGS: 2,
  EXPIRY_DATE: 3
}, jde = Object.keys(Ex).length, OM = "sales@tldraw.com", Lde = `${ch()}/watermarks/watermark-track.svg`;
class f_ {
  constructor(e, t, r) {
    U(this, "publicKey", "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEHJh0uUfxHtCGyerXmmatE368Hd9rI6LH9oPDQihnaCryRFWEVeOvf9U/SPbyxX74LFyJs5tYeAHq5Nc0Ax25LQ");
    U(this, "isDevelopment");
    U(this, "isTest");
    U(this, "isCryptoAvailable");
    U(this, "state", mi(
      "license state",
      "pending"
    ));
    U(this, "verbose", !0);
    this.isTest = Ade.NODE_ENV === "test", this.isDevelopment = this.getIsDevelopment(r), this.publicKey = t || this.publicKey, this.isCryptoAvailable = !!crypto.subtle, this.getLicenseFromKey(e).then((i) => {
      const s = Nde(i);
      !this.isDevelopment && s && Eu(Lde), s ? this.state.set("unlicensed") : i.isLicensedWithWatermark ? this.state.set("licensed-with-watermark") : this.state.set("licensed");
    });
  }
  getIsDevelopment(e) {
    return e === "development" ? !0 : e === "production" ? !1 : window.location.protocol !== "https:";
  }
  async extractLicenseKey(e) {
    const [t, r] = e.split("."), [i, s] = t.split("/");
    if (!i.startsWith("tldraw-"))
      throw new Error(`Unsupported prefix '${i}'`);
    const l = await Mde(this.publicKey);
    let c;
    try {
      c = await crypto.subtle.verify(
        {
          name: "ECDSA",
          hash: { name: "SHA-256" }
        },
        l,
        new Uint8Array(oD(atob(r))),
        new Uint8Array(oD(atob(s)))
      );
    } catch (h) {
      throw console.error(h), new Error("Could not perform signature validation");
    }
    if (!c)
      throw new Error("Invalid signature");
    let d;
    try {
      d = JSON.parse(atob(s));
    } catch {
      throw new Error("Could not parse object");
    }
    return d.length > jde && this.outputMessages([
      "License key contains some unknown properties.",
      "You may want to update tldraw packages to a newer version to get access to new functionality."
    ]), {
      id: d[Ex.ID],
      hosts: d[Ex.HOSTS],
      flags: d[Ex.FLAGS],
      expiryDate: d[Ex.EXPIRY_DATE]
    };
  }
  async getLicenseFromKey(e) {
    if (!e)
      return this.isDevelopment || this.outputNoLicenseKeyProvided(), { isLicenseParseable: !1, reason: "no-key-provided" };
    if (this.isDevelopment && !this.isCryptoAvailable)
      return this.verbose && (console.log(
        "tldraw: you seem to be in a development environment that does not support crypto. License not verified."
      ), console.log("You should check that this works in production separately.")), { isLicenseParseable: !1, reason: "has-key-development-mode" };
    let t = e.replace(/[\u200B-\u200D\uFEFF]/g, "");
    t = t.replace(/\r?\n|\r/g, "");
    try {
      const r = await this.extractLicenseKey(t), i = new Date(r.expiryDate), s = this.isFlagEnabled(r.flags, Cx.ANNUAL_LICENSE), l = this.isFlagEnabled(r.flags, Cx.PERPETUAL_LICENSE), c = {
        license: r,
        isLicenseParseable: !0,
        isDevelopment: this.isDevelopment,
        isDomainValid: this.isDomainValid(r),
        expiryDate: i,
        isAnnualLicense: s,
        isAnnualLicenseExpired: s && this.isAnnualLicenseExpired(i),
        isPerpetualLicense: l,
        isPerpetualLicenseExpired: l && this.isPerpetualLicenseExpired(i),
        isInternalLicense: this.isFlagEnabled(r.flags, Cx.INTERNAL_LICENSE),
        isLicensedWithWatermark: this.isFlagEnabled(r.flags, Cx.WITH_WATERMARK)
      };
      return this.outputLicenseInfoIfNeeded(c), c;
    } catch (r) {
      return this.outputInvalidLicenseKey(r.message), { isLicenseParseable: !1, reason: "invalid-license-key" };
    }
  }
  isDomainValid(e) {
    const t = window.location.hostname.toLowerCase();
    return e.hosts.some((r) => {
      const i = r.toLowerCase().trim();
      if (i === t || `www.${i}` === t || i === `www.${t}` || r === "*")
        return !0;
      if (r.includes("*")) {
        const s = new RegExp(r.replace(/\*/g, ".*?"));
        return s.test(t) || s.test(`www.${t}`);
      }
      return !1;
    });
  }
  getExpirationDateWithoutGracePeriod(e) {
    return new Date(e.getFullYear(), e.getMonth(), e.getDate());
  }
  getExpirationDateWithGracePeriod(e) {
    return new Date(
      e.getFullYear(),
      e.getMonth(),
      e.getDate() + Dde + 1
      // Add 1 day to include the expiration day
    );
  }
  isAnnualLicenseExpired(e) {
    const t = this.getExpirationDateWithGracePeriod(e), r = /* @__PURE__ */ new Date() >= t;
    return !r && /* @__PURE__ */ new Date() >= this.getExpirationDateWithoutGracePeriod(e) && this.outputMessages([
      "tldraw license is about to expire, you are in a grace period.",
      `Please reach out to ${OM} if you would like to renew your license.`
    ]), r;
  }
  isPerpetualLicenseExpired(e) {
    const t = this.getExpirationDateWithGracePeriod(e), r = {
      major: new Date(m4.major),
      minor: new Date(m4.minor)
    };
    return r.major >= t || r.minor >= t;
  }
  isFlagEnabled(e, t) {
    return (e & t) === t;
  }
  outputNoLicenseKeyProvided() {
  }
  outputInvalidLicenseKey(e) {
    this.outputMessages(["Invalid tldraw license key", `Reason: ${e}`]);
  }
  outputLicenseInfoIfNeeded(e) {
    e.isAnnualLicenseExpired && this.outputMessages([
      "Your tldraw license has expired!",
      `Please reach out to ${OM} to renew.`
    ]), !e.isDomainValid && !e.isDevelopment && this.outputMessages([
      "This tldraw license key is not valid for this domain!",
      `Please reach out to ${OM} if you would like to use tldraw on other domains.`
    ]), e.license.flags >= Ode * 2 && this.outputMessages([
      "This tldraw license contains some unknown flags.",
      "You may want to update tldraw packages to a newer version to get access to new functionality."
    ]);
  }
  outputMessages(e) {
    if (!this.isTest && this.verbose) {
      this.outputDelimiter();
      for (const t of e)
        console.log(
          `%c${t}`,
          "color: white; background: crimson; padding: 2px; border-radius: 3px;"
        );
      this.outputDelimiter();
    }
  }
  outputDelimiter() {
    console.log(
      "%c-------------------------------------------------------------------",
      "color: white; background: crimson; padding: 2px; border-radius: 3px;"
    );
  }
}
U(f_, "className", "tl-watermark_SEE-LICENSE");
function Nde(n) {
  if (!n.isLicenseParseable || !n.isDomainValid && !n.isDevelopment) return !0;
  if (n.isPerpetualLicenseExpired || n.isAnnualLicenseExpired) {
    if (n.isInternalLicense)
      throw new Error("License: Internal license expired.");
    return !0;
  }
  return !1;
}
const kH = M.createContext({}), Fde = () => M.useContext(kH);
function zde({
  licenseKey: n,
  children: e
}) {
  const [t] = M.useState(() => new f_(n));
  return /* @__PURE__ */ m.jsx(kH.Provider, { value: t, children: e });
}
function Th(n) {
  if (!n) throw Error("usePassThroughWheelEvents must be passed a ref");
  const e = io();
  M.useEffect(() => {
    function t(i) {
      if (i.isSpecialRedispatchedEvent) return;
      wn(i);
      const s = e.querySelector(".tl-canvas");
      if (!s) return;
      const l = new WheelEvent("wheel", i);
      l.isSpecialRedispatchedEvent = !0, s.dispatchEvent(l);
    }
    const r = n.current;
    if (r)
      return r.addEventListener("wheel", t, { passive: !1 }), () => {
        r.removeEventListener("wheel", t);
      };
  }, [e, n]);
}
const Ude = '<svg xmlns="http://www.w3.org/2000/svg" width="3001" height="1000" fill="none"><path fill="#000" d="M590.656 300.449c0 49.706-40.294 90-90 90-49.705 0-90-40.294-90-90 0-49.705 40.295-90 90-90 49.706 0 90 40.295 90 90M569.431 719.011c-15.247 32.821-56.006 91.589-98.338 91.438-32.004-.115-38.642-30.904-17.414-50.856 17.381-16.337 28.246-48.075 31.995-72.719.415-2.728-1.556-5.197-4.272-5.679-39.666-7.04-70.746-40.877-70.746-83.417 0-48.23 38.983-87.329 87.07-87.329 39.936 0 70.172 22.237 83.369 52.397 18.839 43.055 7.117 115.733-11.664 156.165M2613.29 385.681V239.319c0-11.363 9.22-20.569 20.59-20.569h8.26c11.37 0 20.59 9.206 20.59 20.569v36.911c0 8.629 7 15.625 15.63 15.625h35.25c8.63 0 15.63-6.996 15.63-15.625v-36.911c0-11.363 9.22-20.569 20.59-20.569h8.17c11.37 0 20.59 9.206 20.59 20.569v146.362c0 11.363-9.22 20.569-20.59 20.569h-8.17c-11.37 0-20.59-9.206-20.59-20.569v-36.999c0-8.63-7-15.625-15.63-15.625h-35.25c-8.63 0-15.63 6.995-15.63 15.625v36.999c0 11.363-9.22 20.569-20.59 20.569h-8.26c-11.37 0-20.59-9.206-20.59-20.569M2391.97 239.319v146.362c0 11.348-9.16 20.569-20.49 20.569h-8.2c-11.33 0-20.49-9.221-20.49-20.569V239.319c0-11.348 9.16-20.569 20.49-20.569h8.2c11.33 0 20.49 9.221 20.49 20.569M2098.23 391.43l-42.69-146.361c-3.85-13.171 6.06-26.319 19.79-26.319h10.6c9.59 0 17.93 6.611 20.08 15.952l17.01 73.045c1.48 6.348 10.47 6.478 12.14.176l19.47-73.838c2.38-9.04 10.57-15.335 19.93-15.335h12.1c9.37 0 17.56 6.3 19.94 15.346l19.49 74.067c1.66 6.305 10.65 6.178 12.13-.171l17.09-73.294c2.15-9.339 10.49-15.948 20.08-15.948h10.53c13.72 0 23.63 13.141 19.79 26.31l-42.63 146.361c-2.56 8.789-10.63 14.829-19.79 14.829h-15.68c-9.12 0-17.16-5.98-19.76-14.709l-21.17-71.059c-1.77-5.948-10.19-5.957-11.97-.012l-21.33 71.071c-2.6 8.729-10.64 14.709-19.76 14.709h-15.59c-9.17 0-17.23-6.035-19.8-14.82M2443.23 218.75h118.59c11.38 0 20.62 9.195 20.62 20.557s-9.24 20.556-20.62 20.556h-24.79c-5.53 0-10 4.477-10 10v115.818c0 11.368-9.25 20.569-20.63 20.569h-7.65c-11.39 0-20.63-9.201-20.63-20.569V269.863c0-5.523-4.48-10-10-10h-24.89c-11.37 0-20.61-9.195-20.61-20.556s9.24-20.557 20.61-20.557M1174.15 218.75h24.64c8.35 0 15.88 5.042 19.04 12.764l34.61 83.942c2.13 5.161 9.44 5.155 11.56-.01l34.43-83.932a20.58 20.58 0 0 1 19.04-12.764h24.64c11.37 0 20.58 9.208 20.58 20.569v146.362c0 11.361-9.21 20.569-20.58 20.569h-7.09c-11.36 0-20.58-9.208-20.58-20.569l-.12-50.645c-.01-6.888-9.53-8.688-12.06-2.283l-23.46 59.332a20.57 20.57 0 0 1-19.14 13.009h-3.03a20.57 20.57 0 0 1-19.15-13.046l-23.47-59.68c-2.52-6.416-12.05-4.623-12.06 2.271l-.13 51.042c0 11.361-9.21 20.569-20.57 20.569h-7.1c-11.36 0-20.57-9.208-20.57-20.569V239.319c0-11.361 9.21-20.569 20.57-20.569"/><path fill="#000" fill-rule="evenodd" d="m1449.94 391.836 6.12-19.392a6.255 6.255 0 0 1 5.96-4.369l50.22-.061a6.24 6.24 0 0 1 5.96 4.348l6.23 19.486c2.71 8.581 10.71 14.402 19.74 14.402h9.34c14.13 0 24.15-13.791 19.61-27.151l-49.74-146.361c-2.85-8.37-10.74-13.988-19.61-13.988h-33.16c-8.87 0-16.77 5.618-19.61 13.988l-49.74 146.361c-4.54 13.36 5.48 27.151 19.61 27.151h9.32c9.04 0 17.04-5.827 19.75-14.414m31.1-98.858c1.85-5.807 10.08-5.796 11.91.016l8.83 27.916c1.28 4.028-1.73 8.134-5.96 8.134h-17.74c-4.23 0-7.24-4.119-5.95-8.151zM1681.81 406.25c18.91 0 35.39-3.686 49.36-11.168 13.97-7.544 24.73-18.394 32.24-32.489 7.56-14.105 11.29-30.866 11.29-50.182 0-19.256-3.73-35.957-11.29-50.004-7.57-14.094-18.35-24.912-32.32-32.397-13.91-7.545-30.4-11.26-49.37-11.26h-49.5c-11.38 0-20.63 9.201-20.63 20.569v146.362c0 11.368 9.25 20.569 20.63 20.569zm23.13-47.701c-6.62 3.215-14.85 4.886-24.79 4.886-10.49 0-19-8.507-19-19v-64.34c0-10.149 8.23-18.376 18.38-18.376 10.18 0 18.56 1.703 25.23 4.974 6.59 3.149 11.63 8.315 15.08 15.633 3.45 7.269 5.28 17.268 5.28 30.162 0 12.891-1.82 22.951-5.28 30.347-3.39 7.319-8.36 12.509-14.9 15.714" clip-rule="evenodd"/><path fill="#000" d="M1804.21 385.681V239.319c0-11.361 9.21-20.569 20.58-20.569h91.28c11.36 0 20.57 9.202 20.57 20.557s-9.21 20.556-20.57 20.556h-54.64a7.807 7.807 0 0 0-7.81 7.813v16.366a7.806 7.806 0 0 0 7.81 7.812h48.13c11.37 0 20.58 9.246 20.58 20.602s-9.21 20.601-20.58 20.601h-48.13a7.806 7.806 0 0 0-7.81 7.812v16.455a7.807 7.807 0 0 0 7.81 7.813h54.64c11.36 0 20.57 9.202 20.57 20.556s-9.21 20.557-20.57 20.557h-91.28c-11.37 0-20.58-9.208-20.58-20.569"/><path fill="#000" fill-rule="evenodd" d="M2875.5 68.75h-2750c-31.066 0-56.25 25.184-56.25 56.25v750c0 31.066 25.184 56.25 56.25 56.25h2750c31.07 0 56.25-25.184 56.25-56.25V125c0-31.066-25.18-56.25-56.25-56.25M125.5 0C56.464 0 .5 55.964.5 125v750c0 69.036 55.965 125 125 125h2750c69.04 0 125-55.964 125-125V125c0-69.036-55.96-125-125-125z" clip-rule="evenodd"/><path fill="#000" d="M2476.06 804.813c-10.54 0-19.82-6.947-22.81-17.068L2390.79 575.7c-4.49-15.248 6.92-30.534 22.8-30.534h27.75c11.1 0 20.72 7.686 23.18 18.52L2489 671.402c2.07 9.093 14.93 9.321 17.32.308l28.83-108.844c2.76-10.435 12.19-17.7 22.98-17.7h25.17c10.8 0 20.25 7.293 22.99 17.755l28.27 107.739c2.36 9.001 15.18 8.829 17.3-.232l25.01-106.888c2.51-10.763 12.1-18.374 23.14-18.374h27.87c15.88 0 27.29 15.286 22.8 30.534l-62.46 212.045a23.78 23.78 0 0 1-22.81 17.068h-32.12c-10.39 0-19.58-6.763-22.69-16.696l-32.08-102.694c-2.62-8.397-14.51-8.331-17.04.095l-30.74 102.346c-3.02 10.061-12.27 16.949-22.76 16.949zM1742.44 804.813h-75.81c-13.09 0-23.71-10.656-23.71-23.801V568.967c0-13.145 10.62-23.801 23.71-23.801h74.8c26.6 0 49.59 5.198 68.95 15.594 19.45 10.312 34.44 25.187 44.96 44.627 10.61 19.355 15.91 42.556 15.91 69.602q0 40.57-15.78 69.73c-10.53 19.355-25.43 34.231-44.71 44.627-19.28 10.311-42.05 15.467-68.32 15.467m-29.3-83.642c0 13.145 10.61 23.801 23.71 23.801h3.06c12.8 0 23.7-2.07 32.71-6.212 9.09-4.141 16-11.283 20.71-21.426q7.2-15.213 7.2-42.345 0-27.13-7.32-42.344c-4.8-10.143-11.87-17.285-21.22-21.426-9.26-4.142-20.63-6.212-34.1-6.212h-1.04c-13.1 0-23.71 10.656-23.71 23.801zM1460.86 804.813c-13.12 0-23.76-10.656-23.76-23.801V568.967c0-13.145 10.64-23.801 23.76-23.801h22.84c13.13 0 23.76 10.656 23.76 23.801v155.247c0 13.145 10.64 23.801 23.76 23.801h57.27c13.12 0 23.76 10.656 23.76 23.801v9.196c0 13.145-10.64 23.801-23.76 23.801zM1204.45 601.964c-13.13 0-23.77-10.656-23.77-23.801v-9.196c0-13.145 10.64-23.801 23.77-23.801h177.89c13.13 0 23.78 10.656 23.78 23.801v9.196c0 13.145-10.65 23.801-23.78 23.801h-39.38c-8.21 0-14.86 6.66-14.86 14.875v164.173c0 13.145-10.64 23.801-23.78 23.801h-21.85c-13.13 0-23.78-10.656-23.78-23.801V616.839c0-8.215-6.65-14.875-14.86-14.875z"/><path fill="#000" fill-rule="evenodd" d="M2223.05 787.891c-3.02 10.047-12.27 16.922-22.74 16.922h-25.43c-16.19 0-27.64-15.862-22.57-31.261l69.88-212.045c3.21-9.753 12.31-16.341 22.56-16.341h61.84c10.25 0 19.35 6.588 22.56 16.341l69.87 212.045c5.08 15.399-6.37 31.261-22.56 31.261h-25.43c-10.48 0-19.72-6.875-22.74-16.922l-6.7-22.2a14.84 14.84 0 0 0-14.21-10.576h-63.42c-6.55 0-12.32 4.296-14.22 10.576zm76.13-96.945-14.13-48.436c-2.46-8.451-14.36-8.602-17.04-.217l-15.46 48.436c-1.84 5.759 2.45 11.645 8.48 11.645h29.6c5.94 0 10.22-5.715 8.55-11.428" clip-rule="evenodd"/><path fill="#000" d="M1939.6 804.813c-13.13 0-23.77-10.656-23.77-23.801V568.967c0-13.145 10.64-23.801 23.77-23.801h88.13c19.24 0 36.08 3.508 50.51 10.523s25.65 17.115 33.67 30.3q12.03 19.779 12.03 47.416c0 18.595-4.14 34.273-12.41 47.036-7.64 11.913-18.18 21.101-31.63 27.564-16.98 8.159-36 11.104-54.7 11.104h-43.07c-76.56 0 4.08-135.84 4.08-84.706v7.996c0 12.117 9.81 21.941 21.91 21.941 8.12 0 16.3-.345 24.04-3.043 5.91-2.113 10.43-5.451 13.55-10.015 3.2-4.565 4.81-10.523 4.81-17.877 0-7.437-1.61-13.481-4.81-18.129-3.12-4.733-7.64-8.199-13.55-10.396-7.05-2.766-14.67-3.423-22.18-3.423-13.13 0-23.77 10.656-23.77 23.801v47.71c0 11.825 11.14 16.003 19.91 20.752 12.31 6.671 7.58 25.389-6.42 25.389-7.45 0-13.49 6.048-13.49 13.508v48.395c0 13.145-10.63 23.801-23.76 23.801zm134.89-106.758 5.41 9.95 33.51 61.622c8.62 15.86-2.84 35.186-20.87 35.186h-22.27c-8.74 0-16.77-4.798-20.92-12.496l-35.05-65.04a15.52 15.52 0 0 0-13.66-8.168c-42.24 0 40.62-82.154 73.85-21.054M931.652 0h68.748v1000h-68.748z"/></svg>', $de = '<svg xmlns="http://www.w3.org/2000/svg" width="400" height="1601" fill="none"><path fill="#000" d="M72 1319.8c0-10.73 7.071-20.18 17.372-23.22l215.823-63.62c15.519-4.57 31.078 7.05 31.078 23.22v28.26c0 11.31-7.824 21.1-18.85 23.61l-109.636 24.94c-9.254 2.1-9.487 15.2-.313 17.63l110.784 29.37a24.21 24.21 0 0 1 18.015 23.4v25.64c0 11-7.423 20.62-18.071 23.41l-109.659 28.79c-9.162 2.41-8.986 15.47.236 17.63l108.792 25.46c10.955 2.56 18.702 12.33 18.702 23.57v28.39c0 16.17-15.559 27.79-31.078 23.22l-215.823-63.62c-10.3-3.04-17.372-12.49-17.372-23.22v-32.72c0-10.59 6.883-19.95 16.994-23.11l104.523-32.67c8.547-2.67 8.479-14.79-.096-17.36l-104.17-31.3C79.01 1372.42 72 1363 72 1352.31zM72 572.638V495.43c0-13.336 10.846-24.147 24.225-24.147h215.823c13.379 0 24.225 10.811 24.225 24.147v76.179q0 40.645-15.872 70.228-15.743 29.712-45.422 45.79-29.55 16.206-70.843 16.206-41.292 0-70.971-16.078-29.55-16.077-45.422-45.532Q72 612.767 72 572.638m85.132-29.84c-13.379 0-24.225 10.81-24.225 24.146v3.122q0 19.55 6.323 33.313 6.323 13.89 21.807 21.094 15.485 7.332 43.099 7.331t43.1-7.46q15.484-7.33 21.807-21.608 6.323-14.15 6.323-34.728v-1.064c0-13.336-10.846-24.146-24.225-24.146zM72 285.858c0-13.363 10.846-24.197 24.225-24.197h215.823c13.379 0 24.225 10.834 24.225 24.197v23.27c0 13.364-10.846 24.197-24.225 24.197H154.035c-13.379 0-24.225 10.834-24.225 24.197v58.328c0 13.364-10.846 24.197-24.225 24.197h-9.36C82.845 440.047 72 429.214 72 415.85zM278.463 24.72c0-13.374 10.846-24.216 24.225-24.216h9.36c13.379 0 24.225 10.842 24.225 24.216v181.174c0 13.374-10.846 24.216-24.225 24.216h-9.36c-13.379 0-24.225-10.842-24.225-24.216v-40.108c0-8.359-6.779-15.135-15.141-15.135H96.225c-13.38 0-24.225-10.842-24.225-24.216v-22.256c0-13.374 10.846-24.216 24.225-24.216h167.097c8.362 0 15.141-6.776 15.141-15.135z"/><path fill="#000" fill-rule="evenodd" d="M89.224 1062.13C78.997 1059.04 72 1049.63 72 1038.96v-25.9c0-16.486 16.145-28.147 31.818-22.979l215.823 71.169a24.19 24.19 0 0 1 16.632 22.98v62.97c0 10.45-6.706 19.71-16.632 22.98l-215.823 71.17C88.145 1246.51 72 1234.86 72 1218.37v-25.9c0-10.67 6.997-20.08 17.224-23.17l22.595-6.81a15.13 15.13 0 0 0 10.765-14.48v-64.59a15.13 15.13 0 0 0-10.765-14.48zm98.672 77.53 49.299-14.39c8.601-2.51 8.755-14.62.22-17.35l-49.299-15.75c-5.861-1.88-11.852 2.49-11.852 8.64v30.14c0 6.05 5.817 10.41 11.632 8.71" clip-rule="evenodd"/><path fill="#000" d="M72 773.439c0-13.367 10.846-24.203 24.225-24.203h215.823c13.379 0 24.225 10.836 24.225 24.203v89.762q0 29.395-10.711 51.439-10.71 22.046-30.84 34.293t-48.261 12.248q-28.388 0-47.873-12.635-18.187-11.672-28.056-32.218c-8.303-17.289-11.301-36.661-11.301-55.705v-43.867c0-77.976 138.26 4.16 86.215 4.16h-8.138c-12.334 0-22.332 9.989-22.332 22.311 0 8.269.351 16.6 3.097 24.487q3.225 9.024 10.194 13.794 6.968 4.899 18.194 4.899 11.356 0 18.453-4.899 7.226-4.77 10.581-13.794c2.815-7.188 3.484-14.944 3.484-22.596 0-13.366-10.846-24.202-24.225-24.202h-48.56c-12.036 0-16.288 11.345-21.122 20.272-6.79 12.539-25.841 7.72-25.841-6.536 0-7.586-6.156-13.736-13.749-13.736H96.225C82.845 820.916 72 810.08 72 796.714zm108.66 137.378-10.128 5.511-62.72 34.131C91.67 959.243 72 947.569 72 929.205V906.52a24.2 24.2 0 0 1 12.719-21.299l66.199-35.696a15.82 15.82 0 0 0 8.313-13.921c0-43.012 83.618 41.371 21.429 75.213"/></svg>';
function Bde(n) {
  return Pe("watermarkState", () => n.state.get(), [n]);
}
const Hde = `data:image/svg+xml;utf8,${encodeURIComponent(Ude)}`, Vde = `data:image/svg+xml;utf8,${encodeURIComponent($de)}`, Kde = M.memo(function() {
  const e = Fde(), t = be(), r = Pe("is mobile", () => t.getViewportScreenBounds().width < 700, [
    t
  ]), i = Bde(e);
  return ["licensed-with-watermark", "unlicensed"].includes(i) ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Gde, {}),
    /* @__PURE__ */ m.jsx(Wde, { src: r ? Vde : Hde })
  ] }) : null;
}), Wde = M.memo(function({ src: e }) {
  const t = be(), r = Pe("debug mode", () => t.getInstanceState().isDebugMode, [t]), i = Pe("is mobile", () => t.getViewportScreenBounds().width < 700, [
    t
  ]), s = jO(), l = M.useRef(null);
  Th(l);
  const c = `url('${e}') center 100% / 100% no-repeat`, d = "https://tldraw.dev";
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: l,
      className: f_.className,
      "data-debug": r,
      "data-mobile": i,
      draggable: !1,
      ...s,
      children: Er.isWebview ? /* @__PURE__ */ m.jsx(
        "a",
        {
          draggable: !1,
          role: "button",
          onPointerDown: (h) => {
            Ti(h), wn(h);
          },
          onClick: () => e_.openWindow(d, "_blank"),
          style: { mask: c, WebkitMask: c }
        }
      ) : /* @__PURE__ */ m.jsx(
        "a",
        {
          href: d,
          target: "_blank",
          rel: "noreferrer",
          draggable: !1,
          onPointerDown: (h) => {
            Ti(h);
          },
          style: { mask: c, WebkitMask: c }
        }
      )
    }
  );
}), Gde = M.memo(function() {
  const e = f_.className, t = `/* ------------------- SEE LICENSE -------------------
The tldraw watermark is part of tldraw's license. It is shown for unlicensed
or "licensed-with-watermark" users. By using this library, you agree to
preserve the watermark's behavior, keeping it visible, unobscured, and
available to user-interaction.

To remove the watermark, please purchase a license at tldraw.dev.
*/

	.${e} {
		position: absolute;
		bottom: var(--space-2);
		right: var(--space-2);
		width: 96px;
		height: 32px;
		display: flex;
		align-items: center;
		justify-content: center;
		z-index: var(--layer-watermark) !important;
		background-color: color-mix(in srgb, var(--color-background) 62%, transparent);
		opacity: 1;
		border-radius: 5px;
		pointer-events: all;
		padding: 2px;
		box-sizing: content-box;
	}

	.${e} > a {
		position: absolute;
		width: 96px;
		height: 32px;
		pointer-events: all;
		cursor: inherit;
		color: var(--color-text);
		opacity: .38;
		background-color: currentColor;
	}

	.${e}[data-debug='true'] {
		bottom: 46px;
	}

	.${e}[data-mobile='true'] {
		border-radius: 4px 0px 0px 4px;
		right: -2px;
		width: 8px;
		height: 48px;
	}

	.${e}[data-mobile='true'] > a {
		width: 8px;
		height: 32px;
	}

	@media (hover: hover) {
		.${e} > a {
			pointer-events: none;
		}

		.${e}:hover {
			background-color: var(--color-background);
			transition: background-color 0.2s ease-in-out;
			transition-delay: 0.32s;
		}

		.${e}:hover > a {
			animation: delayed_link 0.2s forwards ease-in-out;
			animation-delay: 0.32s;
		}
	}

	@keyframes delayed_link {
		0% {
			cursor: inherit;
			opacity: .38;
			pointer-events: none;
		}
		100% {
			cursor: pointer;
			opacity: 1;
			pointer-events: all;
		}
	}`;
  return /* @__PURE__ */ m.jsx("style", { children: t });
}), qde = [], Yde = [], Xde = [], Zde = "tl-container", Qde = M.memo(function({
  store: e,
  components: t,
  className: r,
  user: i,
  options: s,
  ...l
}) {
  const [c, d] = M.useState(null), h = M.useMemo(() => i ?? PB(), [i]), g = (t == null ? void 0 : t.ErrorFallback) === void 0 ? vB : t == null ? void 0 : t.ErrorFallback, y = {
    ...l,
    shapeUtils: l.shapeUtils ?? qde,
    bindingUtils: l.bindingUtils ?? Yde,
    tools: l.tools ?? Xde,
    components: t,
    options: fg(s)
  };
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: d,
      "data-tldraw": K8,
      draggable: !1,
      className: It(`${Zde} tl-theme__light`, r),
      onPointerDown: Ti,
      tabIndex: -1,
      children: /* @__PURE__ */ m.jsx(
        Yx,
        {
          fallback: g,
          onError: (v) => qD(v, { tags: { origin: "react.tldraw-before-app" } }),
          children: c && /* @__PURE__ */ m.jsx(zde, { licenseKey: l.licenseKey, children: /* @__PURE__ */ m.jsx(Q8, { container: c, children: /* @__PURE__ */ m.jsx(vle, { overrides: t, children: e ? e instanceof sO ? (
            // Store is ready to go, whether externally synced or not
            /* @__PURE__ */ m.jsx(MH, { ...y, store: e, user: h })
          ) : (
            // Store is a synced store, so handle syncing stages internally
            /* @__PURE__ */ m.jsx(RH, { ...y, store: e, user: h })
          ) : (
            // We have no store (it's undefined) so create one and possibly sync it
            /* @__PURE__ */ m.jsx(Jde, { ...y, store: e, user: h })
          ) }) }) })
        }
      )
    }
  );
});
function Jde(n) {
  const {
    defaultName: e,
    snapshot: t,
    initialData: r,
    shapeUtils: i,
    bindingUtils: s,
    persistenceKey: l,
    sessionId: c,
    user: d,
    assets: h
  } = n, g = kde({
    shapeUtils: i,
    bindingUtils: s,
    initialData: r,
    persistenceKey: l,
    sessionId: c,
    defaultName: e,
    snapshot: t,
    assets: h
  });
  return /* @__PURE__ */ m.jsx(RH, { ...n, store: g, user: d });
}
const RH = M.memo(function({
  store: e,
  user: t,
  ...r
}) {
  const i = io();
  M.useLayoutEffect(() => {
    t.userPreferences.get().colorScheme === "dark" && (i.classList.remove("tl-theme__light"), i.classList.add("tl-theme__dark"));
  }, [i, t]);
  const { LoadingScreen: s } = Br();
  switch (e.status) {
    case "error":
      throw e.error;
    case "loading":
      return s ? /* @__PURE__ */ m.jsx(s, {}) : null;
  }
  return /* @__PURE__ */ m.jsx(MH, { ...r, store: e.store, user: t });
}), jM = () => document.location.search.includes("tldraw_preserve_focus");
function MH({
  onMount: n,
  children: e,
  store: t,
  tools: r,
  shapeUtils: i,
  bindingUtils: s,
  user: l,
  initialState: c,
  autoFocus: d = !0,
  inferDarkMode: h,
  cameraOptions: g,
  options: y,
  licenseKey: v,
  deepLinks: w,
  isShapeHidden: C
}) {
  const { ErrorFallback: E } = Br(), P = io(), [I, k] = nj(null), L = M.useRef(null), O = fg(w === !0 ? {} : w), z = M.useRef({
    // for these, it's because they're only used when the editor first mounts:
    autoFocus: d && !jM(),
    inferDarkMode: h,
    initialState: c,
    // for these, it's because we keep them up to date in a separate effect:
    cameraOptions: g,
    deepLinks: O
  });
  M.useLayoutEffect(() => {
    z.current = {
      autoFocus: d && !jM(),
      inferDarkMode: h,
      initialState: c,
      cameraOptions: g,
      deepLinks: O
    };
  }, [d, h, c, g, O]), M.useLayoutEffect(
    () => {
      const { autoFocus: V, inferDarkMode: re, initialState: q, cameraOptions: J, deepLinks: ie } = z.current, W = new at({
        store: t,
        shapeUtils: i,
        bindingUtils: s,
        tools: r,
        getContainer: () => P,
        user: l,
        initialState: q,
        // we should check for some kind of query parameter that turns off autofocus
        autoFocus: V,
        inferDarkMode: re,
        cameraOptions: J,
        options: y,
        licenseKey: v,
        isShapeHidden: C
      });
      return W.updateViewportScreenBounds(L.current ?? P), ie && (ie != null && ie.getUrl ? W.navigateToDeepLink({ ...ie, url: ie.getUrl(W) }) : W.navigateToDeepLink(ie)), k(W), () => {
        W.dispose();
      };
    },
    // if any of these change, we need to recreate the editor.
    [
      s,
      P,
      y,
      i,
      t,
      r,
      l,
      k,
      v,
      C
    ]
  ), M.useLayoutEffect(() => {
    if (I && O)
      return I.registerDeepLinkListener(O);
  }, [I, O]), M.useLayoutEffect(() => {
    I && g && I.setCameraOptions(g);
  }, [I, g]);
  const F = M.useSyncExternalStore(
    M.useCallback(
      (V) => I ? (I.on("crash", V), () => I.off("crash", V)) : () => {
      },
      [I]
    ),
    () => (I == null ? void 0 : I.getCrashingError()) ?? null
  );
  M.useEffect(
    function() {
      if (!I) return;
      function re() {
        I && I.focus();
      }
      function q() {
        I && I.blur();
      }
      if (d && jM())
        return I.getContainer().addEventListener("pointerdown", re), document.body.addEventListener("pointerdown", q), () => {
          var J;
          (J = I.getContainer()) == null || J.removeEventListener("pointerdown", re), document.body.removeEventListener("pointerdown", q);
        };
    },
    [I, d]
  );
  const { Canvas: H } = Br();
  return I ? (
    // the top-level tldraw component also renders an error boundary almost
    // identical to this one. the reason we have two is because this one has
    // access to `App`, which means that here we can enrich errors with data
    // from app for reporting, and also still attempt to render the user's
    // document in the event of an error to reassure them that their work is
    // not lost.
    /* @__PURE__ */ m.jsx(Yx, {
      fallback: E,
      onError: (V) => I.annotateError(V, { origin: "react.tldraw", willCrashApp: !0 }),
      children: F ? /* @__PURE__ */ m.jsx(tfe, { crashingError: F }) : /* @__PURE__ */ m.jsx(AO, { editor: I, children: /* @__PURE__ */ m.jsxs(efe, { onMount: n, children: [
        e ?? (H ? /* @__PURE__ */ m.jsx(H, {}, I.contextId) : null),
        /* @__PURE__ */ m.jsx(Kde, {})
      ] }) })
    })
  ) : /* @__PURE__ */ m.jsx("div", { className: "tl-canvas", ref: L });
}
function efe({ children: n, onMount: e }) {
  return Rde(), mde(), yde(), vde(), DH((t) => {
    const r = t.store.props.onMount(t), i = e == null ? void 0 : e(t);
    return () => {
      r == null || r(), i == null || i();
    };
  }), n;
}
function tfe({ crashingError: n }) {
  throw n;
}
function rj({ children: n }) {
  return /* @__PURE__ */ m.jsx("div", { className: "tl-loading", children: n });
}
function AH({ children: n }) {
  return /* @__PURE__ */ m.jsx("div", { className: "tl-loading", children: n });
}
function DH(n) {
  const e = be(), t = s_((r) => {
    let i;
    return r.run(
      () => {
        i = n == null ? void 0 : n(r), r.emit("mount");
      },
      { history: "ignore" }
    ), window.tldrawReady = !0, i;
  });
  Bt.useLayoutEffect(() => {
    if (e) return t == null ? void 0 : t(e);
  }, [e, t]);
}
function hh({ children: n, className: e = "", ...t }) {
  return /* @__PURE__ */ m.jsx("div", { ...t, className: It("tl-html-container", e), children: n });
}
class CC {
  constructor(e) {
    this.editor = e;
  }
}
U(CC, "props"), U(CC, "migrations"), /**
 * The type of the binding util, which should match the binding's type.
 *
 * @public
 */
U(CC, "type");
function h_(n, e, t = {}) {
  const { newPoint: r, handle: i, scaleX: s, scaleY: l } = e, { minWidth: c = 1, maxWidth: d = 1 / 0, minHeight: h = 1, maxHeight: g = 1 / 0 } = t;
  let y = n.props.w * s, v = n.props.h * l;
  const w = new R(0, 0);
  if (y > 0) {
    if (y < c) {
      switch (i) {
        case "top_left":
        case "left":
        case "bottom_left": {
          w.x = y - c;
          break;
        }
        case "top":
        case "bottom": {
          w.x = (y - c) / 2;
          break;
        }
        default:
          w.x = 0;
      }
      y = c;
    }
  } else if (w.x = y, y = -y, y < c) {
    switch (i) {
      case "top_left":
      case "left":
      case "bottom_left": {
        w.x = -y;
        break;
      }
      default:
        w.x = -c;
    }
    y = c;
  }
  if (v > 0) {
    if (v < h) {
      switch (i) {
        case "top_left":
        case "top":
        case "top_right": {
          w.y = v - h;
          break;
        }
        case "right":
        case "left": {
          w.y = (v - h) / 2;
          break;
        }
        default:
          w.y = 0;
      }
      v = h;
    }
  } else if (w.y = v, v = -v, v < h) {
    switch (i) {
      case "top_left":
      case "top":
      case "top_right": {
        w.y = -v;
        break;
      }
      default:
        w.y = -h;
    }
    v = h;
  }
  const { x: C, y: E } = w.rot(n.rotation).add(r);
  return {
    ...n,
    x: C,
    y: E,
    props: {
      w: Math.min(d, y),
      h: Math.min(g, v)
    }
  };
}
class Xy extends Cc {
  getGeometry(e) {
    return new Tu({
      width: e.props.w,
      height: e.props.h,
      isFilled: !0
    });
  }
  onResize(e, t) {
    return h_(e, t);
  }
  getHandleSnapGeometry(e) {
    return {
      points: this.getGeometry(e).bounds.cornersAndCenter
    };
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...t.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r)
    };
  }
}
var dA;
let nfe = (dA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(dA, "id", "idle"), dA);
var fA;
let rfe = (fA = class extends Et {
  onPointerMove(e) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint: t } = this.editor.inputs, r = this.parent.shapeType, i = Sr(), s = this.editor.markHistoryStoppingPoint(`creating_box:${i}`), l = Ec(t, this.editor);
      this.editor.createShapes([
        {
          id: i,
          type: r,
          x: l.x,
          y: l.y,
          props: {
            w: 1,
            h: 1
          }
        }
      ]).select(i);
      const c = this.parent;
      this.editor.setCurrentTool(
        "select.resizing",
        {
          ...e,
          target: "selection",
          handle: "bottom_right",
          isCreating: !0,
          creatingMarkId: s,
          creationCursorOffset: { x: 1, y: 1 },
          onInteractionEnd: this.parent.id,
          onCreate: c.onCreate ? (d) => {
            var h;
            return (h = c.onCreate) == null ? void 0 : h.call(c, d);
          } : void 0
        }
        /** satisfies ResizingInfo, defined in main tldraw package 😧 */
      );
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs, t = this.parent.shapeType, r = Sr();
    this.editor.markHistoryStoppingPoint(`creating_box:${r}`), this.editor.createShapes([
      {
        id: r,
        type: t,
        x: e.x,
        y: e.y
      }
    ]);
    const i = this.editor.getShape(r);
    if (!i) {
      this.cancel();
      return;
    }
    let { w: s, h: l } = i.props;
    const c = new R(s / 2, l / 2), d = this.editor.getShapeParentTransform(i);
    d && c.rot(-d.rotation());
    let h = 1;
    this.editor.user.getIsDynamicResizeMode() && (h = 1 / this.editor.getZoomLevel(), s *= h, l *= h, c.mul(h));
    const g = $r(i), y = Ec(new R(i.x - c.x, i.y - c.y), this.editor);
    g.x = y.x, g.y = y.y, g.props.w = s, g.props.h = l, "scale" in i.props && (g.props.scale = h), this.editor.updateShape(g), this.editor.setSelectedShapes([r]), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select.idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}, U(fA, "id", "pointing"), fA);
function Ec(n, e) {
  const t = e.getInstanceState().isGridMode, r = e.getDocumentSettings().gridSize;
  return t ? n.clone().snapToGrid(r) : n.clone();
}
class sD extends Et {
  static children() {
    return [nfe, rfe];
  }
}
U(sD, "id", "box"), U(sD, "initial", "idle");
function ife(n, e, t) {
  const r = M.useRef(!1), i = M.useCallback(
    (l) => {
      r.current = l, l ? gc.addOpenMenu(n) : gc.deleteOpenMenu(n), e == null || e(l);
    },
    [n, e]
  ), s = Pe("is menu open", () => gc.getOpenMenus().includes(n), [n]);
  return M.useEffect(() => (r.current && (t == null || t("open-menu"), gc.addOpenMenu(n)), () => {
    r.current && (gc.deleteOpenMenu(n), gc.getOpenMenus().forEach((l) => {
      l.startsWith(n) && (t == null || t("close-menu"), gc.deleteOpenMenu(l));
    }), r.current = !1);
  }), [n, t]), [s, i];
}
function p_(n) {
  const e = be();
  return Pe("isEditing", () => e.getEditingShapeId() === n, [e, n]);
}
function gu(n) {
  const e = be();
  return M.useMemo(
    function() {
      const i = (h) => {
        if (h.isKilled) return;
        if (h.button === OO) {
          e.dispatch({
            type: "pointer",
            target: "selection",
            handle: n,
            name: "right_click",
            ...Xa(h)
          });
          return;
        }
        if (h.button !== 0) return;
        const g = vE(h.currentTarget);
        function y() {
          g.removeEventListener("pointerup", y), vw(g, h);
        }
        yw(g, h), g.addEventListener("pointerup", y), e.dispatch({
          name: "pointer_down",
          type: "pointer",
          target: "selection",
          handle: n,
          ...Xa(h)
        }), Ti(h);
      };
      let s, l;
      function c(h) {
        h.isKilled || h.button === 0 && (h.clientX === s && h.clientY === l || (s = h.clientX, l = h.clientY, e.dispatch({
          name: "pointer_move",
          type: "pointer",
          target: "selection",
          handle: n,
          ...Xa(h)
        })));
      }
      return {
        onPointerDown: i,
        onPointerMove: c,
        onPointerUp: (h) => {
          h.isKilled || h.button === 0 && e.dispatch({
            name: "pointer_up",
            type: "pointer",
            target: "selection",
            handle: n,
            ...Xa(h)
          });
        }
      };
    },
    [e, n]
  );
}
function ofe(n) {
  const [e, t] = M.useState(() => ({ store: Zx(n), opts: n }));
  if (!ZD(e.opts, n)) {
    const r = { store: Zx(n), opts: n };
    return t(r), r.store;
  }
  return e.store;
}
function sfe(n) {
  const [e, t] = M.useState(() => ({ opts: n, schema: iD(n) }));
  if (!ZD(e.opts, n)) {
    const r = iD(n);
    return t({ opts: n, schema: r }), r;
  }
  return e.schema;
}
const afe = 20, lfe = 8;
function ij(n, e = afe) {
  return Math.max(lfe, Math.ceil(n / e));
}
class Sy extends Ph {
  constructor(t) {
    super({ ...t, isFilled: !1, isClosed: !1 });
    U(this, "_center");
    U(this, "radius");
    U(this, "start");
    U(this, "end");
    U(this, "largeArcFlag");
    U(this, "sweepFlag");
    U(this, "measure");
    U(this, "angleStart");
    U(this, "angleEnd");
    const { center: r, sweepFlag: i, largeArcFlag: s, start: l, end: c } = t;
    if (l.equals(c)) throw Error("Arc must have different start and end points.");
    this.angleStart = R.Angle(r, l), this.angleEnd = R.Angle(r, c), this.radius = R.Dist(r, l), this.measure = sse(this.angleStart, this.angleEnd, i, s), this.start = l, this.end = c, this.sweepFlag = i, this.largeArcFlag = s, this._center = r;
  }
  nearestPoint(t) {
    const { _center: r, measure: i, radius: s, angleEnd: l, angleStart: c, start: d, end: h } = this, g = WA(i, c, l, r.angle(t));
    if (g <= 0) return d;
    if (g >= 1) return h;
    const y = r.clone().add(t.clone().sub(r).uni().mul(s));
    let v, w = 1 / 0, C;
    for (const E of [d, h, y])
      C = R.Dist2(t, E), C < w && (v = E, w = C);
    if (!v) throw Error("nearest point not found");
    return v;
  }
  hitTestLineSegment(t, r) {
    const { _center: i, radius: s, measure: l, angleStart: c, angleEnd: d } = this, h = ww(t, r, i, s);
    return h === null ? !1 : h.some((g) => {
      const y = WA(l, c, d, i.angle(g));
      return y >= 0 && y <= 1;
    });
  }
  getVertices() {
    const { _center: t, measure: r, length: i, radius: s, angleStart: l } = this, c = [];
    for (let d = 0, h = ij(Math.abs(i)); d < h + 1; d++) {
      const g = d / h * r, y = l + g;
      c.push(tg(t, s, y));
    }
    return c;
  }
  getSvgPathData(t = !0) {
    const { start: r, end: i, radius: s, largeArcFlag: l, sweepFlag: c } = this;
    return `${t ? `M${r.toFixed()}` : ""} A${s} ${s} 0 ${l} ${c} ${i.toFixed()}`;
  }
  getLength() {
    return this.measure * this.radius;
  }
}
class oj extends Ph {
  constructor(t) {
    super({ isClosed: !0, ...t });
    U(this, "_center");
    U(this, "radius");
    U(this, "x");
    U(this, "y");
    this.config = t;
    const { x: r = 0, y: i = 0, radius: s } = t;
    this.x = r, this.y = i, this._center = new R(s + r, s + i), this.radius = s;
  }
  getBounds() {
    return new Xe(this.x, this.y, this.radius * 2, this.radius * 2);
  }
  getVertices() {
    const { _center: t, radius: r } = this, i = hr * r, s = [];
    for (let l = 0, c = ij(i); l < c; l++) {
      const d = l / c * hr;
      s.push(tg(t, r, d));
    }
    return s;
  }
  nearestPoint(t) {
    const { _center: r, radius: i } = this;
    return r.equals(t) ? R.AddXY(r, i, 0) : r.clone().add(t.clone().sub(r).uni().mul(i));
  }
  hitTestLineSegment(t, r, i = 0) {
    const { _center: s, radius: l } = this;
    return ww(t, r, s, l + i) !== null;
  }
  getSvgPathData() {
    const { _center: t, radius: r } = this;
    return `M${t.x + r},${t.y} a${r},${r} 0 1,0 ${r * 2},0a${r},${r} 0 1,0 -${r * 2},0`;
  }
}
class fs extends Wy {
  constructor(t) {
    const { start: r, cp1: i, cp2: s, end: l } = t;
    super({ ...t, points: [r, l] });
    U(this, "a");
    U(this, "b");
    U(this, "c");
    U(this, "d");
    this.a = r, this.b = i, this.c = s, this.d = l;
  }
  getVertices() {
    const t = [], { a: r, b: i, c: s, d: l } = this;
    for (let c = 0, d = 10; c <= d; c++) {
      const h = c / d;
      t.push(
        new R(
          (1 - h) * (1 - h) * (1 - h) * r.x + 3 * ((1 - h) * (1 - h)) * h * i.x + 3 * (1 - h) * (h * h) * s.x + h * h * h * l.x,
          (1 - h) * (1 - h) * (1 - h) * r.y + 3 * ((1 - h) * (1 - h)) * h * i.y + 3 * (1 - h) * (h * h) * s.y + h * h * h * l.y
        )
      );
    }
    return t;
  }
  midPoint() {
    return fs.GetAtT(this, 0.5);
  }
  nearestPoint(t) {
    let r, i = 1 / 0, s, l;
    for (const c of this.segments)
      l = c.nearestPoint(t), s = R.Dist2(l, t), s < i && (r = l, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  getSvgPathData(t = !0) {
    const { a: r, b: i, c: s, d: l } = this;
    return `${t ? `M ${r.toFixed()} ` : ""} C${i.toFixed()} ${s.toFixed()} ${l.toFixed()}`;
  }
  static GetAtT(t, r) {
    const { a: i, b: s, c: l, d: c } = t;
    return new R(
      (1 - r) * (1 - r) * (1 - r) * i.x + 3 * ((1 - r) * (1 - r)) * r * s.x + 3 * (1 - r) * (r * r) * l.x + r * r * r * c.x,
      (1 - r) * (1 - r) * (1 - r) * i.y + 3 * ((1 - r) * (1 - r)) * r * s.y + 3 * (1 - r) * (r * r) * l.y + r * r * r * c.y
    );
  }
  getLength(t = 32) {
    let r, i = this.a, s = 0;
    for (let l = 1; l <= t; l++)
      r = fs.GetAtT(this, l / t), s += R.Dist(i, r), i = r;
    return s;
  }
}
class cfe extends Ph {
  constructor(t) {
    super({ ...t, isClosed: !1, isFilled: !1 });
    U(this, "points");
    U(this, "_segments");
    const { points: r } = t;
    this.points = r;
  }
  // eslint-disable-next-line no-restricted-syntax
  get segments() {
    if (!this._segments) {
      this._segments = [];
      const { points: t } = this, r = t.length, i = r - 2, s = 1.25;
      for (let l = 0; l < r - 1; l++) {
        const c = l === 0 ? t[0] : t[l - 1], d = t[l], h = t[l + 1], g = l === i ? h : t[l + 2], y = d, v = l === 0 ? c : new R(d.x + (h.x - c.x) / 6 * s, d.y + (h.y - c.y) / 6 * s), w = l === i ? h : new R(h.x - (g.x - d.x) / 6 * s, h.y - (g.y - d.y) / 6 * s), C = h;
        this._segments.push(new fs({ start: y, cp1: v, cp2: w, end: C }));
      }
    }
    return this._segments;
  }
  getLength() {
    return this.segments.reduce((t, r) => t + r.length, 0);
  }
  getVertices() {
    const t = this.segments.reduce((r, i) => r.concat(i.vertices), []);
    return t.push(this.points[this.points.length - 1]), t;
  }
  nearestPoint(t) {
    let r, i = 1 / 0, s, l;
    for (const c of this.segments)
      l = c.nearestPoint(t), s = R.Dist2(l, t), s < i && (r = l, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(t, r) {
    return this.segments.some((i) => i.hitTestLineSegment(t, r));
  }
  getSvgPathData() {
    let t = this.segments.reduce((r, i, s) => r + i.getSvgPathData(s === 0), "");
    return this.isClosed && (t += "Z"), t;
  }
}
class ufe extends Ph {
  constructor(t) {
    super({ ...t, isClosed: !0 });
    U(this, "w");
    U(this, "h");
    U(this, "_edges");
    this.config = t;
    const { width: r, height: i } = t;
    this.w = r, this.h = i;
  }
  // eslint-disable-next-line no-restricted-syntax
  get edges() {
    if (!this._edges) {
      const { vertices: t } = this;
      this._edges = [];
      for (let r = 0, i = t.length; r < i; r++) {
        const s = t[r], l = t[(r + 1) % i];
        this._edges.push(new Ld({ start: s, end: l }));
      }
    }
    return this._edges;
  }
  getVertices() {
    const t = Math.max(1, this.w), r = Math.max(1, this.h), i = t / 2, s = r / 2, l = Math.pow(i - s, 2) / Math.pow(i + s, 2), c = Xn * (i + s) * (1 + 3 * l / (10 + Math.sqrt(4 - 3 * l))), d = ij(c), h = hr / d, g = Math.cos(h), y = Math.sin(h);
    let v = 0, w = 1, C = 0, E = 1;
    const P = Array(d);
    for (let I = 0; I < d; I++)
      P[I] = new R(i + i * w, s + s * v), C = y * w + g * v, E = g * w - y * v, v = C, w = E;
    return P;
  }
  nearestPoint(t) {
    let r, i = 1 / 0, s, l;
    for (const c of this.edges)
      l = c.nearestPoint(t), s = R.Dist2(l, t), s < i && (r = l, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(t, r) {
    return this.edges.some((i) => i.hitTestLineSegment(t, r));
  }
  getBounds() {
    return new Xe(0, 0, this.w, this.h);
  }
  getLength() {
    const { w: t, h: r } = this, i = t / 2, s = r / 2, l = Math.max(0, i), c = Math.max(0, s);
    return G8(l, c);
  }
  getSvgPathData(t = !1) {
    const { w: r, h: i } = this, s = r / 2, l = i / 2, c = Math.max(0, s), d = Math.max(0, l);
    return `${t ? `M${s - c},${l}` : ""} a${c},${d},0,1,1,${c * 2},0a${c},${d},0,1,1,-${c * 2},0`;
  }
}
class dfe extends Ph {
  constructor(t) {
    super({ ...t, isClosed: !0 });
    U(this, "w");
    U(this, "h");
    U(this, "a");
    U(this, "b");
    U(this, "c");
    U(this, "d");
    this.config = t;
    const { width: r, height: i } = t;
    if (this.w = r, this.h = i, i > r) {
      const s = r / 2;
      this.a = new Sy({
        start: new R(0, s),
        end: new R(r, s),
        center: new R(r / 2, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.b = new Ld({ start: new R(r, s), end: new R(r, i - s) }), this.c = new Sy({
        start: new R(r, i - s),
        end: new R(0, i - s),
        center: new R(r / 2, i - s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.d = new Ld({ start: new R(0, i - s), end: new R(0, s) });
    } else {
      const s = i / 2;
      this.a = new Sy({
        start: new R(s, i),
        end: new R(s, 0),
        center: new R(s, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.b = new Ld({ start: new R(s, 0), end: new R(r - s, 0) }), this.c = new Sy({
        start: new R(r - s, 0),
        end: new R(r - s, i),
        center: new R(r - s, s),
        sweepFlag: 1,
        largeArcFlag: 1
      }), this.d = new Ld({ start: new R(r - s, i), end: new R(s, i) });
    }
  }
  nearestPoint(t) {
    let r, i = 1 / 0, s, l;
    const { a: c, b: d, c: h, d: g } = this;
    for (const y of [c, d, h, g])
      l = y.nearestPoint(t), s = R.Dist2(l, t), s < i && (r = l, i = s);
    if (!r) throw Error("nearest point not found");
    return r;
  }
  hitTestLineSegment(t, r) {
    const { a: i, b: s, c: l, d: c } = this;
    return [i, s, l, c].some((d) => d.hitTestLineSegment(t, r));
  }
  getVertices() {
    const { a: t, b: r, c: i, d: s } = this;
    return [t, r, i, s].reduce((l, c) => (l.push(...c.vertices), l), []);
  }
  getBounds() {
    return new Xe(0, 0, this.w, this.h);
  }
  getLength() {
    const { h: t, w: r } = this;
    return t > r ? (Xn * (r / 2) + (t - r)) * 2 : (Xn * (t / 2) + (r - t)) * 2;
  }
  getSvgPathData() {
    const { a: t, b: r, c: i, d: s } = this;
    return [t, r, i, s].map((l, c) => l.getSvgPathData(c === 0)).join(" ") + " Z";
  }
}
var ffe = {};
async function cU({ shouldReload: n = !0 } = {}) {
  pne();
  for (const e of mE.connectedInstances)
    await e.close();
  await Promise.all(IO().map((e) => B8(e))), hne(), n && window.location.reload();
}
typeof window < "u" && (ffe.NODE_ENV === "development" && (window.hardReset = cU), window.__tldraw__hardReset = cU);
function hfe(n, e = "_blank") {
  e_.openWindow(n, e);
}
Au(
  "@tldraw/editor",
  "3.7.0",
  "esm"
);
function OH() {
  const [n, e] = M.useState(!1);
  return M.useEffect(() => {
    if (typeof window > "u" || !("matchMedia" in window)) return;
    const t = window.matchMedia("(prefers-reduced-motion: reduce)"), r = () => {
      e(t.matches);
    };
    return r(), t.addEventListener("change", r), () => t.removeEventListener("change", r);
  }, []), n;
}
const jH = () => {
}, LH = M.createContext(null);
function pfe({ onEvent: n, children: e }) {
  return /* @__PURE__ */ m.jsx(LH.Provider, { value: n ?? jH, children: e });
}
function Vo() {
  return M.useContext(LH) ?? jH;
}
function bt(n, e, { checkForDefaultPrevented: t = !0 } = {}) {
  return function(i) {
    if (n == null || n(i), t === !1 || !i.defaultPrevented)
      return e == null ? void 0 : e(i);
  };
}
function gfe(n, e) {
  const t = M.createContext(e), r = (s) => {
    const { children: l, ...c } = s, d = M.useMemo(() => c, Object.values(c));
    return /* @__PURE__ */ m.jsx(t.Provider, { value: d, children: l });
  };
  r.displayName = n + "Provider";
  function i(s) {
    const l = M.useContext(t);
    if (l) return l;
    if (e !== void 0) return e;
    throw new Error(`\`${s}\` must be used within \`${n}\``);
  }
  return [r, i];
}
function ju(n, e = []) {
  let t = [];
  function r(s, l) {
    const c = M.createContext(l), d = t.length;
    t = [...t, l];
    const h = (y) => {
      var I;
      const { scope: v, children: w, ...C } = y, E = ((I = v == null ? void 0 : v[n]) == null ? void 0 : I[d]) || c, P = M.useMemo(() => C, Object.values(C));
      return /* @__PURE__ */ m.jsx(E.Provider, { value: P, children: w });
    };
    h.displayName = s + "Provider";
    function g(y, v) {
      var E;
      const w = ((E = v == null ? void 0 : v[n]) == null ? void 0 : E[d]) || c, C = M.useContext(w);
      if (C) return C;
      if (l !== void 0) return l;
      throw new Error(`\`${y}\` must be used within \`${s}\``);
    }
    return [h, g];
  }
  const i = () => {
    const s = t.map((l) => M.createContext(l));
    return function(c) {
      const d = (c == null ? void 0 : c[n]) || s;
      return M.useMemo(
        () => ({ [`__scope${n}`]: { ...c, [n]: d } }),
        [c, d]
      );
    };
  };
  return i.scopeName = n, [r, mfe(i, ...e)];
}
function mfe(...n) {
  const e = n[0];
  if (n.length === 1) return e;
  const t = () => {
    const r = n.map((i) => ({
      useScope: i(),
      scopeName: i.scopeName
    }));
    return function(s) {
      const l = r.reduce((c, { useScope: d, scopeName: h }) => {
        const y = d(s)[`__scope${h}`];
        return { ...c, ...y };
      }, {});
      return M.useMemo(() => ({ [`__scope${e.scopeName}`]: l }), [l]);
    };
  };
  return t.scopeName = e.scopeName, t;
}
function uU(n, e) {
  if (typeof n == "function")
    return n(e);
  n != null && (n.current = e);
}
function g_(...n) {
  return (e) => {
    let t = !1;
    const r = n.map((i) => {
      const s = uU(i, e);
      return !t && typeof s == "function" && (t = !0), s;
    });
    if (t)
      return () => {
        for (let i = 0; i < r.length; i++) {
          const s = r[i];
          typeof s == "function" ? s() : uU(n[i], null);
        }
      };
  };
}
function jr(...n) {
  return M.useCallback(g_(...n), n);
}
var ng = M.forwardRef((n, e) => {
  const { children: t, ...r } = n, i = M.Children.toArray(t), s = i.find(vfe);
  if (s) {
    const l = s.props.children, c = i.map((d) => d === s ? M.Children.count(l) > 1 ? M.Children.only(null) : M.isValidElement(l) ? l.props.children : null : d);
    return /* @__PURE__ */ m.jsx(aD, { ...r, ref: e, children: M.isValidElement(l) ? M.cloneElement(l, void 0, c) : null });
  }
  return /* @__PURE__ */ m.jsx(aD, { ...r, ref: e, children: t });
});
ng.displayName = "Slot";
var aD = M.forwardRef((n, e) => {
  const { children: t, ...r } = n;
  if (M.isValidElement(t)) {
    const i = xfe(t);
    return M.cloneElement(t, {
      ...Sfe(r, t.props),
      // @ts-ignore
      ref: e ? g_(e, i) : i
    });
  }
  return M.Children.count(t) > 1 ? M.Children.only(null) : null;
});
aD.displayName = "SlotClone";
var yfe = ({ children: n }) => /* @__PURE__ */ m.jsx(m.Fragment, { children: n });
function vfe(n) {
  return M.isValidElement(n) && n.type === yfe;
}
function Sfe(n, e) {
  const t = { ...e };
  for (const r in e) {
    const i = n[r], s = e[r];
    /^on[A-Z]/.test(r) ? i && s ? t[r] = (...c) => {
      s(...c), i(...c);
    } : i && (t[r] = i) : r === "style" ? t[r] = { ...i, ...s } : r === "className" && (t[r] = [i, s].filter(Boolean).join(" "));
  }
  return { ...n, ...t };
}
function xfe(n) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? n.ref : (e = (i = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : i.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? n.props.ref : n.props.ref || n.ref);
}
var wfe = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
], Wn = wfe.reduce((n, e) => {
  const t = M.forwardRef((r, i) => {
    const { asChild: s, ...l } = r, c = s ? ng : e;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0), /* @__PURE__ */ m.jsx(c, { ...l, ref: i });
  });
  return t.displayName = `Primitive.${e}`, { ...n, [e]: t };
}, {});
function sj(n, e) {
  n && Gy.flushSync(() => n.dispatchEvent(e));
}
function m_(n) {
  const e = n + "CollectionProvider", [t, r] = ju(e), [i, s] = t(
    e,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  ), l = (w) => {
    const { scope: C, children: E } = w, P = Bt.useRef(null), I = Bt.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ m.jsx(i, { scope: C, itemMap: I, collectionRef: P, children: E });
  };
  l.displayName = e;
  const c = n + "CollectionSlot", d = Bt.forwardRef(
    (w, C) => {
      const { scope: E, children: P } = w, I = s(c, E), k = jr(C, I.collectionRef);
      return /* @__PURE__ */ m.jsx(ng, { ref: k, children: P });
    }
  );
  d.displayName = c;
  const h = n + "CollectionItemSlot", g = "data-radix-collection-item", y = Bt.forwardRef(
    (w, C) => {
      const { scope: E, children: P, ...I } = w, k = Bt.useRef(null), L = jr(C, k), O = s(h, E);
      return Bt.useEffect(() => (O.itemMap.set(k, { ref: k, ...I }), () => void O.itemMap.delete(k))), /* @__PURE__ */ m.jsx(ng, { [g]: "", ref: L, children: P });
    }
  );
  y.displayName = h;
  function v(w) {
    const C = s(n + "CollectionConsumer", w);
    return Bt.useCallback(() => {
      const P = C.collectionRef.current;
      if (!P) return [];
      const I = Array.from(P.querySelectorAll(`[${g}]`));
      return Array.from(C.itemMap.values()).sort(
        (O, z) => I.indexOf(O.ref.current) - I.indexOf(z.ref.current)
      );
    }, [C.collectionRef, C.itemMap]);
  }
  return [
    { Provider: l, Slot: d, ItemSlot: y },
    v,
    r
  ];
}
var bfe = M.createContext(void 0);
function aj(n) {
  const e = M.useContext(bfe);
  return n || e || "ltr";
}
function $o(n) {
  const e = M.useRef(n);
  return M.useEffect(() => {
    e.current = n;
  }), M.useMemo(() => (...t) => {
    var r;
    return (r = e.current) == null ? void 0 : r.call(e, ...t);
  }, []);
}
function Cfe(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = $o(n);
  M.useEffect(() => {
    const r = (i) => {
      i.key === "Escape" && t(i);
    };
    return e.addEventListener("keydown", r, { capture: !0 }), () => e.removeEventListener("keydown", r, { capture: !0 });
  }, [t, e]);
}
var Efe = "DismissableLayer", lD = "dismissableLayer.update", _fe = "dismissableLayer.pointerDownOutside", Pfe = "dismissableLayer.focusOutside", dU, NH = M.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
}), Tw = M.forwardRef(
  (n, e) => {
    const {
      disableOutsidePointerEvents: t = !1,
      onEscapeKeyDown: r,
      onPointerDownOutside: i,
      onFocusOutside: s,
      onInteractOutside: l,
      onDismiss: c,
      ...d
    } = n, h = M.useContext(NH), [g, y] = M.useState(null), v = (g == null ? void 0 : g.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, w] = M.useState({}), C = jr(e, (H) => y(H)), E = Array.from(h.layers), [P] = [...h.layersWithOutsidePointerEventsDisabled].slice(-1), I = E.indexOf(P), k = g ? E.indexOf(g) : -1, L = h.layersWithOutsidePointerEventsDisabled.size > 0, O = k >= I, z = Ife((H) => {
      const V = H.target, re = [...h.branches].some((q) => q.contains(V));
      !O || re || (i == null || i(H), l == null || l(H), H.defaultPrevented || c == null || c());
    }, v), F = kfe((H) => {
      const V = H.target;
      [...h.branches].some((q) => q.contains(V)) || (s == null || s(H), l == null || l(H), H.defaultPrevented || c == null || c());
    }, v);
    return Cfe((H) => {
      k === h.layers.size - 1 && (r == null || r(H), !H.defaultPrevented && c && (H.preventDefault(), c()));
    }, v), M.useEffect(() => {
      if (g)
        return t && (h.layersWithOutsidePointerEventsDisabled.size === 0 && (dU = v.body.style.pointerEvents, v.body.style.pointerEvents = "none"), h.layersWithOutsidePointerEventsDisabled.add(g)), h.layers.add(g), fU(), () => {
          t && h.layersWithOutsidePointerEventsDisabled.size === 1 && (v.body.style.pointerEvents = dU);
        };
    }, [g, v, t, h]), M.useEffect(() => () => {
      g && (h.layers.delete(g), h.layersWithOutsidePointerEventsDisabled.delete(g), fU());
    }, [g, h]), M.useEffect(() => {
      const H = () => w({});
      return document.addEventListener(lD, H), () => document.removeEventListener(lD, H);
    }, []), /* @__PURE__ */ m.jsx(
      Wn.div,
      {
        ...d,
        ref: C,
        style: {
          pointerEvents: L ? O ? "auto" : "none" : void 0,
          ...n.style
        },
        onFocusCapture: bt(n.onFocusCapture, F.onFocusCapture),
        onBlurCapture: bt(n.onBlurCapture, F.onBlurCapture),
        onPointerDownCapture: bt(
          n.onPointerDownCapture,
          z.onPointerDownCapture
        )
      }
    );
  }
);
Tw.displayName = Efe;
var Tfe = "DismissableLayerBranch", FH = M.forwardRef((n, e) => {
  const t = M.useContext(NH), r = M.useRef(null), i = jr(e, r);
  return M.useEffect(() => {
    const s = r.current;
    if (s)
      return t.branches.add(s), () => {
        t.branches.delete(s);
      };
  }, [t.branches]), /* @__PURE__ */ m.jsx(Wn.div, { ...n, ref: i });
});
FH.displayName = Tfe;
function Ife(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = $o(n), r = M.useRef(!1), i = M.useRef(() => {
  });
  return M.useEffect(() => {
    const s = (c) => {
      if (c.target && !r.current) {
        let d = function() {
          zH(
            _fe,
            t,
            h,
            { discrete: !0 }
          );
        };
        const h = { originalEvent: c };
        c.pointerType === "touch" ? (e.removeEventListener("click", i.current), i.current = d, e.addEventListener("click", i.current, { once: !0 })) : d();
      } else
        e.removeEventListener("click", i.current);
      r.current = !1;
    }, l = window.setTimeout(() => {
      e.addEventListener("pointerdown", s);
    }, 0);
    return () => {
      window.clearTimeout(l), e.removeEventListener("pointerdown", s), e.removeEventListener("click", i.current);
    };
  }, [e, t]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => r.current = !0
  };
}
function kfe(n, e = globalThis == null ? void 0 : globalThis.document) {
  const t = $o(n), r = M.useRef(!1);
  return M.useEffect(() => {
    const i = (s) => {
      s.target && !r.current && zH(Pfe, t, { originalEvent: s }, {
        discrete: !1
      });
    };
    return e.addEventListener("focusin", i), () => e.removeEventListener("focusin", i);
  }, [e, t]), {
    onFocusCapture: () => r.current = !0,
    onBlurCapture: () => r.current = !1
  };
}
function fU() {
  const n = new CustomEvent(lD);
  document.dispatchEvent(n);
}
function zH(n, e, t, { discrete: r }) {
  const i = t.originalEvent.target, s = new CustomEvent(n, { bubbles: !1, cancelable: !0, detail: t });
  e && i.addEventListener(n, e, { once: !0 }), r ? sj(i, s) : i.dispatchEvent(s);
}
var Rfe = Tw, Mfe = FH, LM = 0;
function lj() {
  M.useEffect(() => {
    const n = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", n[0] ?? hU()), document.body.insertAdjacentElement("beforeend", n[1] ?? hU()), LM++, () => {
      LM === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((e) => e.remove()), LM--;
    };
  }, []);
}
function hU() {
  const n = document.createElement("span");
  return n.setAttribute("data-radix-focus-guard", ""), n.tabIndex = 0, n.style.outline = "none", n.style.opacity = "0", n.style.position = "fixed", n.style.pointerEvents = "none", n;
}
var NM = "focusScope.autoFocusOnMount", FM = "focusScope.autoFocusOnUnmount", pU = { bubbles: !1, cancelable: !0 }, Afe = "FocusScope", y_ = M.forwardRef((n, e) => {
  const {
    loop: t = !1,
    trapped: r = !1,
    onMountAutoFocus: i,
    onUnmountAutoFocus: s,
    ...l
  } = n, [c, d] = M.useState(null), h = $o(i), g = $o(s), y = M.useRef(null), v = jr(e, (E) => d(E)), w = M.useRef({
    paused: !1,
    pause() {
      this.paused = !0;
    },
    resume() {
      this.paused = !1;
    }
  }).current;
  M.useEffect(() => {
    if (r) {
      let E = function(L) {
        if (w.paused || !c) return;
        const O = L.target;
        c.contains(O) ? y.current = O : nh(y.current, { select: !0 });
      }, P = function(L) {
        if (w.paused || !c) return;
        const O = L.relatedTarget;
        O !== null && (c.contains(O) || nh(y.current, { select: !0 }));
      }, I = function(L) {
        if (document.activeElement === document.body)
          for (const z of L)
            z.removedNodes.length > 0 && nh(c);
      };
      document.addEventListener("focusin", E), document.addEventListener("focusout", P);
      const k = new MutationObserver(I);
      return c && k.observe(c, { childList: !0, subtree: !0 }), () => {
        document.removeEventListener("focusin", E), document.removeEventListener("focusout", P), k.disconnect();
      };
    }
  }, [r, c, w.paused]), M.useEffect(() => {
    if (c) {
      mU.add(w);
      const E = document.activeElement;
      if (!c.contains(E)) {
        const I = new CustomEvent(NM, pU);
        c.addEventListener(NM, h), c.dispatchEvent(I), I.defaultPrevented || (Dfe(Ffe(UH(c)), { select: !0 }), document.activeElement === E && nh(c));
      }
      return () => {
        c.removeEventListener(NM, h), setTimeout(() => {
          const I = new CustomEvent(FM, pU);
          c.addEventListener(FM, g), c.dispatchEvent(I), I.defaultPrevented || nh(E ?? document.body, { select: !0 }), c.removeEventListener(FM, g), mU.remove(w);
        }, 0);
      };
    }
  }, [c, h, g, w]);
  const C = M.useCallback(
    (E) => {
      if (!t && !r || w.paused) return;
      const P = E.key === "Tab" && !E.altKey && !E.ctrlKey && !E.metaKey, I = document.activeElement;
      if (P && I) {
        const k = E.currentTarget, [L, O] = Ofe(k);
        L && O ? !E.shiftKey && I === O ? (E.preventDefault(), t && nh(L, { select: !0 })) : E.shiftKey && I === L && (E.preventDefault(), t && nh(O, { select: !0 })) : I === k && E.preventDefault();
      }
    },
    [t, r, w.paused]
  );
  return /* @__PURE__ */ m.jsx(Wn.div, { tabIndex: -1, ...l, ref: v, onKeyDown: C });
});
y_.displayName = Afe;
function Dfe(n, { select: e = !1 } = {}) {
  const t = document.activeElement;
  for (const r of n)
    if (nh(r, { select: e }), document.activeElement !== t) return;
}
function Ofe(n) {
  const e = UH(n), t = gU(e, n), r = gU(e.reverse(), n);
  return [t, r];
}
function UH(n) {
  const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function gU(n, e) {
  for (const t of n)
    if (!jfe(t, { upTo: e })) return t;
}
function jfe(n, { upTo: e }) {
  if (getComputedStyle(n).visibility === "hidden") return !0;
  for (; n; ) {
    if (e !== void 0 && n === e) return !1;
    if (getComputedStyle(n).display === "none") return !0;
    n = n.parentElement;
  }
  return !1;
}
function Lfe(n) {
  return n instanceof HTMLInputElement && "select" in n;
}
function nh(n, { select: e = !1 } = {}) {
  if (n && n.focus) {
    const t = document.activeElement;
    n.focus({ preventScroll: !0 }), n !== t && Lfe(n) && e && n.select();
  }
}
var mU = Nfe();
function Nfe() {
  let n = [];
  return {
    add(e) {
      const t = n[0];
      e !== t && (t == null || t.pause()), n = yU(n, e), n.unshift(e);
    },
    remove(e) {
      var t;
      n = yU(n, e), (t = n[0]) == null || t.resume();
    }
  };
}
function yU(n, e) {
  const t = [...n], r = t.indexOf(e);
  return r !== -1 && t.splice(r, 1), t;
}
function Ffe(n) {
  return n.filter((e) => e.tagName !== "A");
}
var yh = globalThis != null && globalThis.document ? M.useLayoutEffect : () => {
}, zfe = lte.useId || (() => {
}), Ufe = 0;
function $d(n) {
  const [e, t] = M.useState(zfe());
  return yh(() => {
    n || t((r) => r ?? String(Ufe++));
  }, [n]), n || (e ? `radix-${e}` : "");
}
const $fe = ["top", "right", "bottom", "left"], vh = Math.min, qa = Math.max, xE = Math.round, Y1 = Math.floor, bu = (n) => ({
  x: n,
  y: n
}), Bfe = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
}, Hfe = {
  start: "end",
  end: "start"
};
function cD(n, e, t) {
  return qa(n, vh(e, t));
}
function Hd(n, e) {
  return typeof n == "function" ? n(e) : n;
}
function Vd(n) {
  return n.split("-")[0];
}
function Zy(n) {
  return n.split("-")[1];
}
function cj(n) {
  return n === "x" ? "y" : "x";
}
function uj(n) {
  return n === "y" ? "height" : "width";
}
function Sh(n) {
  return ["top", "bottom"].includes(Vd(n)) ? "y" : "x";
}
function dj(n) {
  return cj(Sh(n));
}
function Vfe(n, e, t) {
  t === void 0 && (t = !1);
  const r = Zy(n), i = dj(n), s = uj(i);
  let l = i === "x" ? r === (t ? "end" : "start") ? "right" : "left" : r === "start" ? "bottom" : "top";
  return e.reference[s] > e.floating[s] && (l = wE(l)), [l, wE(l)];
}
function Kfe(n) {
  const e = wE(n);
  return [uD(n), e, uD(e)];
}
function uD(n) {
  return n.replace(/start|end/g, (e) => Hfe[e]);
}
function Wfe(n, e, t) {
  const r = ["left", "right"], i = ["right", "left"], s = ["top", "bottom"], l = ["bottom", "top"];
  switch (n) {
    case "top":
    case "bottom":
      return t ? e ? i : r : e ? r : i;
    case "left":
    case "right":
      return e ? s : l;
    default:
      return [];
  }
}
function Gfe(n, e, t, r) {
  const i = Zy(n);
  let s = Wfe(Vd(n), t === "start", r);
  return i && (s = s.map((l) => l + "-" + i), e && (s = s.concat(s.map(uD)))), s;
}
function wE(n) {
  return n.replace(/left|right|bottom|top/g, (e) => Bfe[e]);
}
function qfe(n) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...n
  };
}
function $H(n) {
  return typeof n != "number" ? qfe(n) : {
    top: n,
    right: n,
    bottom: n,
    left: n
  };
}
function bE(n) {
  const {
    x: e,
    y: t,
    width: r,
    height: i
  } = n;
  return {
    width: r,
    height: i,
    top: t,
    left: e,
    right: e + r,
    bottom: t + i,
    x: e,
    y: t
  };
}
function vU(n, e, t) {
  let {
    reference: r,
    floating: i
  } = n;
  const s = Sh(e), l = dj(e), c = uj(l), d = Vd(e), h = s === "y", g = r.x + r.width / 2 - i.width / 2, y = r.y + r.height / 2 - i.height / 2, v = r[c] / 2 - i[c] / 2;
  let w;
  switch (d) {
    case "top":
      w = {
        x: g,
        y: r.y - i.height
      };
      break;
    case "bottom":
      w = {
        x: g,
        y: r.y + r.height
      };
      break;
    case "right":
      w = {
        x: r.x + r.width,
        y
      };
      break;
    case "left":
      w = {
        x: r.x - i.width,
        y
      };
      break;
    default:
      w = {
        x: r.x,
        y: r.y
      };
  }
  switch (Zy(e)) {
    case "start":
      w[l] -= v * (t && h ? -1 : 1);
      break;
    case "end":
      w[l] += v * (t && h ? -1 : 1);
      break;
  }
  return w;
}
const Yfe = async (n, e, t) => {
  const {
    placement: r = "bottom",
    strategy: i = "absolute",
    middleware: s = [],
    platform: l
  } = t, c = s.filter(Boolean), d = await (l.isRTL == null ? void 0 : l.isRTL(e));
  let h = await l.getElementRects({
    reference: n,
    floating: e,
    strategy: i
  }), {
    x: g,
    y
  } = vU(h, r, d), v = r, w = {}, C = 0;
  for (let E = 0; E < c.length; E++) {
    const {
      name: P,
      fn: I
    } = c[E], {
      x: k,
      y: L,
      data: O,
      reset: z
    } = await I({
      x: g,
      y,
      initialPlacement: r,
      placement: v,
      strategy: i,
      middlewareData: w,
      rects: h,
      platform: l,
      elements: {
        reference: n,
        floating: e
      }
    });
    g = k ?? g, y = L ?? y, w = {
      ...w,
      [P]: {
        ...w[P],
        ...O
      }
    }, z && C <= 50 && (C++, typeof z == "object" && (z.placement && (v = z.placement), z.rects && (h = z.rects === !0 ? await l.getElementRects({
      reference: n,
      floating: e,
      strategy: i
    }) : z.rects), {
      x: g,
      y
    } = vU(h, v, d)), E = -1);
  }
  return {
    x: g,
    y,
    placement: v,
    strategy: i,
    middlewareData: w
  };
};
async function Qx(n, e) {
  var t;
  e === void 0 && (e = {});
  const {
    x: r,
    y: i,
    platform: s,
    rects: l,
    elements: c,
    strategy: d
  } = n, {
    boundary: h = "clippingAncestors",
    rootBoundary: g = "viewport",
    elementContext: y = "floating",
    altBoundary: v = !1,
    padding: w = 0
  } = Hd(e, n), C = $H(w), P = c[v ? y === "floating" ? "reference" : "floating" : y], I = bE(await s.getClippingRect({
    element: (t = await (s.isElement == null ? void 0 : s.isElement(P))) == null || t ? P : P.contextElement || await (s.getDocumentElement == null ? void 0 : s.getDocumentElement(c.floating)),
    boundary: h,
    rootBoundary: g,
    strategy: d
  })), k = y === "floating" ? {
    x: r,
    y: i,
    width: l.floating.width,
    height: l.floating.height
  } : l.reference, L = await (s.getOffsetParent == null ? void 0 : s.getOffsetParent(c.floating)), O = await (s.isElement == null ? void 0 : s.isElement(L)) ? await (s.getScale == null ? void 0 : s.getScale(L)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  }, z = bE(s.convertOffsetParentRelativeRectToViewportRelativeRect ? await s.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements: c,
    rect: k,
    offsetParent: L,
    strategy: d
  }) : k);
  return {
    top: (I.top - z.top + C.top) / O.y,
    bottom: (z.bottom - I.bottom + C.bottom) / O.y,
    left: (I.left - z.left + C.left) / O.x,
    right: (z.right - I.right + C.right) / O.x
  };
}
const Xfe = (n) => ({
  name: "arrow",
  options: n,
  async fn(e) {
    const {
      x: t,
      y: r,
      placement: i,
      rects: s,
      platform: l,
      elements: c,
      middlewareData: d
    } = e, {
      element: h,
      padding: g = 0
    } = Hd(n, e) || {};
    if (h == null)
      return {};
    const y = $H(g), v = {
      x: t,
      y: r
    }, w = dj(i), C = uj(w), E = await l.getDimensions(h), P = w === "y", I = P ? "top" : "left", k = P ? "bottom" : "right", L = P ? "clientHeight" : "clientWidth", O = s.reference[C] + s.reference[w] - v[w] - s.floating[C], z = v[w] - s.reference[w], F = await (l.getOffsetParent == null ? void 0 : l.getOffsetParent(h));
    let H = F ? F[L] : 0;
    (!H || !await (l.isElement == null ? void 0 : l.isElement(F))) && (H = c.floating[L] || s.floating[C]);
    const V = O / 2 - z / 2, re = H / 2 - E[C] / 2 - 1, q = vh(y[I], re), J = vh(y[k], re), ie = q, W = H - E[C] - J, Y = H / 2 - E[C] / 2 + V, oe = cD(ie, Y, W), le = !d.arrow && Zy(i) != null && Y !== oe && s.reference[C] / 2 - (Y < ie ? q : J) - E[C] / 2 < 0, ce = le ? Y < ie ? Y - ie : Y - W : 0;
    return {
      [w]: v[w] + ce,
      data: {
        [w]: oe,
        centerOffset: Y - oe - ce,
        ...le && {
          alignmentOffset: ce
        }
      },
      reset: le
    };
  }
}), Zfe = function(n) {
  return n === void 0 && (n = {}), {
    name: "flip",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        middlewareData: s,
        rects: l,
        initialPlacement: c,
        platform: d,
        elements: h
      } = e, {
        mainAxis: g = !0,
        crossAxis: y = !0,
        fallbackPlacements: v,
        fallbackStrategy: w = "bestFit",
        fallbackAxisSideDirection: C = "none",
        flipAlignment: E = !0,
        ...P
      } = Hd(n, e);
      if ((t = s.arrow) != null && t.alignmentOffset)
        return {};
      const I = Vd(i), k = Sh(c), L = Vd(c) === c, O = await (d.isRTL == null ? void 0 : d.isRTL(h.floating)), z = v || (L || !E ? [wE(c)] : Kfe(c)), F = C !== "none";
      !v && F && z.push(...Gfe(c, E, C, O));
      const H = [c, ...z], V = await Qx(e, P), re = [];
      let q = ((r = s.flip) == null ? void 0 : r.overflows) || [];
      if (g && re.push(V[I]), y) {
        const Y = Vfe(i, l, O);
        re.push(V[Y[0]], V[Y[1]]);
      }
      if (q = [...q, {
        placement: i,
        overflows: re
      }], !re.every((Y) => Y <= 0)) {
        var J, ie;
        const Y = (((J = s.flip) == null ? void 0 : J.index) || 0) + 1, oe = H[Y];
        if (oe)
          return {
            data: {
              index: Y,
              overflows: q
            },
            reset: {
              placement: oe
            }
          };
        let le = (ie = q.filter((ce) => ce.overflows[0] <= 0).sort((ce, Q) => ce.overflows[1] - Q.overflows[1])[0]) == null ? void 0 : ie.placement;
        if (!le)
          switch (w) {
            case "bestFit": {
              var W;
              const ce = (W = q.filter((Q) => {
                if (F) {
                  const he = Sh(Q.placement);
                  return he === k || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  he === "y";
                }
                return !0;
              }).map((Q) => [Q.placement, Q.overflows.filter((he) => he > 0).reduce((he, ke) => he + ke, 0)]).sort((Q, he) => Q[1] - he[1])[0]) == null ? void 0 : W[0];
              ce && (le = ce);
              break;
            }
            case "initialPlacement":
              le = c;
              break;
          }
        if (i !== le)
          return {
            reset: {
              placement: le
            }
          };
      }
      return {};
    }
  };
};
function SU(n, e) {
  return {
    top: n.top - e.height,
    right: n.right - e.width,
    bottom: n.bottom - e.height,
    left: n.left - e.width
  };
}
function xU(n) {
  return $fe.some((e) => n[e] >= 0);
}
const Qfe = function(n) {
  return n === void 0 && (n = {}), {
    name: "hide",
    options: n,
    async fn(e) {
      const {
        rects: t
      } = e, {
        strategy: r = "referenceHidden",
        ...i
      } = Hd(n, e);
      switch (r) {
        case "referenceHidden": {
          const s = await Qx(e, {
            ...i,
            elementContext: "reference"
          }), l = SU(s, t.reference);
          return {
            data: {
              referenceHiddenOffsets: l,
              referenceHidden: xU(l)
            }
          };
        }
        case "escaped": {
          const s = await Qx(e, {
            ...i,
            altBoundary: !0
          }), l = SU(s, t.floating);
          return {
            data: {
              escapedOffsets: l,
              escaped: xU(l)
            }
          };
        }
        default:
          return {};
      }
    }
  };
};
async function Jfe(n, e) {
  const {
    placement: t,
    platform: r,
    elements: i
  } = n, s = await (r.isRTL == null ? void 0 : r.isRTL(i.floating)), l = Vd(t), c = Zy(t), d = Sh(t) === "y", h = ["left", "top"].includes(l) ? -1 : 1, g = s && d ? -1 : 1, y = Hd(e, n);
  let {
    mainAxis: v,
    crossAxis: w,
    alignmentAxis: C
  } = typeof y == "number" ? {
    mainAxis: y,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: y.mainAxis || 0,
    crossAxis: y.crossAxis || 0,
    alignmentAxis: y.alignmentAxis
  };
  return c && typeof C == "number" && (w = c === "end" ? C * -1 : C), d ? {
    x: w * g,
    y: v * h
  } : {
    x: v * h,
    y: w * g
  };
}
const ehe = function(n) {
  return n === void 0 && (n = 0), {
    name: "offset",
    options: n,
    async fn(e) {
      var t, r;
      const {
        x: i,
        y: s,
        placement: l,
        middlewareData: c
      } = e, d = await Jfe(e, n);
      return l === ((t = c.offset) == null ? void 0 : t.placement) && (r = c.arrow) != null && r.alignmentOffset ? {} : {
        x: i + d.x,
        y: s + d.y,
        data: {
          ...d,
          placement: l
        }
      };
    }
  };
}, the = function(n) {
  return n === void 0 && (n = {}), {
    name: "shift",
    options: n,
    async fn(e) {
      const {
        x: t,
        y: r,
        placement: i
      } = e, {
        mainAxis: s = !0,
        crossAxis: l = !1,
        limiter: c = {
          fn: (P) => {
            let {
              x: I,
              y: k
            } = P;
            return {
              x: I,
              y: k
            };
          }
        },
        ...d
      } = Hd(n, e), h = {
        x: t,
        y: r
      }, g = await Qx(e, d), y = Sh(Vd(i)), v = cj(y);
      let w = h[v], C = h[y];
      if (s) {
        const P = v === "y" ? "top" : "left", I = v === "y" ? "bottom" : "right", k = w + g[P], L = w - g[I];
        w = cD(k, w, L);
      }
      if (l) {
        const P = y === "y" ? "top" : "left", I = y === "y" ? "bottom" : "right", k = C + g[P], L = C - g[I];
        C = cD(k, C, L);
      }
      const E = c.fn({
        ...e,
        [v]: w,
        [y]: C
      });
      return {
        ...E,
        data: {
          x: E.x - t,
          y: E.y - r,
          enabled: {
            [v]: s,
            [y]: l
          }
        }
      };
    }
  };
}, nhe = function(n) {
  return n === void 0 && (n = {}), {
    options: n,
    fn(e) {
      const {
        x: t,
        y: r,
        placement: i,
        rects: s,
        middlewareData: l
      } = e, {
        offset: c = 0,
        mainAxis: d = !0,
        crossAxis: h = !0
      } = Hd(n, e), g = {
        x: t,
        y: r
      }, y = Sh(i), v = cj(y);
      let w = g[v], C = g[y];
      const E = Hd(c, e), P = typeof E == "number" ? {
        mainAxis: E,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...E
      };
      if (d) {
        const L = v === "y" ? "height" : "width", O = s.reference[v] - s.floating[L] + P.mainAxis, z = s.reference[v] + s.reference[L] - P.mainAxis;
        w < O ? w = O : w > z && (w = z);
      }
      if (h) {
        var I, k;
        const L = v === "y" ? "width" : "height", O = ["top", "left"].includes(Vd(i)), z = s.reference[y] - s.floating[L] + (O && ((I = l.offset) == null ? void 0 : I[y]) || 0) + (O ? 0 : P.crossAxis), F = s.reference[y] + s.reference[L] + (O ? 0 : ((k = l.offset) == null ? void 0 : k[y]) || 0) - (O ? P.crossAxis : 0);
        C < z ? C = z : C > F && (C = F);
      }
      return {
        [v]: w,
        [y]: C
      };
    }
  };
}, rhe = function(n) {
  return n === void 0 && (n = {}), {
    name: "size",
    options: n,
    async fn(e) {
      var t, r;
      const {
        placement: i,
        rects: s,
        platform: l,
        elements: c
      } = e, {
        apply: d = () => {
        },
        ...h
      } = Hd(n, e), g = await Qx(e, h), y = Vd(i), v = Zy(i), w = Sh(i) === "y", {
        width: C,
        height: E
      } = s.floating;
      let P, I;
      y === "top" || y === "bottom" ? (P = y, I = v === (await (l.isRTL == null ? void 0 : l.isRTL(c.floating)) ? "start" : "end") ? "left" : "right") : (I = y, P = v === "end" ? "top" : "bottom");
      const k = E - g.top - g.bottom, L = C - g.left - g.right, O = vh(E - g[P], k), z = vh(C - g[I], L), F = !e.middlewareData.shift;
      let H = O, V = z;
      if ((t = e.middlewareData.shift) != null && t.enabled.x && (V = L), (r = e.middlewareData.shift) != null && r.enabled.y && (H = k), F && !v) {
        const q = qa(g.left, 0), J = qa(g.right, 0), ie = qa(g.top, 0), W = qa(g.bottom, 0);
        w ? V = C - 2 * (q !== 0 || J !== 0 ? q + J : qa(g.left, g.right)) : H = E - 2 * (ie !== 0 || W !== 0 ? ie + W : qa(g.top, g.bottom));
      }
      await d({
        ...e,
        availableWidth: V,
        availableHeight: H
      });
      const re = await l.getDimensions(c.floating);
      return C !== re.width || E !== re.height ? {
        reset: {
          rects: !0
        }
      } : {};
    }
  };
};
function v_() {
  return typeof window < "u";
}
function Qy(n) {
  return BH(n) ? (n.nodeName || "").toLowerCase() : "#document";
}
function el(n) {
  var e;
  return (n == null || (e = n.ownerDocument) == null ? void 0 : e.defaultView) || window;
}
function Lu(n) {
  var e;
  return (e = (BH(n) ? n.ownerDocument : n.document) || window.document) == null ? void 0 : e.documentElement;
}
function BH(n) {
  return v_() ? n instanceof Node || n instanceof el(n).Node : !1;
}
function _c(n) {
  return v_() ? n instanceof Element || n instanceof el(n).Element : !1;
}
function Iu(n) {
  return v_() ? n instanceof HTMLElement || n instanceof el(n).HTMLElement : !1;
}
function wU(n) {
  return !v_() || typeof ShadowRoot > "u" ? !1 : n instanceof ShadowRoot || n instanceof el(n).ShadowRoot;
}
function Iw(n) {
  const {
    overflow: e,
    overflowX: t,
    overflowY: r,
    display: i
  } = Pc(n);
  return /auto|scroll|overlay|hidden|clip/.test(e + r + t) && !["inline", "contents"].includes(i);
}
function ihe(n) {
  return ["table", "td", "th"].includes(Qy(n));
}
function S_(n) {
  return [":popover-open", ":modal"].some((e) => {
    try {
      return n.matches(e);
    } catch {
      return !1;
    }
  });
}
function fj(n) {
  const e = hj(), t = _c(n) ? Pc(n) : n;
  return ["transform", "translate", "scale", "rotate", "perspective"].some((r) => t[r] ? t[r] !== "none" : !1) || (t.containerType ? t.containerType !== "normal" : !1) || !e && (t.backdropFilter ? t.backdropFilter !== "none" : !1) || !e && (t.filter ? t.filter !== "none" : !1) || ["transform", "translate", "scale", "rotate", "perspective", "filter"].some((r) => (t.willChange || "").includes(r)) || ["paint", "layout", "strict", "content"].some((r) => (t.contain || "").includes(r));
}
function ohe(n) {
  let e = xh(n);
  for (; Iu(e) && !Ay(e); ) {
    if (fj(e))
      return e;
    if (S_(e))
      return null;
    e = xh(e);
  }
  return null;
}
function hj() {
  return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none");
}
function Ay(n) {
  return ["html", "body", "#document"].includes(Qy(n));
}
function Pc(n) {
  return el(n).getComputedStyle(n);
}
function x_(n) {
  return _c(n) ? {
    scrollLeft: n.scrollLeft,
    scrollTop: n.scrollTop
  } : {
    scrollLeft: n.scrollX,
    scrollTop: n.scrollY
  };
}
function xh(n) {
  if (Qy(n) === "html")
    return n;
  const e = (
    // Step into the shadow DOM of the parent of a slotted node.
    n.assignedSlot || // DOM Element detected.
    n.parentNode || // ShadowRoot detected.
    wU(n) && n.host || // Fallback.
    Lu(n)
  );
  return wU(e) ? e.host : e;
}
function HH(n) {
  const e = xh(n);
  return Ay(e) ? n.ownerDocument ? n.ownerDocument.body : n.body : Iu(e) && Iw(e) ? e : HH(e);
}
function Jx(n, e, t) {
  var r;
  e === void 0 && (e = []), t === void 0 && (t = !0);
  const i = HH(n), s = i === ((r = n.ownerDocument) == null ? void 0 : r.body), l = el(i);
  if (s) {
    const c = dD(l);
    return e.concat(l, l.visualViewport || [], Iw(i) ? i : [], c && t ? Jx(c) : []);
  }
  return e.concat(i, Jx(i, [], t));
}
function dD(n) {
  return n.parent && Object.getPrototypeOf(n.parent) ? n.frameElement : null;
}
function VH(n) {
  const e = Pc(n);
  let t = parseFloat(e.width) || 0, r = parseFloat(e.height) || 0;
  const i = Iu(n), s = i ? n.offsetWidth : t, l = i ? n.offsetHeight : r, c = xE(t) !== s || xE(r) !== l;
  return c && (t = s, r = l), {
    width: t,
    height: r,
    $: c
  };
}
function pj(n) {
  return _c(n) ? n : n.contextElement;
}
function Ty(n) {
  const e = pj(n);
  if (!Iu(e))
    return bu(1);
  const t = e.getBoundingClientRect(), {
    width: r,
    height: i,
    $: s
  } = VH(e);
  let l = (s ? xE(t.width) : t.width) / r, c = (s ? xE(t.height) : t.height) / i;
  return (!l || !Number.isFinite(l)) && (l = 1), (!c || !Number.isFinite(c)) && (c = 1), {
    x: l,
    y: c
  };
}
const she = /* @__PURE__ */ bu(0);
function KH(n) {
  const e = el(n);
  return !hj() || !e.visualViewport ? she : {
    x: e.visualViewport.offsetLeft,
    y: e.visualViewport.offsetTop
  };
}
function ahe(n, e, t) {
  return e === void 0 && (e = !1), !t || e && t !== el(n) ? !1 : e;
}
function rg(n, e, t, r) {
  e === void 0 && (e = !1), t === void 0 && (t = !1);
  const i = n.getBoundingClientRect(), s = pj(n);
  let l = bu(1);
  e && (r ? _c(r) && (l = Ty(r)) : l = Ty(n));
  const c = ahe(s, t, r) ? KH(s) : bu(0);
  let d = (i.left + c.x) / l.x, h = (i.top + c.y) / l.y, g = i.width / l.x, y = i.height / l.y;
  if (s) {
    const v = el(s), w = r && _c(r) ? el(r) : r;
    let C = v, E = dD(C);
    for (; E && r && w !== C; ) {
      const P = Ty(E), I = E.getBoundingClientRect(), k = Pc(E), L = I.left + (E.clientLeft + parseFloat(k.paddingLeft)) * P.x, O = I.top + (E.clientTop + parseFloat(k.paddingTop)) * P.y;
      d *= P.x, h *= P.y, g *= P.x, y *= P.y, d += L, h += O, C = el(E), E = dD(C);
    }
  }
  return bE({
    width: g,
    height: y,
    x: d,
    y: h
  });
}
function gj(n, e) {
  const t = x_(n).scrollLeft;
  return e ? e.left + t : rg(Lu(n)).left + t;
}
function WH(n, e, t) {
  t === void 0 && (t = !1);
  const r = n.getBoundingClientRect(), i = r.left + e.scrollLeft - (t ? 0 : (
    // RTL <body> scrollbar.
    gj(n, r)
  )), s = r.top + e.scrollTop;
  return {
    x: i,
    y: s
  };
}
function lhe(n) {
  let {
    elements: e,
    rect: t,
    offsetParent: r,
    strategy: i
  } = n;
  const s = i === "fixed", l = Lu(r), c = e ? S_(e.floating) : !1;
  if (r === l || c && s)
    return t;
  let d = {
    scrollLeft: 0,
    scrollTop: 0
  }, h = bu(1);
  const g = bu(0), y = Iu(r);
  if ((y || !y && !s) && ((Qy(r) !== "body" || Iw(l)) && (d = x_(r)), Iu(r))) {
    const w = rg(r);
    h = Ty(r), g.x = w.x + r.clientLeft, g.y = w.y + r.clientTop;
  }
  const v = l && !y && !s ? WH(l, d, !0) : bu(0);
  return {
    width: t.width * h.x,
    height: t.height * h.y,
    x: t.x * h.x - d.scrollLeft * h.x + g.x + v.x,
    y: t.y * h.y - d.scrollTop * h.y + g.y + v.y
  };
}
function che(n) {
  return Array.from(n.getClientRects());
}
function uhe(n) {
  const e = Lu(n), t = x_(n), r = n.ownerDocument.body, i = qa(e.scrollWidth, e.clientWidth, r.scrollWidth, r.clientWidth), s = qa(e.scrollHeight, e.clientHeight, r.scrollHeight, r.clientHeight);
  let l = -t.scrollLeft + gj(n);
  const c = -t.scrollTop;
  return Pc(r).direction === "rtl" && (l += qa(e.clientWidth, r.clientWidth) - i), {
    width: i,
    height: s,
    x: l,
    y: c
  };
}
function dhe(n, e) {
  const t = el(n), r = Lu(n), i = t.visualViewport;
  let s = r.clientWidth, l = r.clientHeight, c = 0, d = 0;
  if (i) {
    s = i.width, l = i.height;
    const h = hj();
    (!h || h && e === "fixed") && (c = i.offsetLeft, d = i.offsetTop);
  }
  return {
    width: s,
    height: l,
    x: c,
    y: d
  };
}
function fhe(n, e) {
  const t = rg(n, !0, e === "fixed"), r = t.top + n.clientTop, i = t.left + n.clientLeft, s = Iu(n) ? Ty(n) : bu(1), l = n.clientWidth * s.x, c = n.clientHeight * s.y, d = i * s.x, h = r * s.y;
  return {
    width: l,
    height: c,
    x: d,
    y: h
  };
}
function bU(n, e, t) {
  let r;
  if (e === "viewport")
    r = dhe(n, t);
  else if (e === "document")
    r = uhe(Lu(n));
  else if (_c(e))
    r = fhe(e, t);
  else {
    const i = KH(n);
    r = {
      x: e.x - i.x,
      y: e.y - i.y,
      width: e.width,
      height: e.height
    };
  }
  return bE(r);
}
function GH(n, e) {
  const t = xh(n);
  return t === e || !_c(t) || Ay(t) ? !1 : Pc(t).position === "fixed" || GH(t, e);
}
function hhe(n, e) {
  const t = e.get(n);
  if (t)
    return t;
  let r = Jx(n, [], !1).filter((c) => _c(c) && Qy(c) !== "body"), i = null;
  const s = Pc(n).position === "fixed";
  let l = s ? xh(n) : n;
  for (; _c(l) && !Ay(l); ) {
    const c = Pc(l), d = fj(l);
    !d && c.position === "fixed" && (i = null), (s ? !d && !i : !d && c.position === "static" && !!i && ["absolute", "fixed"].includes(i.position) || Iw(l) && !d && GH(n, l)) ? r = r.filter((g) => g !== l) : i = c, l = xh(l);
  }
  return e.set(n, r), r;
}
function phe(n) {
  let {
    element: e,
    boundary: t,
    rootBoundary: r,
    strategy: i
  } = n;
  const l = [...t === "clippingAncestors" ? S_(e) ? [] : hhe(e, this._c) : [].concat(t), r], c = l[0], d = l.reduce((h, g) => {
    const y = bU(e, g, i);
    return h.top = qa(y.top, h.top), h.right = vh(y.right, h.right), h.bottom = vh(y.bottom, h.bottom), h.left = qa(y.left, h.left), h;
  }, bU(e, c, i));
  return {
    width: d.right - d.left,
    height: d.bottom - d.top,
    x: d.left,
    y: d.top
  };
}
function ghe(n) {
  const {
    width: e,
    height: t
  } = VH(n);
  return {
    width: e,
    height: t
  };
}
function mhe(n, e, t) {
  const r = Iu(e), i = Lu(e), s = t === "fixed", l = rg(n, !0, s, e);
  let c = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const d = bu(0);
  if (r || !r && !s)
    if ((Qy(e) !== "body" || Iw(i)) && (c = x_(e)), r) {
      const v = rg(e, !0, s, e);
      d.x = v.x + e.clientLeft, d.y = v.y + e.clientTop;
    } else i && (d.x = gj(i));
  const h = i && !r && !s ? WH(i, c) : bu(0), g = l.left + c.scrollLeft - d.x - h.x, y = l.top + c.scrollTop - d.y - h.y;
  return {
    x: g,
    y,
    width: l.width,
    height: l.height
  };
}
function zM(n) {
  return Pc(n).position === "static";
}
function CU(n, e) {
  if (!Iu(n) || Pc(n).position === "fixed")
    return null;
  if (e)
    return e(n);
  let t = n.offsetParent;
  return Lu(n) === t && (t = t.ownerDocument.body), t;
}
function qH(n, e) {
  const t = el(n);
  if (S_(n))
    return t;
  if (!Iu(n)) {
    let i = xh(n);
    for (; i && !Ay(i); ) {
      if (_c(i) && !zM(i))
        return i;
      i = xh(i);
    }
    return t;
  }
  let r = CU(n, e);
  for (; r && ihe(r) && zM(r); )
    r = CU(r, e);
  return r && Ay(r) && zM(r) && !fj(r) ? t : r || ohe(n) || t;
}
const yhe = async function(n) {
  const e = this.getOffsetParent || qH, t = this.getDimensions, r = await t(n.floating);
  return {
    reference: mhe(n.reference, await e(n.floating), n.strategy),
    floating: {
      x: 0,
      y: 0,
      width: r.width,
      height: r.height
    }
  };
};
function vhe(n) {
  return Pc(n).direction === "rtl";
}
const She = {
  convertOffsetParentRelativeRectToViewportRelativeRect: lhe,
  getDocumentElement: Lu,
  getClippingRect: phe,
  getOffsetParent: qH,
  getElementRects: yhe,
  getClientRects: che,
  getDimensions: ghe,
  getScale: Ty,
  isElement: _c,
  isRTL: vhe
};
function YH(n, e) {
  return n.x === e.x && n.y === e.y && n.width === e.width && n.height === e.height;
}
function xhe(n, e) {
  let t = null, r;
  const i = Lu(n);
  function s() {
    var c;
    clearTimeout(r), (c = t) == null || c.disconnect(), t = null;
  }
  function l(c, d) {
    c === void 0 && (c = !1), d === void 0 && (d = 1), s();
    const h = n.getBoundingClientRect(), {
      left: g,
      top: y,
      width: v,
      height: w
    } = h;
    if (c || e(), !v || !w)
      return;
    const C = Y1(y), E = Y1(i.clientWidth - (g + v)), P = Y1(i.clientHeight - (y + w)), I = Y1(g), L = {
      rootMargin: -C + "px " + -E + "px " + -P + "px " + -I + "px",
      threshold: qa(0, vh(1, d)) || 1
    };
    let O = !0;
    function z(F) {
      const H = F[0].intersectionRatio;
      if (H !== d) {
        if (!O)
          return l();
        H ? l(!1, H) : r = setTimeout(() => {
          l(!1, 1e-7);
        }, 1e3);
      }
      H === 1 && !YH(h, n.getBoundingClientRect()) && l(), O = !1;
    }
    try {
      t = new IntersectionObserver(z, {
        ...L,
        // Handle <iframe>s
        root: i.ownerDocument
      });
    } catch {
      t = new IntersectionObserver(z, L);
    }
    t.observe(n);
  }
  return l(!0), s;
}
function whe(n, e, t, r) {
  r === void 0 && (r = {});
  const {
    ancestorScroll: i = !0,
    ancestorResize: s = !0,
    elementResize: l = typeof ResizeObserver == "function",
    layoutShift: c = typeof IntersectionObserver == "function",
    animationFrame: d = !1
  } = r, h = pj(n), g = i || s ? [...h ? Jx(h) : [], ...Jx(e)] : [];
  g.forEach((I) => {
    i && I.addEventListener("scroll", t, {
      passive: !0
    }), s && I.addEventListener("resize", t);
  });
  const y = h && c ? xhe(h, t) : null;
  let v = -1, w = null;
  l && (w = new ResizeObserver((I) => {
    let [k] = I;
    k && k.target === h && w && (w.unobserve(e), cancelAnimationFrame(v), v = requestAnimationFrame(() => {
      var L;
      (L = w) == null || L.observe(e);
    })), t();
  }), h && !d && w.observe(h), w.observe(e));
  let C, E = d ? rg(n) : null;
  d && P();
  function P() {
    const I = rg(n);
    E && !YH(E, I) && t(), E = I, C = requestAnimationFrame(P);
  }
  return t(), () => {
    var I;
    g.forEach((k) => {
      i && k.removeEventListener("scroll", t), s && k.removeEventListener("resize", t);
    }), y == null || y(), (I = w) == null || I.disconnect(), w = null, d && cancelAnimationFrame(C);
  };
}
const bhe = ehe, Che = the, Ehe = Zfe, _he = rhe, Phe = Qfe, EU = Xfe, The = nhe, Ihe = (n, e, t) => {
  const r = /* @__PURE__ */ new Map(), i = {
    platform: She,
    ...t
  }, s = {
    ...i.platform,
    _c: r
  };
  return Yfe(n, e, {
    ...i,
    platform: s
  });
};
var EC = typeof document < "u" ? M.useLayoutEffect : M.useEffect;
function CE(n, e) {
  if (n === e)
    return !0;
  if (typeof n != typeof e)
    return !1;
  if (typeof n == "function" && n.toString() === e.toString())
    return !0;
  let t, r, i;
  if (n && e && typeof n == "object") {
    if (Array.isArray(n)) {
      if (t = n.length, t !== e.length) return !1;
      for (r = t; r-- !== 0; )
        if (!CE(n[r], e[r]))
          return !1;
      return !0;
    }
    if (i = Object.keys(n), t = i.length, t !== Object.keys(e).length)
      return !1;
    for (r = t; r-- !== 0; )
      if (!{}.hasOwnProperty.call(e, i[r]))
        return !1;
    for (r = t; r-- !== 0; ) {
      const s = i[r];
      if (!(s === "_owner" && n.$$typeof) && !CE(n[s], e[s]))
        return !1;
    }
    return !0;
  }
  return n !== n && e !== e;
}
function XH(n) {
  return typeof window > "u" ? 1 : (n.ownerDocument.defaultView || window).devicePixelRatio || 1;
}
function _U(n, e) {
  const t = XH(n);
  return Math.round(e * t) / t;
}
function UM(n) {
  const e = M.useRef(n);
  return EC(() => {
    e.current = n;
  }), e;
}
function khe(n) {
  n === void 0 && (n = {});
  const {
    placement: e = "bottom",
    strategy: t = "absolute",
    middleware: r = [],
    platform: i,
    elements: {
      reference: s,
      floating: l
    } = {},
    transform: c = !0,
    whileElementsMounted: d,
    open: h
  } = n, [g, y] = M.useState({
    x: 0,
    y: 0,
    strategy: t,
    placement: e,
    middlewareData: {},
    isPositioned: !1
  }), [v, w] = M.useState(r);
  CE(v, r) || w(r);
  const [C, E] = M.useState(null), [P, I] = M.useState(null), k = M.useCallback((Q) => {
    Q !== F.current && (F.current = Q, E(Q));
  }, []), L = M.useCallback((Q) => {
    Q !== H.current && (H.current = Q, I(Q));
  }, []), O = s || C, z = l || P, F = M.useRef(null), H = M.useRef(null), V = M.useRef(g), re = d != null, q = UM(d), J = UM(i), ie = UM(h), W = M.useCallback(() => {
    if (!F.current || !H.current)
      return;
    const Q = {
      placement: e,
      strategy: t,
      middleware: v
    };
    J.current && (Q.platform = J.current), Ihe(F.current, H.current, Q).then((he) => {
      const ke = {
        ...he,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: ie.current !== !1
      };
      Y.current && !CE(V.current, ke) && (V.current = ke, Gy.flushSync(() => {
        y(ke);
      }));
    });
  }, [v, e, t, J, ie]);
  EC(() => {
    h === !1 && V.current.isPositioned && (V.current.isPositioned = !1, y((Q) => ({
      ...Q,
      isPositioned: !1
    })));
  }, [h]);
  const Y = M.useRef(!1);
  EC(() => (Y.current = !0, () => {
    Y.current = !1;
  }), []), EC(() => {
    if (O && (F.current = O), z && (H.current = z), O && z) {
      if (q.current)
        return q.current(O, z, W);
      W();
    }
  }, [O, z, W, q, re]);
  const oe = M.useMemo(() => ({
    reference: F,
    floating: H,
    setReference: k,
    setFloating: L
  }), [k, L]), le = M.useMemo(() => ({
    reference: O,
    floating: z
  }), [O, z]), ce = M.useMemo(() => {
    const Q = {
      position: t,
      left: 0,
      top: 0
    };
    if (!le.floating)
      return Q;
    const he = _U(le.floating, g.x), ke = _U(le.floating, g.y);
    return c ? {
      ...Q,
      transform: "translate(" + he + "px, " + ke + "px)",
      ...XH(le.floating) >= 1.5 && {
        willChange: "transform"
      }
    } : {
      position: t,
      left: he,
      top: ke
    };
  }, [t, c, le.floating, g.x, g.y]);
  return M.useMemo(() => ({
    ...g,
    update: W,
    refs: oe,
    elements: le,
    floatingStyles: ce
  }), [g, W, oe, le, ce]);
}
const Rhe = (n) => {
  function e(t) {
    return {}.hasOwnProperty.call(t, "current");
  }
  return {
    name: "arrow",
    options: n,
    fn(t) {
      const {
        element: r,
        padding: i
      } = typeof n == "function" ? n(t) : n;
      return r && e(r) ? r.current != null ? EU({
        element: r.current,
        padding: i
      }).fn(t) : {} : r ? EU({
        element: r,
        padding: i
      }).fn(t) : {};
    }
  };
}, Mhe = (n, e) => ({
  ...bhe(n),
  options: [n, e]
}), Ahe = (n, e) => ({
  ...Che(n),
  options: [n, e]
}), Dhe = (n, e) => ({
  ...The(n),
  options: [n, e]
}), Ohe = (n, e) => ({
  ...Ehe(n),
  options: [n, e]
}), jhe = (n, e) => ({
  ..._he(n),
  options: [n, e]
}), Lhe = (n, e) => ({
  ...Phe(n),
  options: [n, e]
}), Nhe = (n, e) => ({
  ...Rhe(n),
  options: [n, e]
});
var Fhe = "Arrow", ZH = M.forwardRef((n, e) => {
  const { children: t, width: r = 10, height: i = 5, ...s } = n;
  return /* @__PURE__ */ m.jsx(
    Wn.svg,
    {
      ...s,
      ref: e,
      width: r,
      height: i,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: n.asChild ? t : /* @__PURE__ */ m.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
ZH.displayName = Fhe;
var zhe = ZH;
function QH(n) {
  const [e, t] = M.useState(void 0);
  return yh(() => {
    if (n) {
      t({ width: n.offsetWidth, height: n.offsetHeight });
      const r = new ResizeObserver((i) => {
        if (!Array.isArray(i) || !i.length)
          return;
        const s = i[0];
        let l, c;
        if ("borderBoxSize" in s) {
          const d = s.borderBoxSize, h = Array.isArray(d) ? d[0] : d;
          l = h.inlineSize, c = h.blockSize;
        } else
          l = n.offsetWidth, c = n.offsetHeight;
        t({ width: l, height: c });
      });
      return r.observe(n, { box: "border-box" }), () => r.unobserve(n);
    } else
      t(void 0);
  }, [n]), e;
}
var mj = "Popper", [JH, w_] = ju(mj), [Uhe, eV] = JH(mj), tV = (n) => {
  const { __scopePopper: e, children: t } = n, [r, i] = M.useState(null);
  return /* @__PURE__ */ m.jsx(Uhe, { scope: e, anchor: r, onAnchorChange: i, children: t });
};
tV.displayName = mj;
var nV = "PopperAnchor", rV = M.forwardRef(
  (n, e) => {
    const { __scopePopper: t, virtualRef: r, ...i } = n, s = eV(nV, t), l = M.useRef(null), c = jr(e, l);
    return M.useEffect(() => {
      s.onAnchorChange((r == null ? void 0 : r.current) || l.current);
    }), r ? null : /* @__PURE__ */ m.jsx(Wn.div, { ...i, ref: c });
  }
);
rV.displayName = nV;
var yj = "PopperContent", [$he, Bhe] = JH(yj), iV = M.forwardRef(
  (n, e) => {
    var it, We, Qe, gt, Pt, mn;
    const {
      __scopePopper: t,
      side: r = "bottom",
      sideOffset: i = 0,
      align: s = "center",
      alignOffset: l = 0,
      arrowPadding: c = 0,
      avoidCollisions: d = !0,
      collisionBoundary: h = [],
      collisionPadding: g = 0,
      sticky: y = "partial",
      hideWhenDetached: v = !1,
      updatePositionStrategy: w = "optimized",
      onPlaced: C,
      ...E
    } = n, P = eV(yj, t), [I, k] = M.useState(null), L = jr(e, (Zt) => k(Zt)), [O, z] = M.useState(null), F = QH(O), H = (F == null ? void 0 : F.width) ?? 0, V = (F == null ? void 0 : F.height) ?? 0, re = r + (s !== "center" ? "-" + s : ""), q = typeof g == "number" ? g : { top: 0, right: 0, bottom: 0, left: 0, ...g }, J = Array.isArray(h) ? h : [h], ie = J.length > 0, W = {
      padding: q,
      boundary: J.filter(Vhe),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: ie
    }, { refs: Y, floatingStyles: oe, placement: le, isPositioned: ce, middlewareData: Q } = khe({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: re,
      whileElementsMounted: (...Zt) => whe(...Zt, {
        animationFrame: w === "always"
      }),
      elements: {
        reference: P.anchor
      },
      middleware: [
        Mhe({ mainAxis: i + V, alignmentAxis: l }),
        d && Ahe({
          mainAxis: !0,
          crossAxis: !1,
          limiter: y === "partial" ? Dhe() : void 0,
          ...W
        }),
        d && Ohe({ ...W }),
        jhe({
          ...W,
          apply: ({ elements: Zt, rects: an, availableWidth: ln, availableHeight: Yt }) => {
            const { width: Gn, height: xr } = an.reference, Hr = Zt.floating.style;
            Hr.setProperty("--radix-popper-available-width", `${ln}px`), Hr.setProperty("--radix-popper-available-height", `${Yt}px`), Hr.setProperty("--radix-popper-anchor-width", `${Gn}px`), Hr.setProperty("--radix-popper-anchor-height", `${xr}px`);
          }
        }),
        O && Nhe({ element: O, padding: c }),
        Khe({ arrowWidth: H, arrowHeight: V }),
        v && Lhe({ strategy: "referenceHidden", ...W })
      ]
    }), [he, ke] = aV(le), te = $o(C);
    yh(() => {
      ce && (te == null || te());
    }, [ce, te]);
    const me = (it = Q.arrow) == null ? void 0 : it.x, Oe = (We = Q.arrow) == null ? void 0 : We.y, Ze = ((Qe = Q.arrow) == null ? void 0 : Qe.centerOffset) !== 0, [De, yt] = M.useState();
    return yh(() => {
      I && yt(window.getComputedStyle(I).zIndex);
    }, [I]), /* @__PURE__ */ m.jsx(
      "div",
      {
        ref: Y.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...oe,
          transform: ce ? oe.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: De,
          "--radix-popper-transform-origin": [
            (gt = Q.transformOrigin) == null ? void 0 : gt.x,
            (Pt = Q.transformOrigin) == null ? void 0 : Pt.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...((mn = Q.hide) == null ? void 0 : mn.referenceHidden) && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: n.dir,
        children: /* @__PURE__ */ m.jsx(
          $he,
          {
            scope: t,
            placedSide: he,
            onArrowChange: z,
            arrowX: me,
            arrowY: Oe,
            shouldHideArrow: Ze,
            children: /* @__PURE__ */ m.jsx(
              Wn.div,
              {
                "data-side": he,
                "data-align": ke,
                ...E,
                ref: L,
                style: {
                  ...E.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: ce ? void 0 : "none"
                }
              }
            )
          }
        )
      }
    );
  }
);
iV.displayName = yj;
var oV = "PopperArrow", Hhe = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
}, sV = M.forwardRef(function(e, t) {
  const { __scopePopper: r, ...i } = e, s = Bhe(oV, r), l = Hhe[s.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ m.jsx(
      "span",
      {
        ref: s.onArrowChange,
        style: {
          position: "absolute",
          left: s.arrowX,
          top: s.arrowY,
          [l]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[s.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: "rotate(180deg)",
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[s.placedSide],
          visibility: s.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ m.jsx(
          zhe,
          {
            ...i,
            ref: t,
            style: {
              ...i.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
sV.displayName = oV;
function Vhe(n) {
  return n !== null;
}
var Khe = (n) => ({
  name: "transformOrigin",
  options: n,
  fn(e) {
    var P, I, k;
    const { placement: t, rects: r, middlewareData: i } = e, l = ((P = i.arrow) == null ? void 0 : P.centerOffset) !== 0, c = l ? 0 : n.arrowWidth, d = l ? 0 : n.arrowHeight, [h, g] = aV(t), y = { start: "0%", center: "50%", end: "100%" }[g], v = (((I = i.arrow) == null ? void 0 : I.x) ?? 0) + c / 2, w = (((k = i.arrow) == null ? void 0 : k.y) ?? 0) + d / 2;
    let C = "", E = "";
    return h === "bottom" ? (C = l ? y : `${v}px`, E = `${-d}px`) : h === "top" ? (C = l ? y : `${v}px`, E = `${r.floating.height + d}px`) : h === "right" ? (C = `${-d}px`, E = l ? y : `${w}px`) : h === "left" && (C = `${r.floating.width + d}px`, E = l ? y : `${w}px`), { data: { x: C, y: E } };
  }
});
function aV(n) {
  const [e, t = "center"] = n.split("-");
  return [e, t];
}
var vj = tV, Sj = rV, lV = iV, cV = sV, Whe = "Portal", kw = M.forwardRef((n, e) => {
  var c;
  const { container: t, ...r } = n, [i, s] = M.useState(!1);
  yh(() => s(!0), []);
  const l = t || i && ((c = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : c.body);
  return l ? Hle.createPortal(/* @__PURE__ */ m.jsx(Wn.div, { ...r, ref: e }), l) : null;
});
kw.displayName = Whe;
function Ghe(n, e) {
  return M.useReducer((t, r) => e[t][r] ?? t, n);
}
var kc = (n) => {
  const { present: e, children: t } = n, r = qhe(e), i = typeof t == "function" ? t({ present: r.isPresent }) : M.Children.only(t), s = jr(r.ref, Yhe(i));
  return typeof t == "function" || r.isPresent ? M.cloneElement(i, { ref: s }) : null;
};
kc.displayName = "Presence";
function qhe(n) {
  const [e, t] = M.useState(), r = M.useRef({}), i = M.useRef(n), s = M.useRef("none"), l = n ? "mounted" : "unmounted", [c, d] = Ghe(l, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return M.useEffect(() => {
    const h = X1(r.current);
    s.current = c === "mounted" ? h : "none";
  }, [c]), yh(() => {
    const h = r.current, g = i.current;
    if (g !== n) {
      const v = s.current, w = X1(h);
      n ? d("MOUNT") : w === "none" || (h == null ? void 0 : h.display) === "none" ? d("UNMOUNT") : d(g && v !== w ? "ANIMATION_OUT" : "UNMOUNT"), i.current = n;
    }
  }, [n, d]), yh(() => {
    if (e) {
      let h;
      const g = e.ownerDocument.defaultView ?? window, y = (w) => {
        const E = X1(r.current).includes(w.animationName);
        if (w.target === e && E && (d("ANIMATION_END"), !i.current)) {
          const P = e.style.animationFillMode;
          e.style.animationFillMode = "forwards", h = g.setTimeout(() => {
            e.style.animationFillMode === "forwards" && (e.style.animationFillMode = P);
          });
        }
      }, v = (w) => {
        w.target === e && (s.current = X1(r.current));
      };
      return e.addEventListener("animationstart", v), e.addEventListener("animationcancel", y), e.addEventListener("animationend", y), () => {
        g.clearTimeout(h), e.removeEventListener("animationstart", v), e.removeEventListener("animationcancel", y), e.removeEventListener("animationend", y);
      };
    } else
      d("ANIMATION_END");
  }, [e, d]), {
    isPresent: ["mounted", "unmountSuspended"].includes(c),
    ref: M.useCallback((h) => {
      h && (r.current = getComputedStyle(h)), t(h);
    }, [])
  };
}
function X1(n) {
  return (n == null ? void 0 : n.animationName) || "none";
}
function Yhe(n) {
  var r, i;
  let e = (r = Object.getOwnPropertyDescriptor(n.props, "ref")) == null ? void 0 : r.get, t = e && "isReactWarning" in e && e.isReactWarning;
  return t ? n.ref : (e = (i = Object.getOwnPropertyDescriptor(n, "ref")) == null ? void 0 : i.get, t = e && "isReactWarning" in e && e.isReactWarning, t ? n.props.ref : n.props.ref || n.ref);
}
function Ih({
  prop: n,
  defaultProp: e,
  onChange: t = () => {
  }
}) {
  const [r, i] = Xhe({ defaultProp: e, onChange: t }), s = n !== void 0, l = s ? n : r, c = $o(t), d = M.useCallback(
    (h) => {
      if (s) {
        const y = typeof h == "function" ? h(n) : h;
        y !== n && c(y);
      } else
        i(h);
    },
    [s, n, i, c]
  );
  return [l, d];
}
function Xhe({
  defaultProp: n,
  onChange: e
}) {
  const t = M.useState(n), [r] = t, i = M.useRef(r), s = $o(e);
  return M.useEffect(() => {
    i.current !== r && (s(r), i.current = r);
  }, [r, i, s]), t;
}
var $M = "rovingFocusGroup.onEntryFocus", Zhe = { bubbles: !1, cancelable: !0 }, b_ = "RovingFocusGroup", [fD, uV, Qhe] = m_(b_), [Jhe, dV] = ju(
  b_,
  [Qhe]
), [epe, tpe] = Jhe(b_), fV = M.forwardRef(
  (n, e) => /* @__PURE__ */ m.jsx(fD.Provider, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ m.jsx(fD.Slot, { scope: n.__scopeRovingFocusGroup, children: /* @__PURE__ */ m.jsx(npe, { ...n, ref: e }) }) })
);
fV.displayName = b_;
var npe = M.forwardRef((n, e) => {
  const {
    __scopeRovingFocusGroup: t,
    orientation: r,
    loop: i = !1,
    dir: s,
    currentTabStopId: l,
    defaultCurrentTabStopId: c,
    onCurrentTabStopIdChange: d,
    onEntryFocus: h,
    preventScrollOnEntryFocus: g = !1,
    ...y
  } = n, v = M.useRef(null), w = jr(e, v), C = aj(s), [E = null, P] = Ih({
    prop: l,
    defaultProp: c,
    onChange: d
  }), [I, k] = M.useState(!1), L = $o(h), O = uV(t), z = M.useRef(!1), [F, H] = M.useState(0);
  return M.useEffect(() => {
    const V = v.current;
    if (V)
      return V.addEventListener($M, L), () => V.removeEventListener($M, L);
  }, [L]), /* @__PURE__ */ m.jsx(
    epe,
    {
      scope: t,
      orientation: r,
      dir: C,
      loop: i,
      currentTabStopId: E,
      onItemFocus: M.useCallback(
        (V) => P(V),
        [P]
      ),
      onItemShiftTab: M.useCallback(() => k(!0), []),
      onFocusableItemAdd: M.useCallback(
        () => H((V) => V + 1),
        []
      ),
      onFocusableItemRemove: M.useCallback(
        () => H((V) => V - 1),
        []
      ),
      children: /* @__PURE__ */ m.jsx(
        Wn.div,
        {
          tabIndex: I || F === 0 ? -1 : 0,
          "data-orientation": r,
          ...y,
          ref: w,
          style: { outline: "none", ...n.style },
          onMouseDown: bt(n.onMouseDown, () => {
            z.current = !0;
          }),
          onFocus: bt(n.onFocus, (V) => {
            const re = !z.current;
            if (V.target === V.currentTarget && re && !I) {
              const q = new CustomEvent($M, Zhe);
              if (V.currentTarget.dispatchEvent(q), !q.defaultPrevented) {
                const J = O().filter((le) => le.focusable), ie = J.find((le) => le.active), W = J.find((le) => le.id === E), oe = [ie, W, ...J].filter(
                  Boolean
                ).map((le) => le.ref.current);
                gV(oe, g);
              }
            }
            z.current = !1;
          }),
          onBlur: bt(n.onBlur, () => k(!1))
        }
      )
    }
  );
}), hV = "RovingFocusGroupItem", pV = M.forwardRef(
  (n, e) => {
    const {
      __scopeRovingFocusGroup: t,
      focusable: r = !0,
      active: i = !1,
      tabStopId: s,
      ...l
    } = n, c = $d(), d = s || c, h = tpe(hV, t), g = h.currentTabStopId === d, y = uV(t), { onFocusableItemAdd: v, onFocusableItemRemove: w } = h;
    return M.useEffect(() => {
      if (r)
        return v(), () => w();
    }, [r, v, w]), /* @__PURE__ */ m.jsx(
      fD.ItemSlot,
      {
        scope: t,
        id: d,
        focusable: r,
        active: i,
        children: /* @__PURE__ */ m.jsx(
          Wn.span,
          {
            tabIndex: g ? 0 : -1,
            "data-orientation": h.orientation,
            ...l,
            ref: e,
            onMouseDown: bt(n.onMouseDown, (C) => {
              r ? h.onItemFocus(d) : C.preventDefault();
            }),
            onFocus: bt(n.onFocus, () => h.onItemFocus(d)),
            onKeyDown: bt(n.onKeyDown, (C) => {
              if (C.key === "Tab" && C.shiftKey) {
                h.onItemShiftTab();
                return;
              }
              if (C.target !== C.currentTarget) return;
              const E = ope(C, h.orientation, h.dir);
              if (E !== void 0) {
                if (C.metaKey || C.ctrlKey || C.altKey || C.shiftKey) return;
                C.preventDefault();
                let I = y().filter((k) => k.focusable).map((k) => k.ref.current);
                if (E === "last") I.reverse();
                else if (E === "prev" || E === "next") {
                  E === "prev" && I.reverse();
                  const k = I.indexOf(C.currentTarget);
                  I = h.loop ? spe(I, k + 1) : I.slice(k + 1);
                }
                setTimeout(() => gV(I));
              }
            })
          }
        )
      }
    );
  }
);
pV.displayName = hV;
var rpe = {
  ArrowLeft: "prev",
  ArrowUp: "prev",
  ArrowRight: "next",
  ArrowDown: "next",
  PageUp: "first",
  Home: "first",
  PageDown: "last",
  End: "last"
};
function ipe(n, e) {
  return e !== "rtl" ? n : n === "ArrowLeft" ? "ArrowRight" : n === "ArrowRight" ? "ArrowLeft" : n;
}
function ope(n, e, t) {
  const r = ipe(n.key, t);
  if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(r)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(r)))
    return rpe[r];
}
function gV(n, e = !1) {
  const t = document.activeElement;
  for (const r of n)
    if (r === t || (r.focus({ preventScroll: e }), document.activeElement !== t)) return;
}
function spe(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
var ape = fV, lpe = pV, cpe = function(n) {
  if (typeof document > "u")
    return null;
  var e = Array.isArray(n) ? n[0] : n;
  return e.ownerDocument.body;
}, ly = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), Q1 = {}, BM = 0, mV = function(n) {
  return n && (n.host || mV(n.parentNode));
}, upe = function(n, e) {
  return e.map(function(t) {
    if (n.contains(t))
      return t;
    var r = mV(t);
    return r && n.contains(r) ? r : (console.error("aria-hidden", t, "in not contained inside", n, ". Doing nothing"), null);
  }).filter(function(t) {
    return !!t;
  });
}, dpe = function(n, e, t, r) {
  var i = upe(e, Array.isArray(n) ? n : [n]);
  Q1[t] || (Q1[t] = /* @__PURE__ */ new WeakMap());
  var s = Q1[t], l = [], c = /* @__PURE__ */ new Set(), d = new Set(i), h = function(y) {
    !y || c.has(y) || (c.add(y), h(y.parentNode));
  };
  i.forEach(h);
  var g = function(y) {
    !y || d.has(y) || Array.prototype.forEach.call(y.children, function(v) {
      if (c.has(v))
        g(v);
      else
        try {
          var w = v.getAttribute(r), C = w !== null && w !== "false", E = (ly.get(v) || 0) + 1, P = (s.get(v) || 0) + 1;
          ly.set(v, E), s.set(v, P), l.push(v), E === 1 && C && Z1.set(v, !0), P === 1 && v.setAttribute(t, "true"), C || v.setAttribute(r, "true");
        } catch (I) {
          console.error("aria-hidden: cannot operate on ", v, I);
        }
    });
  };
  return g(e), c.clear(), BM++, function() {
    l.forEach(function(y) {
      var v = ly.get(y) - 1, w = s.get(y) - 1;
      ly.set(y, v), s.set(y, w), v || (Z1.has(y) || y.removeAttribute(r), Z1.delete(y)), w || y.removeAttribute(t);
    }), BM--, BM || (ly = /* @__PURE__ */ new WeakMap(), ly = /* @__PURE__ */ new WeakMap(), Z1 = /* @__PURE__ */ new WeakMap(), Q1 = {});
  };
}, xj = function(n, e, t) {
  t === void 0 && (t = "data-aria-hidden");
  var r = Array.from(Array.isArray(n) ? n : [n]), i = cpe(n);
  return i ? (r.push.apply(r, Array.from(i.querySelectorAll("[aria-live]"))), dpe(r, i, t, "aria-hidden")) : function() {
    return null;
  };
}, yu = function() {
  return yu = Object.assign || function(e) {
    for (var t, r = 1, i = arguments.length; r < i; r++) {
      t = arguments[r];
      for (var s in t) Object.prototype.hasOwnProperty.call(t, s) && (e[s] = t[s]);
    }
    return e;
  }, yu.apply(this, arguments);
};
function yV(n, e) {
  var t = {};
  for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && e.indexOf(r) < 0 && (t[r] = n[r]);
  if (n != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, r = Object.getOwnPropertySymbols(n); i < r.length; i++)
      e.indexOf(r[i]) < 0 && Object.prototype.propertyIsEnumerable.call(n, r[i]) && (t[r[i]] = n[r[i]]);
  return t;
}
function fpe(n, e, t) {
  if (t || arguments.length === 2) for (var r = 0, i = e.length, s; r < i; r++)
    (s || !(r in e)) && (s || (s = Array.prototype.slice.call(e, 0, r)), s[r] = e[r]);
  return n.concat(s || Array.prototype.slice.call(e));
}
var _C = "right-scroll-bar-position", PC = "width-before-scroll-bar", hpe = "with-scroll-bars-hidden", ppe = "--removed-body-scroll-bar-size";
function HM(n, e) {
  return typeof n == "function" ? n(e) : n && (n.current = e), n;
}
function gpe(n, e) {
  var t = M.useState(function() {
    return {
      // value
      value: n,
      // last callback
      callback: e,
      // "memoized" public interface
      facade: {
        get current() {
          return t.value;
        },
        set current(r) {
          var i = t.value;
          i !== r && (t.value = r, t.callback(r, i));
        }
      }
    };
  })[0];
  return t.callback = e, t.facade;
}
var mpe = typeof window < "u" ? M.useLayoutEffect : M.useEffect, PU = /* @__PURE__ */ new WeakMap();
function ype(n, e) {
  var t = gpe(null, function(r) {
    return n.forEach(function(i) {
      return HM(i, r);
    });
  });
  return mpe(function() {
    var r = PU.get(t);
    if (r) {
      var i = new Set(r), s = new Set(n), l = t.current;
      i.forEach(function(c) {
        s.has(c) || HM(c, null);
      }), s.forEach(function(c) {
        i.has(c) || HM(c, l);
      });
    }
    PU.set(t, n);
  }, [n]), t;
}
function vpe(n) {
  return n;
}
function Spe(n, e) {
  e === void 0 && (e = vpe);
  var t = [], r = !1, i = {
    read: function() {
      if (r)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return t.length ? t[t.length - 1] : n;
    },
    useMedium: function(s) {
      var l = e(s, r);
      return t.push(l), function() {
        t = t.filter(function(c) {
          return c !== l;
        });
      };
    },
    assignSyncMedium: function(s) {
      for (r = !0; t.length; ) {
        var l = t;
        t = [], l.forEach(s);
      }
      t = {
        push: function(c) {
          return s(c);
        },
        filter: function() {
          return t;
        }
      };
    },
    assignMedium: function(s) {
      r = !0;
      var l = [];
      if (t.length) {
        var c = t;
        t = [], c.forEach(s), l = t;
      }
      var d = function() {
        var g = l;
        l = [], g.forEach(s);
      }, h = function() {
        return Promise.resolve().then(d);
      };
      h(), t = {
        push: function(g) {
          l.push(g), h();
        },
        filter: function(g) {
          return l = l.filter(g), t;
        }
      };
    }
  };
  return i;
}
function xpe(n) {
  n === void 0 && (n = {});
  var e = Spe(null);
  return e.options = yu({ async: !0, ssr: !1 }, n), e;
}
var vV = function(n) {
  var e = n.sideCar, t = yV(n, ["sideCar"]);
  if (!e)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var r = e.read();
  if (!r)
    throw new Error("Sidecar medium not found");
  return M.createElement(r, yu({}, t));
};
vV.isSideCarExport = !0;
function wpe(n, e) {
  return n.useMedium(e), vV;
}
var SV = xpe(), VM = function() {
}, C_ = M.forwardRef(function(n, e) {
  var t = M.useRef(null), r = M.useState({
    onScrollCapture: VM,
    onWheelCapture: VM,
    onTouchMoveCapture: VM
  }), i = r[0], s = r[1], l = n.forwardProps, c = n.children, d = n.className, h = n.removeScrollBar, g = n.enabled, y = n.shards, v = n.sideCar, w = n.noIsolation, C = n.inert, E = n.allowPinchZoom, P = n.as, I = P === void 0 ? "div" : P, k = n.gapMode, L = yV(n, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), O = v, z = ype([t, e]), F = yu(yu({}, L), i);
  return M.createElement(
    M.Fragment,
    null,
    g && M.createElement(O, { sideCar: SV, removeScrollBar: h, shards: y, noIsolation: w, inert: C, setCallbacks: s, allowPinchZoom: !!E, lockRef: t, gapMode: k }),
    l ? M.cloneElement(M.Children.only(c), yu(yu({}, F), { ref: z })) : M.createElement(I, yu({}, F, { className: d, ref: z }), c)
  );
});
C_.defaultProps = {
  enabled: !0,
  removeScrollBar: !0,
  inert: !1
};
C_.classNames = {
  fullWidth: PC,
  zeroRight: _C
};
var bpe = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Cpe() {
  if (!document)
    return null;
  var n = document.createElement("style");
  n.type = "text/css";
  var e = bpe();
  return e && n.setAttribute("nonce", e), n;
}
function Epe(n, e) {
  n.styleSheet ? n.styleSheet.cssText = e : n.appendChild(document.createTextNode(e));
}
function _pe(n) {
  var e = document.head || document.getElementsByTagName("head")[0];
  e.appendChild(n);
}
var Ppe = function() {
  var n = 0, e = null;
  return {
    add: function(t) {
      n == 0 && (e = Cpe()) && (Epe(e, t), _pe(e)), n++;
    },
    remove: function() {
      n--, !n && e && (e.parentNode && e.parentNode.removeChild(e), e = null);
    }
  };
}, Tpe = function() {
  var n = Ppe();
  return function(e, t) {
    M.useEffect(function() {
      return n.add(e), function() {
        n.remove();
      };
    }, [e && t]);
  };
}, xV = function() {
  var n = Tpe(), e = function(t) {
    var r = t.styles, i = t.dynamic;
    return n(r, i), null;
  };
  return e;
}, Ipe = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
}, KM = function(n) {
  return parseInt(n || "", 10) || 0;
}, kpe = function(n) {
  var e = window.getComputedStyle(document.body), t = e[n === "padding" ? "paddingLeft" : "marginLeft"], r = e[n === "padding" ? "paddingTop" : "marginTop"], i = e[n === "padding" ? "paddingRight" : "marginRight"];
  return [KM(t), KM(r), KM(i)];
}, Rpe = function(n) {
  if (n === void 0 && (n = "margin"), typeof window > "u")
    return Ipe;
  var e = kpe(n), t = document.documentElement.clientWidth, r = window.innerWidth;
  return {
    left: e[0],
    top: e[1],
    right: e[2],
    gap: Math.max(0, r - t + e[2] - e[0])
  };
}, Mpe = xV(), Iy = "data-scroll-locked", Ape = function(n, e, t, r) {
  var i = n.left, s = n.top, l = n.right, c = n.gap;
  return t === void 0 && (t = "margin"), `
  .`.concat(hpe, ` {
   overflow: hidden `).concat(r, `;
   padding-right: `).concat(c, "px ").concat(r, `;
  }
  body[`).concat(Iy, `] {
    overflow: hidden `).concat(r, `;
    overscroll-behavior: contain;
    `).concat([
    e && "position: relative ".concat(r, ";"),
    t === "margin" && `
    padding-left: `.concat(i, `px;
    padding-top: `).concat(s, `px;
    padding-right: `).concat(l, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(c, "px ").concat(r, `;
    `),
    t === "padding" && "padding-right: ".concat(c, "px ").concat(r, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(_C, ` {
    right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(PC, ` {
    margin-right: `).concat(c, "px ").concat(r, `;
  }
  
  .`).concat(_C, " .").concat(_C, ` {
    right: 0 `).concat(r, `;
  }
  
  .`).concat(PC, " .").concat(PC, ` {
    margin-right: 0 `).concat(r, `;
  }
  
  body[`).concat(Iy, `] {
    `).concat(ppe, ": ").concat(c, `px;
  }
`);
}, TU = function() {
  var n = parseInt(document.body.getAttribute(Iy) || "0", 10);
  return isFinite(n) ? n : 0;
}, Dpe = function() {
  M.useEffect(function() {
    return document.body.setAttribute(Iy, (TU() + 1).toString()), function() {
      var n = TU() - 1;
      n <= 0 ? document.body.removeAttribute(Iy) : document.body.setAttribute(Iy, n.toString());
    };
  }, []);
}, Ope = function(n) {
  var e = n.noRelative, t = n.noImportant, r = n.gapMode, i = r === void 0 ? "margin" : r;
  Dpe();
  var s = M.useMemo(function() {
    return Rpe(i);
  }, [i]);
  return M.createElement(Mpe, { styles: Ape(s, !e, i, t ? "" : "!important") });
}, hD = !1;
if (typeof window < "u")
  try {
    var J1 = Object.defineProperty({}, "passive", {
      get: function() {
        return hD = !0, !0;
      }
    });
    window.addEventListener("test", J1, J1), window.removeEventListener("test", J1, J1);
  } catch {
    hD = !1;
  }
var cy = hD ? { passive: !1 } : !1, jpe = function(n) {
  return n.tagName === "TEXTAREA";
}, wV = function(n, e) {
  if (!(n instanceof Element))
    return !1;
  var t = window.getComputedStyle(n);
  return (
    // not-not-scrollable
    t[e] !== "hidden" && // contains scroll inside self
    !(t.overflowY === t.overflowX && !jpe(n) && t[e] === "visible")
  );
}, Lpe = function(n) {
  return wV(n, "overflowY");
}, Npe = function(n) {
  return wV(n, "overflowX");
}, IU = function(n, e) {
  var t = e.ownerDocument, r = e;
  do {
    typeof ShadowRoot < "u" && r instanceof ShadowRoot && (r = r.host);
    var i = bV(n, r);
    if (i) {
      var s = CV(n, r), l = s[1], c = s[2];
      if (l > c)
        return !0;
    }
    r = r.parentNode;
  } while (r && r !== t.body);
  return !1;
}, Fpe = function(n) {
  var e = n.scrollTop, t = n.scrollHeight, r = n.clientHeight;
  return [
    e,
    t,
    r
  ];
}, zpe = function(n) {
  var e = n.scrollLeft, t = n.scrollWidth, r = n.clientWidth;
  return [
    e,
    t,
    r
  ];
}, bV = function(n, e) {
  return n === "v" ? Lpe(e) : Npe(e);
}, CV = function(n, e) {
  return n === "v" ? Fpe(e) : zpe(e);
}, Upe = function(n, e) {
  return n === "h" && e === "rtl" ? -1 : 1;
}, $pe = function(n, e, t, r, i) {
  var s = Upe(n, window.getComputedStyle(e).direction), l = s * r, c = t.target, d = e.contains(c), h = !1, g = l > 0, y = 0, v = 0;
  do {
    var w = CV(n, c), C = w[0], E = w[1], P = w[2], I = E - P - s * C;
    (C || I) && bV(n, c) && (y += I, v += C), c instanceof ShadowRoot ? c = c.host : c = c.parentNode;
  } while (
    // portaled content
    !d && c !== document.body || // self content
    d && (e.contains(c) || e === c)
  );
  return (g && Math.abs(y) < 1 || !g && Math.abs(v) < 1) && (h = !0), h;
}, eC = function(n) {
  return "changedTouches" in n ? [n.changedTouches[0].clientX, n.changedTouches[0].clientY] : [0, 0];
}, kU = function(n) {
  return [n.deltaX, n.deltaY];
}, RU = function(n) {
  return n && "current" in n ? n.current : n;
}, Bpe = function(n, e) {
  return n[0] === e[0] && n[1] === e[1];
}, Hpe = function(n) {
  return `
  .block-interactivity-`.concat(n, ` {pointer-events: none;}
  .allow-interactivity-`).concat(n, ` {pointer-events: all;}
`);
}, Vpe = 0, uy = [];
function Kpe(n) {
  var e = M.useRef([]), t = M.useRef([0, 0]), r = M.useRef(), i = M.useState(Vpe++)[0], s = M.useState(xV)[0], l = M.useRef(n);
  M.useEffect(function() {
    l.current = n;
  }, [n]), M.useEffect(function() {
    if (n.inert) {
      document.body.classList.add("block-interactivity-".concat(i));
      var E = fpe([n.lockRef.current], (n.shards || []).map(RU), !0).filter(Boolean);
      return E.forEach(function(P) {
        return P.classList.add("allow-interactivity-".concat(i));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(i)), E.forEach(function(P) {
          return P.classList.remove("allow-interactivity-".concat(i));
        });
      };
    }
  }, [n.inert, n.lockRef.current, n.shards]);
  var c = M.useCallback(function(E, P) {
    if ("touches" in E && E.touches.length === 2 || E.type === "wheel" && E.ctrlKey)
      return !l.current.allowPinchZoom;
    var I = eC(E), k = t.current, L = "deltaX" in E ? E.deltaX : k[0] - I[0], O = "deltaY" in E ? E.deltaY : k[1] - I[1], z, F = E.target, H = Math.abs(L) > Math.abs(O) ? "h" : "v";
    if ("touches" in E && H === "h" && F.type === "range")
      return !1;
    var V = IU(H, F);
    if (!V)
      return !0;
    if (V ? z = H : (z = H === "v" ? "h" : "v", V = IU(H, F)), !V)
      return !1;
    if (!r.current && "changedTouches" in E && (L || O) && (r.current = z), !z)
      return !0;
    var re = r.current || z;
    return $pe(re, P, E, re === "h" ? L : O);
  }, []), d = M.useCallback(function(E) {
    var P = E;
    if (!(!uy.length || uy[uy.length - 1] !== s)) {
      var I = "deltaY" in P ? kU(P) : eC(P), k = e.current.filter(function(z) {
        return z.name === P.type && (z.target === P.target || P.target === z.shadowParent) && Bpe(z.delta, I);
      })[0];
      if (k && k.should) {
        P.cancelable && P.preventDefault();
        return;
      }
      if (!k) {
        var L = (l.current.shards || []).map(RU).filter(Boolean).filter(function(z) {
          return z.contains(P.target);
        }), O = L.length > 0 ? c(P, L[0]) : !l.current.noIsolation;
        O && P.cancelable && P.preventDefault();
      }
    }
  }, []), h = M.useCallback(function(E, P, I, k) {
    var L = { name: E, delta: P, target: I, should: k, shadowParent: Wpe(I) };
    e.current.push(L), setTimeout(function() {
      e.current = e.current.filter(function(O) {
        return O !== L;
      });
    }, 1);
  }, []), g = M.useCallback(function(E) {
    t.current = eC(E), r.current = void 0;
  }, []), y = M.useCallback(function(E) {
    h(E.type, kU(E), E.target, c(E, n.lockRef.current));
  }, []), v = M.useCallback(function(E) {
    h(E.type, eC(E), E.target, c(E, n.lockRef.current));
  }, []);
  M.useEffect(function() {
    return uy.push(s), n.setCallbacks({
      onScrollCapture: y,
      onWheelCapture: y,
      onTouchMoveCapture: v
    }), document.addEventListener("wheel", d, cy), document.addEventListener("touchmove", d, cy), document.addEventListener("touchstart", g, cy), function() {
      uy = uy.filter(function(E) {
        return E !== s;
      }), document.removeEventListener("wheel", d, cy), document.removeEventListener("touchmove", d, cy), document.removeEventListener("touchstart", g, cy);
    };
  }, []);
  var w = n.removeScrollBar, C = n.inert;
  return M.createElement(
    M.Fragment,
    null,
    C ? M.createElement(s, { styles: Hpe(i) }) : null,
    w ? M.createElement(Ope, { gapMode: n.gapMode }) : null
  );
}
function Wpe(n) {
  for (var e = null; n !== null; )
    n instanceof ShadowRoot && (e = n.host, n = n.host), n = n.parentNode;
  return e;
}
const Gpe = wpe(SV, Kpe);
var E_ = M.forwardRef(function(n, e) {
  return M.createElement(C_, yu({}, n, { ref: e, sideCar: Gpe }));
});
E_.classNames = C_.classNames;
var pD = ["Enter", " "], qpe = ["ArrowDown", "PageUp", "Home"], EV = ["ArrowUp", "PageDown", "End"], Ype = [...qpe, ...EV], Xpe = {
  ltr: [...pD, "ArrowRight"],
  rtl: [...pD, "ArrowLeft"]
}, Zpe = {
  ltr: ["ArrowLeft"],
  rtl: ["ArrowRight"]
}, Rw = "Menu", [ew, Qpe, Jpe] = m_(Rw), [pg, __] = ju(Rw, [
  Jpe,
  w_,
  dV
]), Mw = w_(), _V = dV(), [PV, kh] = pg(Rw), [ege, Aw] = pg(Rw), TV = (n) => {
  const { __scopeMenu: e, open: t = !1, children: r, dir: i, onOpenChange: s, modal: l = !0 } = n, c = Mw(e), [d, h] = M.useState(null), g = M.useRef(!1), y = $o(s), v = aj(i);
  return M.useEffect(() => {
    const w = () => {
      g.current = !0, document.addEventListener("pointerdown", C, { capture: !0, once: !0 }), document.addEventListener("pointermove", C, { capture: !0, once: !0 });
    }, C = () => g.current = !1;
    return document.addEventListener("keydown", w, { capture: !0 }), () => {
      document.removeEventListener("keydown", w, { capture: !0 }), document.removeEventListener("pointerdown", C, { capture: !0 }), document.removeEventListener("pointermove", C, { capture: !0 });
    };
  }, []), /* @__PURE__ */ m.jsx(vj, { ...c, children: /* @__PURE__ */ m.jsx(
    PV,
    {
      scope: e,
      open: t,
      onOpenChange: y,
      content: d,
      onContentChange: h,
      children: /* @__PURE__ */ m.jsx(
        ege,
        {
          scope: e,
          onClose: M.useCallback(() => y(!1), [y]),
          isUsingKeyboardRef: g,
          dir: v,
          modal: l,
          children: r
        }
      )
    }
  ) });
};
TV.displayName = Rw;
var tge = "MenuAnchor", wj = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, ...r } = n, i = Mw(t);
    return /* @__PURE__ */ m.jsx(Sj, { ...i, ...r, ref: e });
  }
);
wj.displayName = tge;
var bj = "MenuPortal", [nge, IV] = pg(bj, {
  forceMount: void 0
}), kV = (n) => {
  const { __scopeMenu: e, forceMount: t, children: r, container: i } = n, s = kh(bj, e);
  return /* @__PURE__ */ m.jsx(nge, { scope: e, forceMount: t, children: /* @__PURE__ */ m.jsx(kc, { present: t || s.open, children: /* @__PURE__ */ m.jsx(kw, { asChild: !0, container: i, children: r }) }) });
};
kV.displayName = bj;
var Ol = "MenuContent", [rge, Cj] = pg(Ol), RV = M.forwardRef(
  (n, e) => {
    const t = IV(Ol, n.__scopeMenu), { forceMount: r = t.forceMount, ...i } = n, s = kh(Ol, n.__scopeMenu), l = Aw(Ol, n.__scopeMenu);
    return /* @__PURE__ */ m.jsx(ew.Provider, { scope: n.__scopeMenu, children: /* @__PURE__ */ m.jsx(kc, { present: r || s.open, children: /* @__PURE__ */ m.jsx(ew.Slot, { scope: n.__scopeMenu, children: l.modal ? /* @__PURE__ */ m.jsx(ige, { ...i, ref: e }) : /* @__PURE__ */ m.jsx(oge, { ...i, ref: e }) }) }) });
  }
), ige = M.forwardRef(
  (n, e) => {
    const t = kh(Ol, n.__scopeMenu), r = M.useRef(null), i = jr(e, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return xj(s);
    }, []), /* @__PURE__ */ m.jsx(
      Ej,
      {
        ...n,
        ref: i,
        trapFocus: t.open,
        disableOutsidePointerEvents: t.open,
        disableOutsideScroll: !0,
        onFocusOutside: bt(
          n.onFocusOutside,
          (s) => s.preventDefault(),
          { checkForDefaultPrevented: !1 }
        ),
        onDismiss: () => t.onOpenChange(!1)
      }
    );
  }
), oge = M.forwardRef((n, e) => {
  const t = kh(Ol, n.__scopeMenu);
  return /* @__PURE__ */ m.jsx(
    Ej,
    {
      ...n,
      ref: e,
      trapFocus: !1,
      disableOutsidePointerEvents: !1,
      disableOutsideScroll: !1,
      onDismiss: () => t.onOpenChange(!1)
    }
  );
}), Ej = M.forwardRef(
  (n, e) => {
    const {
      __scopeMenu: t,
      loop: r = !1,
      trapFocus: i,
      onOpenAutoFocus: s,
      onCloseAutoFocus: l,
      disableOutsidePointerEvents: c,
      onEntryFocus: d,
      onEscapeKeyDown: h,
      onPointerDownOutside: g,
      onFocusOutside: y,
      onInteractOutside: v,
      onDismiss: w,
      disableOutsideScroll: C,
      ...E
    } = n, P = kh(Ol, t), I = Aw(Ol, t), k = Mw(t), L = _V(t), O = Qpe(t), [z, F] = M.useState(null), H = M.useRef(null), V = jr(e, H, P.onContentChange), re = M.useRef(0), q = M.useRef(""), J = M.useRef(0), ie = M.useRef(null), W = M.useRef("right"), Y = M.useRef(0), oe = C ? E_ : M.Fragment, le = C ? { as: ng, allowPinchZoom: !0 } : void 0, ce = (he) => {
      var it, We;
      const ke = q.current + he, te = O().filter((Qe) => !Qe.disabled), me = document.activeElement, Oe = (it = te.find((Qe) => Qe.ref.current === me)) == null ? void 0 : it.textValue, Ze = te.map((Qe) => Qe.textValue), De = yge(Ze, ke, Oe), yt = (We = te.find((Qe) => Qe.textValue === De)) == null ? void 0 : We.ref.current;
      (function Qe(gt) {
        q.current = gt, window.clearTimeout(re.current), gt !== "" && (re.current = window.setTimeout(() => Qe(""), 1e3));
      })(ke), yt && setTimeout(() => yt.focus());
    };
    M.useEffect(() => () => window.clearTimeout(re.current), []), lj();
    const Q = M.useCallback((he) => {
      var te, me;
      return W.current === ((te = ie.current) == null ? void 0 : te.side) && Sge(he, (me = ie.current) == null ? void 0 : me.area);
    }, []);
    return /* @__PURE__ */ m.jsx(
      rge,
      {
        scope: t,
        searchRef: q,
        onItemEnter: M.useCallback(
          (he) => {
            Q(he) && he.preventDefault();
          },
          [Q]
        ),
        onItemLeave: M.useCallback(
          (he) => {
            var ke;
            Q(he) || ((ke = H.current) == null || ke.focus(), F(null));
          },
          [Q]
        ),
        onTriggerLeave: M.useCallback(
          (he) => {
            Q(he) && he.preventDefault();
          },
          [Q]
        ),
        pointerGraceTimerRef: J,
        onPointerGraceIntentChange: M.useCallback((he) => {
          ie.current = he;
        }, []),
        children: /* @__PURE__ */ m.jsx(oe, { ...le, children: /* @__PURE__ */ m.jsx(
          y_,
          {
            asChild: !0,
            trapped: i,
            onMountAutoFocus: bt(s, (he) => {
              var ke;
              he.preventDefault(), (ke = H.current) == null || ke.focus({ preventScroll: !0 });
            }),
            onUnmountAutoFocus: l,
            children: /* @__PURE__ */ m.jsx(
              Tw,
              {
                asChild: !0,
                disableOutsidePointerEvents: c,
                onEscapeKeyDown: h,
                onPointerDownOutside: g,
                onFocusOutside: y,
                onInteractOutside: v,
                onDismiss: w,
                children: /* @__PURE__ */ m.jsx(
                  ape,
                  {
                    asChild: !0,
                    ...L,
                    dir: I.dir,
                    orientation: "vertical",
                    loop: r,
                    currentTabStopId: z,
                    onCurrentTabStopIdChange: F,
                    onEntryFocus: bt(d, (he) => {
                      I.isUsingKeyboardRef.current || he.preventDefault();
                    }),
                    preventScrollOnEntryFocus: !0,
                    children: /* @__PURE__ */ m.jsx(
                      lV,
                      {
                        role: "menu",
                        "aria-orientation": "vertical",
                        "data-state": GV(P.open),
                        "data-radix-menu-content": "",
                        dir: I.dir,
                        ...k,
                        ...E,
                        ref: V,
                        style: { outline: "none", ...E.style },
                        onKeyDown: bt(E.onKeyDown, (he) => {
                          const te = he.target.closest("[data-radix-menu-content]") === he.currentTarget, me = he.ctrlKey || he.altKey || he.metaKey, Oe = he.key.length === 1;
                          te && (he.key === "Tab" && he.preventDefault(), !me && Oe && ce(he.key));
                          const Ze = H.current;
                          if (he.target !== Ze || !Ype.includes(he.key)) return;
                          he.preventDefault();
                          const yt = O().filter((it) => !it.disabled).map((it) => it.ref.current);
                          EV.includes(he.key) && yt.reverse(), gge(yt);
                        }),
                        onBlur: bt(n.onBlur, (he) => {
                          he.currentTarget.contains(he.target) || (window.clearTimeout(re.current), q.current = "");
                        }),
                        onPointerMove: bt(
                          n.onPointerMove,
                          tw((he) => {
                            const ke = he.target, te = Y.current !== he.clientX;
                            if (he.currentTarget.contains(ke) && te) {
                              const me = he.clientX > Y.current ? "right" : "left";
                              W.current = me, Y.current = he.clientX;
                            }
                          })
                        )
                      }
                    )
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
RV.displayName = Ol;
var sge = "MenuGroup", _j = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, ...r } = n;
    return /* @__PURE__ */ m.jsx(Wn.div, { role: "group", ...r, ref: e });
  }
);
_j.displayName = sge;
var age = "MenuLabel", MV = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, ...r } = n;
    return /* @__PURE__ */ m.jsx(Wn.div, { ...r, ref: e });
  }
);
MV.displayName = age;
var EE = "MenuItem", MU = "menu.itemSelect", P_ = M.forwardRef(
  (n, e) => {
    const { disabled: t = !1, onSelect: r, ...i } = n, s = M.useRef(null), l = Aw(EE, n.__scopeMenu), c = Cj(EE, n.__scopeMenu), d = jr(e, s), h = M.useRef(!1), g = () => {
      const y = s.current;
      if (!t && y) {
        const v = new CustomEvent(MU, { bubbles: !0, cancelable: !0 });
        y.addEventListener(MU, (w) => r == null ? void 0 : r(w), { once: !0 }), sj(y, v), v.defaultPrevented ? h.current = !1 : l.onClose();
      }
    };
    return /* @__PURE__ */ m.jsx(
      AV,
      {
        ...i,
        ref: d,
        disabled: t,
        onClick: bt(n.onClick, g),
        onPointerDown: (y) => {
          var v;
          (v = n.onPointerDown) == null || v.call(n, y), h.current = !0;
        },
        onPointerUp: bt(n.onPointerUp, (y) => {
          var v;
          h.current || (v = y.currentTarget) == null || v.click();
        }),
        onKeyDown: bt(n.onKeyDown, (y) => {
          const v = c.searchRef.current !== "";
          t || v && y.key === " " || pD.includes(y.key) && (y.currentTarget.click(), y.preventDefault());
        })
      }
    );
  }
);
P_.displayName = EE;
var AV = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, disabled: r = !1, textValue: i, ...s } = n, l = Cj(EE, t), c = _V(t), d = M.useRef(null), h = jr(e, d), [g, y] = M.useState(!1), [v, w] = M.useState("");
    return M.useEffect(() => {
      const C = d.current;
      C && w((C.textContent ?? "").trim());
    }, [s.children]), /* @__PURE__ */ m.jsx(
      ew.ItemSlot,
      {
        scope: t,
        disabled: r,
        textValue: i ?? v,
        children: /* @__PURE__ */ m.jsx(lpe, { asChild: !0, ...c, focusable: !r, children: /* @__PURE__ */ m.jsx(
          Wn.div,
          {
            role: "menuitem",
            "data-highlighted": g ? "" : void 0,
            "aria-disabled": r || void 0,
            "data-disabled": r ? "" : void 0,
            ...s,
            ref: h,
            onPointerMove: bt(
              n.onPointerMove,
              tw((C) => {
                r ? l.onItemLeave(C) : (l.onItemEnter(C), C.defaultPrevented || C.currentTarget.focus({ preventScroll: !0 }));
              })
            ),
            onPointerLeave: bt(
              n.onPointerLeave,
              tw((C) => l.onItemLeave(C))
            ),
            onFocus: bt(n.onFocus, () => y(!0)),
            onBlur: bt(n.onBlur, () => y(!1))
          }
        ) })
      }
    );
  }
), lge = "MenuCheckboxItem", DV = M.forwardRef(
  (n, e) => {
    const { checked: t = !1, onCheckedChange: r, ...i } = n;
    return /* @__PURE__ */ m.jsx(FV, { scope: n.__scopeMenu, checked: t, children: /* @__PURE__ */ m.jsx(
      P_,
      {
        role: "menuitemcheckbox",
        "aria-checked": _E(t) ? "mixed" : t,
        ...i,
        ref: e,
        "data-state": Ij(t),
        onSelect: bt(
          i.onSelect,
          () => r == null ? void 0 : r(_E(t) ? !0 : !t),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
DV.displayName = lge;
var OV = "MenuRadioGroup", [cge, uge] = pg(
  OV,
  { value: void 0, onValueChange: () => {
  } }
), jV = M.forwardRef(
  (n, e) => {
    const { value: t, onValueChange: r, ...i } = n, s = $o(r);
    return /* @__PURE__ */ m.jsx(cge, { scope: n.__scopeMenu, value: t, onValueChange: s, children: /* @__PURE__ */ m.jsx(_j, { ...i, ref: e }) });
  }
);
jV.displayName = OV;
var LV = "MenuRadioItem", NV = M.forwardRef(
  (n, e) => {
    const { value: t, ...r } = n, i = uge(LV, n.__scopeMenu), s = t === i.value;
    return /* @__PURE__ */ m.jsx(FV, { scope: n.__scopeMenu, checked: s, children: /* @__PURE__ */ m.jsx(
      P_,
      {
        role: "menuitemradio",
        "aria-checked": s,
        ...r,
        ref: e,
        "data-state": Ij(s),
        onSelect: bt(
          r.onSelect,
          () => {
            var l;
            return (l = i.onValueChange) == null ? void 0 : l.call(i, t);
          },
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
);
NV.displayName = LV;
var Pj = "MenuItemIndicator", [FV, dge] = pg(
  Pj,
  { checked: !1 }
), zV = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, forceMount: r, ...i } = n, s = dge(Pj, t);
    return /* @__PURE__ */ m.jsx(
      kc,
      {
        present: r || _E(s.checked) || s.checked === !0,
        children: /* @__PURE__ */ m.jsx(
          Wn.span,
          {
            ...i,
            ref: e,
            "data-state": Ij(s.checked)
          }
        )
      }
    );
  }
);
zV.displayName = Pj;
var fge = "MenuSeparator", UV = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, ...r } = n;
    return /* @__PURE__ */ m.jsx(
      Wn.div,
      {
        role: "separator",
        "aria-orientation": "horizontal",
        ...r,
        ref: e
      }
    );
  }
);
UV.displayName = fge;
var hge = "MenuArrow", $V = M.forwardRef(
  (n, e) => {
    const { __scopeMenu: t, ...r } = n, i = Mw(t);
    return /* @__PURE__ */ m.jsx(cV, { ...i, ...r, ref: e });
  }
);
$V.displayName = hge;
var Tj = "MenuSub", [pge, BV] = pg(Tj), HV = (n) => {
  const { __scopeMenu: e, children: t, open: r = !1, onOpenChange: i } = n, s = kh(Tj, e), l = Mw(e), [c, d] = M.useState(null), [h, g] = M.useState(null), y = $o(i);
  return M.useEffect(() => (s.open === !1 && y(!1), () => y(!1)), [s.open, y]), /* @__PURE__ */ m.jsx(vj, { ...l, children: /* @__PURE__ */ m.jsx(
    PV,
    {
      scope: e,
      open: r,
      onOpenChange: y,
      content: h,
      onContentChange: g,
      children: /* @__PURE__ */ m.jsx(
        pge,
        {
          scope: e,
          contentId: $d(),
          triggerId: $d(),
          trigger: c,
          onTriggerChange: d,
          children: t
        }
      )
    }
  ) });
};
HV.displayName = Tj;
var _x = "MenuSubTrigger", VV = M.forwardRef(
  (n, e) => {
    const t = kh(_x, n.__scopeMenu), r = Aw(_x, n.__scopeMenu), i = BV(_x, n.__scopeMenu), s = Cj(_x, n.__scopeMenu), l = M.useRef(null), { pointerGraceTimerRef: c, onPointerGraceIntentChange: d } = s, h = { __scopeMenu: n.__scopeMenu }, g = M.useCallback(() => {
      l.current && window.clearTimeout(l.current), l.current = null;
    }, []);
    return M.useEffect(() => g, [g]), M.useEffect(() => {
      const y = c.current;
      return () => {
        window.clearTimeout(y), d(null);
      };
    }, [c, d]), /* @__PURE__ */ m.jsx(wj, { asChild: !0, ...h, children: /* @__PURE__ */ m.jsx(
      AV,
      {
        id: i.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": t.open,
        "aria-controls": i.contentId,
        "data-state": GV(t.open),
        ...n,
        ref: g_(e, i.onTriggerChange),
        onClick: (y) => {
          var v;
          (v = n.onClick) == null || v.call(n, y), !(n.disabled || y.defaultPrevented) && (y.currentTarget.focus(), t.open || t.onOpenChange(!0));
        },
        onPointerMove: bt(
          n.onPointerMove,
          tw((y) => {
            s.onItemEnter(y), !y.defaultPrevented && !n.disabled && !t.open && !l.current && (s.onPointerGraceIntentChange(null), l.current = window.setTimeout(() => {
              t.onOpenChange(!0), g();
            }, 100));
          })
        ),
        onPointerLeave: bt(
          n.onPointerLeave,
          tw((y) => {
            var w, C;
            g();
            const v = (w = t.content) == null ? void 0 : w.getBoundingClientRect();
            if (v) {
              const E = (C = t.content) == null ? void 0 : C.dataset.side, P = E === "right", I = P ? -5 : 5, k = v[P ? "left" : "right"], L = v[P ? "right" : "left"];
              s.onPointerGraceIntentChange({
                area: [
                  // Apply a bleed on clientX to ensure that our exit point is
                  // consistently within polygon bounds
                  { x: y.clientX + I, y: y.clientY },
                  { x: k, y: v.top },
                  { x: L, y: v.top },
                  { x: L, y: v.bottom },
                  { x: k, y: v.bottom }
                ],
                side: E
              }), window.clearTimeout(c.current), c.current = window.setTimeout(
                () => s.onPointerGraceIntentChange(null),
                300
              );
            } else {
              if (s.onTriggerLeave(y), y.defaultPrevented) return;
              s.onPointerGraceIntentChange(null);
            }
          })
        ),
        onKeyDown: bt(n.onKeyDown, (y) => {
          var w;
          const v = s.searchRef.current !== "";
          n.disabled || v && y.key === " " || Xpe[r.dir].includes(y.key) && (t.onOpenChange(!0), (w = t.content) == null || w.focus(), y.preventDefault());
        })
      }
    ) });
  }
);
VV.displayName = _x;
var KV = "MenuSubContent", WV = M.forwardRef(
  (n, e) => {
    const t = IV(Ol, n.__scopeMenu), { forceMount: r = t.forceMount, ...i } = n, s = kh(Ol, n.__scopeMenu), l = Aw(Ol, n.__scopeMenu), c = BV(KV, n.__scopeMenu), d = M.useRef(null), h = jr(e, d);
    return /* @__PURE__ */ m.jsx(ew.Provider, { scope: n.__scopeMenu, children: /* @__PURE__ */ m.jsx(kc, { present: r || s.open, children: /* @__PURE__ */ m.jsx(ew.Slot, { scope: n.__scopeMenu, children: /* @__PURE__ */ m.jsx(
      Ej,
      {
        id: c.contentId,
        "aria-labelledby": c.triggerId,
        ...i,
        ref: h,
        align: "start",
        side: l.dir === "rtl" ? "left" : "right",
        disableOutsidePointerEvents: !1,
        disableOutsideScroll: !1,
        trapFocus: !1,
        onOpenAutoFocus: (g) => {
          var y;
          l.isUsingKeyboardRef.current && ((y = d.current) == null || y.focus()), g.preventDefault();
        },
        onCloseAutoFocus: (g) => g.preventDefault(),
        onFocusOutside: bt(n.onFocusOutside, (g) => {
          g.target !== c.trigger && s.onOpenChange(!1);
        }),
        onEscapeKeyDown: bt(n.onEscapeKeyDown, (g) => {
          l.onClose(), g.preventDefault();
        }),
        onKeyDown: bt(n.onKeyDown, (g) => {
          var w;
          const y = g.currentTarget.contains(g.target), v = Zpe[l.dir].includes(g.key);
          y && v && (s.onOpenChange(!1), (w = c.trigger) == null || w.focus(), g.preventDefault());
        })
      }
    ) }) }) });
  }
);
WV.displayName = KV;
function GV(n) {
  return n ? "open" : "closed";
}
function _E(n) {
  return n === "indeterminate";
}
function Ij(n) {
  return _E(n) ? "indeterminate" : n ? "checked" : "unchecked";
}
function gge(n) {
  const e = document.activeElement;
  for (const t of n)
    if (t === e || (t.focus(), document.activeElement !== e)) return;
}
function mge(n, e) {
  return n.map((t, r) => n[(e + r) % n.length]);
}
function yge(n, e, t) {
  const i = e.length > 1 && Array.from(e).every((h) => h === e[0]) ? e[0] : e, s = t ? n.indexOf(t) : -1;
  let l = mge(n, Math.max(s, 0));
  i.length === 1 && (l = l.filter((h) => h !== t));
  const d = l.find(
    (h) => h.toLowerCase().startsWith(i.toLowerCase())
  );
  return d !== t ? d : void 0;
}
function vge(n, e) {
  const { x: t, y: r } = n;
  let i = !1;
  for (let s = 0, l = e.length - 1; s < e.length; l = s++) {
    const c = e[s].x, d = e[s].y, h = e[l].x, g = e[l].y;
    d > r != g > r && t < (h - c) * (r - d) / (g - d) + c && (i = !i);
  }
  return i;
}
function Sge(n, e) {
  if (!e) return !1;
  const t = { x: n.clientX, y: n.clientY };
  return vge(t, e);
}
function tw(n) {
  return (e) => e.pointerType === "mouse" ? n(e) : void 0;
}
var qV = TV, YV = wj, XV = kV, ZV = RV, QV = _j, JV = MV, eK = P_, tK = DV, nK = jV, rK = NV, iK = zV, oK = UV, sK = $V, aK = HV, lK = VV, cK = WV, kj = "ContextMenu", [xge, fEe] = ju(kj, [
  __
]), ws = __(), [wge, uK] = xge(kj), dK = (n) => {
  const { __scopeContextMenu: e, children: t, onOpenChange: r, dir: i, modal: s = !0 } = n, [l, c] = M.useState(!1), d = ws(e), h = $o(r), g = M.useCallback(
    (y) => {
      c(y), h(y);
    },
    [h]
  );
  return /* @__PURE__ */ m.jsx(
    wge,
    {
      scope: e,
      open: l,
      onOpenChange: g,
      modal: s,
      children: /* @__PURE__ */ m.jsx(
        qV,
        {
          ...d,
          dir: i,
          open: l,
          onOpenChange: g,
          modal: s,
          children: t
        }
      )
    }
  );
};
dK.displayName = kj;
var fK = "ContextMenuTrigger", hK = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, disabled: r = !1, ...i } = n, s = uK(fK, t), l = ws(t), c = M.useRef({ x: 0, y: 0 }), d = M.useRef({
      getBoundingClientRect: () => DOMRect.fromRect({ width: 0, height: 0, ...c.current })
    }), h = M.useRef(0), g = M.useCallback(
      () => window.clearTimeout(h.current),
      []
    ), y = (v) => {
      c.current = { x: v.clientX, y: v.clientY }, s.onOpenChange(!0);
    };
    return M.useEffect(() => g, [g]), M.useEffect(() => void (r && g()), [r, g]), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(YV, { ...l, virtualRef: d }),
      /* @__PURE__ */ m.jsx(
        Wn.span,
        {
          "data-state": s.open ? "open" : "closed",
          "data-disabled": r ? "" : void 0,
          ...i,
          ref: e,
          style: { WebkitTouchCallout: "none", ...n.style },
          onContextMenu: r ? n.onContextMenu : bt(n.onContextMenu, (v) => {
            g(), y(v), v.preventDefault();
          }),
          onPointerDown: r ? n.onPointerDown : bt(
            n.onPointerDown,
            tC((v) => {
              g(), h.current = window.setTimeout(() => y(v), 700);
            })
          ),
          onPointerMove: r ? n.onPointerMove : bt(n.onPointerMove, tC(g)),
          onPointerCancel: r ? n.onPointerCancel : bt(n.onPointerCancel, tC(g)),
          onPointerUp: r ? n.onPointerUp : bt(n.onPointerUp, tC(g))
        }
      )
    ] });
  }
);
hK.displayName = fK;
var bge = "ContextMenuPortal", Rj = (n) => {
  const { __scopeContextMenu: e, ...t } = n, r = ws(e);
  return /* @__PURE__ */ m.jsx(XV, { ...r, ...t });
};
Rj.displayName = bge;
var pK = "ContextMenuContent", gK = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, ...r } = n, i = uK(pK, t), s = ws(t), l = M.useRef(!1);
    return /* @__PURE__ */ m.jsx(
      ZV,
      {
        ...s,
        ...r,
        ref: e,
        side: "right",
        sideOffset: 2,
        align: "start",
        onCloseAutoFocus: (c) => {
          var d;
          (d = n.onCloseAutoFocus) == null || d.call(n, c), !c.defaultPrevented && l.current && c.preventDefault(), l.current = !1;
        },
        onInteractOutside: (c) => {
          var d;
          (d = n.onInteractOutside) == null || d.call(n, c), !c.defaultPrevented && !i.modal && (l.current = !0);
        },
        style: {
          ...n.style,
          "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
gK.displayName = pK;
var Cge = "ContextMenuGroup", mK = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, ...r } = n, i = ws(t);
    return /* @__PURE__ */ m.jsx(QV, { ...i, ...r, ref: e });
  }
);
mK.displayName = Cge;
var Ege = "ContextMenuLabel", _ge = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, ...r } = n, i = ws(t);
    return /* @__PURE__ */ m.jsx(JV, { ...i, ...r, ref: e });
  }
);
_ge.displayName = Ege;
var Pge = "ContextMenuItem", yK = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, ...r } = n, i = ws(t);
    return /* @__PURE__ */ m.jsx(eK, { ...i, ...r, ref: e });
  }
);
yK.displayName = Pge;
var Tge = "ContextMenuCheckboxItem", vK = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(tK, { ...i, ...r, ref: e });
});
vK.displayName = Tge;
var Ige = "ContextMenuRadioGroup", kge = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(nK, { ...i, ...r, ref: e });
});
kge.displayName = Ige;
var Rge = "ContextMenuRadioItem", Mge = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(rK, { ...i, ...r, ref: e });
});
Mge.displayName = Rge;
var Age = "ContextMenuItemIndicator", Dge = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(iK, { ...i, ...r, ref: e });
});
Dge.displayName = Age;
var Oge = "ContextMenuSeparator", jge = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(oK, { ...i, ...r, ref: e });
});
jge.displayName = Oge;
var Lge = "ContextMenuArrow", Nge = M.forwardRef(
  (n, e) => {
    const { __scopeContextMenu: t, ...r } = n, i = ws(t);
    return /* @__PURE__ */ m.jsx(sK, { ...i, ...r, ref: e });
  }
);
Nge.displayName = Lge;
var Fge = "ContextMenuSub", SK = (n) => {
  const { __scopeContextMenu: e, children: t, onOpenChange: r, open: i, defaultOpen: s } = n, l = ws(e), [c, d] = Ih({
    prop: i,
    defaultProp: s,
    onChange: r
  });
  return /* @__PURE__ */ m.jsx(aK, { ...l, open: c, onOpenChange: d, children: t });
};
SK.displayName = Fge;
var zge = "ContextMenuSubTrigger", xK = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(lK, { ...i, ...r, ref: e });
});
xK.displayName = zge;
var Uge = "ContextMenuSubContent", wK = M.forwardRef((n, e) => {
  const { __scopeContextMenu: t, ...r } = n, i = ws(t);
  return /* @__PURE__ */ m.jsx(
    cK,
    {
      ...i,
      ...r,
      ref: e,
      style: {
        ...n.style,
        "--radix-context-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-context-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-context-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-context-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-context-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
wK.displayName = Uge;
function tC(n) {
  return (e) => e.pointerType !== "mouse" ? n(e) : void 0;
}
var $ge = dK, Bge = hK, Hge = Rj, Vge = gK, Kge = vK, Mj = "DropdownMenu", [Wge, hEe] = ju(
  Mj,
  [__]
), bs = __(), [Gge, bK] = Wge(Mj), CK = (n) => {
  const {
    __scopeDropdownMenu: e,
    children: t,
    dir: r,
    open: i,
    defaultOpen: s,
    onOpenChange: l,
    modal: c = !0
  } = n, d = bs(e), h = M.useRef(null), [g = !1, y] = Ih({
    prop: i,
    defaultProp: s,
    onChange: l
  });
  return /* @__PURE__ */ m.jsx(
    Gge,
    {
      scope: e,
      triggerId: $d(),
      triggerRef: h,
      contentId: $d(),
      open: g,
      onOpenChange: y,
      onOpenToggle: M.useCallback(() => y((v) => !v), [y]),
      modal: c,
      children: /* @__PURE__ */ m.jsx(qV, { ...d, open: g, onOpenChange: y, dir: r, modal: c, children: t })
    }
  );
};
CK.displayName = Mj;
var EK = "DropdownMenuTrigger", _K = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, disabled: r = !1, ...i } = n, s = bK(EK, t), l = bs(t);
    return /* @__PURE__ */ m.jsx(YV, { asChild: !0, ...l, children: /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        id: s.triggerId,
        "aria-haspopup": "menu",
        "aria-expanded": s.open,
        "aria-controls": s.open ? s.contentId : void 0,
        "data-state": s.open ? "open" : "closed",
        "data-disabled": r ? "" : void 0,
        disabled: r,
        ...i,
        ref: g_(e, s.triggerRef),
        onPointerDown: bt(n.onPointerDown, (c) => {
          !r && c.button === 0 && c.ctrlKey === !1 && (s.onOpenToggle(), s.open || c.preventDefault());
        }),
        onKeyDown: bt(n.onKeyDown, (c) => {
          r || (["Enter", " "].includes(c.key) && s.onOpenToggle(), c.key === "ArrowDown" && s.onOpenChange(!0), ["Enter", " ", "ArrowDown"].includes(c.key) && c.preventDefault());
        })
      }
    ) });
  }
);
_K.displayName = EK;
var qge = "DropdownMenuPortal", PK = (n) => {
  const { __scopeDropdownMenu: e, ...t } = n, r = bs(e);
  return /* @__PURE__ */ m.jsx(XV, { ...r, ...t });
};
PK.displayName = qge;
var TK = "DropdownMenuContent", IK = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n, i = bK(TK, t), s = bs(t), l = M.useRef(!1);
    return /* @__PURE__ */ m.jsx(
      ZV,
      {
        id: i.contentId,
        "aria-labelledby": i.triggerId,
        ...s,
        ...r,
        ref: e,
        onCloseAutoFocus: bt(n.onCloseAutoFocus, (c) => {
          var d;
          l.current || (d = i.triggerRef.current) == null || d.focus(), l.current = !1, c.preventDefault();
        }),
        onInteractOutside: bt(n.onInteractOutside, (c) => {
          const d = c.detail.originalEvent, h = d.button === 0 && d.ctrlKey === !0, g = d.button === 2 || h;
          (!i.modal || g) && (l.current = !0);
        }),
        style: {
          ...n.style,
          "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
          "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
          "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    );
  }
);
IK.displayName = TK;
var Yge = "DropdownMenuGroup", kK = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
    return /* @__PURE__ */ m.jsx(QV, { ...i, ...r, ref: e });
  }
);
kK.displayName = Yge;
var Xge = "DropdownMenuLabel", Zge = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
    return /* @__PURE__ */ m.jsx(JV, { ...i, ...r, ref: e });
  }
);
Zge.displayName = Xge;
var Qge = "DropdownMenuItem", RK = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
    return /* @__PURE__ */ m.jsx(eK, { ...i, ...r, ref: e });
  }
);
RK.displayName = Qge;
var Jge = "DropdownMenuCheckboxItem", MK = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(tK, { ...i, ...r, ref: e });
});
MK.displayName = Jge;
var eme = "DropdownMenuRadioGroup", tme = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(nK, { ...i, ...r, ref: e });
});
tme.displayName = eme;
var nme = "DropdownMenuRadioItem", rme = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(rK, { ...i, ...r, ref: e });
});
rme.displayName = nme;
var ime = "DropdownMenuItemIndicator", ome = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(iK, { ...i, ...r, ref: e });
});
ome.displayName = ime;
var sme = "DropdownMenuSeparator", ame = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(oK, { ...i, ...r, ref: e });
});
ame.displayName = sme;
var lme = "DropdownMenuArrow", cme = M.forwardRef(
  (n, e) => {
    const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
    return /* @__PURE__ */ m.jsx(sK, { ...i, ...r, ref: e });
  }
);
cme.displayName = lme;
var ume = (n) => {
  const { __scopeDropdownMenu: e, children: t, open: r, onOpenChange: i, defaultOpen: s } = n, l = bs(e), [c = !1, d] = Ih({
    prop: r,
    defaultProp: s,
    onChange: i
  });
  return /* @__PURE__ */ m.jsx(aK, { ...l, open: c, onOpenChange: d, children: t });
}, dme = "DropdownMenuSubTrigger", AK = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(lK, { ...i, ...r, ref: e });
});
AK.displayName = dme;
var fme = "DropdownMenuSubContent", DK = M.forwardRef((n, e) => {
  const { __scopeDropdownMenu: t, ...r } = n, i = bs(t);
  return /* @__PURE__ */ m.jsx(
    cK,
    {
      ...i,
      ...r,
      ref: e,
      style: {
        ...n.style,
        "--radix-dropdown-menu-content-transform-origin": "var(--radix-popper-transform-origin)",
        "--radix-dropdown-menu-content-available-width": "var(--radix-popper-available-width)",
        "--radix-dropdown-menu-content-available-height": "var(--radix-popper-available-height)",
        "--radix-dropdown-menu-trigger-width": "var(--radix-popper-anchor-width)",
        "--radix-dropdown-menu-trigger-height": "var(--radix-popper-anchor-height)"
      }
    }
  );
});
DK.displayName = fme;
var Aj = CK, Dj = _K, T_ = PK, Oj = IK, hme = kK, pme = RK, gme = MK, mme = ume, yme = AK, vme = DK;
function Dr(n, e) {
  var i;
  const t = /* @__PURE__ */ new Set();
  for (const s of e) {
    const l = n.getShape(s);
    if (!l) continue;
    n.getShapeUtil(l).onDragShapesOut && t.add(l);
    const c = n.getShape(l.parentId);
    c && n.getShapeUtil(c).onDragShapesOut && t.add(c);
  }
  const r = /* @__PURE__ */ new Map();
  for (const s of t) {
    const l = OK(n, s);
    l.length && r.set(s, l);
  }
  for (const [s, l] of r) {
    const c = n.getShapeUtil(s), d = rn(l.map((h) => n.getShape(h)));
    (i = c.onDragShapesOut) == null || i.call(c, s, d);
  }
}
function OK(n, e) {
  const t = n.getSortedChildIdsForParent(e.id);
  if (t.length === 0) return [];
  const r = n.getShapePageBounds(e);
  if (!r) return [];
  let i, s, l;
  const c = [];
  for (const d of t) {
    const h = n.getShapePageBounds(d);
    if (!h)
      continue;
    if (!r.includes(h)) {
      c.push(d);
      continue;
    }
    i ?? (i = n.getShapeGeometry(e)), s ?? (s = n.getShapePageTransform(e)), l ?? (l = s.applyToPoints(i.vertices));
    const g = n.getShapePageTransform(d).clone().invert().applyToPoints(l), { vertices: y, isClosed: v } = n.getShapeGeometry(d);
    if (!y.some((w) => Ja(w, g))) {
      if (v) {
        if (GO(g, y))
          continue;
      } else if ($le(g, y))
        continue;
      c.push(d);
    }
  }
  return c;
}
function PE(n, e, t = !1) {
  n.select(e), n.setEditingShape(e), n.setCurrentTool("select.editing_shape", {
    target: "shape",
    shape: e
  }), t && n.emit("select-all-text", { shapeId: e.id });
}
function Sme(n, e) {
  const t = rn(
    e.map((i) => n.getShape(i)).filter((i) => i && n.isShapeOfType(i, "frame"))
  );
  if (!t.length) return;
  const r = [];
  n.run(() => {
    t.map((i) => {
      const s = n.getSortedChildIdsForParent(i.id);
      s.length && (n.reparentShapes(s, i.parentId, i.index), r.push(...s));
    }), n.setSelectedShapes(r), n.deleteShapes(e);
  });
}
const xme = 50;
function wme(n, e, t = {}) {
  const r = n.getShape(e);
  if (!r) return;
  const i = n.getSortedChildIdsForParent(r.id), s = rn(i.map((w) => n.getShape(w)));
  if (!s.length) return;
  const l = Xe.FromPoints(
    s.flatMap((w) => {
      const C = n.getShapeGeometry(w.id);
      return n.getShapeLocalTransform(w).applyToPoints(C.vertices);
    })
  ), { padding: c = xme } = t, d = l.w + 2 * c, h = l.h + 2 * c, g = c - l.minX, y = c - l.minY;
  if (g === 0 && y === 0 && r.props.w === d && r.props.h === h) return;
  const v = new R(g, y).rot(r.rotation);
  n.run(() => {
    const w = i.map((C) => {
      const E = n.getShape(C);
      return {
        id: E.id,
        type: E.type,
        x: E.x + g,
        y: E.y + y
      };
    });
    w.push({
      id: r.id,
      type: r.type,
      x: r.x - v.x,
      y: r.y - v.y,
      props: {
        w: d,
        h
      }
    }), n.updateShapes(w);
  });
}
const jK = M.createContext(null);
function bme({
  assetUrls: n,
  children: e
}) {
  return M.useEffect(() => {
    for (const t of Object.values(n.icons)) {
      const r = Bx();
      r.src = t, r.decode();
    }
    for (const t of Object.values(n.embedIcons)) {
      const r = Bx();
      r.src = t, r.decode();
    }
  }, [n]), /* @__PURE__ */ m.jsx(jK.Provider, { value: n, children: e });
}
function jj() {
  const n = M.useContext(jK);
  if (!n)
    throw new Error("useAssetUrls must be used within an AssetUrlsProvider");
  return n;
}
const gD = {
  "action.convert-to-bookmark": "Convert to Bookmark",
  "action.convert-to-embed": "Convert to Embed",
  "action.open-embed-link": "Open link",
  "action.align-bottom": "Align bottom",
  "action.align-center-horizontal": "Align horizontally",
  "action.align-center-vertical": "Align vertically",
  "action.align-center-horizontal.short": "Align H",
  "action.align-center-vertical.short": "Align V",
  "action.align-left": "Align left",
  "action.align-right": "Align right",
  "action.align-top": "Align top",
  "action.back-to-content": "Back to content",
  "action.bring-forward": "Bring forward",
  "action.bring-to-front": "Bring to front",
  "action.copy-as-json.short": "JSON",
  "action.copy-as-json": "Copy as JSON",
  "action.copy-as-png.short": "PNG",
  "action.copy-as-png": "Copy as PNG",
  "action.copy-as-svg.short": "SVG",
  "action.copy-as-svg": "Copy as SVG",
  "action.copy": "Copy",
  "action.cut": "Cut",
  "action.delete": "Delete",
  "action.unlock-all": "Unlock all",
  "action.distribute-horizontal": "Distribute horizontally",
  "action.distribute-vertical": "Distribute vertically",
  "action.distribute-horizontal.short": "Distribute H",
  "action.distribute-vertical.short": "Distribute V",
  "action.duplicate": "Duplicate",
  "action.edit-link": "Edit link",
  "action.exit-pen-mode": "Exit pen mode",
  "action.export-as-json.short": "JSON",
  "action.export-as-json": "Export as JSON",
  "action.export-as-png.short": "PNG",
  "action.export-as-png": "Export as PNG",
  "action.export-as-svg.short": "SVG",
  "action.export-as-svg": "Export as SVG",
  "action.export-all-as-json.short": "JSON",
  "action.export-all-as-json": "Export as JSON",
  "action.export-all-as-png.short": "PNG",
  "action.export-all-as-png": "Export as PNG",
  "action.export-all-as-svg.short": "SVG",
  "action.export-all-as-svg": "Export as SVG",
  "action.fit-frame-to-content": "Fit to content",
  "action.flip-horizontal": "Flip horizontally",
  "action.flip-vertical": "Flip vertically",
  "action.flip-horizontal.short": "Flip H",
  "action.flip-vertical.short": "Flip V",
  "action.fork-project": "Fork this project",
  "action.fork-project-on-tldraw": "Fork project on tldraw",
  "action.group": "Group",
  "action.insert-embed": "Insert embed",
  "action.insert-media": "Upload media",
  "action.leave-shared-project": "Leave shared project",
  "action.new-project": "New project",
  "action.new-shared-project": "New shared project",
  "action.open-cursor-chat": "Cursor chat",
  "action.open-file": "Open file",
  "action.pack": "Pack",
  "action.paste": "Paste",
  "action.paste-error-title": "Pasting failed",
  "action.paste-error-description": "Could not paste due to missing clipboard permissions. Please enable the permissions and try again.",
  "action.print": "Print",
  "action.redo": "Redo",
  "action.remove-frame": "Remove frame",
  "action.rename": "Rename",
  "action.rotate-ccw": "Rotate counterclockwise",
  "action.rotate-cw": "Rotate clockwise",
  "action.save-copy": "Save a copy",
  "action.select-all": "Select all",
  "action.select-none": "Select none",
  "action.send-backward": "Send backward",
  "action.send-to-back": "Send to back",
  "action.share-project": "Share this project",
  "action.stack-horizontal": "Stack horizontally",
  "action.stack-vertical": "Stack vertically",
  "action.stack-horizontal.short": "Stack H",
  "action.stack-vertical.short": "Stack V",
  "action.stop-following": "Stop following",
  "action.stretch-horizontal": "Stretch horizontally",
  "action.stretch-vertical": "Stretch vertically",
  "action.stretch-horizontal.short": "Stretch H",
  "action.stretch-vertical.short": "Stretch V",
  "action.toggle-auto-size": "Toggle auto size",
  "action.toggle-dark-mode.menu": "Dark mode",
  "action.toggle-dark-mode": "Toggle dark mode",
  "action.toggle-paste-at-cursor.menu": "Paste at cursor",
  "action.toggle-paste-at-cursor": "Toggle paste at cursor",
  "action.toggle-wrap-mode.menu": "Select on wrap",
  "action.toggle-wrap-mode": "Toggle Select on wrap",
  "action.toggle-reduce-motion.menu": "Reduce motion",
  "action.toggle-reduce-motion": "Toggle reduce motion",
  "action.toggle-edge-scrolling.menu": "Edge scrolling",
  "action.toggle-edge-scrolling": "Toggle edge scrolling",
  "action.toggle-debug-mode.menu": "Debug mode",
  "action.toggle-debug-mode": "Toggle debug mode",
  "action.toggle-focus-mode.menu": "Focus mode",
  "action.toggle-focus-mode": "Toggle focus mode",
  "action.toggle-dynamic-size-mode.menu": "Dynamic size",
  "action.toggle-dynamic-size-mode": "Toggle dynamic size",
  "action.toggle-grid.menu": "Show grid",
  "action.toggle-grid": "Toggle grid",
  "action.toggle-lock": "Toggle locked",
  "action.flatten-to-image": "Flatten",
  "action.toggle-snap-mode.menu": "Always snap",
  "action.toggle-snap-mode": "Toggle always snap",
  "action.toggle-tool-lock.menu": "Tool lock",
  "action.toggle-tool-lock": "Toggle tool lock",
  "action.toggle-transparent.context-menu": "Transparent",
  "action.toggle-transparent.menu": "Transparent",
  "action.toggle-transparent": "Toggle transparent background",
  "action.undo": "Undo",
  "action.ungroup": "Ungroup",
  "action.zoom-in": "Zoom in",
  "action.zoom-out": "Zoom out",
  "action.zoom-to-100": "Zoom to 100%",
  "action.zoom-to-fit": "Zoom to fit",
  "action.zoom-to-selection": "Zoom to selection",
  "assets.files.size-too-big": "File size is too big",
  "assets.files.type-not-allowed": "File type is not allowed",
  "assets.files.upload-failed": "Upload failed",
  "assets.url.failed": "Couldn't load URL preview",
  "theme.dark": "Dark",
  "theme.light": "Light",
  "theme.system": "System",
  "color-style.white": "White",
  "color-style.black": "Black",
  "color-style.blue": "Blue",
  "color-style.green": "Green",
  "color-style.grey": "Grey",
  "color-style.light-blue": "Light blue",
  "color-style.light-green": "Light green",
  "color-style.light-red": "Light red",
  "color-style.light-violet": "Light violet",
  "color-style.orange": "Orange",
  "color-style.red": "Red",
  "color-style.violet": "Violet",
  "color-style.yellow": "Yellow",
  "fill-style.none": "None",
  "document.default-name": "Untitled",
  "fill-style.semi": "Semi",
  "fill-style.solid": "Solid",
  "fill-style.pattern": "Pattern",
  "fill-style.fill": "Fill",
  "dash-style.dashed": "Dashed",
  "dash-style.dotted": "Dotted",
  "dash-style.draw": "Draw",
  "dash-style.solid": "Solid",
  "size-style.s": "Small",
  "size-style.m": "Medium",
  "size-style.l": "Large",
  "size-style.xl": "Extra large",
  "opacity-style.0.1": "10%",
  "opacity-style.0.25": "25%",
  "opacity-style.0.5": "50%",
  "opacity-style.0.75": "75%",
  "opacity-style.1": "100%",
  "font-style.draw": "Draw",
  "font-style.sans": "Sans",
  "font-style.serif": "Serif",
  "font-style.mono": "Mono",
  "align-style.start": "Start",
  "align-style.middle": "Middle",
  "align-style.end": "End",
  "align-style.justify": "Justify",
  "verticalAlign-style.start": "Top",
  "verticalAlign-style.middle": "Middle",
  "verticalAlign-style.end": "Bottom",
  "geo-style.arrow-down": "Arrow down",
  "geo-style.arrow-left": "Arrow left",
  "geo-style.arrow-right": "Arrow right",
  "geo-style.arrow-up": "Arrow up",
  "geo-style.diamond": "Diamond",
  "geo-style.ellipse": "Ellipse",
  "geo-style.hexagon": "Hexagon",
  "geo-style.octagon": "Octagon",
  "geo-style.oval": "Oval",
  "geo-style.cloud": "Cloud",
  "geo-style.pentagon": "Pentagon",
  "geo-style.rectangle": "Rectangle",
  "geo-style.rhombus-2": "Rhombus 2",
  "geo-style.rhombus": "Rhombus",
  "geo-style.star": "Star",
  "geo-style.trapezoid": "Trapezoid",
  "geo-style.triangle": "Triangle",
  "geo-style.x-box": "X box",
  "geo-style.check-box": "Check box",
  "arrowheadStart-style.none": "None",
  "arrowheadStart-style.arrow": "Arrow",
  "arrowheadStart-style.bar": "Bar",
  "arrowheadStart-style.diamond": "Diamond",
  "arrowheadStart-style.dot": "Dot",
  "arrowheadStart-style.inverted": "Inverted",
  "arrowheadStart-style.pipe": "Pipe",
  "arrowheadStart-style.square": "Square",
  "arrowheadStart-style.triangle": "Triangle",
  "arrowheadEnd-style.none": "None",
  "arrowheadEnd-style.arrow": "Arrow",
  "arrowheadEnd-style.bar": "Bar",
  "arrowheadEnd-style.diamond": "Diamond",
  "arrowheadEnd-style.dot": "Dot",
  "arrowheadEnd-style.inverted": "Inverted",
  "arrowheadEnd-style.pipe": "Pipe",
  "arrowheadEnd-style.square": "Square",
  "arrowheadEnd-style.triangle": "Triangle",
  "spline-style.line": "Line",
  "spline-style.cubic": "Cubic",
  "tool.select": "Select",
  "tool.hand": "Hand",
  "tool.draw": "Draw",
  "tool.eraser": "Eraser",
  "tool.arrow-down": "Arrow down",
  "tool.arrow-left": "Arrow left",
  "tool.arrow-right": "Arrow right",
  "tool.arrow-up": "Arrow up",
  "tool.arrow": "Arrow",
  "tool.cloud": "Cloud",
  "tool.diamond": "Diamond",
  "tool.ellipse": "Ellipse",
  "tool.hexagon": "Hexagon",
  "tool.highlight": "Highlight",
  "tool.line": "Line",
  "tool.octagon": "Octagon",
  "tool.oval": "Oval",
  "tool.pentagon": "Pentagon",
  "tool.rectangle": "Rectangle",
  "tool.rhombus": "Rhombus",
  "tool.star": "Star",
  "tool.trapezoid": "Trapezoid",
  "tool.triangle": "Triangle",
  "tool.x-box": "X box",
  "tool.check-box": "Check box",
  "tool.asset": "Asset",
  "tool.frame": "Frame",
  "tool.note": "Note",
  "tool.laser": "Laser",
  "tool.embed": "Embed",
  "tool.text": "Text",
  "tool.pointer-down": "Pointer down",
  "menu.title": "Menu",
  "menu.theme": "Theme",
  "menu.copy-as": "Copy as",
  "menu.edit": "Edit",
  "menu.export-as": "Export as",
  "menu.file": "File",
  "menu.language": "Language",
  "menu.preferences": "Preferences",
  "menu.help": "Help",
  "menu.view": "View",
  "context-menu.edit": "Edit",
  "context-menu.arrange": "Arrange",
  "context-menu.copy-as": "Copy as",
  "context-menu.export-as": "Export as",
  "context-menu.export-all-as": "Export",
  "context-menu.move-to-page": "Move to page",
  "context-menu.reorder": "Reorder",
  "page-menu.title": "Pages",
  "page-menu.create-new-page": "Create new page",
  "page-menu.max-page-count-reached": "Max pages reached",
  "page-menu.new-page-initial-name": "Page 1",
  "page-menu.edit-start": "Edit",
  "page-menu.edit-done": "Done",
  "page-menu.go-to-page": "Go to page",
  "page-menu.submenu.rename": "Rename",
  "page-menu.submenu.duplicate-page": "Duplicate",
  "page-menu.submenu.title": "Menu",
  "page-menu.submenu.move-down": "Move down",
  "page-menu.submenu.move-up": "Move up",
  "page-menu.submenu.delete": "Delete",
  "share-menu.title": "Share",
  "share-menu.save-note": "Download this project to your computer as a .tldr file.",
  "share-menu.fork-note": "Create a new shared project based on this snapshot.",
  "share-menu.share-project": "Share this project",
  "share-menu.default-project-name": "Shared Project",
  "share-menu.copy-link": "Copy editor link",
  "share-menu.readonly-link": "Read-only",
  "share-menu.create-snapshot-link": "Copy snapshot link",
  "share-menu.snapshot-link-note": "Capture and share this project as a read-only snapshot link.",
  "share-menu.copy-readonly-link": "Copy viewer link",
  "share-menu.offline-note": "Create a new shared project based on your current project.",
  "share-menu.copy-link-note": "Anyone with the link will be able to view and edit this project.",
  "share-menu.copy-readonly-link-note": "Anyone with the link will be able to access this project.",
  "share-menu.project-too-large": "Sorry, this project can't be shared because it's too large. We're working on it!",
  "share-menu.upload-failed": "Sorry, we couldn't upload your project at the moment. Please try again or let us know if the problem persists.",
  "share-menu.creating-project": "Creating the new project…",
  "share-menu.copied": "Copied link",
  "document-name-menu.copy-link": "Copy link",
  "status.offline": "Offline",
  "status.online": "Online",
  "people-menu.title": "People",
  "people-menu.change-name": "Change name",
  "people-menu.change-color": "Change color",
  "people-menu.follow": "Following",
  "people-menu.following": "Following",
  "people-menu.leading": "Following You",
  "people-menu.user": "(You)",
  "people-menu.invite": "Invite others",
  "help-menu.import-tldr-file": "Import file...",
  "help-menu.title": "Help and resources",
  "help-menu.about": "About tldraw",
  "help-menu.docs": "Documentation & API",
  "help-menu.discord": "Discord",
  "help-menu.github": "GitHub",
  "help-menu.keyboard-shortcuts": "Keyboard shortcuts",
  "help-menu.twitter": "Twitter",
  "help-menu.terms": "Terms of service",
  "help-menu.privacy": "Privacy policy",
  "actions-menu.title": "Actions",
  "edit-link-dialog.title": "Edit link",
  "edit-link-dialog.invalid-url": "A link must be a valid URL.",
  "edit-link-dialog.detail": "Links will open in a new tab.",
  "edit-link-dialog.url": "URL",
  "edit-link-dialog.clear": "Clear",
  "edit-link-dialog.save": "Continue",
  "edit-link-dialog.cancel": "Cancel",
  "embed-dialog.title": "Insert embed",
  "embed-dialog.back": "Back",
  "embed-dialog.create": "Create",
  "embed-dialog.cancel": "Cancel",
  "embed-dialog.url": "URL",
  "embed-dialog.instruction": "Paste in the site's URL to create the embed.",
  "embed-dialog.invalid-url": "We could not create an embed from that URL.",
  "edit-pages-dialog.move-down": "Move down",
  "edit-pages-dialog.move-up": "Move up",
  "shortcuts-dialog.title": "Keyboard shortcuts",
  "shortcuts-dialog.edit": "Edit",
  "shortcuts-dialog.file": "File",
  "shortcuts-dialog.preferences": "Preferences",
  "shortcuts-dialog.tools": "Tools",
  "shortcuts-dialog.transform": "Transform",
  "shortcuts-dialog.view": "View",
  "shortcuts-dialog.collaboration": "Collaboration",
  "home-project-dialog.title": "Home project",
  "home-project-dialog.description": "This is your local home project. It's just for you!",
  "rename-project-dialog.title": "Rename project",
  "rename-project-dialog.cancel": "Cancel",
  "rename-project-dialog.rename": "Rename",
  "home-project-dialog.ok": "Ok",
  "style-panel.title": "Styles",
  "style-panel.align": "Align",
  "style-panel.label-align": "Label align",
  "style-panel.vertical-align": "Vertical align",
  "style-panel.position": "Position",
  "style-panel.arrowheads": "Arrows",
  "style-panel.arrowhead-start": "Start",
  "style-panel.arrowhead-end": "End",
  "style-panel.color": "Color",
  "style-panel.dash": "Dash",
  "style-panel.fill": "Fill",
  "style-panel.font": "Font",
  "style-panel.geo": "Shape",
  "style-panel.mixed": "Mixed",
  "style-panel.opacity": "Opacity",
  "style-panel.size": "Size",
  "style-panel.spline": "Spline",
  "tool-panel.drawing": "Drawing",
  "tool-panel.shapes": "Shapes",
  "tool-panel.more": "More",
  "debug-panel.more": "More",
  "navigation-zone.toggle-minimap": "Toggle minimap",
  "navigation-zone.zoom": "Zoom",
  "focus-mode.toggle-focus-mode": "Toggle focus mode",
  "toast.close": "Close",
  "file-system.file-open-error.title": "Could not open file",
  "file-system.file-open-error.not-a-tldraw-file": "The file you tried to open doesn't look like a tldraw file.",
  "file-system.file-open-error.file-format-version-too-new": "The file you tried to open is from a newer version of tldraw. Please reload the page and try again.",
  "file-system.file-open-error.generic-corrupted-file": "The file you tried to open is corrupted.",
  "file-system.confirm-open.title": "Overwrite current project?",
  "file-system.confirm-open.description": "Opening a file will replace your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-open.cancel": "Cancel",
  "file-system.confirm-open.open": "Open file",
  "file-system.confirm-open.dont-show-again": "Don't ask again",
  "file-system.confirm-clear.title": "Clear current project?",
  "file-system.confirm-clear.description": "Creating a new project will clear your current project and any unsaved changes will be lost. Are you sure you want to continue?",
  "file-system.confirm-clear.cancel": "Cancel",
  "file-system.confirm-clear.continue": "Continue",
  "file-system.confirm-clear.dont-show-again": "Don't ask again",
  "file-system.shared-document-file-open-error.title": "Could not open file",
  "file-system.shared-document-file-open-error.description": "Opening files from shared projects is not supported.",
  "sharing.confirm-leave.title": "Leave current project?",
  "sharing.confirm-leave.description": "Are you sure you want to leave this shared project? You can return to it by navigating to its URL.",
  "sharing.confirm-leave.cancel": "Cancel",
  "sharing.confirm-leave.leave": "Leave",
  "sharing.confirm-leave.dont-show-again": "Don't ask again",
  "toast.error.export-fail.title": "Failed export",
  "toast.error.export-fail.desc": "Failed to export image",
  "toast.error.copy-fail.title": "Failed copy",
  "toast.error.copy-fail.desc": "Failed to copy image",
  "context.pages.new-page": "New page",
  "vscode.file-open.desc": "We've updated this document to work with the current version of tldraw. If you'd like to keep the original version (which will work on old.tldraw.com), click below to create a backup.",
  "vscode.file-open.open": "Continue",
  "vscode.file-open.backup": "Backup",
  "vscode.file-open.backup-saved": "Backup saved",
  "vscode.file-open.backup-failed": "Backup failed: this is not a .tldr file.",
  "vscode.file-open.dont-show-again": "Don't ask again",
  "cursor-chat.type-to-chat": "Type to chat..."
};
var Cme = {};
const Eme = /* @__PURE__ */ new Set(["ar", "fa", "he", "ur", "ku"]), dy = {
  locale: "en",
  label: "English",
  messages: gD,
  dir: "ltr"
};
async function _me(n, e) {
  if (!(await Eu(e.translations.en)).ok)
    return console.warn("No main translations found."), dy;
  if (n === "en")
    return dy;
  const r = qx.find((c) => c.locale === n);
  if (!r)
    return console.warn(`No translation found for locale ${n}`), dy;
  const s = await (await Eu(e.translations[r.locale])).json();
  if (!s)
    return console.warn(`No messages found for locale ${n}`), dy;
  const l = [];
  for (const c in dy.messages)
    s[c] || l.push(c);
  return l.length > 0 && Cme.NODE_ENV === "development" && console.warn(`Language ${n}: missing messages for keys:
${l.join(`
`)}`), {
    locale: n,
    label: r.label,
    dir: Eme.has(r.locale) ? "rtl" : "ltr",
    messages: { ...dy.messages, ...s }
  };
}
const LK = M.createContext(null);
function NK() {
  const n = M.useContext(LK);
  if (!n)
    throw new Error("useCurrentTranslation must be used inside of <TldrawUiContextProvider />");
  return n;
}
function Pme({
  overrides: n,
  locale: e,
  children: t
}) {
  const r = jj(), [i, s] = M.useState(() => n && n.en ? {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: { ...gD, ...n.en }
  } : {
    locale: "en",
    label: "English",
    dir: "ltr",
    messages: gD
  });
  return M.useEffect(() => {
    let l = !1;
    async function c() {
      const d = await _me(e, r);
      d && !l && (n && n[e] ? s({
        ...d,
        messages: { ...d.messages, ...n[e] }
      }) : s(d));
    }
    return c(), () => {
      l = !0;
    };
  }, [r, e, n]), /* @__PURE__ */ m.jsx(LK.Provider, { value: i, children: t });
}
function Ln() {
  const n = NK();
  return M.useCallback(
    function(t) {
      return n.messages[t] ?? t;
    },
    [n]
  );
}
const Ot = M.forwardRef(
  function({ children: e, type: t, ...r }, i) {
    return /* @__PURE__ */ m.jsx(
      "button",
      {
        ref: i,
        type: "button",
        draggable: !1,
        ...r,
        className: It("tlui-button", `tlui-button__${t}`, r.className),
        children: e
      }
    );
  }
);
function _i({ children: n }) {
  return /* @__PURE__ */ m.jsx("span", { className: "tlui-button__label", children: n });
}
var Lj = "Dialog", [FK, pEe] = ju(Lj), [Tme, Rc] = FK(Lj), zK = (n) => {
  const {
    __scopeDialog: e,
    children: t,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: l = !0
  } = n, c = M.useRef(null), d = M.useRef(null), [h = !1, g] = Ih({
    prop: r,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ m.jsx(
    Tme,
    {
      scope: e,
      triggerRef: c,
      contentRef: d,
      contentId: $d(),
      titleId: $d(),
      descriptionId: $d(),
      open: h,
      onOpenChange: g,
      onOpenToggle: M.useCallback(() => g((y) => !y), [g]),
      modal: l,
      children: t
    }
  );
};
zK.displayName = Lj;
var UK = "DialogTrigger", Ime = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, ...r } = n, i = Rc(UK, t), s = jr(e, i.triggerRef);
    return /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": zj(i.open),
        ...r,
        ref: s,
        onClick: bt(n.onClick, i.onOpenToggle)
      }
    );
  }
);
Ime.displayName = UK;
var Nj = "DialogPortal", [kme, $K] = FK(Nj, {
  forceMount: void 0
}), BK = (n) => {
  const { __scopeDialog: e, forceMount: t, children: r, container: i } = n, s = Rc(Nj, e);
  return /* @__PURE__ */ m.jsx(kme, { scope: e, forceMount: t, children: M.Children.map(r, (l) => /* @__PURE__ */ m.jsx(kc, { present: t || s.open, children: /* @__PURE__ */ m.jsx(kw, { asChild: !0, container: i, children: l }) })) });
};
BK.displayName = Nj;
var TE = "DialogOverlay", HK = M.forwardRef(
  (n, e) => {
    const t = $K(TE, n.__scopeDialog), { forceMount: r = t.forceMount, ...i } = n, s = Rc(TE, n.__scopeDialog);
    return s.modal ? /* @__PURE__ */ m.jsx(kc, { present: r || s.open, children: /* @__PURE__ */ m.jsx(Rme, { ...i, ref: e }) }) : null;
  }
);
HK.displayName = TE;
var Rme = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, ...r } = n, i = Rc(TE, t);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ m.jsx(E_, { as: ng, allowPinchZoom: !0, shards: [i.contentRef], children: /* @__PURE__ */ m.jsx(
        Wn.div,
        {
          "data-state": zj(i.open),
          ...r,
          ref: e,
          style: { pointerEvents: "auto", ...r.style }
        }
      ) })
    );
  }
), ig = "DialogContent", VK = M.forwardRef(
  (n, e) => {
    const t = $K(ig, n.__scopeDialog), { forceMount: r = t.forceMount, ...i } = n, s = Rc(ig, n.__scopeDialog);
    return /* @__PURE__ */ m.jsx(kc, { present: r || s.open, children: s.modal ? /* @__PURE__ */ m.jsx(Mme, { ...i, ref: e }) : /* @__PURE__ */ m.jsx(Ame, { ...i, ref: e }) });
  }
);
VK.displayName = ig;
var Mme = M.forwardRef(
  (n, e) => {
    const t = Rc(ig, n.__scopeDialog), r = M.useRef(null), i = jr(e, t.contentRef, r);
    return M.useEffect(() => {
      const s = r.current;
      if (s) return xj(s);
    }, []), /* @__PURE__ */ m.jsx(
      KK,
      {
        ...n,
        ref: i,
        trapFocus: t.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: bt(n.onCloseAutoFocus, (s) => {
          var l;
          s.preventDefault(), (l = t.triggerRef.current) == null || l.focus();
        }),
        onPointerDownOutside: bt(n.onPointerDownOutside, (s) => {
          const l = s.detail.originalEvent, c = l.button === 0 && l.ctrlKey === !0;
          (l.button === 2 || c) && s.preventDefault();
        }),
        onFocusOutside: bt(
          n.onFocusOutside,
          (s) => s.preventDefault()
        )
      }
    );
  }
), Ame = M.forwardRef(
  (n, e) => {
    const t = Rc(ig, n.__scopeDialog), r = M.useRef(!1), i = M.useRef(!1);
    return /* @__PURE__ */ m.jsx(
      KK,
      {
        ...n,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var l, c;
          (l = n.onCloseAutoFocus) == null || l.call(n, s), s.defaultPrevented || (r.current || (c = t.triggerRef.current) == null || c.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var d, h;
          (d = n.onInteractOutside) == null || d.call(n, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const l = s.target;
          ((h = t.triggerRef.current) == null ? void 0 : h.contains(l)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), KK = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, trapFocus: r, onOpenAutoFocus: i, onCloseAutoFocus: s, ...l } = n, c = Rc(ig, t), d = M.useRef(null), h = jr(e, d);
    return lj(), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        y_,
        {
          asChild: !0,
          loop: !0,
          trapped: r,
          onMountAutoFocus: i,
          onUnmountAutoFocus: s,
          children: /* @__PURE__ */ m.jsx(
            Tw,
            {
              role: "dialog",
              id: c.contentId,
              "aria-describedby": c.descriptionId,
              "aria-labelledby": c.titleId,
              "data-state": zj(c.open),
              ...l,
              ref: h,
              onDismiss: () => c.onOpenChange(!1)
            }
          )
        }
      ),
      /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
        /* @__PURE__ */ m.jsx(Ome, { titleId: c.titleId }),
        /* @__PURE__ */ m.jsx(Lme, { contentRef: d, descriptionId: c.descriptionId })
      ] })
    ] });
  }
), Fj = "DialogTitle", WK = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, ...r } = n, i = Rc(Fj, t);
    return /* @__PURE__ */ m.jsx(Wn.h2, { id: i.titleId, ...r, ref: e });
  }
);
WK.displayName = Fj;
var GK = "DialogDescription", Dme = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, ...r } = n, i = Rc(GK, t);
    return /* @__PURE__ */ m.jsx(Wn.p, { id: i.descriptionId, ...r, ref: e });
  }
);
Dme.displayName = GK;
var qK = "DialogClose", YK = M.forwardRef(
  (n, e) => {
    const { __scopeDialog: t, ...r } = n, i = Rc(qK, t);
    return /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: bt(n.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
YK.displayName = qK;
function zj(n) {
  return n ? "open" : "closed";
}
var XK = "DialogTitleWarning", [gEe, ZK] = gfe(XK, {
  contentName: ig,
  titleName: Fj,
  docsSlug: "dialog"
}), Ome = ({ titleId: n }) => {
  const e = ZK(XK), t = `\`${e.contentName}\` requires a \`${e.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${e.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${e.docsSlug}`;
  return M.useEffect(() => {
    n && (document.getElementById(n) || console.error(t));
  }, [t, n]), null;
}, jme = "DialogDescriptionWarning", Lme = ({ contentRef: n, descriptionId: e }) => {
  const r = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${ZK(jme).contentName}}.`;
  return M.useEffect(() => {
    var s;
    const i = (s = n.current) == null ? void 0 : s.getAttribute("aria-describedby");
    e && i && (document.getElementById(e) || console.warn(r));
  }, [r, n, e]), null;
}, Nme = zK, Fme = BK, zme = HK, Ume = VK;
const ku = M.memo(function({
  small: e,
  invertIcon: t,
  icon: r,
  color: i,
  className: s,
  ...l
}) {
  const c = jj(), d = c.icons[r] ?? c.icons["question-mark-circle"], h = M.useRef(null);
  return M.useLayoutEffect(() => {
    d || console.error(`Icon not found: ${r}. Add it to the assetUrls.icons object.`), h != null && h.current && (h.current.style.webkitMask = `url(${d}) center 100% / 100% no-repeat`);
  }, [h, d, r]), r === "none" ? /* @__PURE__ */ m.jsx(
    "div",
    {
      className: It(
        "tlui-icon tlui-icon__placeholder",
        { "tlui-icon__small": e },
        s
      )
    }
  ) : /* @__PURE__ */ m.jsx(
    "div",
    {
      ...l,
      ref: h,
      className: It("tlui-icon", { "tlui-icon__small": e }, s),
      style: {
        color: i,
        mask: `url(${d}) center 100% / 100% no-repeat`,
        transform: t ? "scale(-1, 1)" : void 0
      }
    }
  );
});
function In({ icon: n, small: e, invertIcon: t }) {
  return /* @__PURE__ */ m.jsx(ku, { className: "tlui-button__icon", icon: n, small: e, invertIcon: t });
}
function I_({ className: n, children: e }) {
  return /* @__PURE__ */ m.jsx("div", { className: It("tlui-dialog__header", n), children: e });
}
function k_({ className: n, children: e }) {
  return /* @__PURE__ */ m.jsx(WK, { dir: "ltr", className: It("tlui-dialog__header__title", n), children: e });
}
function R_() {
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-dialog__header__close", children: /* @__PURE__ */ m.jsx(YK, { "data-testid": "dialog.close", dir: "ltr", asChild: !0, children: /* @__PURE__ */ m.jsx(
    Ot,
    {
      type: "icon",
      "aria-label": "Close",
      onTouchEnd: (n) => n.target.click(),
      children: /* @__PURE__ */ m.jsx(In, { small: !0, icon: "cross-2" })
    }
  ) }) });
}
function nw({ className: n, children: e, style: t }) {
  return /* @__PURE__ */ m.jsx("div", { className: It("tlui-dialog__body", n), style: t, children: e });
}
function Uj({ className: n, children: e }) {
  return /* @__PURE__ */ m.jsx("div", { className: It("tlui-dialog__footer", n), children: e });
}
const M_ = M.forwardRef(
  function({
    className: e,
    label: t,
    icon: r,
    iconLeft: i,
    autoSelect: s = !1,
    autoFocus: l = !1,
    defaultValue: c,
    placeholder: d,
    onComplete: h,
    onValueChange: g,
    onCancel: y,
    onFocus: v,
    onBlur: w,
    shouldManuallyMaintainScrollPositionWhenFocused: C = !1,
    children: E,
    value: P
  }, I) {
    const k = _h(), L = M.useRef(null);
    M.useImperativeHandle(I, () => L.current);
    const O = Ln(), z = M.useRef(c ?? ""), F = M.useRef(c ?? ""), [H, V] = M.useState(!1), re = M.useCallback(
      (W) => {
        V(!0);
        const Y = W.currentTarget;
        F.current = Y.value, k ? k.timers.requestAnimationFrame(() => {
          s && Y.select();
        }) : eD.requestAnimationFrame("anon", () => {
          s && Y.select();
        }), v == null || v();
      },
      [s, k, v]
    ), q = M.useCallback(
      (W) => {
        const Y = W.currentTarget.value;
        F.current = Y, g == null || g(Y);
      },
      [g]
    ), J = M.useCallback(
      (W) => {
        switch (W.key) {
          case "Enter": {
            W.currentTarget.blur(), Ti(W), h == null || h(W.currentTarget.value);
            break;
          }
          case "Escape": {
            W.currentTarget.value = z.current, y == null || y(W.currentTarget.value), W.currentTarget.blur(), Ti(W);
            break;
          }
        }
      },
      [h, y]
    ), ie = M.useCallback(
      (W) => {
        V(!1);
        const Y = W.currentTarget.value;
        w == null || w(Y);
      },
      [w]
    );
    return M.useEffect(() => {
      if (!Er.isIos) return;
      const W = window.visualViewport;
      if (H && C && W) {
        const Y = () => {
          var oe;
          (oe = L.current) == null || oe.scrollIntoView({ block: "center" });
        };
        return W.addEventListener("resize", Y), W.addEventListener("scroll", Y), k ? k.timers.requestAnimationFrame(() => {
          var oe;
          (oe = L.current) == null || oe.scrollIntoView({ block: "center" });
        }) : eD.requestAnimationFrame("anon", () => {
          var oe;
          (oe = L.current) == null || oe.scrollIntoView({ block: "center" });
        }), () => {
          W.removeEventListener("resize", Y), W.removeEventListener("scroll", Y);
        };
      }
    }, [H, k, C]), /* @__PURE__ */ m.jsxs("div", { draggable: !1, className: "tlui-input__wrapper", children: [
      E,
      t && /* @__PURE__ */ m.jsx("label", { children: O(t) }),
      i && /* @__PURE__ */ m.jsx(ku, { icon: i, className: "tlui-icon-left", small: !0 }),
      /* @__PURE__ */ m.jsx(
        "input",
        {
          ref: L,
          className: It("tlui-input", e),
          type: "text",
          defaultValue: c,
          onKeyDownCapture: J,
          onChange: q,
          onFocus: re,
          onBlur: ie,
          autoFocus: l,
          placeholder: d,
          value: P
        }
      ),
      r && /* @__PURE__ */ m.jsx(ku, { icon: r, small: !!t })
    ] });
  }
);
function AU(n) {
  return tl.isValid(n) ? { isValid: !0, hasProtocol: !0 } : tl.isValid("https://" + n) ? { isValid: !0, hasProtocol: !1 } : { isValid: !1, hasProtocol: !1 };
}
const $me = Ho(function({ onClose: e }) {
  const r = be().getOnlySelectedShape();
  return r && "url" in r.props && typeof r.props.url == "string" ? /* @__PURE__ */ m.jsx(Bme, { onClose: e, selectedShape: r }) : null;
}), Bme = Ho(function({
  onClose: e,
  selectedShape: t
}) {
  const r = be(), i = Ln(), s = M.useRef(null);
  M.useEffect(() => {
    r.timers.requestAnimationFrame(() => {
      var C;
      return (C = s.current) == null ? void 0 : C.focus();
    });
  }, [r]);
  const l = M.useRef(t.props.url), [c, d] = M.useState(() => {
    const C = AU(t.props.url), E = C.isValid === !0 ? C.hasProtocol ? t.props.url : "https://" + t.props.url : "https://";
    return {
      actual: E,
      safe: E,
      valid: !0
    };
  }), h = M.useCallback((C) => {
    const E = C.replace(/https?:\/\/(https?:\/\/)/, (k, L) => L), P = AU(E), I = P.isValid === !0 ? P.hasProtocol ? E : "https://" + E : "https://";
    d({
      actual: E,
      safe: I,
      valid: P.isValid
    });
  }, []), g = M.useCallback(() => {
    const C = r.getOnlySelectedShape();
    C && (r.updateShapes([
      { id: C.id, type: C.type, props: { url: "" } }
    ]), e());
  }, [r, e]), y = M.useCallback(() => {
    const C = r.getOnlySelectedShape();
    C && (C && "url" in C.props && C.props.url !== c.safe && r.updateShapes([
      {
        id: C.id,
        type: C.type,
        props: { url: c.safe }
      }
    ]), e());
  }, [r, e, c]), v = M.useCallback(() => {
    e();
  }, [e]);
  if (!t)
    return e(), null;
  const w = l.current && !c.valid;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(I_, { children: [
      /* @__PURE__ */ m.jsx(k_, { children: i("edit-link-dialog.title") }),
      /* @__PURE__ */ m.jsx(R_, {})
    ] }),
    /* @__PURE__ */ m.jsx(nw, { children: /* @__PURE__ */ m.jsxs("div", { className: "tlui-edit-link-dialog", children: [
      /* @__PURE__ */ m.jsx(
        M_,
        {
          ref: s,
          className: "tlui-edit-link-dialog__input",
          label: "edit-link-dialog.url",
          autoFocus: !0,
          value: c.actual,
          onValueChange: h,
          onComplete: y,
          onCancel: v
        }
      ),
      /* @__PURE__ */ m.jsx("div", { children: c.valid ? i("edit-link-dialog.detail") : i("edit-link-dialog.invalid-url") })
    ] }) }),
    /* @__PURE__ */ m.jsxs(Uj, { className: "tlui-dialog__footer__actions", children: [
      /* @__PURE__ */ m.jsx(Ot, { type: "normal", onClick: v, onTouchEnd: v, children: /* @__PURE__ */ m.jsx(_i, { children: i("edit-link-dialog.cancel") }) }),
      w ? /* @__PURE__ */ m.jsx(Ot, { type: "danger", onTouchEnd: g, onClick: g, children: /* @__PURE__ */ m.jsx(_i, { children: i("edit-link-dialog.clear") }) }) : /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "primary",
          disabled: !c.valid,
          onTouchEnd: y,
          onClick: y,
          children: /* @__PURE__ */ m.jsx(_i, { children: i("edit-link-dialog.save") })
        }
      )
    ] })
  ] });
});
var Hme = {};
const DU = /(^\/r\/[^/]+\/?$)/, $j = [
  {
    type: "tldraw",
    title: "tldraw",
    hostnames: ["beta.tldraw.com", "tldraw.com", "localhost:3000"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-top-navigation": !0
    },
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(DU))
        return n;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(DU))
        return n;
    }
  },
  {
    type: "figma",
    title: "Figma",
    hostnames: ["figma.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      if (n.match(
        // eslint-disable-next-line no-useless-escape
        /https:\/\/([\w\.-]+\.)?figma.com\/(file|proto)\/([0-9a-zA-Z]{22,128})(?:\/.*)?$/
      ) && !n.includes("figma.com/embed"))
        return `https://www.figma.com/embed?embed_host=share&url=${n}`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/?$/)) {
        const t = e.searchParams.get("url");
        if (t)
          return t;
      }
    }
  },
  {
    type: "google_maps",
    title: "Google Maps",
    hostnames: ["google.*"],
    width: 720,
    height: 500,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0
    },
    toEmbedUrl: (n) => {
      if (n.includes("/maps/embed?"))
        return n;
      if (n.includes("/maps/")) {
        const e = n.match(/@(.*?),(.*?),(.*?)z/);
        let t;
        if (e) {
          const [, r, i, s] = e;
          t = `https://${new URL(n).host.replace("www.", "")}/maps/embed/v1/view?key=${Hme.NEXT_PUBLIC_GC_API_KEY}&center=${r},${i}&zoom=${s}`;
        } else
          t = "";
        return t;
      }
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (!e) return;
      if (e.pathname.match(/^\/maps\/embed\/v1\/view\/?$/) && e.searchParams.has("center") && e.searchParams.get("zoom")) {
        const r = e.searchParams.get("zoom"), [i, s] = e.searchParams.get("center").split(",");
        return `https://www.google.com/maps/@${i},${s},${r}z`;
      }
    }
  },
  {
    type: "val_town",
    title: "Val Town",
    hostnames: ["val.town"],
    minWidth: 260,
    minHeight: 100,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/v\/(.+)\/?/);
      if (t)
        return `https://www.val.town/embed/${t[1]}`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/embed\/(.+)\/?/);
      if (t)
        return `https://www.val.town/v/${t[1]}`;
    }
  },
  {
    type: "codesandbox",
    title: "CodeSandbox",
    hostnames: ["codesandbox.io"],
    minWidth: 300,
    minHeight: 300,
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/s\/([^/]+)\/?/);
      if (t)
        return `https://codesandbox.io/embed/${t[1]}`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e && e.pathname.match(/\/embed\/([^/]+)\/?/);
      if (t)
        return `https://codesandbox.io/s/${t[1]}`;
    }
  },
  {
    type: "codepen",
    title: "Codepen",
    hostnames: ["codepen.io"],
    minWidth: 300,
    minHeight: 300,
    width: 520,
    height: 400,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/pen\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i, s] = t;
        return `https://codepen.io/${i}/embed/${s}`;
      }
    },
    fromEmbedUrl: (n) => {
      const e = /https:\/\/codepen.io\/([^/]+)\/embed\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i, s] = t;
        return `https://codepen.io/${i}/pen/${s}`;
      }
    }
  },
  {
    type: "scratch",
    title: "Scratch",
    hostnames: ["scratch.mit.edu"],
    width: 520,
    height: 400,
    doesResize: !1,
    toEmbedUrl: (n) => {
      const e = /https?:\/\/scratch.mit.edu\/projects\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i] = t;
        return `https://scratch.mit.edu/projects/embed/${i}`;
      }
    },
    fromEmbedUrl: (n) => {
      const e = /https:\/\/scratch.mit.edu\/projects\/embed\/([^/]+)/, t = n.match(e);
      if (t) {
        const [r, i] = t;
        return `https://scratch.mit.edu/projects/${i}`;
      }
    }
  },
  {
    type: "youtube",
    title: "YouTube",
    hostnames: ["*.youtube.com", "youtube.com", "youtu.be"],
    width: 800,
    height: 450,
    doesResize: !0,
    overridePermissions: {
      "allow-presentation": !0,
      "allow-popups-to-escape-sandbox": !0
    },
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (!e) return;
      const t = e.hostname.replace(/^www./, "");
      if (t === "youtu.be")
        return `https://www.youtube.com/embed/${e.pathname.split("/").filter(Boolean)[0]}`;
      if ((t === "youtube.com" || t === "m.youtube.com") && e.pathname.match(/^\/watch/))
        return `https://www.youtube.com/embed/${e.searchParams.get("v")}`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (!e) return;
      if (e.hostname.replace(/^www./, "") === "youtube.com") {
        const r = e.pathname.match(/^\/embed\/([^/]+)\/?/);
        if (r)
          return `https://www.youtube.com/watch?v=${r[1]}`;
      }
    }
  },
  {
    type: "google_calendar",
    title: "Google Calendar",
    hostnames: ["calendar.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    instructionLink: "https://support.google.com/calendar/answer/41207?hl=en",
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (n) => {
      const e = Wt(n), t = e == null ? void 0 : e.searchParams.get("cid");
      if (e != null && e.pathname.match(/\/calendar\/u\/0/) && t) {
        e.pathname = "/calendar/embed";
        const r = Array.from(e.searchParams.keys());
        for (const i of r)
          e.searchParams.delete(i);
        return e.searchParams.set("src", t), e.href;
      }
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n), t = e == null ? void 0 : e.searchParams.get("src");
      if (e != null && e.pathname.match(/\/calendar\/embed/) && t) {
        e.pathname = "/calendar/u/0";
        const r = Array.from(e.searchParams.keys());
        for (const i of r)
          e.searchParams.delete(i);
        return e.searchParams.set("cid", t), e.href;
      }
    }
  },
  {
    type: "google_slides",
    title: "Google Slides",
    hostnames: ["docs.google.*"],
    width: 720,
    height: 500,
    minWidth: 460,
    minHeight: 360,
    doesResize: !0,
    overridePermissions: {
      "allow-popups-to-escape-sandbox": !0
    },
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/pub\/?$/))) {
        e.pathname = e.pathname.replace(/\/pub$/, "/embed");
        const t = Array.from(e.searchParams.keys());
        for (const r of t)
          e.searchParams.delete(r);
        return e.href;
      }
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e != null && e.pathname.match(/^\/presentation/) && (e != null && e.pathname.match(/\/embed\/?$/))) {
        e.pathname = e.pathname.replace(/\/embed$/, "/pub");
        const t = Array.from(e.searchParams.keys());
        for (const r of t)
          e.searchParams.delete(r);
        return e.href;
      }
    }
  },
  {
    type: "github_gist",
    title: "GitHub Gist",
    hostnames: ["gist.github.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    // Security warning:
    // Gists allow adding .json extensions to the URL which return JSONP.
    // Furthermore, the JSONP can include callbacks that execute arbitrary JavaScript.
    // It _is_ sandboxed by the iframe but we still want to disable it nonetheless.
    // We restrict the id to only allow hexdecimal characters to prevent this.
    // Read more:
    //   https://github.com/bhaveshk90/Content-Security-Policy-CSP-Bypass-Techniques
    //   https://github.com/renniepak/CSPBypass
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/))
        return n.split("/").pop() ? n : void 0;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/([^/]+)\/([0-9a-f]+)$/))
        return n.split("/").pop() ? n : void 0;
    }
  },
  {
    type: "replit",
    title: "Replit",
    hostnames: ["replit.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/))
        return `${n}?embed=true`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/\/@([^/]+)\/([^/]+)/) && e.searchParams.has("embed"))
        return e.searchParams.delete("embed"), e.href;
    }
  },
  {
    type: "felt",
    title: "Felt",
    hostnames: ["felt.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/map\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/map\//))
        return e.pathname = e.pathname.replace(/^\/embed/, ""), e.href;
    }
  },
  {
    type: "spotify",
    title: "Spotify",
    hostnames: ["open.spotify.com"],
    width: 720,
    height: 500,
    minHeight: 500,
    overrideOutlineRadius: 12,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/(artist|album)\//))
        return e.origin + "/embed" + e.pathname;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/(artist|album)\//))
        return e.origin + e.pathname.replace(/^\/embed/, "");
    }
  },
  {
    type: "vimeo",
    title: "Vimeo",
    hostnames: ["vimeo.com", "player.vimeo.com"],
    width: 640,
    height: 360,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "vimeo.com" && e.pathname.match(/^\/[0-9]+/))
        return "https://player.vimeo.com/video/" + e.pathname.split("/")[1] + "?title=0&byline=0";
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "player.vimeo.com") {
        const t = e.pathname.match(/^\/video\/([^/]+)\/?$/);
        if (t)
          return "https://vimeo.com/" + t[1];
      }
    }
  },
  {
    type: "excalidraw",
    title: "Excalidraw",
    hostnames: ["excalidraw.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hash.match(/#room=/))
        return n;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hash.match(/#room=/))
        return n;
    }
  },
  {
    type: "observable",
    title: "Observable",
    hostnames: ["observablehq.com"],
    width: 720,
    height: 500,
    doesResize: !0,
    isAspectRatioLocked: !1,
    backgroundColor: "#fff",
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}/embed${e.pathname}?cell=*`;
      if (e && e.pathname.match(/^\/d\/([^/]+)\/?$/)) {
        const t = e.pathname.replace(/^\/d/, "");
        return `${e.origin}/embed${t}?cell=*`;
      }
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.pathname.match(/^\/embed\/@([^/]+)\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "")}#cell-*`;
      if (e && e.pathname.match(/^\/embed\/([^/]+)\/?$/))
        return `${e.origin}${e.pathname.replace("/embed", "/d")}#cell-*`;
    }
  },
  {
    type: "desmos",
    title: "Desmos",
    hostnames: ["desmos.com"],
    width: 700,
    height: 450,
    doesResize: !0,
    toEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "" && e.hash === "")
        return `${n}?embed`;
    },
    fromEmbedUrl: (n) => {
      const e = Wt(n);
      if (e && e.hostname === "www.desmos.com" && e.pathname.match(/^\/calculator\/([^/]+)\/?$/) && e.search === "?embed" && e.hash === "")
        return n.replace("?embed", "");
    }
  }
], Vme = {
  // ========================================================================================
  // Disabled permissions
  // ========================================================================================
  // [MDN] Experimental: Allows for downloads to occur without a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads-without-user-activation": !1,
  // [MDN] Allows for downloads to occur with a gesture from the user.
  // [REASON] Disabled because otherwise the <iframe/> can trick the user on behalf of us to perform an action.
  "allow-downloads": !1,
  // [MDN] Lets the resource open modal windows.
  // [REASON] The <iframe/> could 'window.prompt("Enter your tldraw password")'.
  "allow-modals": !1,
  // [MDN] Lets the resource lock the screen orientation.
  // [REASON] Would interfere with the tldraw interface.
  "allow-orientation-lock": !1,
  // [MDN] Lets the resource use the Pointer Lock API.
  // [REASON] Maybe we should allow this for games embeds (scratch/codepen/codesandbox).
  "allow-pointer-lock": !1,
  // [MDN] Allows popups (such as window.open(), target="_blank", or showModalDialog()). If this keyword is not used, the popup will silently fail to open.
  // [REASON] We want to allow embeds to link back to their original sites (e.g. YouTube).
  "allow-popups": !0,
  // [MDN] Lets the sandboxed document open new windows without those windows inheriting the sandboxing. For example, this can safely sandbox an advertisement without forcing the same restrictions upon the page the ad links to.
  // [REASON] We shouldn't allow popups as a embed could pretend to be us by opening a mocked version of tldraw. This is very unobvious when it is performed as an action within our app.
  "allow-popups-to-escape-sandbox": !1,
  // [MDN] Lets the resource start a presentation session.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-presentation": !1,
  // [MDN] Experimental: Lets the resource request access to the parent's storage capabilities with the Storage Access API.
  // [REASON] We don't want anyone else to access our storage.
  "allow-storage-access-by-user-activation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context (the one named _top).
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation": !1,
  // [MDN] Lets the resource navigate the top-level browsing context, but only if initiated by a user gesture.
  // [REASON] Prevents embed from navigating away from tldraw and pretending to be us.
  "allow-top-navigation-by-user-activation": !1,
  // ========================================================================================
  // Enabled permissions
  // ========================================================================================
  // [MDN] Lets the resource run scripts (but not create popup windows).
  "allow-scripts": !0,
  // [MDN] If this token is not used, the resource is treated as being from a special origin that always fails the same-origin policy (potentially preventing access to data storage/cookies and some JavaScript APIs).
  "allow-same-origin": !0,
  // [MDN] Allows the resource to submit forms. If this keyword is not used, form submission is blocked.
  "allow-forms": !0
}, Kme = $j.map(
  (n) => n.type
);
function Wme(n) {
  return Kme.includes(n);
}
function Gme(n) {
  return "icon" in n;
}
function QK() {
  return be().getShapeUtil("embed");
}
function Bj() {
  const n = QK();
  return (e) => n ? n.getEmbedDefinition(e) : void 0;
}
function qme() {
  const n = QK();
  return n ? n.getEmbedDefinitions() : [];
}
const JK = Ho(function({ onClose: e }) {
  const t = be(), r = Ln(), i = jj(), [s, l] = M.useState(null), [c, d] = M.useState(""), [h, g] = M.useState(null), [y, v] = M.useState(!1), w = M.useRef(-1), C = qme(), E = Bj();
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(I_, { children: [
      /* @__PURE__ */ m.jsx(k_, { children: s ? `${r("embed-dialog.title")} — ${s.title}` : r("embed-dialog.title") }),
      /* @__PURE__ */ m.jsx(R_, {})
    ] }),
    s ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsxs(nw, { className: "tlui-embed-dialog__enter", children: [
        /* @__PURE__ */ m.jsx(
          M_,
          {
            className: "tlui-embed-dialog__input",
            label: "embed-dialog.url",
            placeholder: "https://example.com",
            autoFocus: !0,
            onValueChange: (P) => {
              d(P);
              const I = E(P);
              g(
                I && I.definition.type === s.type ? I : null
              ), v(!1), clearTimeout(w.current), w.current = t.timers.setTimeout(
                () => v(!I),
                320
              );
            }
          }
        ),
        c === "" ? /* @__PURE__ */ m.jsxs("div", { className: "tlui-embed-dialog__instruction", children: [
          /* @__PURE__ */ m.jsx("span", { children: r("embed-dialog.instruction") }),
          " ",
          s.instructionLink && /* @__PURE__ */ m.jsxs(
            "a",
            {
              target: "_blank",
              rel: "noopener noreferrer",
              href: s.instructionLink,
              className: "tlui-embed-dialog__instruction__link",
              children: [
                "Learn more.",
                /* @__PURE__ */ m.jsx(ku, { icon: "external-link", small: !0 })
              ]
            }
          )
        ] }) : /* @__PURE__ */ m.jsx("div", { className: "tlui-embed-dialog__warning", children: y ? r("embed-dialog.invalid-url") : " " })
      ] }),
      /* @__PURE__ */ m.jsxs(Uj, { className: "tlui-dialog__footer__actions", children: [
        /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "normal",
            onClick: () => {
              l(null), g(null), d("");
            },
            children: /* @__PURE__ */ m.jsx(_i, { children: r("embed-dialog.back") })
          }
        ),
        /* @__PURE__ */ m.jsx("div", { className: "tlui-embed__spacer" }),
        /* @__PURE__ */ m.jsx(Ot, { type: "normal", onClick: e, children: /* @__PURE__ */ m.jsx(_i, { children: r("embed-dialog.cancel") }) }),
        /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "primary",
            disabled: !h,
            onClick: () => {
              h && (t.putExternalContent({
                type: "embed",
                url: c,
                point: t.getViewportPageBounds().center,
                embed: h.definition
              }), e());
            },
            children: /* @__PURE__ */ m.jsx(_i, { children: r("embed-dialog.create") })
          }
        )
      ] })
    ] }) : /* @__PURE__ */ m.jsx(m.Fragment, { children: /* @__PURE__ */ m.jsx(nw, { className: "tlui-embed-dialog__list", children: C.map((P) => {
      const I = Wme(P.type) ? i.embedIcons[P.type] : Gme(P) ? P.icon : void 0;
      return /* @__PURE__ */ m.jsxs(Ot, { type: "menu", onClick: () => l(P), children: [
        /* @__PURE__ */ m.jsx(_i, { children: P.title }),
        I && /* @__PURE__ */ m.jsx(
          "div",
          {
            className: "tlui-embed-dialog__item__image",
            style: { backgroundImage: `url(${I})` }
          }
        )
      ] }, P.type);
    }) }) })
  ] });
});
async function Yme(n, e, t) {
  const r = rn(
    e.map((c) => {
      const d = n.getShape(c);
      if (!(!d || n.getShapeUtil(d.type).toSvg === void 0))
        return d;
    })
  );
  if (r.length === 0) return;
  if (r.length === 1) {
    const c = r[0];
    if (!c || n.isShapeOfType(c, "image")) return;
  }
  const i = [];
  if (t !== void 0) {
    const c = r.map((d) => ({
      shape: d,
      bounds: n.getShapeMaskedPageBounds(d).clone().expandBy(t)
    }));
    for (let d = 0; d < c.length; d++) {
      const h = c[d];
      if (d === 0) {
        i[0] = {
          shapes: [h.shape],
          bounds: h.bounds
        };
        continue;
      }
      let g = !1;
      for (const y of i)
        if (y.bounds.includes(h.bounds)) {
          y.shapes.push(h.shape), y.bounds.expand(h.bounds), g = !0;
          break;
        }
      g || i.push({
        shapes: [h.shape],
        bounds: h.bounds
      });
    }
  } else {
    const c = Xe.Common(r.map((d) => n.getShapeMaskedPageBounds(d)));
    i.push({
      shapes: r,
      bounds: c
    });
  }
  const s = n.options.flattenImageBoundsPadding;
  for (const c of i) {
    t !== void 0 && c.bounds.expandBy(-t);
    const d = await n.getSvgString(c.shapes, {
      padding: s
    });
    if (!(d != null && d.svg)) continue;
    const h = new Blob([d.svg], { type: "image/svg+xml" }), g = await n.getAssetForExternalContent({
      type: "file",
      file: new File([h], "asset.svg", { type: "image/svg+xml" })
    });
    g && (c.asset = g);
  }
  const l = [];
  return Dl(() => {
    for (const c of i) {
      const { asset: d, bounds: h, shapes: g } = c;
      if (!d) continue;
      const y = n.findCommonAncestor(g) ?? n.getCurrentPageId();
      if (!y) continue;
      let v = "a1";
      for (const I of g)
        if (I.parentId === y) {
          I.index > v && (v = I.index);
          break;
        }
      let w, C, E;
      if (va(y)) {
        const I = n.getShape(y);
        if (!I) continue;
        const k = n.getPointInShapeSpace(I, {
          x: h.x,
          y: h.y
        });
        E = n.getShapePageTransform(y).rotation(), k.sub(new R(s, s).rot(-E)), w = k.x, C = k.y;
      } else
        w = h.x - s, C = h.y - s, E = 0;
      n.deleteShapes(g), n.createAssets([{ ...d, id: d.id }]);
      const P = Sr();
      n.createShape({
        id: P,
        type: "image",
        index: v,
        parentId: y,
        x: w,
        y: C,
        rotation: -E,
        props: {
          assetId: d.id,
          w: h.w + s * 2,
          h: h.h + s * 2
        }
      }), l.push(P);
    }
  }), l;
}
function A_() {
  const n = _h();
  return (n == null ? void 0 : n.store.props.collaboration) !== void 0;
}
function Xme() {
  const n = _h();
  return Pe(
    "sync status",
    () => {
      var e;
      return (e = n == null ? void 0 : n.store.props.collaboration) != null && e.status ? n.store.props.collaboration.status.get() : null;
    },
    [n]
  );
}
const WM = [0, 389, 436, 476, 580, 640, 840, 1023];
var yi = /* @__PURE__ */ ((n) => (n[n.ZERO = 0] = "ZERO", n[n.MOBILE_XXS = 1] = "MOBILE_XXS", n[n.MOBILE_XS = 2] = "MOBILE_XS", n[n.MOBILE_SM = 3] = "MOBILE_SM", n[n.MOBILE = 4] = "MOBILE", n[n.TABLET_SM = 5] = "TABLET_SM", n[n.TABLET = 6] = "TABLET", n[n.DESKTOP = 7] = "DESKTOP", n))(yi || {});
const eW = Bt.createContext(null);
function Zme({ forceMobile: n = !1, children: e }) {
  const t = _h(), r = Pe(
    "breakpoint",
    () => {
      const { width: i } = (t == null ? void 0 : t.getViewportScreenBounds()) ?? { width: window.innerWidth }, s = n ? yi.MOBILE_SM : WM.length - 1;
      for (let l = 0; l < s; l++)
        if (i > WM[l] && i <= WM[l + 1])
          return l;
      return s;
    },
    [t]
  );
  return /* @__PURE__ */ m.jsx(eW.Provider, { value: r, children: e });
}
function qs() {
  const n = M.useContext(eW);
  if (n === null)
    throw new Error("useBreakpoint must be used inside of the <BreakpointProvider /> component");
  return n;
}
const tW = M.createContext(null);
function Qme({ context: n, children: e }) {
  const t = Vo(), r = uw("dialogs", []), i = M.useMemo(() => ({
    dialogs: r,
    addDialog(s) {
      const l = s.id ?? or();
      return r.update((c) => [...c.filter((d) => d.id !== s.id), { ...s, id: l }]), t("open-menu", { source: "dialog", id: l }), gc.addOpenMenu(l, n), l;
    },
    removeDialog(s) {
      var c;
      const l = r.get().find((d) => d.id === s);
      return l && ((c = l.onClose) == null || c.call(l), t("close-menu", { source: "dialog", id: s }), gc.deleteOpenMenu(s, n), r.update((d) => d.filter((h) => h !== l))), s;
    },
    clearDialogs() {
      const s = r.get();
      s.length !== 0 && (s.forEach((l) => {
        var c;
        (c = l.onClose) == null || c.call(l), t("close-menu", { source: "dialog", id: l.id }), gc.deleteOpenMenu(l.id, n);
      }), r.set([]));
    }
  }), [t, r, n]);
  return /* @__PURE__ */ m.jsx(tW.Provider, { value: i, children: e });
}
function Dw() {
  const n = M.useContext(tW);
  if (!n)
    throw new Error("useDialogs must be used within a DialogsProvider");
  return n;
}
var Jme = "VisuallyHidden", Hj = M.forwardRef(
  (n, e) => /* @__PURE__ */ m.jsx(
    Wn.span,
    {
      ...n,
      ref: e,
      style: {
        // See: https://github.com/twbs/bootstrap/blob/main/scss/mixins/_visually-hidden.scss
        position: "absolute",
        border: 0,
        width: 1,
        height: 1,
        padding: 0,
        margin: -1,
        overflow: "hidden",
        clip: "rect(0, 0, 0, 0)",
        whiteSpace: "nowrap",
        wordWrap: "normal",
        ...n.style
      }
    }
  )
);
Hj.displayName = Jme;
var Vj = "ToastProvider", [Kj, eye, tye] = m_("Toast"), [nW, mEe] = ju("Toast", [tye]), [nye, D_] = nW(Vj), rW = (n) => {
  const {
    __scopeToast: e,
    label: t = "Notification",
    duration: r = 5e3,
    swipeDirection: i = "right",
    swipeThreshold: s = 50,
    children: l
  } = n, [c, d] = M.useState(null), [h, g] = M.useState(0), y = M.useRef(!1), v = M.useRef(!1);
  return t.trim() || console.error(
    `Invalid prop \`label\` supplied to \`${Vj}\`. Expected non-empty \`string\`.`
  ), /* @__PURE__ */ m.jsx(Kj.Provider, { scope: e, children: /* @__PURE__ */ m.jsx(
    nye,
    {
      scope: e,
      label: t,
      duration: r,
      swipeDirection: i,
      swipeThreshold: s,
      toastCount: h,
      viewport: c,
      onViewportChange: d,
      onToastAdd: M.useCallback(() => g((w) => w + 1), []),
      onToastRemove: M.useCallback(() => g((w) => w - 1), []),
      isFocusedToastEscapeKeyDownRef: y,
      isClosePausedRef: v,
      children: l
    }
  ) });
};
rW.displayName = Vj;
var iW = "ToastViewport", rye = ["F8"], mD = "toast.viewportPause", yD = "toast.viewportResume", oW = M.forwardRef(
  (n, e) => {
    const {
      __scopeToast: t,
      hotkey: r = rye,
      label: i = "Notifications ({hotkey})",
      ...s
    } = n, l = D_(iW, t), c = eye(t), d = M.useRef(null), h = M.useRef(null), g = M.useRef(null), y = M.useRef(null), v = jr(e, y, l.onViewportChange), w = r.join("+").replace(/Key/g, "").replace(/Digit/g, ""), C = l.toastCount > 0;
    M.useEffect(() => {
      const P = (I) => {
        var L;
        r.length !== 0 && r.every((O) => I[O] || I.code === O) && ((L = y.current) == null || L.focus());
      };
      return document.addEventListener("keydown", P), () => document.removeEventListener("keydown", P);
    }, [r]), M.useEffect(() => {
      const P = d.current, I = y.current;
      if (C && P && I) {
        const k = () => {
          if (!l.isClosePausedRef.current) {
            const F = new CustomEvent(mD);
            I.dispatchEvent(F), l.isClosePausedRef.current = !0;
          }
        }, L = () => {
          if (l.isClosePausedRef.current) {
            const F = new CustomEvent(yD);
            I.dispatchEvent(F), l.isClosePausedRef.current = !1;
          }
        }, O = (F) => {
          !P.contains(F.relatedTarget) && L();
        }, z = () => {
          P.contains(document.activeElement) || L();
        };
        return P.addEventListener("focusin", k), P.addEventListener("focusout", O), P.addEventListener("pointermove", k), P.addEventListener("pointerleave", z), window.addEventListener("blur", k), window.addEventListener("focus", L), () => {
          P.removeEventListener("focusin", k), P.removeEventListener("focusout", O), P.removeEventListener("pointermove", k), P.removeEventListener("pointerleave", z), window.removeEventListener("blur", k), window.removeEventListener("focus", L);
        };
      }
    }, [C, l.isClosePausedRef]);
    const E = M.useCallback(
      ({ tabbingDirection: P }) => {
        const k = c().map((L) => {
          const O = L.ref.current, z = [O, ...mye(O)];
          return P === "forwards" ? z : z.reverse();
        });
        return (P === "forwards" ? k.reverse() : k).flat();
      },
      [c]
    );
    return M.useEffect(() => {
      const P = y.current;
      if (P) {
        const I = (k) => {
          var z, F, H;
          const L = k.altKey || k.ctrlKey || k.metaKey;
          if (k.key === "Tab" && !L) {
            const V = document.activeElement, re = k.shiftKey;
            if (k.target === P && re) {
              (z = h.current) == null || z.focus();
              return;
            }
            const ie = E({ tabbingDirection: re ? "backwards" : "forwards" }), W = ie.findIndex((Y) => Y === V);
            GM(ie.slice(W + 1)) ? k.preventDefault() : re ? (F = h.current) == null || F.focus() : (H = g.current) == null || H.focus();
          }
        };
        return P.addEventListener("keydown", I), () => P.removeEventListener("keydown", I);
      }
    }, [c, E]), /* @__PURE__ */ m.jsxs(
      Mfe,
      {
        ref: d,
        role: "region",
        "aria-label": i.replace("{hotkey}", w),
        tabIndex: -1,
        style: { pointerEvents: C ? void 0 : "none" },
        children: [
          C && /* @__PURE__ */ m.jsx(
            vD,
            {
              ref: h,
              onFocusFromOutsideViewport: () => {
                const P = E({
                  tabbingDirection: "forwards"
                });
                GM(P);
              }
            }
          ),
          /* @__PURE__ */ m.jsx(Kj.Slot, { scope: t, children: /* @__PURE__ */ m.jsx(Wn.ol, { tabIndex: -1, ...s, ref: v }) }),
          C && /* @__PURE__ */ m.jsx(
            vD,
            {
              ref: g,
              onFocusFromOutsideViewport: () => {
                const P = E({
                  tabbingDirection: "backwards"
                });
                GM(P);
              }
            }
          )
        ]
      }
    );
  }
);
oW.displayName = iW;
var sW = "ToastFocusProxy", vD = M.forwardRef(
  (n, e) => {
    const { __scopeToast: t, onFocusFromOutsideViewport: r, ...i } = n, s = D_(sW, t);
    return /* @__PURE__ */ m.jsx(
      Hj,
      {
        "aria-hidden": !0,
        tabIndex: 0,
        ...i,
        ref: e,
        style: { position: "fixed" },
        onFocus: (l) => {
          var h;
          const c = l.relatedTarget;
          !((h = s.viewport) != null && h.contains(c)) && r();
        }
      }
    );
  }
);
vD.displayName = sW;
var O_ = "Toast", iye = "toast.swipeStart", oye = "toast.swipeMove", sye = "toast.swipeCancel", aye = "toast.swipeEnd", aW = M.forwardRef(
  (n, e) => {
    const { forceMount: t, open: r, defaultOpen: i, onOpenChange: s, ...l } = n, [c = !0, d] = Ih({
      prop: r,
      defaultProp: i,
      onChange: s
    });
    return /* @__PURE__ */ m.jsx(kc, { present: t || c, children: /* @__PURE__ */ m.jsx(
      uye,
      {
        open: c,
        ...l,
        ref: e,
        onClose: () => d(!1),
        onPause: $o(n.onPause),
        onResume: $o(n.onResume),
        onSwipeStart: bt(n.onSwipeStart, (h) => {
          h.currentTarget.setAttribute("data-swipe", "start");
        }),
        onSwipeMove: bt(n.onSwipeMove, (h) => {
          const { x: g, y } = h.detail.delta;
          h.currentTarget.setAttribute("data-swipe", "move"), h.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${g}px`), h.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${y}px`);
        }),
        onSwipeCancel: bt(n.onSwipeCancel, (h) => {
          h.currentTarget.setAttribute("data-swipe", "cancel"), h.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), h.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), h.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"), h.currentTarget.style.removeProperty("--radix-toast-swipe-end-y");
        }),
        onSwipeEnd: bt(n.onSwipeEnd, (h) => {
          const { x: g, y } = h.detail.delta;
          h.currentTarget.setAttribute("data-swipe", "end"), h.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"), h.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"), h.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${g}px`), h.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${y}px`), d(!1);
        })
      }
    ) });
  }
);
aW.displayName = O_;
var [lye, cye] = nW(O_, {
  onClose() {
  }
}), uye = M.forwardRef(
  (n, e) => {
    const {
      __scopeToast: t,
      type: r = "foreground",
      duration: i,
      open: s,
      onClose: l,
      onEscapeKeyDown: c,
      onPause: d,
      onResume: h,
      onSwipeStart: g,
      onSwipeMove: y,
      onSwipeCancel: v,
      onSwipeEnd: w,
      ...C
    } = n, E = D_(O_, t), [P, I] = M.useState(null), k = jr(e, (Y) => I(Y)), L = M.useRef(null), O = M.useRef(null), z = i || E.duration, F = M.useRef(0), H = M.useRef(z), V = M.useRef(0), { onToastAdd: re, onToastRemove: q } = E, J = $o(() => {
      var oe;
      (P == null ? void 0 : P.contains(document.activeElement)) && ((oe = E.viewport) == null || oe.focus()), l();
    }), ie = M.useCallback(
      (Y) => {
        !Y || Y === 1 / 0 || (window.clearTimeout(V.current), F.current = (/* @__PURE__ */ new Date()).getTime(), V.current = window.setTimeout(J, Y));
      },
      [J]
    );
    M.useEffect(() => {
      const Y = E.viewport;
      if (Y) {
        const oe = () => {
          ie(H.current), h == null || h();
        }, le = () => {
          const ce = (/* @__PURE__ */ new Date()).getTime() - F.current;
          H.current = H.current - ce, window.clearTimeout(V.current), d == null || d();
        };
        return Y.addEventListener(mD, le), Y.addEventListener(yD, oe), () => {
          Y.removeEventListener(mD, le), Y.removeEventListener(yD, oe);
        };
      }
    }, [E.viewport, z, d, h, ie]), M.useEffect(() => {
      s && !E.isClosePausedRef.current && ie(z);
    }, [s, z, E.isClosePausedRef, ie]), M.useEffect(() => (re(), () => q()), [re, q]);
    const W = M.useMemo(() => P ? pW(P) : null, [P]);
    return E.viewport ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      W && /* @__PURE__ */ m.jsx(
        dye,
        {
          __scopeToast: t,
          role: "status",
          "aria-live": r === "foreground" ? "assertive" : "polite",
          "aria-atomic": !0,
          children: W
        }
      ),
      /* @__PURE__ */ m.jsx(lye, { scope: t, onClose: J, children: Gy.createPortal(
        /* @__PURE__ */ m.jsx(Kj.ItemSlot, { scope: t, children: /* @__PURE__ */ m.jsx(
          Rfe,
          {
            asChild: !0,
            onEscapeKeyDown: bt(c, () => {
              E.isFocusedToastEscapeKeyDownRef.current || J(), E.isFocusedToastEscapeKeyDownRef.current = !1;
            }),
            children: /* @__PURE__ */ m.jsx(
              Wn.li,
              {
                role: "status",
                "aria-live": "off",
                "aria-atomic": !0,
                tabIndex: 0,
                "data-state": s ? "open" : "closed",
                "data-swipe-direction": E.swipeDirection,
                ...C,
                ref: k,
                style: { userSelect: "none", touchAction: "none", ...n.style },
                onKeyDown: bt(n.onKeyDown, (Y) => {
                  Y.key === "Escape" && (c == null || c(Y.nativeEvent), Y.nativeEvent.defaultPrevented || (E.isFocusedToastEscapeKeyDownRef.current = !0, J()));
                }),
                onPointerDown: bt(n.onPointerDown, (Y) => {
                  Y.button === 0 && (L.current = { x: Y.clientX, y: Y.clientY });
                }),
                onPointerMove: bt(n.onPointerMove, (Y) => {
                  if (!L.current) return;
                  const oe = Y.clientX - L.current.x, le = Y.clientY - L.current.y, ce = !!O.current, Q = ["left", "right"].includes(E.swipeDirection), he = ["left", "up"].includes(E.swipeDirection) ? Math.min : Math.max, ke = Q ? he(0, oe) : 0, te = Q ? 0 : he(0, le), me = Y.pointerType === "touch" ? 10 : 2, Oe = { x: ke, y: te }, Ze = { originalEvent: Y, delta: Oe };
                  ce ? (O.current = Oe, nC(oye, y, Ze, {
                    discrete: !1
                  })) : OU(Oe, E.swipeDirection, me) ? (O.current = Oe, nC(iye, g, Ze, {
                    discrete: !1
                  }), Y.target.setPointerCapture(Y.pointerId)) : (Math.abs(oe) > me || Math.abs(le) > me) && (L.current = null);
                }),
                onPointerUp: bt(n.onPointerUp, (Y) => {
                  const oe = O.current, le = Y.target;
                  if (le.hasPointerCapture(Y.pointerId) && le.releasePointerCapture(Y.pointerId), O.current = null, L.current = null, oe) {
                    const ce = Y.currentTarget, Q = { originalEvent: Y, delta: oe };
                    OU(oe, E.swipeDirection, E.swipeThreshold) ? nC(aye, w, Q, {
                      discrete: !0
                    }) : nC(
                      sye,
                      v,
                      Q,
                      {
                        discrete: !0
                      }
                    ), ce.addEventListener("click", (he) => he.preventDefault(), {
                      once: !0
                    });
                  }
                })
              }
            )
          }
        ) }),
        E.viewport
      ) })
    ] }) : null;
  }
), dye = (n) => {
  const { __scopeToast: e, children: t, ...r } = n, i = D_(O_, e), [s, l] = M.useState(!1), [c, d] = M.useState(!1);
  return pye(() => l(!0)), M.useEffect(() => {
    const h = window.setTimeout(() => d(!0), 1e3);
    return () => window.clearTimeout(h);
  }, []), c ? null : /* @__PURE__ */ m.jsx(kw, { asChild: !0, children: /* @__PURE__ */ m.jsx(Hj, { ...r, children: s && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    i.label,
    " ",
    t
  ] }) }) });
}, fye = "ToastTitle", lW = M.forwardRef(
  (n, e) => {
    const { __scopeToast: t, ...r } = n;
    return /* @__PURE__ */ m.jsx(Wn.div, { ...r, ref: e });
  }
);
lW.displayName = fye;
var hye = "ToastDescription", cW = M.forwardRef(
  (n, e) => {
    const { __scopeToast: t, ...r } = n;
    return /* @__PURE__ */ m.jsx(Wn.div, { ...r, ref: e });
  }
);
cW.displayName = hye;
var uW = "ToastAction", dW = M.forwardRef(
  (n, e) => {
    const { altText: t, ...r } = n;
    return t.trim() ? /* @__PURE__ */ m.jsx(hW, { altText: t, asChild: !0, children: /* @__PURE__ */ m.jsx(Wj, { ...r, ref: e }) }) : (console.error(
      `Invalid prop \`altText\` supplied to \`${uW}\`. Expected non-empty \`string\`.`
    ), null);
  }
);
dW.displayName = uW;
var fW = "ToastClose", Wj = M.forwardRef(
  (n, e) => {
    const { __scopeToast: t, ...r } = n, i = cye(fW, t);
    return /* @__PURE__ */ m.jsx(hW, { asChild: !0, children: /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: bt(n.onClick, i.onClose)
      }
    ) });
  }
);
Wj.displayName = fW;
var hW = M.forwardRef((n, e) => {
  const { __scopeToast: t, altText: r, ...i } = n;
  return /* @__PURE__ */ m.jsx(
    Wn.div,
    {
      "data-radix-toast-announce-exclude": "",
      "data-radix-toast-announce-alt": r || void 0,
      ...i,
      ref: e
    }
  );
});
function pW(n) {
  const e = [];
  return Array.from(n.childNodes).forEach((r) => {
    if (r.nodeType === r.TEXT_NODE && r.textContent && e.push(r.textContent), gye(r)) {
      const i = r.ariaHidden || r.hidden || r.style.display === "none", s = r.dataset.radixToastAnnounceExclude === "";
      if (!i)
        if (s) {
          const l = r.dataset.radixToastAnnounceAlt;
          l && e.push(l);
        } else
          e.push(...pW(r));
    }
  }), e;
}
function nC(n, e, t, { discrete: r }) {
  const i = t.originalEvent.currentTarget, s = new CustomEvent(n, { bubbles: !0, cancelable: !0, detail: t });
  e && i.addEventListener(n, e, { once: !0 }), r ? sj(i, s) : i.dispatchEvent(s);
}
var OU = (n, e, t = 0) => {
  const r = Math.abs(n.x), i = Math.abs(n.y), s = r > i;
  return e === "left" || e === "right" ? s && r > t : !s && i > t;
};
function pye(n = () => {
}) {
  const e = $o(n);
  yh(() => {
    let t = 0, r = 0;
    return t = window.requestAnimationFrame(() => r = window.requestAnimationFrame(e)), () => {
      window.cancelAnimationFrame(t), window.cancelAnimationFrame(r);
    };
  }, [e]);
}
function gye(n) {
  return n.nodeType === n.ELEMENT_NODE;
}
function mye(n) {
  const e = [], t = document.createTreeWalker(n, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (r) => {
      const i = r.tagName === "INPUT" && r.type === "hidden";
      return r.disabled || r.hidden || i ? NodeFilter.FILTER_SKIP : r.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; t.nextNode(); ) e.push(t.currentNode);
  return e;
}
function GM(n) {
  const e = document.activeElement;
  return n.some((t) => t === e ? !0 : (t.focus(), document.activeElement !== e));
}
var yye = aW, vye = lW, Sye = cW, xye = dW, jU = Wj;
const gW = M.createContext(null);
function wye({ children: n }) {
  const e = uw("toasts", []), t = M.useMemo(() => ({
    toasts: e,
    addToast(r) {
      const i = r.id ?? or();
      return e.update((s) => [...s.filter((l) => l.id !== r.id), { ...r, id: i }]), i;
    },
    removeToast(r) {
      return e.update((i) => i.filter((s) => s.id !== r)), r;
    },
    clearToasts() {
      e.set([]);
    }
  }), [e]);
  return /* @__PURE__ */ m.jsx(rW, { children: /* @__PURE__ */ m.jsx(gW.Provider, { value: t, children: n }) });
}
function Yd() {
  const n = M.useContext(gW);
  if (!n)
    throw new Error("useToasts must be used within a ToastsProvider");
  return n;
}
var TC = { exports: {} };
TC.exports;
var LU;
function bye() {
  return LU || (LU = 1, function(n) {
    var e = function() {
      var t = String.fromCharCode, r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$", s = {};
      function l(d, h) {
        if (!s[d]) {
          s[d] = {};
          for (var g = 0; g < d.length; g++)
            s[d][d.charAt(g)] = g;
        }
        return s[d][h];
      }
      var c = {
        compressToBase64: function(d) {
          if (d == null) return "";
          var h = c._compress(d, 6, function(g) {
            return r.charAt(g);
          });
          switch (h.length % 4) {
            // To produce valid Base64
            default:
            // When could this happen ?
            case 0:
              return h;
            case 1:
              return h + "===";
            case 2:
              return h + "==";
            case 3:
              return h + "=";
          }
        },
        decompressFromBase64: function(d) {
          return d == null ? "" : d == "" ? null : c._decompress(d.length, 32, function(h) {
            return l(r, d.charAt(h));
          });
        },
        compressToUTF16: function(d) {
          return d == null ? "" : c._compress(d, 15, function(h) {
            return t(h + 32);
          }) + " ";
        },
        decompressFromUTF16: function(d) {
          return d == null ? "" : d == "" ? null : c._decompress(d.length, 16384, function(h) {
            return d.charCodeAt(h) - 32;
          });
        },
        //compress into uint8array (UCS-2 big endian format)
        compressToUint8Array: function(d) {
          for (var h = c.compress(d), g = new Uint8Array(h.length * 2), y = 0, v = h.length; y < v; y++) {
            var w = h.charCodeAt(y);
            g[y * 2] = w >>> 8, g[y * 2 + 1] = w % 256;
          }
          return g;
        },
        //decompress from uint8array (UCS-2 big endian format)
        decompressFromUint8Array: function(d) {
          if (d == null)
            return c.decompress(d);
          for (var h = new Array(d.length / 2), g = 0, y = h.length; g < y; g++)
            h[g] = d[g * 2] * 256 + d[g * 2 + 1];
          var v = [];
          return h.forEach(function(w) {
            v.push(t(w));
          }), c.decompress(v.join(""));
        },
        //compress into a string that is already URI encoded
        compressToEncodedURIComponent: function(d) {
          return d == null ? "" : c._compress(d, 6, function(h) {
            return i.charAt(h);
          });
        },
        //decompress from an output of compressToEncodedURIComponent
        decompressFromEncodedURIComponent: function(d) {
          return d == null ? "" : d == "" ? null : (d = d.replace(/ /g, "+"), c._decompress(d.length, 32, function(h) {
            return l(i, d.charAt(h));
          }));
        },
        compress: function(d) {
          return c._compress(d, 16, function(h) {
            return t(h);
          });
        },
        _compress: function(d, h, g) {
          if (d == null) return "";
          var y, v, w = {}, C = {}, E = "", P = "", I = "", k = 2, L = 3, O = 2, z = [], F = 0, H = 0, V;
          for (V = 0; V < d.length; V += 1)
            if (E = d.charAt(V), Object.prototype.hasOwnProperty.call(w, E) || (w[E] = L++, C[E] = !0), P = I + E, Object.prototype.hasOwnProperty.call(w, P))
              I = P;
            else {
              if (Object.prototype.hasOwnProperty.call(C, I)) {
                if (I.charCodeAt(0) < 256) {
                  for (y = 0; y < O; y++)
                    F = F << 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++;
                  for (v = I.charCodeAt(0), y = 0; y < 8; y++)
                    F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
                } else {
                  for (v = 1, y = 0; y < O; y++)
                    F = F << 1 | v, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = 0;
                  for (v = I.charCodeAt(0), y = 0; y < 16; y++)
                    F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
                }
                k--, k == 0 && (k = Math.pow(2, O), O++), delete C[I];
              } else
                for (v = w[I], y = 0; y < O; y++)
                  F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
              k--, k == 0 && (k = Math.pow(2, O), O++), w[P] = L++, I = String(E);
            }
          if (I !== "") {
            if (Object.prototype.hasOwnProperty.call(C, I)) {
              if (I.charCodeAt(0) < 256) {
                for (y = 0; y < O; y++)
                  F = F << 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++;
                for (v = I.charCodeAt(0), y = 0; y < 8; y++)
                  F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
              } else {
                for (v = 1, y = 0; y < O; y++)
                  F = F << 1 | v, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = 0;
                for (v = I.charCodeAt(0), y = 0; y < 16; y++)
                  F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
              }
              k--, k == 0 && (k = Math.pow(2, O), O++), delete C[I];
            } else
              for (v = w[I], y = 0; y < O; y++)
                F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
            k--, k == 0 && (k = Math.pow(2, O), O++);
          }
          for (v = 2, y = 0; y < O; y++)
            F = F << 1 | v & 1, H == h - 1 ? (H = 0, z.push(g(F)), F = 0) : H++, v = v >> 1;
          for (; ; )
            if (F = F << 1, H == h - 1) {
              z.push(g(F));
              break;
            } else H++;
          return z.join("");
        },
        decompress: function(d) {
          return d == null ? "" : d == "" ? null : c._decompress(d.length, 32768, function(h) {
            return d.charCodeAt(h);
          });
        },
        _decompress: function(d, h, g) {
          var y = [], v = 4, w = 4, C = 3, E = "", P = [], I, k, L, O, z, F, H, V = { val: g(0), position: h, index: 1 };
          for (I = 0; I < 3; I += 1)
            y[I] = I;
          for (L = 0, z = Math.pow(2, 2), F = 1; F != z; )
            O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
          switch (L) {
            case 0:
              for (L = 0, z = Math.pow(2, 8), F = 1; F != z; )
                O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
              H = t(L);
              break;
            case 1:
              for (L = 0, z = Math.pow(2, 16), F = 1; F != z; )
                O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
              H = t(L);
              break;
            case 2:
              return "";
          }
          for (y[3] = H, k = H, P.push(H); ; ) {
            if (V.index > d)
              return "";
            for (L = 0, z = Math.pow(2, C), F = 1; F != z; )
              O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
            switch (H = L) {
              case 0:
                for (L = 0, z = Math.pow(2, 8), F = 1; F != z; )
                  O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
                y[w++] = t(L), H = w - 1, v--;
                break;
              case 1:
                for (L = 0, z = Math.pow(2, 16), F = 1; F != z; )
                  O = V.val & V.position, V.position >>= 1, V.position == 0 && (V.position = h, V.val = g(V.index++)), L |= (O > 0 ? 1 : 0) * F, F <<= 1;
                y[w++] = t(L), H = w - 1, v--;
                break;
              case 2:
                return P.join("");
            }
            if (v == 0 && (v = Math.pow(2, C), C++), y[H])
              E = y[H];
            else if (H === w)
              E = k + k.charAt(0);
            else
              return null;
            P.push(E), y[w++] = k + E.charAt(0), v--, k = E, v == 0 && (v = Math.pow(2, C), C++);
          }
        }
      };
      return c;
    }();
    n != null ? n.exports = e : typeof angular < "u" && angular != null && angular.module("LZString", []).factory("LZString", function() {
      return e;
    });
  }(TC)), TC.exports;
}
var Cye = bye();
const mW = /* @__PURE__ */ wh(Cye), Gj = "web image/vnd.tldraw+png", Eye = {
  "image/png": Gj
}, _ye = {
  [Gj]: "image/png"
};
function Pye(n) {
  return ys(Eye, n) ?? null;
}
function Tye(n) {
  return ys(_ye, n) ?? n;
}
function Iye(n) {
  return typeof ClipboardItem < "u" && "supports" in ClipboardItem && ClipboardItem.supports(n);
}
function kye(n) {
  const e = Object.entries(n);
  for (const [t, r] of e) r.catch((i) => console.error(i));
  return navigator.clipboard.write([new ClipboardItem(n)]).catch((t) => (console.error(t), Promise.all(
    e.map(async ([r, i]) => [r, await i])
  ).then((r) => {
    const i = XD(r);
    return navigator.clipboard.write([new ClipboardItem(i)]);
  })));
}
async function Rye(n, e, t) {
  var I, k, L;
  const { elements: r, files: i } = e, s = {
    shapes: [],
    bindings: [],
    rootShapeIds: [],
    assets: [],
    schema: n.store.schema.serialize()
  }, l = /* @__PURE__ */ new Map(), c = /* @__PURE__ */ new Map(), d = n.getCurrentPageId(), h = /* @__PURE__ */ new Map(), g = [], y = /* @__PURE__ */ new Set();
  r.forEach((O) => {
    if (h.set(O.id, Sr()), O.boundElements !== null)
      for (const z of O.boundElements)
        z.type === "text" && y.add(z.id);
  });
  let v = i6;
  for (const O of r) {
    if (y.has(O.id))
      continue;
    const z = h.get(O.id), F = {
      id: z,
      typeName: "shape",
      parentId: d,
      index: v,
      x: O.x,
      y: O.y,
      rotation: 0,
      isLocked: O.locked,
      opacity: Mye(O.opacity),
      meta: {}
    };
    switch (O.angle !== 0 && c.set(z, O.angle), O.groupIds && O.groupIds.length > 0 ? l.has(O.groupIds[0]) ? (I = l.get(O.groupIds[0])) == null || I.push(z) : l.set(O.groupIds[0], [z]) : g.push(z), O.type) {
      case "rectangle":
      case "ellipse":
      case "diamond": {
        let H = "", V = "middle";
        if (O.boundElements !== null) {
          for (const q of O.boundElements)
            if (q.type === "text") {
              const J = r.find((ie) => ie.id === q.id);
              J && (H = J.text, V = Fye[J.textAlign]);
            }
        }
        const re = O.backgroundColor === "transparent" ? O.strokeColor : O.backgroundColor;
        s.shapes.push({
          ...F,
          type: "geo",
          props: {
            geo: O.type,
            url: O.link ?? "",
            w: O.width,
            h: O.height,
            size: rC[O.strokeWidth] ?? "draw",
            color: ux[re] ?? "black",
            text: H,
            align: V,
            dash: iC(O),
            fill: $ye(O)
          }
        });
        break;
      }
      case "freedraw": {
        s.shapes.push({
          ...F,
          type: "draw",
          props: {
            dash: iC(O),
            size: rC[O.strokeWidth],
            color: ux[O.strokeColor] ?? "black",
            segments: [
              {
                type: "free",
                points: O.points.map(([H, V, re = 0.5]) => ({
                  x: H,
                  y: V,
                  z: re
                }))
              }
            ]
          }
        });
        break;
      }
      case "line": {
        if (O.points.slice().length < 2)
          break;
        const V = Vx(O.points.length);
        s.shapes.push({
          ...F,
          type: "line",
          props: {
            dash: iC(O),
            size: rC[O.strokeWidth],
            color: ux[O.strokeColor] ?? "black",
            spline: O.roundness ? "cubic" : "line",
            points: {
              ...Object.fromEntries(
                O.points.map(([re, q], J) => {
                  const ie = V[J];
                  return [ie, { id: ie, index: ie, x: re, y: q }];
                })
              )
            }
          }
        });
        break;
      }
      case "arrow": {
        let H = "";
        if (O.boundElements !== null) {
          for (const ie of O.boundElements)
            if (ie.type === "text") {
              const W = r.find((Y) => Y.id === ie.id);
              W && (H = W.text);
            }
        }
        const V = O.points[0], re = O.points[O.points.length - 1], q = h.get((k = O.startBinding) == null ? void 0 : k.elementId), J = h.get((L = O.endBinding) == null ? void 0 : L.elementId);
        s.shapes.push({
          ...F,
          type: "arrow",
          props: {
            text: H,
            bend: Uye(O, V, re),
            dash: iC(O),
            size: rC[O.strokeWidth] ?? "m",
            color: ux[O.strokeColor] ?? "black",
            start: { x: V[0], y: V[1] },
            end: { x: re[0], y: re[1] },
            arrowheadEnd: NU[O.endArrowhead] ?? "none",
            arrowheadStart: NU[O.startArrowhead] ?? "none"
          }
        }), q && s.bindings.push({
          id: qp(),
          typeName: "binding",
          type: "arrow",
          fromId: z,
          toId: q,
          props: {
            terminal: "start",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        }), J && s.bindings.push({
          id: qp(),
          typeName: "binding",
          type: "arrow",
          fromId: z,
          toId: J,
          props: {
            terminal: "end",
            normalizedAnchor: { x: 0.5, y: 0.5 },
            isPrecise: !1,
            isExact: !1
          },
          meta: {}
        });
        break;
      }
      case "text": {
        const { size: H, scale: V } = Dye(O.fontSize);
        s.shapes.push({
          ...F,
          type: "text",
          props: {
            size: H,
            scale: V,
            font: Oye[O.fontFamily] ?? "draw",
            color: ux[O.strokeColor] ?? "black",
            text: O.text,
            textAlign: zye[O.textAlign]
          }
        });
        break;
      }
      case "image": {
        const H = i[O.fileId];
        if (!H) break;
        const V = ih.createId();
        s.assets.push({
          id: V,
          typeName: "asset",
          type: "image",
          props: {
            w: O.width,
            h: O.height,
            fileSize: H.size,
            name: O.id ?? "Untitled",
            isAnimated: !1,
            mimeType: H.mimeType,
            src: H.dataURL
          },
          meta: {}
        }), s.shapes.push({
          ...F,
          type: "image",
          props: {
            w: O.width,
            h: O.height,
            assetId: V
          }
        });
      }
    }
    v = vu(v);
  }
  const w = t ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : void 0);
  n.markHistoryStoppingPoint("paste"), n.putContentOntoCurrentPage(s, {
    point: w,
    select: !1,
    preserveIds: !0
  });
  for (const O of l.values())
    if (O.length > 1) {
      n.groupShapes(O);
      const z = n.getShape(O[0]);
      z != null && z.parentId && va(z.parentId) && g.push(z.parentId);
    }
  for (const [O, z] of c)
    n.select(O), n.rotateShapesBy([O], z);
  const C = rn(g.map((O) => n.getShape(O))), E = Xe.Common(C.map((O) => n.getShapePageBounds(O))), P = n.getViewportPageBounds().center;
  n.updateShapes(
    C.map((O) => {
      const z = {
        x: (O.x ?? 0) - (E.x + E.w / 2),
        y: (O.y ?? 0) - (E.y + E.h / 2)
      };
      return {
        id: O.id,
        type: O.type,
        x: P.x + z.x,
        y: P.y + z.y
      };
    })
  ), n.setSelectedShapes(g);
}
const Mye = (n) => {
  const e = n / 100;
  return e < 0.2 ? 0.1 : e < 0.4 ? 0.25 : e < 0.6 ? 0.5 : e < 0.8 ? 0.75 : 1;
}, rC = {
  1: "s",
  2: "m",
  3: "l",
  4: "xl"
}, Aye = {
  16: "s",
  20: "m",
  28: "l",
  36: "xl"
};
function Dye(n) {
  const e = Aye[n];
  return e ? { size: e, scale: 1 } : n < 16 ? { size: "s", scale: n / 16 } : n > 36 ? { size: "xl", scale: n / 36 } : { size: "m", scale: 1 };
}
const Oye = {
  1: "draw",
  2: "sans",
  3: "mono"
}, jye = {
  gray: ["#f8f9fa", "#e9ecef", "#ced4da", "#868e96", "#343a40"],
  red: ["#fff5f5", "#ffc9c9", "#ff8787", "#fa5252", "#e03131"],
  pink: ["#fff0f6", "#fcc2d7", "#f783ac", "#e64980", "#c2255c"],
  grape: ["#f8f0fc", "#eebefa", "#da77f2", "#be4bdb", "#9c36b5"],
  violet: ["#f3f0ff", "#d0bfff", "#9775fa", "#7950f2", "#6741d9"],
  indigo: ["#edf2ff", "#bac8ff", "#748ffc", "#4c6ef5", "#3b5bdb"],
  blue: ["#e7f5ff", "#a5d8ff", "#4dabf7", "#228be6", "#1971c2"],
  cyan: ["#e3fafc", "#99e9f2", "#3bc9db", "#15aabf", "#0c8599"],
  teal: ["#e6fcf5", "#96f2d7", "#38d9a9", "#12b886", "#099268"],
  green: ["#ebfbee", "#b2f2bb", "#69db7c", "#40c057", "#2f9e44"],
  lime: ["#f4fce3", "#d8f5a2", "#a9e34b", "#82c91e", "#66a80f"],
  yellow: ["#fff9db", "#ffec99", "#ffd43b", "#fab005", "#f08c00"],
  orange: ["#fff4e6", "#ffd8a8", "#ffa94d", "#fd7e14", "#e8590c"]
};
function pu(n, e, t) {
  const r = [0, 1, 2, 3, 4].map((i) => jye[n][i]);
  return Object.fromEntries(r.map((i, s) => [i, s < 3 ? e : t]));
}
const ux = {
  ...pu("gray", "grey", "black"),
  ...pu("red", "light-red", "red"),
  ...pu("pink", "light-red", "red"),
  ...pu("grape", "light-violet", "violet"),
  ...pu("blue", "light-blue", "blue"),
  ...pu("cyan", "light-blue", "blue"),
  ...pu("teal", "light-green", "green"),
  ...pu("green", "light-green", "green"),
  ...pu("yellow", "yellow", "orange"),
  ...pu("orange", "yellow", "orange"),
  "#ffffff": "white",
  "#000000": "black"
}, Lye = {
  solid: "draw",
  dashed: "dashed",
  dotted: "dotted"
}, Nye = {
  "cross-hatch": "pattern",
  hachure: "pattern",
  solid: "solid"
}, Fye = {
  left: "start",
  center: "middle",
  right: "end"
}, zye = {
  left: "start",
  center: "middle",
  right: "end"
}, NU = {
  arrow: "arrow",
  dot: "dot",
  triangle: "triangle",
  bar: "pipe"
};
function Uye(n, e, t) {
  let r = 0;
  if (n.points.length > 2) {
    const i = new R(e[0], e[1]), s = new R(t[0], t[1]), l = new R(n.points[1][0], n.points[1][1]), c = R.Sub(s, i), d = R.Per(c), h = R.Med(s, i), g = R.Sub(h, d), y = R.Add(h, d), v = R.NearestPointOnLineSegment(g, y, l, !1);
    r = R.Dist(v, h), R.Clockwise(v, s, h) && (r *= -1);
  }
  return r;
}
const iC = (n) => {
  let e = Lye[n.strokeStyle] ?? "draw";
  return e === "draw" && n.roughness === 0 && (e = "solid"), e;
}, $ye = (n) => n.backgroundColor === "transparent" ? "none" : Nye[n.fillStyle] ?? "solid";
async function Bye(n, e, t, r) {
  const i = e.map(
    (s) => s instanceof File ? s : new File([s], "tldrawFile", { type: s.type })
  );
  n.markHistoryStoppingPoint("paste"), await n.putExternalContent({
    type: "files",
    files: i,
    point: t,
    ignoreParent: !1,
    sources: r
  });
}
function Hye(n, e, t) {
  const r = n.getSelectionPageBounds();
  n.markHistoryStoppingPoint("paste"), n.putContentOntoCurrentPage(e, {
    point: t,
    select: !0
  });
  const i = n.getSelectionPageBounds();
  r && i && (r != null && r.collides(i)) && (n.updateInstanceState({ isChangingStyle: !0 }), n.timers.setTimeout(() => {
    n.updateInstanceState({ isChangingStyle: !1 });
  }, 150));
}
async function SD(n, e, t, r) {
  return n.markHistoryStoppingPoint("paste"), await n.putExternalContent({
    type: "url",
    point: t,
    url: e,
    sources: r
  });
}
const Vye = [
  Gj,
  "image/png",
  "image/jpeg",
  "image/webp",
  "image/svg+xml"
];
function Kye(n) {
  const e = document.implementation.createHTMLDocument("");
  return e.documentElement.innerHTML = n.trim(), e.body.textContent || e.body.innerText || "";
}
const Wye = (n) => {
  try {
    const e = new URL(n);
    return e.protocol === "http:" || e.protocol === "https:";
  } catch {
    return !1;
  }
}, Gye = (n) => {
  const e = n.split(/[\n\s]/);
  for (const t of e)
    try {
      const r = new URL(t);
      if (!(r.protocol === "http:" || r.protocol === "https:"))
        return;
    } catch {
      return;
    }
  return lB(e);
}, qye = (n) => /^<svg/.test(n), Yye = ["input", "select", "textarea"];
function qM(n) {
  const { activeElement: e } = document;
  return n.menus.hasAnyOpenMenus() || e && (e.getAttribute("contenteditable") || Yye.indexOf(e.tagName.toLowerCase()) > -1);
}
const oC = (n, e, t, r) => {
  const i = Gye(e);
  if (i)
    for (const s of i)
      SD(n, s, t);
  else Wye(e) ? SD(n, e, t) : qye(e) ? (n.markHistoryStoppingPoint("paste"), n.putExternalContent({
    type: "svg-text",
    text: e,
    point: t,
    sources: r
  })) : (n.markHistoryStoppingPoint("paste"), n.putExternalContent({
    type: "text",
    text: e,
    point: t,
    sources: r
  }));
}, Xye = async (n, e, t) => {
  if (n.getEditingShapeId() !== null) return;
  if (!e)
    throw Error("No clipboard data");
  const r = [];
  for (const i of Object.values(e.items))
    switch (i.kind) {
      case "file": {
        r.push({
          type: "file",
          source: new Promise((s) => s(i.getAsFile()))
        });
        break;
      }
      case "string": {
        i.type === "text/html" ? r.push({
          type: "html",
          source: new Promise((s) => i.getAsString(s))
        }) : i.type === "text/plain" ? r.push({
          type: "text",
          source: new Promise((s) => i.getAsString(s))
        }) : r.push({ type: i.type, source: new Promise((s) => i.getAsString(s)) });
        break;
      }
    }
  vW(n, r, t);
}, yW = async (n, e, t) => {
  const r = [];
  for (const i of e) {
    for (const s of Vye)
      if (i.types.includes(s)) {
        const l = i.getType(s).then((c) => yc.rewriteMimeType(c, Tye(s)));
        r.push({
          type: "blob",
          source: l
        });
        break;
      }
    i.types.includes("text/html") && r.push({
      type: "html",
      source: (async () => {
        const s = await i.getType("text/html");
        return await yc.blobToText(s);
      })()
    }), i.types.includes("text/uri-list") && r.push({
      type: "url",
      source: (async () => {
        const s = await i.getType("text/uri-list");
        return await yc.blobToText(s);
      })()
    }), i.types.includes("text/plain") && r.push({
      type: "text",
      source: (async () => {
        const s = await i.getType("text/plain");
        return await yc.blobToText(s);
      })()
    });
  }
  return await vW(n, r, t);
};
async function vW(n, e, t) {
  const r = e.filter(
    (s) => (s.type === "file" || s.type === "blob") && s.source !== null
  );
  if (r.length) {
    if (r.length > n.options.maxFilesAtOnce)
      throw Error("Too many files");
    const s = rn(await Promise.all(r.map((l) => l.source)));
    return await Bye(n, s, t);
  }
  const i = await Promise.all(
    e.filter((s) => s.type !== "file").map(
      (s) => new Promise((l) => {
        const c = s;
        if (c.type === "file") {
          l({ type: "error", data: null, reason: "unexpected file" });
          return;
        }
        c.source.then((d) => {
          var g;
          const h = (g = d.match(/<div data-tldraw[^>]*>(.*)<\/div>/)) == null ? void 0 : g[1];
          if (h)
            try {
              const y = mW.decompressFromBase64(h);
              if (y === null) {
                l({
                  type: "error",
                  data: y,
                  reason: "found tldraw data comment but could not parse base64"
                });
                return;
              } else {
                const v = JSON.parse(y);
                if (v.type !== "application/tldraw" && l({
                  type: "error",
                  data: v,
                  reason: `found tldraw data comment but JSON was of a different type: ${v.type}`
                }), typeof v.data == "string") {
                  l({
                    type: "error",
                    data: v,
                    reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
                  });
                  return;
                }
                l({ type: "tldraw", data: v.data });
                return;
              }
            } catch {
              l({
                type: "error",
                data: h,
                reason: "found tldraw json but data was a string instead of a TLClipboardModel object"
              });
              return;
            }
          else {
            if (c.type === "html") {
              l({ type: "text", data: d, subtype: "html" });
              return;
            }
            if (c.type === "url") {
              l({ type: "text", data: d, subtype: "url" });
              return;
            }
            try {
              const y = JSON.parse(d);
              if (y.type === "excalidraw/clipboard") {
                l({ type: "excalidraw", data: y });
                return;
              } else {
                l({ type: "text", data: d, subtype: "json" });
                return;
              }
            } catch {
              l({ type: "text", data: d, subtype: "text" });
              return;
            }
          }
          l({ type: "error", data: d, reason: "unhandled case" });
        });
      })
    )
  );
  for (const s of i)
    if (s.type === "tldraw") {
      Hye(n, s.data, t);
      return;
    }
  for (const s of i)
    if (s.type === "excalidraw") {
      Rye(n, s.data, t);
      return;
    }
  for (const s of i) {
    if (s.type === "text" && s.subtype === "html") {
      const c = new DOMParser().parseFromString(s.data, "text/html").querySelector("body");
      if (c && Array.from(c.children).filter((h) => h.nodeType === 1).length === 1 && c.firstElementChild && c.firstElementChild.tagName === "A" && c.firstElementChild.hasAttribute("href") && c.firstElementChild.getAttribute("href") !== "") {
        const h = c.firstElementChild.getAttribute("href");
        oC(n, h, t, i);
        return;
      }
      if (!i.some((h) => h.type === "text" && h.subtype !== "html") && s.data.trim()) {
        oC(n, Kye(s.data), t, i);
        return;
      }
    }
    if (s.type === "text" && s.subtype === "text" && s.data.startsWith("<iframe ")) {
      const c = new DOMParser().parseFromString(s.data, "text/html").querySelector("body");
      if (c && Array.from(c.children).filter((h) => h.nodeType === 1).length === 1 && c.firstElementChild && c.firstElementChild.tagName === "IFRAME" && c.firstElementChild.hasAttribute("src") && c.firstElementChild.getAttribute("src") !== "") {
        const h = c.firstElementChild.getAttribute("src");
        oC(n, h, t, i);
        return;
      }
    }
  }
  for (const s of i)
    if (s.type === "text" && s.subtype === "url") {
      SD(n, s.data, t, i);
      return;
    }
  for (const s of i)
    if (s.type === "text" && s.subtype === "text" && s.data.trim()) {
      oC(n, s.data, t, i);
      return;
    }
}
const IE = async (n) => {
  var r;
  const e = await n.resolveAssetsInContent(
    n.getContentFromCurrentPage(n.getSelectedShapeIds())
  );
  if (!e) {
    navigator && navigator.clipboard && navigator.clipboard.writeText("");
    return;
  }
  const t = mW.compressToBase64(
    JSON.stringify({
      type: "application/tldraw",
      kind: "content",
      data: e
    })
  );
  if (!(typeof navigator > "u")) {
    const i = e.shapes.map((s) => n.getShapeUtil(s).getText(s)).filter(Sne);
    if ((r = navigator.clipboard) != null && r.write) {
      const s = new Blob([`<div data-tldraw>${t}</div>`], {
        type: "text/html"
      });
      let l = i.join(" ");
      l === "" && (l = " "), navigator.clipboard.write([
        new ClipboardItem({
          "text/html": s,
          // What is this second blob used for?
          "text/plain": new Blob([l], { type: "text/plain" })
        })
      ]);
    } else navigator.clipboard.writeText && navigator.clipboard.writeText(`<div data-tldraw>${t}</div>`);
  }
};
function Zye() {
  const n = be(), e = Vo(), t = M.useCallback(
    async function(l) {
      n.getSelectedShapeIds().length !== 0 && (await IE(n), e("copy", { source: l }));
    },
    [n, e]
  ), r = M.useCallback(
    async function(l) {
      n.getSelectedShapeIds().length !== 0 && (await IE(n), n.deleteShapes(n.getSelectedShapeIds()), e("cut", { source: l }));
    },
    [n, e]
  ), i = M.useCallback(
    async function(l, c, d) {
      n.getEditingShapeId() === null && (Array.isArray(l) && l[0] instanceof ClipboardItem ? (yW(n, l, d), e("paste", { source: "menu" })) : navigator.clipboard.read().then((h) => {
        i(h, c, d);
      }));
    },
    [n, e]
  );
  return {
    copy: t,
    cut: r,
    paste: i
  };
}
function Qye() {
  const n = be(), e = Vo(), t = Pe("editor.isFocused", () => n.getInstanceState().isFocused, [
    n
  ]);
  M.useEffect(() => {
    if (!t) return;
    const r = async (d) => {
      n.getSelectedShapeIds().length === 0 || n.getEditingShapeId() !== null || qM(n) || (wn(d), await IE(n), e("copy", { source: "kbd" }));
    };
    async function i(d) {
      n.getSelectedShapeIds().length === 0 || n.getEditingShapeId() !== null || qM(n) || (wn(d), await IE(n), n.deleteShapes(n.getSelectedShapeIds()), e("cut", { source: "kbd" }));
    }
    let s = !1;
    const l = (d) => {
      d.button === 1 && (s = !0, n.timers.requestAnimationFrame(() => {
        s = !1;
      }));
    }, c = (d) => {
      var v;
      if (s) {
        Ti(d);
        return;
      }
      if (n.getEditingShapeId() !== null || qM(n)) return;
      let h, g = !1;
      n.inputs.shiftKey && (g = !0), n.user.getIsPasteAtCursorMode() && (g = !g), g && (h = n.inputs.currentPagePoint);
      const y = () => {
        d.clipboardData && Xye(n, d.clipboardData, h);
      };
      (v = navigator.clipboard) != null && v.read ? navigator.clipboard.read().then(
        (w) => {
          Array.isArray(w) && w[0] instanceof ClipboardItem && yW(n, w, h);
        },
        () => {
          y();
        }
      ) : y(), wn(d), e("paste", { source: "kbd" });
    };
    return document.addEventListener("copy", r), document.addEventListener("cut", i), document.addEventListener("paste", c), document.addEventListener("pointerup", l), () => {
      document.removeEventListener("copy", r), document.removeEventListener("cut", i), document.removeEventListener("paste", c), document.removeEventListener("pointerup", l);
    };
  }, [n, e, t]);
}
/*!
 * canvas-size
 * v1.2.6
 * https://github.com/jhildenbiddle/canvas-size
 * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>
 * MIT license
 */
function Jye(n, e) {
  var t = n == null ? null : typeof Symbol < "u" && n[Symbol.iterator] || n["@@iterator"];
  if (t != null) {
    var r, i, s, l, c = [], d = !0, h = !1;
    try {
      if (s = (t = t.call(n)).next, e === 0) {
        if (Object(t) !== t) return;
        d = !1;
      } else for (; !(d = (r = s.call(t)).done) && (c.push(r.value), c.length !== e); d = !0) ;
    } catch (g) {
      h = !0, i = g;
    } finally {
      try {
        if (!d && t.return != null && (l = t.return(), Object(l) !== l)) return;
      } finally {
        if (h) throw i;
      }
    }
    return c;
  }
}
function FU(n, e) {
  var t = Object.keys(n);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(n);
    e && (r = r.filter(function(i) {
      return Object.getOwnPropertyDescriptor(n, i).enumerable;
    })), t.push.apply(t, r);
  }
  return t;
}
function Ga(n) {
  for (var e = 1; e < arguments.length; e++) {
    var t = arguments[e] != null ? arguments[e] : {};
    e % 2 ? FU(Object(t), !0).forEach(function(r) {
      eve(n, r, t[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(n, Object.getOwnPropertyDescriptors(t)) : FU(Object(t)).forEach(function(r) {
      Object.defineProperty(n, r, Object.getOwnPropertyDescriptor(t, r));
    });
  }
  return n;
}
function eve(n, e, t) {
  return e = cve(e), e in n ? Object.defineProperty(n, e, {
    value: t,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : n[e] = t, n;
}
function tve(n, e) {
  if (n == null) return {};
  var t = {}, r = Object.keys(n), i, s;
  for (s = 0; s < r.length; s++)
    i = r[s], !(e.indexOf(i) >= 0) && (t[i] = n[i]);
  return t;
}
function nve(n, e) {
  if (n == null) return {};
  var t = tve(n, e), r, i;
  if (Object.getOwnPropertySymbols) {
    var s = Object.getOwnPropertySymbols(n);
    for (i = 0; i < s.length; i++)
      r = s[i], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(n, r) && (t[r] = n[r]);
  }
  return t;
}
function zU(n, e) {
  return ive(n) || Jye(n, e) || SW(n, e) || ave();
}
function sC(n) {
  return rve(n) || ove(n) || SW(n) || sve();
}
function rve(n) {
  if (Array.isArray(n)) return xD(n);
}
function ive(n) {
  if (Array.isArray(n)) return n;
}
function ove(n) {
  if (typeof Symbol < "u" && n[Symbol.iterator] != null || n["@@iterator"] != null) return Array.from(n);
}
function SW(n, e) {
  if (n) {
    if (typeof n == "string") return xD(n, e);
    var t = Object.prototype.toString.call(n).slice(8, -1);
    if (t === "Object" && n.constructor && (t = n.constructor.name), t === "Map" || t === "Set") return Array.from(n);
    if (t === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t)) return xD(n, e);
  }
}
function xD(n, e) {
  (e == null || e > n.length) && (e = n.length);
  for (var t = 0, r = new Array(e); t < e; t++) r[t] = n[t];
  return r;
}
function sve() {
  throw new TypeError(`Invalid attempt to spread non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function ave() {
  throw new TypeError(`Invalid attempt to destructure non-iterable instance.
In order to be iterable, non-array objects must have a [Symbol.iterator]() method.`);
}
function lve(n, e) {
  if (typeof n != "object" || n === null) return n;
  var t = n[Symbol.toPrimitive];
  if (t !== void 0) {
    var r = t.call(n, e || "default");
    if (typeof r != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(n);
}
function cve(n) {
  var e = lve(n, "string");
  return typeof e == "symbol" ? e : String(e);
}
function jx(n) {
  var e = n.sizes.shift(), t = Math.max(Math.ceil(e[0]), 1), r = Math.max(Math.ceil(e[1]), 1), i = [t - 1, r - 1, 1, 1], s = Date.now(), l = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope, c, d;
  l ? (c = new OffscreenCanvas(1, 1), d = new OffscreenCanvas(t, r)) : (c = document.createElement("canvas"), c.width = 1, c.height = 1, d = document.createElement("canvas"), d.width = t, d.height = r);
  var h = c.getContext("2d"), g = d.getContext("2d");
  g && (g.fillRect.apply(g, i), h.drawImage(d, t - 1, r - 1, 1, 1, 0, 0, 1, 1));
  var y = h && h.getImageData(0, 0, 1, 1).data[3] !== 0, v = Date.now() - s;
  return [c, d].forEach(function(w) {
    w.height = 0, w.width = 0;
  }), l ? (postMessage({
    width: t,
    height: r,
    benchmark: v,
    isTestPass: y
  }), !y && n.sizes.length && jx(n)) : y ? n.onSuccess(t, r, v) : (n.onError(t, r, v), n.sizes.length && jx(n)), y;
}
var YM = {
  area: [16384, 14188, 11402, 11180, 10836, 8192, 4096, 1],
  height: [8388607, 65535, 32767, 16384, 8192, 4096, 1],
  width: [4194303, 65535, 32767, 16384, 8192, 4096, 1]
}, uve = ["onError", "onSuccess"], xy = {
  max: null,
  min: 1,
  sizes: [],
  step: 1024,
  usePromise: !1,
  useWorker: !1,
  onError: Function.prototype,
  onSuccess: Function.prototype
}, dx = {};
function XM(n) {
  var e = n.width === n.height, t = n.height === 1, r = n.width === 1, i = [];
  if (!n.width || !n.height)
    n.sizes.forEach(function(g) {
      var y = e || t ? g : 1, v = e || r ? g : 1;
      i.push([y, v]);
    });
  else
    for (var s = n.min || xy.min, l = n.step || xy.step, c = Math.max(n.width, n.height); c >= s; ) {
      var d = e || t ? c : 1, h = e || r ? c : 1;
      i.push([d, h]), c -= l;
    }
  return i;
}
function aC(n) {
  var e = window && "HTMLCanvasElement" in window, t = window && "OffscreenCanvas" in window, r = Date.now(), i = n.onError, s = n.onSuccess, l = nve(n, uve), c = null;
  if (!e)
    return !1;
  if (n.useWorker && t) {
    var d = `
            var canvasTest = `.concat(jx.toString(), `;
            onmessage = function(e) {
                canvasTest(e.data);
            };
        `), h = new Blob([d], {
      type: "application/javascript"
    }), g = URL.createObjectURL(h);
    c = new Worker(g), URL.revokeObjectURL(g), c.onmessage = function(y) {
      var v = y.data, w = v.width, C = v.height, E = v.benchmark, P = v.isTestPass;
      P ? (dx[r].onSuccess(w, C, E), delete dx[r]) : dx[r].onError(w, C, E);
    };
  }
  if (n.usePromise)
    return new Promise(function(y, v) {
      var w = Ga(Ga({}, n), {}, {
        onError: function(I, k, L) {
          var O;
          if (n.sizes.length === 0)
            O = !0;
          else {
            var z = n.sizes.slice(-1), F = zU(z, 1), H = zU(F[0], 2), V = H[0], re = H[1];
            O = I === V && k === re;
          }
          i(I, k, L), O && v({
            width: I,
            height: k,
            benchmark: L
          });
        },
        onSuccess: function(I, k, L) {
          s(I, k, L), y({
            width: I,
            height: k,
            benchmark: L
          });
        }
      });
      if (c) {
        var C = w.onError, E = w.onSuccess;
        dx[r] = {
          onError: C,
          onSuccess: E
        }, c.postMessage(l);
      } else
        jx(w);
    });
  if (c)
    dx[r] = {
      onError: i,
      onSuccess: s
    }, c.postMessage(l);
  else
    return jx(n);
}
var ZM = {
  maxArea: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = XM({
      width: e.max,
      height: e.max,
      min: e.min,
      step: e.step,
      sizes: sC(YM.area)
    }), r = Ga(Ga(Ga({}, xy), e), {}, {
      sizes: t
    });
    return aC(r);
  },
  maxHeight: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = XM({
      width: 1,
      height: e.max,
      min: e.min,
      step: e.step,
      sizes: sC(YM.height)
    }), r = Ga(Ga(Ga({}, xy), e), {}, {
      sizes: t
    });
    return aC(r);
  },
  maxWidth: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = XM({
      width: e.max,
      height: 1,
      min: e.min,
      step: e.step,
      sizes: sC(YM.width)
    }), r = Ga(Ga(Ga({}, xy), e), {}, {
      sizes: t
    });
    return aC(r);
  },
  test: function() {
    var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, t = Ga(Ga({}, xy), e);
    return t.sizes = sC(t.sizes), t.width && t.height && (t.sizes = [[t.width, t.height]]), aC(t);
  }
};
let QM = null;
function dve() {
  return QM || (QM = fve()), QM;
}
async function fve() {
  const n = await ZM.maxWidth({ usePromise: !0 }), e = await ZM.maxHeight({ usePromise: !0 }), t = await ZM.maxArea({ usePromise: !0 });
  return {
    maxWidth: n.width,
    maxHeight: e.height,
    maxArea: t.width * t.height
  };
}
const UU = 8192, hve = 4096 * 4096;
async function pve(n, e) {
  if (n <= UU && e <= UU && n * e <= hve)
    return [n, e];
  const { maxWidth: t, maxHeight: r, maxArea: i } = await dve(), s = n / e;
  if (n > t && (n = t, e = n / s), e > r && (e = r, n = e * s), n * e > i) {
    const l = Math.sqrt(i / (n * e));
    n *= l, e *= l;
  }
  return [n, e];
}
async function xW(n, e, t) {
  const { type: r, width: i, height: s, quality: l = 1, pixelRatio: c = 2 } = t;
  let [d, h] = await pve(
    i * c,
    s * c
  );
  d = Math.floor(d), h = Math.floor(h);
  const g = d / i, y = await yc.blobToDataUrl(new Blob([e], { type: "image/svg+xml" })), v = await new Promise((C) => {
    const E = Bx();
    E.crossOrigin = "anonymous", E.onload = async () => {
      Er.isSafari && await MA(250);
      const P = document.createElement("canvas"), I = P.getContext("2d");
      P.width = d, P.height = h, I.imageSmoothingEnabled = !0, I.imageSmoothingQuality = "high", I.drawImage(E, 0, 0, d, h), URL.revokeObjectURL(y), C(P);
    }, E.onerror = () => {
      C(null);
    }, E.src = y;
  });
  if (!v) return null;
  const w = await new Promise(
    (C) => v.toBlob(
      (E) => {
        (!E || Ei.throwToBlob.get()) && C(null), C(E);
      },
      "image/" + r,
      l
    )
  );
  if (!w) return null;
  if (r === "png") {
    const C = new DataView(await w.arrayBuffer());
    return mu.setPhysChunk(C, g, {
      type: "image/" + r
    });
  } else
    return w;
}
async function wW(n, e, t) {
  const r = await n.getSvgString(e != null && e.length ? e : [...n.getCurrentPageShapeIds()], {
    scale: t.scale ?? 1,
    background: n.getInstanceState().exportBackground,
    ...t
  });
  if (!r)
    throw new Error("Could not construct SVG.");
  return r;
}
async function wD(n, e, t, r = {}) {
  var i;
  switch (t) {
    case "svg":
      return (i = await wW(n, e, r)) == null ? void 0 : i.svg;
    case "json": {
      const s = await n.resolveAssetsInContent(n.getContentFromCurrentPage(e));
      return JSON.stringify(s);
    }
    default:
      ro(t);
  }
}
async function bW({
  editor: n,
  ids: e,
  format: t,
  opts: r = {}
}) {
  switch (t) {
    case "svg":
      return new Blob([await wD(n, e, "svg", r)], { type: "text/plain" });
    case "json":
      return new Blob([await wD(n, e, "json", r)], { type: "text/plain" });
    case "jpeg":
    case "png":
    case "webp": {
      const i = await wW(n, e, r);
      if (!i) throw new Error("Could not construct image.");
      const s = await xW(n, i.svg, {
        type: t,
        quality: r.quality,
        pixelRatio: r.pixelRatio,
        width: i.width,
        height: i.height
      });
      if (!s)
        throw new Error("Could not construct image.");
      return s;
    }
    default:
      ro(t);
  }
}
const gve = {
  jpeg: "image/jpeg",
  png: "image/png",
  webp: "image/webp",
  json: "text/plain",
  svg: "text/plain"
};
function mve(n, e, t, r = {}) {
  return {
    blobPromise: bW({ editor: n, ids: e, format: t, opts: r }),
    mimeType: gve[t]
  };
}
function yve(n, e, t = "svg", r = {}) {
  if (!navigator.clipboard) return Promise.reject(new Error("Copy not supported"));
  if (navigator.clipboard.write) {
    const { blobPromise: i, mimeType: s } = mve(n, e, t, r), l = { [s]: i }, c = Pye(s);
    return c && Iye(c) && (l[c] = i.then(
      (d) => yc.rewriteMimeType(d, c)
    )), kye(l);
  }
  switch (t) {
    case "json":
    case "svg":
      return vve(async () => wD(n, e, t, r));
    case "jpeg":
    case "png":
      throw new Error("Copy not supported");
    default:
      ro(t);
  }
}
async function vve(n) {
  var e, t;
  await ((t = (e = navigator.clipboard) == null ? void 0 : e.writeText) == null ? void 0 : t.call(e, await n()));
}
function Sve() {
  const n = be(), { addToast: e } = Yd(), t = Ln();
  return M.useCallback(
    (r, i = "svg") => {
      yve(n, r, i).catch(() => {
        e({
          id: "copy-fail",
          severity: "warning",
          title: t("toast.error.copy-fail.title"),
          description: t("toast.error.copy-fail.desc")
        });
      });
    },
    [n, e, t]
  );
}
async function xve(n, e, t = "png", r, i = {}) {
  if (!r && (r = `shapes at ${$U()}`, e.length === 1)) {
    const c = n.getShape(e[0]);
    n.isShapeOfType(c, "frame") ? r = c.props.name || "frame" : r = `${ZE(c.id)} at ${$U()}`;
  }
  r += `.${t}`;
  const s = await bW({ editor: n, ids: e, format: t, opts: i }), l = new File([s], r, { type: s.type });
  wve(l);
}
function $U() {
  const n = /* @__PURE__ */ new Date(), e = String(n.getFullYear()).slice(2), t = String(n.getMonth() + 1).padStart(2, "0"), r = String(n.getDate()).padStart(2, "0"), i = String(n.getHours()).padStart(2, "0"), s = String(n.getMinutes()).padStart(2, "0"), l = String(n.getSeconds()).padStart(2, "0");
  return `${e}-${t}-${r} ${i}.${s}.${l}`;
}
function wve(n) {
  const e = document.createElement("a"), t = URL.createObjectURL(n);
  e.href = t, e.download = n.name, e.click(), URL.revokeObjectURL(t);
}
function bve() {
  const n = be(), { addToast: e } = Yd(), t = Ln();
  return M.useCallback(
    (r, i = "png", s) => {
      xve(n, r, i, s, {
        scale: 1,
        background: n.getInstanceState().exportBackground
      }).catch((l) => {
        console.error(l.message), e({
          id: "export-fail",
          title: t("toast.error.export-fail.title"),
          description: t("toast.error.export-fail.desc"),
          severity: "error"
        });
      });
    },
    [n, e, t]
  );
}
const CW = Bt.createContext([]);
function Cve() {
  const n = be(), e = M.useRef(), t = sh(Bt.useContext(CW));
  return M.useEffect(() => {
    const r = window.document.createElement("input");
    r.type = "file", r.accept = (t == null ? void 0 : t.join(",")) ?? Yte, r.multiple = !0, e.current = r;
    async function i(s) {
      const l = s.target.files;
      !l || l.length === 0 || (n.markHistoryStoppingPoint("insert media"), await n.putExternalContent({
        type: "files",
        files: Array.from(l),
        point: n.getViewportPageBounds().center,
        ignoreParent: !1
      }), r.value = "");
    }
    return r.addEventListener("change", i), () => {
      e.current = void 0, r.removeEventListener("change", i);
    };
  }, [n, t]), M.useCallback(() => {
    var r;
    (r = e.current) == null || r.click();
  }, [e]);
}
function Eve() {
  const n = be(), e = M.useRef(null), t = M.useRef(null);
  return M.useCallback(
    async function() {
      const i = document.createElement("div"), s = document.createElement("style"), l = (I, k) => {
        I && (I.innerHTML = ""), k && document.head.contains(k) && document.head.removeChild(k), I && document.body.contains(I) && document.body.removeChild(I);
      };
      l(e.current, t.current), e.current = i, t.current = s;
      const c = `tl-print-surface-${or()}`;
      i.className = c, s.innerHTML = `
			.${c} {
				display: none;
			}

			.${c} svg {
				max-width: 100%;
				height: 100%;
				display: block;
			}

			@media print {				  
				html, body {
					min-height: 100%;
					height: 100%;
					margin: 0;
				}

				body {
					position: relative;
				}

				body > * {
					display: none;
				}

				.tldraw__editor {
					display: none;
				}

				.${c} {
					display: block !important;
					background: white;
					min-height: 100%;
					height: 100%;
					max-width: 100%;
				}

				.${c}__item {
					padding: 10mm;
					display: flex;
					min-height: 100%;
					flex-direction: column;
					page-break-after: always;
					position: relative;
					overflow: hidden;
					height: 100%;
				}

				.${c}__item__main {
					flex: 1;
					display: flex;
					align-items: center;
					justify-content: center;
					max-height: 100%;
				}

				.${c}__item__header {
					display: none;
				}

				.${c}__item__footer {
					display: none;
					text-align: right;
				}

				.${c}__item__footer__hide {
					display: none;
				}

				
			}

		`;
      const d = () => {
        document.head.appendChild(s), document.body.appendChild(i);
      }, h = () => {
        n.once("tick", () => {
          l(i, s);
        });
      };
      window.addEventListener("beforeprint", d), window.addEventListener("afterprint", h);
      function g(I, k, L) {
        try {
          i.innerHTML += `<div class="${c}__item">
        <div class="${c}__item__header">
          ${I.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
        </div>
        <div class="${c}__item__main">
          ${L}
        </div>
        <div class="${c}__item__footer ${c}__item__footer__${k ? "" : "hide"}">
          ${k ?? ""}
        </div>
      </div>`;
        } catch (O) {
          console.error(O);
        }
      }
      function y() {
        Er.isChromeForIos ? (d(), window.print()) : Er.isSafari ? (d(), document.execCommand("print", !1)) : window.print();
      }
      const v = n.getSelectedShapeIds(), w = n.getCurrentPageId(), C = n.getPages(), P = {
        scale: 1,
        background: !1,
        darkMode: !1,
        preserveAspectRatio: "xMidYMid meet"
      };
      if (n.getSelectedShapeIds().length > 0) {
        const I = await n.getSvgString(v, P);
        if (I) {
          const k = C.find((L) => L.id === w);
          g(`tldraw — ${k == null ? void 0 : k.name}`, null, I.svg), y();
        }
      } else {
        const I = n.getCurrentPage(), k = await n.getSvgString(
          n.getSortedChildIdsForParent(I.id),
          P
        );
        k && (g(`tldraw — ${I.name}`, null, k.svg), y());
      }
      window.removeEventListener("beforeprint", d), window.removeEventListener("afterprint", h);
    },
    [n]
  );
}
function qj() {
  const { addToast: n, removeToast: e, clearToasts: t } = Yd(), { addDialog: r, clearDialogs: i, removeDialog: s } = Dw(), l = Ln(), c = Cve(), d = Eve(), { cut: h, copy: g, paste: y } = Zye(), v = Sve(), w = bve(), C = Bj(), P = qs() < yi.TABLET_SM;
  return M.useMemo(
    () => ({
      addToast: n,
      removeToast: e,
      clearToasts: t,
      addDialog: r,
      removeDialog: s,
      clearDialogs: i,
      msg: l,
      isMobile: P,
      insertMedia: c,
      printSelectionOrPages: d,
      cut: h,
      copy: g,
      paste: y,
      copyAs: v,
      exportAs: w,
      getEmbedDefinition: C
    }),
    [
      n,
      e,
      t,
      r,
      s,
      i,
      l,
      P,
      c,
      d,
      h,
      g,
      y,
      v,
      w,
      C
    ]
  );
}
function _ve(n, e) {
  const t = {};
  for (const r of n)
    if (r.translations)
      for (const [i, s] of Uo(r.translations)) {
        let l = t[i];
        l || (l = t[i] = {}), Object.assign(l, s);
      }
  return {
    actions: (r, i, s) => {
      for (const l of n)
        l.actions && (i = l.actions(r, i, s));
      return i;
    },
    tools: (r, i, s) => {
      for (const l of n)
        l.tools && (i = l.tools(r, i, { ...e, ...s }));
      return i;
    },
    translations: t
  };
}
function EW(n) {
  return M.useMemo(() => n, n);
}
function Pve(n) {
  const e = EW(
    n == null ? [] : Array.isArray(n) ? n : [n]
  );
  return M.useMemo(() => {
    const t = {};
    for (const r of e)
      if (r.translations)
        for (const [i, s] of Uo(r.translations)) {
          let l = t[i];
          l || (l = t[i] = {}), Object.assign(l, s);
        }
    return t;
  }, [e]);
}
function Tve(n) {
  const e = qj(), t = EW(
    n == null ? [] : Array.isArray(n) ? n : [n]
  );
  return M.useMemo(
    () => _ve(t, e),
    [t, e]
  );
}
const _W = M.createContext(null);
function Ive(n) {
  return Object.fromEntries(n.map((e) => [e.id, e]));
}
function fy(n, e) {
  if (n.getSelectedShapes().length === 0)
    return n.getDocumentSettings().name || e;
}
function kve({ overrides: n, children: e }) {
  const t = be(), r = A_(), i = qj(), s = Vo(), l = i.msg("document.default-name"), c = M.useMemo(() => {
    function d() {
      return t.isIn("select") || (t.complete(), t.setCurrentTool("select")), !1;
    }
    function h() {
      return t.isIn("select") && t.getSelectedShapeIds().length > 0;
    }
    const g = [
      {
        id: "edit-link",
        label: "action.edit-link",
        icon: "link",
        onSelect(v) {
          h() && (d() || (s("edit-link", { source: v }), t.markHistoryStoppingPoint("edit-link"), i.addDialog({ component: $me })));
        }
      },
      {
        id: "insert-embed",
        label: "action.insert-embed",
        kbd: "$i",
        onSelect(v) {
          s("insert-embed", { source: v }), i.addDialog({ component: JK });
        }
      },
      {
        id: "insert-media",
        label: "action.insert-media",
        kbd: "$u",
        onSelect(v) {
          s("insert-media", { source: v }), i.insertMedia();
        }
      },
      {
        id: "undo",
        label: "action.undo",
        icon: "undo",
        kbd: "$z",
        onSelect(v) {
          s("undo", { source: v }), t.undo();
        }
      },
      {
        id: "redo",
        label: "action.redo",
        icon: "redo",
        kbd: "$!z",
        onSelect(v) {
          s("redo", { source: v }), t.redo();
        }
      },
      {
        id: "export-as-svg",
        label: {
          default: "action.export-as-svg",
          menu: "action.export-as-svg.short",
          "context-menu": "action.export-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("export-as", { format: "svg", source: v }), i.exportAs(w, "svg", fy(t, l)));
        }
      },
      {
        id: "export-as-png",
        label: {
          default: "action.export-as-png",
          menu: "action.export-as-png.short",
          "context-menu": "action.export-as-png.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("export-as", { format: "png", source: v }), i.exportAs(w, "png", fy(t, l)));
        }
      },
      {
        id: "export-as-json",
        label: {
          default: "action.export-as-json",
          menu: "action.export-as-json.short",
          "context-menu": "action.export-as-json.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("export-as", { format: "json", source: v }), i.exportAs(w, "json", fy(t, l)));
        }
      },
      {
        id: "export-all-as-svg",
        label: {
          default: "action.export-all-as-svg",
          menu: "action.export-all-as-svg.short",
          "context-menu": "action.export-all-as-svg.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("export-all-as", { format: "svg", source: v }), i.exportAs(
            Array.from(t.getCurrentPageShapeIds()),
            "svg",
            fy(t, l)
          ));
        }
      },
      {
        id: "export-all-as-png",
        label: {
          default: "action.export-all-as-png",
          menu: "action.export-all-as-png.short",
          "context-menu": "action.export-all-as-png.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          const w = Array.from(t.getCurrentPageShapeIds().values());
          w.length !== 0 && (s("export-all-as", { format: "png", source: v }), i.exportAs(w, "png", fy(t, l)));
        }
      },
      {
        id: "export-all-as-json",
        label: {
          default: "action.export-all-as-json",
          menu: "action.export-all-as-json.short",
          "context-menu": "action.export-all-as-json.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          const w = Array.from(t.getCurrentPageShapeIds().values());
          w.length !== 0 && (s("export-all-as", { format: "json", source: v }), i.exportAs(w, "json", fy(t, l)));
        }
      },
      {
        id: "copy-as-svg",
        label: {
          default: "action.copy-as-svg",
          menu: "action.copy-as-svg.short",
          "context-menu": "action.copy-as-svg.short"
        },
        kbd: "$!c",
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("copy-as", { format: "svg", source: v }), i.copyAs(w, "svg"));
        }
      },
      {
        id: "copy-as-png",
        label: {
          default: "action.copy-as-png",
          menu: "action.copy-as-png.short",
          "context-menu": "action.copy-as-png.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("copy-as", { format: "png", source: v }), i.copyAs(w, "png"));
        }
      },
      {
        id: "copy-as-json",
        label: {
          default: "action.copy-as-json",
          menu: "action.copy-as-json.short",
          "context-menu": "action.copy-as-json.short"
        },
        readonlyOk: !0,
        onSelect(v) {
          let w = t.getSelectedShapeIds();
          w.length === 0 && (w = Array.from(t.getCurrentPageShapeIds().values())), w.length !== 0 && (s("copy-as", { format: "json", source: v }), i.copyAs(w, "json"));
        }
      },
      {
        id: "toggle-auto-size",
        label: "action.toggle-auto-size",
        onSelect(v) {
          if (!h() || d()) return;
          s("toggle-auto-size", { source: v }), t.markHistoryStoppingPoint("toggling auto size");
          const w = t.getSelectedShapes().filter(
            (C) => t.isShapeOfType(C, "text") && C.props.autoSize === !1
          );
          t.updateShapes(
            w.map((C) => ({
              id: C.id,
              type: C.type,
              props: {
                ...C.props,
                w: 8,
                autoSize: !0
              }
            }))
          ), Dr(
            t,
            w.map((C) => C.id)
          );
        }
      },
      {
        id: "open-embed-link",
        label: "action.open-embed-link",
        readonlyOk: !0,
        onSelect(v) {
          s("open-embed-link", { source: v });
          const w = t.getSelectedShapeIds(), C = "No embed shapes selected";
          if (w.length !== 1) {
            console.error(C);
            return;
          }
          const E = t.getShape(w[0]);
          if (!E || !t.isShapeOfType(E, "embed")) {
            console.error(C);
            return;
          }
          hfe(E.props.url, "_blank");
        }
      },
      {
        id: "select-zoom-tool",
        readonlyOk: !0,
        kbd: "z",
        onSelect(v) {
          var w, C;
          if (((w = t.root.getCurrent()) == null ? void 0 : w.id) !== "zoom" && (s("zoom-tool", { source: v }), !(t.inputs.shiftKey || t.inputs.ctrlKey))) {
            const E = t.root.getCurrent();
            E && ((C = E.getCurrent()) == null ? void 0 : C.id) === "idle" && t.setCurrentTool("zoom", { onInteractionEnd: E.id, maskAs: "zoom" });
          }
        }
      },
      {
        id: "convert-to-bookmark",
        label: "action.convert-to-bookmark",
        onSelect(v) {
          h() && (d() || t.run(() => {
            s("convert-to-bookmark", { source: v });
            const w = t.getSelectedShapes(), C = [], E = [];
            for (const P of w) {
              if (!P || !t.isShapeOfType(P, "embed") || !P.props.url)
                continue;
              const I = new R(P.x, P.y);
              I.rot(-P.rotation), I.add(new R(P.props.w / 2 - 300 / 2, P.props.h / 2 - 320 / 2)), I.rot(P.rotation);
              const k = {
                id: Sr(),
                type: "bookmark",
                rotation: P.rotation,
                x: I.x,
                y: I.y,
                opacity: 1,
                props: {
                  url: P.props.url
                }
              };
              C.push(k), E.push(P.id);
            }
            t.markHistoryStoppingPoint("convert shapes to bookmark"), t.deleteShapes(E), t.createShapes(C);
          }));
        }
      },
      {
        id: "convert-to-embed",
        label: "action.convert-to-embed",
        onSelect(v) {
          h() && (d() || (s("convert-to-embed", { source: v }), t.run(() => {
            const w = t.getSelectedShapeIds(), C = rn(w.map((I) => t.getShape(I))), E = [], P = [];
            for (const I of C) {
              if (!t.isShapeOfType(I, "bookmark")) continue;
              const { url: k } = I.props, L = i.getEmbedDefinition(k);
              if (!L || !L.definition) continue;
              const { width: O, height: z } = L.definition, F = new R(I.x, I.y);
              F.rot(-I.rotation), F.add(new R(I.props.w / 2 - O / 2, I.props.h / 2 - z / 2)), F.rot(I.rotation);
              const H = {
                id: Sr(),
                type: "embed",
                x: F.x,
                y: F.y,
                rotation: I.rotation,
                props: {
                  url: k,
                  w: O,
                  h: z
                }
              };
              E.push(H), P.push(I.id);
            }
            t.markHistoryStoppingPoint("convert shapes to embed"), t.deleteShapes(P), t.createShapes(E);
          })));
        }
      },
      {
        id: "duplicate",
        kbd: "$d",
        label: "action.duplicate",
        icon: "duplicate",
        onSelect(v) {
          if (!h() || d()) return;
          s("duplicate-shapes", { source: v });
          const w = t.getInstanceState();
          let C, E;
          if (w.duplicateProps)
            C = w.duplicateProps.shapeIds, E = w.duplicateProps.offset;
          else {
            C = t.getSelectedShapeIds();
            const P = Xe.Common(rn(C.map((I) => t.getShapePageBounds(I))));
            E = t.getCameraOptions().isLocked ? {
              // same as the adjacent note margin
              x: t.options.adjacentShapeMargin,
              y: t.options.adjacentShapeMargin
            } : {
              x: P.width + t.options.adjacentShapeMargin,
              y: 0
            };
          }
          t.markHistoryStoppingPoint("duplicate shapes"), t.duplicateShapes(C, E), w.duplicateProps && t.updateInstanceState({
            duplicateProps: {
              ...w.duplicateProps,
              shapeIds: t.getSelectedShapeIds()
            }
          });
        }
      },
      {
        id: "ungroup",
        label: "action.ungroup",
        kbd: "$!g",
        icon: "ungroup",
        onSelect(v) {
          h() && (d() || (s("ungroup-shapes", { source: v }), t.markHistoryStoppingPoint("ungroup"), t.ungroupShapes(t.getSelectedShapeIds())));
        }
      },
      {
        id: "group",
        label: "action.group",
        kbd: "$g",
        icon: "group",
        onSelect(v) {
          if (!h() || d()) return;
          s("group-shapes", { source: v });
          const w = t.getOnlySelectedShape();
          w && t.isShapeOfType(w, "group") ? (t.markHistoryStoppingPoint("ungroup"), t.ungroupShapes(t.getSelectedShapeIds())) : (t.markHistoryStoppingPoint("group"), t.groupShapes(t.getSelectedShapeIds()));
        }
      },
      {
        id: "remove-frame",
        label: "action.remove-frame",
        kbd: "$!f",
        onSelect(v) {
          if (!h()) return;
          s("remove-frame", { source: v });
          const w = t.getSelectedShapes();
          w.length > 0 && w.every((C) => t.isShapeOfType(C, "frame")) && (t.markHistoryStoppingPoint("remove-frame"), Sme(
            t,
            w.map((C) => C.id)
          ));
        }
      },
      {
        id: "fit-frame-to-content",
        label: "action.fit-frame-to-content",
        onSelect(v) {
          if (!h()) return;
          s("fit-frame-to-content", { source: v });
          const w = t.getOnlySelectedShape();
          w && t.isShapeOfType(w, "frame") && (t.markHistoryStoppingPoint("fit-frame-to-content"), wme(t, w.id));
        }
      },
      {
        id: "align-left",
        label: "action.align-left",
        kbd: "?A",
        icon: "align-left",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "left", source: v }), t.markHistoryStoppingPoint("align left");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "left"), Dr(t, w);
        }
      },
      {
        id: "align-center-horizontal",
        label: {
          default: "action.align-center-horizontal",
          "context-menu": "action.align-center-horizontal.short"
        },
        kbd: "?H",
        icon: "align-center-horizontal",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "center-horizontal", source: v }), t.markHistoryStoppingPoint("align center horizontal");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "center-horizontal"), Dr(t, w);
        }
      },
      {
        id: "align-right",
        label: "action.align-right",
        kbd: "?D",
        icon: "align-right",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "right", source: v }), t.markHistoryStoppingPoint("align right");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "right"), Dr(t, w);
        }
      },
      {
        id: "align-center-vertical",
        label: {
          default: "action.align-center-vertical",
          "context-menu": "action.align-center-vertical.short"
        },
        kbd: "?V",
        icon: "align-center-vertical",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "center-vertical", source: v }), t.markHistoryStoppingPoint("align center vertical");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "center-vertical"), Dr(t, w);
        }
      },
      {
        id: "align-top",
        label: "action.align-top",
        icon: "align-top",
        kbd: "?W",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "top", source: v }), t.markHistoryStoppingPoint("align top");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "top"), Dr(t, w);
        }
      },
      {
        id: "align-bottom",
        label: "action.align-bottom",
        icon: "align-bottom",
        kbd: "?S",
        onSelect(v) {
          if (!h() || d()) return;
          s("align-shapes", { operation: "bottom", source: v }), t.markHistoryStoppingPoint("align bottom");
          const w = t.getSelectedShapeIds();
          t.alignShapes(w, "bottom"), Dr(t, w);
        }
      },
      {
        id: "distribute-horizontal",
        label: {
          default: "action.distribute-horizontal",
          "context-menu": "action.distribute-horizontal.short"
        },
        icon: "distribute-horizontal",
        kbd: "?!h",
        onSelect(v) {
          if (!h() || d()) return;
          s("distribute-shapes", { operation: "horizontal", source: v }), t.markHistoryStoppingPoint("distribute horizontal");
          const w = t.getSelectedShapeIds();
          t.distributeShapes(w, "horizontal"), Dr(t, w);
        }
      },
      {
        id: "distribute-vertical",
        label: {
          default: "action.distribute-vertical",
          "context-menu": "action.distribute-vertical.short"
        },
        icon: "distribute-vertical",
        kbd: "?!V",
        onSelect(v) {
          if (!h() || d()) return;
          s("distribute-shapes", { operation: "vertical", source: v }), t.markHistoryStoppingPoint("distribute vertical");
          const w = t.getSelectedShapeIds();
          t.distributeShapes(w, "vertical"), Dr(t, w);
        }
      },
      {
        id: "stretch-horizontal",
        label: {
          default: "action.stretch-horizontal",
          "context-menu": "action.stretch-horizontal.short"
        },
        icon: "stretch-horizontal",
        onSelect(v) {
          if (!h() || d()) return;
          s("stretch-shapes", { operation: "horizontal", source: v }), t.markHistoryStoppingPoint("stretch horizontal");
          const w = t.getSelectedShapeIds();
          t.stretchShapes(w, "horizontal"), Dr(t, w);
        }
      },
      {
        id: "stretch-vertical",
        label: {
          default: "action.stretch-vertical",
          "context-menu": "action.stretch-vertical.short"
        },
        icon: "stretch-vertical",
        onSelect(v) {
          if (!h() || d()) return;
          s("stretch-shapes", { operation: "vertical", source: v }), t.markHistoryStoppingPoint("stretch vertical");
          const w = t.getSelectedShapeIds();
          t.stretchShapes(w, "vertical"), Dr(t, w);
        }
      },
      {
        id: "flip-horizontal",
        label: {
          default: "action.flip-horizontal",
          "context-menu": "action.flip-horizontal.short"
        },
        kbd: "!h",
        onSelect(v) {
          if (!h() || d()) return;
          s("flip-shapes", { operation: "horizontal", source: v }), t.markHistoryStoppingPoint("flip horizontal");
          const w = t.getSelectedShapeIds();
          t.flipShapes(w, "horizontal"), Dr(t, w);
        }
      },
      {
        id: "flip-vertical",
        label: { default: "action.flip-vertical", "context-menu": "action.flip-vertical.short" },
        kbd: "!v",
        onSelect(v) {
          if (!h() || d()) return;
          s("flip-shapes", { operation: "vertical", source: v }), t.markHistoryStoppingPoint("flip vertical");
          const w = t.getSelectedShapeIds();
          t.flipShapes(w, "vertical"), Dr(t, w);
        }
      },
      {
        id: "pack",
        label: "action.pack",
        icon: "pack",
        onSelect(v) {
          if (!h() || d()) return;
          s("pack-shapes", { source: v }), t.markHistoryStoppingPoint("pack");
          const w = t.getSelectedShapeIds();
          t.packShapes(w, t.options.adjacentShapeMargin), Dr(t, w);
        }
      },
      {
        id: "stack-vertical",
        label: {
          default: "action.stack-vertical",
          "context-menu": "action.stack-vertical.short"
        },
        icon: "stack-vertical",
        onSelect(v) {
          if (!h() || d()) return;
          s("stack-shapes", { operation: "vertical", source: v }), t.markHistoryStoppingPoint("stack-vertical");
          const w = t.getSelectedShapeIds();
          t.stackShapes(w, "vertical", 16), Dr(t, w);
        }
      },
      {
        id: "stack-horizontal",
        label: {
          default: "action.stack-horizontal",
          "context-menu": "action.stack-horizontal.short"
        },
        icon: "stack-horizontal",
        onSelect(v) {
          if (!h() || d()) return;
          s("stack-shapes", { operation: "horizontal", source: v }), t.markHistoryStoppingPoint("stack-horizontal");
          const w = t.getSelectedShapeIds();
          t.stackShapes(w, "horizontal", 16), Dr(t, w);
        }
      },
      {
        id: "bring-to-front",
        label: "action.bring-to-front",
        kbd: "]",
        icon: "bring-to-front",
        onSelect(v) {
          h() && (d() || (s("reorder-shapes", { operation: "toFront", source: v }), t.markHistoryStoppingPoint("bring to front"), t.bringToFront(t.getSelectedShapeIds())));
        }
      },
      {
        id: "bring-forward",
        label: "action.bring-forward",
        icon: "bring-forward",
        kbd: "?]",
        onSelect(v) {
          h() && (d() || (s("reorder-shapes", { operation: "forward", source: v }), t.markHistoryStoppingPoint("bring forward"), t.bringForward(t.getSelectedShapeIds())));
        }
      },
      {
        id: "send-backward",
        label: "action.send-backward",
        icon: "send-backward",
        kbd: "?[",
        onSelect(v) {
          h() && (d() || (s("reorder-shapes", { operation: "backward", source: v }), t.markHistoryStoppingPoint("send backward"), t.sendBackward(t.getSelectedShapeIds())));
        }
      },
      {
        id: "send-to-back",
        label: "action.send-to-back",
        icon: "send-to-back",
        kbd: "[",
        onSelect(v) {
          h() && (d() || (s("reorder-shapes", { operation: "toBack", source: v }), t.markHistoryStoppingPoint("send to back"), t.sendToBack(t.getSelectedShapeIds())));
        }
      },
      {
        id: "cut",
        label: "action.cut",
        kbd: "$x",
        onSelect(v) {
          h() && (d() || (t.markHistoryStoppingPoint("cut"), i.cut(v)));
        }
      },
      {
        id: "copy",
        label: "action.copy",
        kbd: "$c",
        readonlyOk: !0,
        onSelect(v) {
          h() && (d() || i.copy(v));
        }
      },
      {
        id: "paste",
        label: "action.paste",
        kbd: "$v",
        onSelect(v) {
          var w;
          (w = navigator.clipboard) == null || w.read().then((C) => {
            i.paste(
              C,
              v,
              v === "context-menu" ? t.inputs.currentPagePoint : void 0
            );
          }).catch(() => {
            i.addToast({
              title: i.msg("action.paste-error-title"),
              description: i.msg("action.paste-error-description"),
              severity: "error"
            });
          });
        }
      },
      {
        id: "select-all",
        label: "action.select-all",
        kbd: "$a",
        readonlyOk: !0,
        onSelect(v) {
          t.run(() => {
            d() || (s("select-all-shapes", { source: v }), t.markHistoryStoppingPoint("select all kbd"), t.selectAll());
          });
        }
      },
      {
        id: "select-none",
        label: "action.select-none",
        readonlyOk: !0,
        onSelect(v) {
          h() && (d() || (s("select-none-shapes", { source: v }), t.markHistoryStoppingPoint("select none"), t.selectNone()));
        }
      },
      {
        id: "delete",
        label: "action.delete",
        kbd: "⌫,del,backspace",
        icon: "trash",
        onSelect(v) {
          h() && (d() || (s("delete-shapes", { source: v }), t.markHistoryStoppingPoint("delete"), t.deleteShapes(t.getSelectedShapeIds())));
        }
      },
      {
        id: "rotate-cw",
        label: "action.rotate-cw",
        icon: "rotate-cw",
        onSelect(v) {
          if (!h() || d()) return;
          s("rotate-cw", { source: v }), t.markHistoryStoppingPoint("rotate-cw");
          const w = t.getSelectionRotation() % (Or / 2), C = fh(w, 0) || fh(w, Or / 2), E = t.getSelectedShapeIds();
          t.rotateShapesBy(E, Or / 2 - (C ? 0 : w)), Dr(t, E);
        }
      },
      {
        id: "rotate-ccw",
        label: "action.rotate-ccw",
        icon: "rotate-ccw",
        onSelect(v) {
          if (!h() || d()) return;
          s("rotate-ccw", { source: v }), t.markHistoryStoppingPoint("rotate-ccw");
          const w = t.getSelectionRotation() % (Or / 2), C = fh(w, 0), E = t.getSelectedShapeIds();
          t.rotateShapesBy(E, C ? -(Or / 2) : -w), Dr(t, E);
        }
      },
      {
        id: "zoom-in",
        label: "action.zoom-in",
        kbd: "$=,=",
        readonlyOk: !0,
        onSelect(v) {
          s("zoom-in", { source: v }), t.zoomIn(void 0, {
            animation: { duration: t.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-out",
        label: "action.zoom-out",
        kbd: "$-,-",
        readonlyOk: !0,
        onSelect(v) {
          s("zoom-out", { source: v }), t.zoomOut(void 0, {
            animation: { duration: t.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-100",
        label: "action.zoom-to-100",
        icon: "reset-zoom",
        kbd: "!0",
        readonlyOk: !0,
        onSelect(v) {
          s("reset-zoom", { source: v }), t.resetZoom(void 0, {
            animation: { duration: t.options.animationMediumMs }
          });
        }
      },
      {
        id: "zoom-to-fit",
        label: "action.zoom-to-fit",
        kbd: "!1",
        readonlyOk: !0,
        onSelect(v) {
          s("zoom-to-fit", { source: v }), t.zoomToFit({ animation: { duration: t.options.animationMediumMs } });
        }
      },
      {
        id: "zoom-to-selection",
        label: "action.zoom-to-selection",
        kbd: "!2",
        readonlyOk: !0,
        onSelect(v) {
          h() && (d() || (s("zoom-to-selection", { source: v }), t.zoomToSelection({ animation: { duration: t.options.animationMediumMs } })));
        }
      },
      {
        id: "toggle-snap-mode",
        label: {
          default: "action.toggle-snap-mode",
          menu: "action.toggle-snap-mode.menu"
        },
        onSelect(v) {
          s("toggle-snap-mode", { source: v }), t.user.updateUserPreferences({ isSnapMode: !t.user.getIsSnapMode() });
        },
        checkbox: !0
      },
      {
        id: "toggle-dark-mode",
        label: {
          default: "action.toggle-dark-mode",
          menu: "action.toggle-dark-mode.menu"
        },
        kbd: "$/",
        readonlyOk: !0,
        onSelect(v) {
          const w = t.user.getIsDarkMode() ? "light" : "dark";
          s("color-scheme", { source: v, value: w }), t.user.updateUserPreferences({
            colorScheme: w
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-wrap-mode",
        label: {
          default: "action.toggle-wrap-mode",
          menu: "action.toggle-wrap-mode.menu"
        },
        readonlyOk: !0,
        onSelect(v) {
          s("toggle-wrap-mode", { source: v }), t.user.updateUserPreferences({
            isWrapMode: !t.user.getIsWrapMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-dynamic-size-mode",
        label: {
          default: "action.toggle-dynamic-size-mode",
          menu: "action.toggle-dynamic-size-mode.menu"
        },
        readonlyOk: !1,
        onSelect(v) {
          s("toggle-dynamic-size-mode", { source: v }), t.user.updateUserPreferences({
            isDynamicSizeMode: !t.user.getIsDynamicResizeMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-paste-at-cursor",
        label: {
          default: "action.toggle-paste-at-cursor",
          menu: "action.toggle-paste-at-cursor.menu"
        },
        readonlyOk: !1,
        onSelect(v) {
          s("toggle-paste-at-cursor", { source: v }), t.user.updateUserPreferences({
            isPasteAtCursorMode: !t.user.getIsPasteAtCursorMode()
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-reduce-motion",
        label: {
          default: "action.toggle-reduce-motion",
          menu: "action.toggle-reduce-motion.menu"
        },
        readonlyOk: !0,
        onSelect(v) {
          s("toggle-reduce-motion", { source: v }), t.user.updateUserPreferences({
            animationSpeed: t.user.getAnimationSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-edge-scrolling",
        label: {
          default: "action.toggle-edge-scrolling",
          menu: "action.toggle-edge-scrolling.menu"
        },
        readonlyOk: !0,
        onSelect(v) {
          s("toggle-edge-scrolling", { source: v }), t.user.updateUserPreferences({
            edgeScrollSpeed: t.user.getEdgeScrollSpeed() === 0 ? 1 : 0
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-transparent",
        label: {
          default: "action.toggle-transparent",
          menu: "action.toggle-transparent.menu",
          "context-menu": "action.toggle-transparent.context-menu"
        },
        readonlyOk: !0,
        onSelect(v) {
          s("toggle-transparent", { source: v }), t.updateInstanceState({
            exportBackground: !t.getInstanceState().exportBackground
          });
        },
        checkbox: !0
      },
      {
        id: "toggle-tool-lock",
        label: {
          default: "action.toggle-tool-lock",
          menu: "action.toggle-tool-lock.menu"
        },
        kbd: "q",
        onSelect(v) {
          s("toggle-tool-lock", { source: v }), t.updateInstanceState({ isToolLocked: !t.getInstanceState().isToolLocked });
        },
        checkbox: !0
      },
      {
        id: "unlock-all",
        label: "action.unlock-all",
        onSelect(v) {
          s("unlock-all", { source: v });
          const w = [];
          for (const C of t.getCurrentPageShapes())
            C.isLocked && w.push({ id: C.id, type: C.type, isLocked: !1 });
          w.length > 0 && t.updateShapes(w);
        }
      },
      {
        id: "toggle-focus-mode",
        label: {
          default: "action.toggle-focus-mode",
          menu: "action.toggle-focus-mode.menu"
        },
        readonlyOk: !0,
        kbd: "$.",
        checkbox: !0,
        onSelect(v) {
          t.timers.requestAnimationFrame(() => {
            t.run(() => {
              s("toggle-focus-mode", { source: v }), i.clearDialogs(), i.clearToasts(), t.updateInstanceState({ isFocusMode: !t.getInstanceState().isFocusMode });
            });
          });
        }
      },
      {
        id: "toggle-grid",
        label: {
          default: "action.toggle-grid",
          menu: "action.toggle-grid.menu"
        },
        readonlyOk: !0,
        kbd: "$'",
        onSelect(v) {
          s("toggle-grid-mode", { source: v }), t.updateInstanceState({ isGridMode: !t.getInstanceState().isGridMode });
        },
        checkbox: !0
      },
      {
        id: "toggle-debug-mode",
        label: {
          default: "action.toggle-debug-mode",
          menu: "action.toggle-debug-mode.menu"
        },
        readonlyOk: !0,
        onSelect(v) {
          s("toggle-debug-mode", { source: v }), t.updateInstanceState({
            isDebugMode: !t.getInstanceState().isDebugMode
          });
        },
        checkbox: !0
      },
      {
        id: "print",
        label: "action.print",
        kbd: "$p",
        readonlyOk: !0,
        onSelect(v) {
          s("print", { source: v }), i.printSelectionOrPages();
        }
      },
      {
        id: "exit-pen-mode",
        label: "action.exit-pen-mode",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(v) {
          s("exit-pen-mode", { source: v }), t.updateInstanceState({ isPenMode: !1 });
        }
      },
      {
        id: "stop-following",
        label: "action.stop-following",
        icon: "cross-2",
        readonlyOk: !0,
        onSelect(v) {
          s("stop-following", { source: v }), t.stopFollowingUser();
        }
      },
      {
        id: "back-to-content",
        label: "action.back-to-content",
        icon: "arrow-left",
        readonlyOk: !0,
        onSelect(v) {
          s("zoom-to-content", { source: v });
          const w = t.getSelectionPageBounds() ?? t.getCurrentPageBounds();
          w && t.zoomToBounds(w, {
            targetZoom: Math.min(1, t.getZoomLevel()),
            animation: { duration: 220 }
          });
        }
      },
      {
        id: "toggle-lock",
        label: "action.toggle-lock",
        kbd: "!l",
        onSelect(v) {
          t.markHistoryStoppingPoint("locking"), s("toggle-lock", { source: v }), t.toggleLock(t.getSelectedShapeIds());
        }
      },
      {
        id: "move-to-new-page",
        label: "context.pages.new-page",
        onSelect(v) {
          const w = rl.createId(), C = t.getSelectedShapeIds();
          t.run(() => {
            t.markHistoryStoppingPoint("move_shapes_to_page"), t.createPage({
              name: i.msg("page-menu.new-page-initial-name"),
              id: w
            }), t.moveShapesToPage(C, w);
          }), s("move-to-new-page", { source: v });
        }
      },
      {
        id: "select-white-color",
        label: "color-style.white",
        kbd: "?t",
        onSelect(v) {
          const w = nl;
          t.run(() => {
            t.markHistoryStoppingPoint("change-color"), t.isIn("select") && t.setStyleForSelectedShapes(w, "white"), t.setStyleForNextShapes(w, "white");
          }), s("set-style", { source: v, id: w.id, value: "white" });
        }
      },
      {
        id: "select-fill-fill",
        label: "fill-style.fill",
        kbd: "?f",
        onSelect(v) {
          const w = eg;
          t.run(() => {
            t.markHistoryStoppingPoint("change-fill"), t.isIn("select") && t.setStyleForSelectedShapes(w, "fill"), t.setStyleForNextShapes(w, "fill");
          }), s("set-style", { source: v, id: w.id, value: "fill" });
        }
      },
      {
        id: "flatten-to-image",
        label: "action.flatten-to-image",
        kbd: "!f",
        onSelect: async (v) => {
          const w = t.getSelectedShapeIds();
          if (w.length === 0) return;
          t.markHistoryStoppingPoint("flattening to image"), s("flatten-to-image", { source: v });
          const C = await Yme(
            t,
            w,
            t.options.flattenImageBoundsExpand
          );
          C != null && C.length && t.setSelectedShapes(C);
        }
      }
    ];
    r && g.push({
      id: "open-cursor-chat",
      label: "action.open-cursor-chat",
      readonlyOk: !0,
      kbd: "/",
      onSelect(v) {
        s("open-cursor-chat", { source: v }), !t.getInstanceState().isCoarsePointer && t.timers.requestAnimationFrame(() => {
          t.updateInstanceState({ isChatting: !0 });
        });
      }
    });
    const y = Ive(g);
    return n ? n(t, y, i) : y;
  }, [i, t, s, n, l, r]);
  return /* @__PURE__ */ m.jsx(_W.Provider, { value: c, children: e });
}
function gg() {
  const n = M.useContext(_W);
  if (!n)
    throw new Error("useTools must be used within a ToolProvider");
  return n;
}
function rw(n, e) {
  return n ? typeof n == "string" ? n : e ? n[e] ?? n.default : void 0 : void 0;
}
function ol() {
  const n = _h();
  return Pe("isReadonlyMode", () => !!(n != null && n.getIsReadonly()), [n]);
}
const Rve = Er.isDarwin ? "⌘" : "Ctrl", Mve = Er.isDarwin ? "⌥" : "Alt";
function PW(n) {
  return n === "," ? [","] : n.split(",")[0].split("").map((e) => {
    const t = e.replace(/\$/g, Rve).replace(/\?/g, Mve).replace(/!/g, "⇧");
    return t[0].toUpperCase() + t.slice(1);
  });
}
function bD(n) {
  return "— " + PW(n).join(" ");
}
function Lx({ children: n, visibleOnMobileLayout: e = !1 }) {
  const t = qs();
  return !e && t < yi.MOBILE ? null : /* @__PURE__ */ m.jsx("kbd", { className: "tlui-kbd", children: PW(n).map((r, i) => /* @__PURE__ */ m.jsx("span", { children: r }, i)) });
}
const TW = M.createContext(null);
function j_() {
  const n = M.useContext(TW);
  if (!n)
    throw new Error("useTldrawUiMenuContext must be used within a TldrawUiMenuContextProvider");
  return n;
}
function Ll({
  type: n,
  sourceId: e,
  children: t
}) {
  return /* @__PURE__ */ m.jsx(TW.Provider, { value: { type: n, sourceId: e }, children: t });
}
function L_({
  id: n,
  kbd: e,
  label: t,
  readonlyOk: r,
  onSelect: i,
  toggle: s = !1,
  disabled: l = !1,
  checked: c = !1
}) {
  const { type: d, sourceId: h } = j_(), g = ol(), y = Ln();
  if (g && !r) return null;
  const v = rw(t, d), w = v ? y(v) : void 0;
  switch (d) {
    case "menu":
      return /* @__PURE__ */ m.jsxs(
        gme,
        {
          dir: "ltr",
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          title: w,
          onSelect: (C) => {
            i == null || i(h), wn(C);
          },
          disabled: l,
          checked: c,
          children: [
            /* @__PURE__ */ m.jsx(
              ku,
              {
                small: !0,
                icon: s ? c ? "toggle-on" : "toggle-off" : c ? "check" : "none"
              }
            ),
            w && /* @__PURE__ */ m.jsx("span", { className: "tlui-button__label", draggable: !1, children: w }),
            e && /* @__PURE__ */ m.jsx(Lx, { children: e })
          ]
        }
      );
    case "context-menu":
      return /* @__PURE__ */ m.jsxs(
        Kge,
        {
          className: "tlui-button tlui-button__menu tlui-button__checkbox",
          dir: "ltr",
          title: w,
          onSelect: (C) => {
            i(h), wn(C);
          },
          disabled: l,
          checked: c,
          children: [
            /* @__PURE__ */ m.jsx(
              ku,
              {
                small: !0,
                icon: s ? c ? "toggle-on" : "toggle-off" : c ? "check" : "none"
              }
            ),
            w && /* @__PURE__ */ m.jsx("span", { className: "tlui-button__label", draggable: !1, children: w }),
            e && /* @__PURE__ */ m.jsx(Lx, { children: e })
          ]
        },
        n
      );
    default:
      return null;
  }
}
function Xd(n, e) {
  const t = _h(), r = M.useCallback(
    (l) => {
      l && (t == null || t.complete()), e == null || e(l);
    },
    [t, e]
  ), i = Vo(), s = M.useCallback(
    (l) => {
      i(l, { source: "unknown", id: n });
    },
    [n, i]
  );
  return ife(t ? `${n}-${t.contextId}` : n, r, s);
}
function og({
  id: n,
  children: e,
  modal: t = !1,
  debugOpen: r = !1
}) {
  const [i, s] = Xd(n);
  return /* @__PURE__ */ m.jsx(
    Aj,
    {
      open: r || i,
      dir: "ltr",
      modal: t,
      onOpenChange: s,
      children: e
    }
  );
}
function sg({ children: n, ...e }) {
  return /* @__PURE__ */ m.jsx(
    Dj,
    {
      dir: "ltr",
      asChild: !0,
      onTouchEnd: (t) => wn(t),
      ...e,
      children: n
    }
  );
}
function ag({
  className: n,
  side: e = "bottom",
  align: t = "start",
  sideOffset: r = 8,
  alignOffset: i = 8,
  children: s
}) {
  const l = io();
  return /* @__PURE__ */ m.jsx(T_, { container: l, children: /* @__PURE__ */ m.jsx(
    Oj,
    {
      className: It("tlui-menu", n),
      side: e,
      sideOffset: r,
      align: t,
      alignOffset: i,
      collisionPadding: 4,
      children: s
    }
  ) });
}
function Ave({ id: n, children: e }) {
  const [t, r] = Xd(n);
  return /* @__PURE__ */ m.jsx(mme, { open: t, onOpenChange: r, children: e });
}
function Dve({
  id: n,
  label: e,
  title: t,
  disabled: r
}) {
  return /* @__PURE__ */ m.jsx(yme, { dir: "ltr", asChild: !0, disabled: r, children: /* @__PURE__ */ m.jsxs(
    Ot,
    {
      "data-testid": n,
      type: "menu",
      className: "tlui-menu__submenu__trigger",
      disabled: r,
      title: t,
      children: [
        /* @__PURE__ */ m.jsx(_i, { children: e }),
        /* @__PURE__ */ m.jsx(In, { icon: "chevron-right", small: !0 })
      ]
    }
  ) });
}
function Ove({
  id: n,
  alignOffset: e = -1,
  sideOffset: t = -6,
  size: r = "small",
  children: i
}) {
  const s = io();
  return /* @__PURE__ */ m.jsx(T_, { container: s, children: /* @__PURE__ */ m.jsx(
    vme,
    {
      "data-testid": n,
      className: "tlui-menu tlui-menu__submenu__content",
      alignOffset: e,
      sideOffset: t,
      collisionPadding: 4,
      "data-size": r,
      children: i
    }
  ) });
}
function jve({ children: n }) {
  return /* @__PURE__ */ m.jsx(hme, { dir: "ltr", className: "tlui-menu__group", children: n });
}
function iw({ noClose: n, children: e }) {
  return /* @__PURE__ */ m.jsx(pme, { dir: "ltr", asChild: !0, onClick: n ? wn : void 0, children: e });
}
function gn({ id: n, label: e, children: t }) {
  const { type: r, sourceId: i } = j_(), s = Ln(), l = rw(e, r), c = l ? s(l) : void 0;
  switch (r) {
    case "panel":
      return /* @__PURE__ */ m.jsx("div", { className: "tlui-menu__group", "data-testid": `${i}-group.${n}`, children: t });
    case "menu":
      return /* @__PURE__ */ m.jsx(jve, { "data-testid": `${i}-group.${n}`, children: t });
    case "context-menu":
      return /* @__PURE__ */ m.jsx(
        mK,
        {
          dir: "ltr",
          className: "tlui-menu__group",
          "data-testid": `${i}-group.${n}`,
          children: t
        }
      );
    case "keyboard-shortcuts":
      return /* @__PURE__ */ m.jsxs("div", { className: "tlui-shortcuts-dialog__group", "data-testid": `${i}-group.${n}`, children: [
        /* @__PURE__ */ m.jsx("h2", { className: "tlui-shortcuts-dialog__group__title", children: c }),
        /* @__PURE__ */ m.jsx("div", { className: "tlui-shortcuts-dialog__group__content", children: t })
      ] });
    default:
      return t;
  }
}
function Ia({
  id: n,
  disabled: e = !1,
  label: t,
  size: r = "small",
  children: i
}) {
  const { type: s, sourceId: l } = j_(), c = io(), d = Ln(), h = t ? typeof t == "string" ? t : t[s] ?? t.default : void 0, g = h ? d(h) : void 0;
  switch (s) {
    case "menu":
      return /* @__PURE__ */ m.jsxs(Ave, { id: `${l}-sub.${n}`, children: [
        /* @__PURE__ */ m.jsx(
          Dve,
          {
            id: `${l}-sub.${n}-button`,
            disabled: e,
            label: g,
            title: g
          }
        ),
        /* @__PURE__ */ m.jsx(Ove, { id: `${l}-sub.${n}-content`, size: r, children: i })
      ] });
    case "context-menu":
      return e ? null : /* @__PURE__ */ m.jsxs(Lve, { id: `${l}-sub.${n}`, children: [
        /* @__PURE__ */ m.jsx(xK, { dir: "ltr", disabled: e, asChild: !0, children: /* @__PURE__ */ m.jsxs(
          Ot,
          {
            "data-testid": `${l}-sub.${n}-button`,
            type: "menu",
            className: "tlui-menu__submenu__trigger",
            children: [
              /* @__PURE__ */ m.jsx(_i, { children: g }),
              /* @__PURE__ */ m.jsx(In, { icon: "chevron-right", small: !0 })
            ]
          }
        ) }),
        /* @__PURE__ */ m.jsx(Rj, { container: c, children: /* @__PURE__ */ m.jsx(
          wK,
          {
            "data-testid": `${l}-sub.${n}-content`,
            className: "tlui-menu tlui-menu__submenu__content",
            alignOffset: -1,
            sideOffset: -4,
            collisionPadding: 4,
            "data-size": r,
            children: i
          }
        ) })
      ] });
    default:
      return i;
  }
}
function Lve({ id: n, children: e }) {
  const [t, r] = Xd(n);
  return /* @__PURE__ */ m.jsx(SK, { open: t, onOpenChange: r, children: e });
}
const Nve = [
  { colorScheme: "light", label: "theme.light" },
  { colorScheme: "dark", label: "theme.dark" },
  { colorScheme: "system", label: "theme.system" }
];
function Fve() {
  const n = be(), e = Vo(), t = Pe(
    "colorScheme",
    () => n.user.getUserPreferences().colorScheme ?? (n.user.getIsDarkMode() ? "dark" : "light"),
    [n]
  );
  return /* @__PURE__ */ m.jsx(Ia, { id: "help menu color-scheme", label: "menu.theme", children: /* @__PURE__ */ m.jsx(gn, { id: "theme", children: Nve.map(({ colorScheme: r, label: i }) => /* @__PURE__ */ m.jsx(
    L_,
    {
      id: `color-scheme-${r}`,
      label: i,
      checked: r === t,
      readonlyOk: !0,
      onSelect: () => {
        n.user.updateUserPreferences({ colorScheme: r }), e("color-scheme", { source: "menu", value: r });
      }
    },
    r
  )) }) });
}
const zve = ({ id: n, component: e, onClose: t }) => {
  const { removeDialog: r } = Dw(), i = io(), s = M.useCallback(
    (l) => {
      if (!l) {
        if (t)
          try {
            t();
          } catch (c) {
            console.warn(c);
          }
        r(n);
      }
    },
    [n, t, r]
  );
  return /* @__PURE__ */ m.jsx(Nme, { onOpenChange: s, defaultOpen: !0, children: /* @__PURE__ */ m.jsx(Fme, { container: i, children: /* @__PURE__ */ m.jsx(
    zme,
    {
      dir: "ltr",
      className: "tlui-dialog__overlay",
      onClick: (l) => {
        l.target === l.currentTarget && s(!1);
      },
      children: /* @__PURE__ */ m.jsx(Ume, { dir: "ltr", className: "tlui-dialog__content", "aria-describedby": void 0, children: /* @__PURE__ */ m.jsx(e, { onClose: () => s(!1) }) })
    }
  ) }) });
}, Uve = M.memo(function() {
  const { dialogs: e } = Dw();
  return Pe("dialogs", () => e.get(), [e]).map((r) => /* @__PURE__ */ m.jsx(zve, { ...r }, r.id));
}), $ve = 4e3, Bve = {
  success: "check-circle",
  warning: "warning-triangle",
  error: "cross-circle",
  info: "info-circle"
};
function Hve({ toast: n }) {
  const { removeToast: e } = Yd(), t = Ln(), r = (l) => {
    l || e(n.id);
  }, i = n.actions && n.actions.length > 0, s = n.icon || n.severity && Bve[n.severity];
  return /* @__PURE__ */ m.jsxs(
    yye,
    {
      onOpenChange: r,
      className: "tlui-toast__container",
      duration: n.keepOpen ? 1 / 0 : $ve,
      "data-severity": n.severity,
      children: [
        s && /* @__PURE__ */ m.jsx("div", { className: "tlui-toast__icon", children: /* @__PURE__ */ m.jsx(ku, { icon: s }) }),
        /* @__PURE__ */ m.jsxs(
          "div",
          {
            className: "tlui-toast__main",
            "data-title": !!n.title,
            "data-description": !!n.description,
            "data-actions": !!n.actions,
            children: [
              /* @__PURE__ */ m.jsxs("div", { className: "tlui-toast__content", children: [
                n.title && /* @__PURE__ */ m.jsx(vye, { className: "tlui-toast__title", children: n.title }),
                n.description && /* @__PURE__ */ m.jsx(Sye, { className: "tlui-toast__description", children: n.description })
              ] }),
              n.actions && /* @__PURE__ */ m.jsxs("div", { className: "tlui-toast__actions", children: [
                n.actions.map((l, c) => /* @__PURE__ */ m.jsx(xye, { altText: l.label, asChild: !0, onClick: l.onClick, children: /* @__PURE__ */ m.jsx(Ot, { type: l.type, children: /* @__PURE__ */ m.jsx(_i, { children: l.label }) }) }, c)),
                /* @__PURE__ */ m.jsx(jU, { asChild: !0, children: /* @__PURE__ */ m.jsx(
                  Ot,
                  {
                    type: "normal",
                    className: "tlui-toast__close",
                    style: { marginLeft: "auto" },
                    children: /* @__PURE__ */ m.jsx(_i, { children: n.closeLabel ?? t("toast.close") })
                  }
                ) })
              ] })
            ]
          }
        ),
        !i && /* @__PURE__ */ m.jsx(jU, { asChild: !0, children: /* @__PURE__ */ m.jsx(Ot, { type: "normal", className: "tlui-toast__close", children: /* @__PURE__ */ m.jsx(_i, { children: n.closeLabel ?? t("toast.close") }) }) })
      ]
    }
  );
}
const Vve = M.memo(function() {
  const { toasts: e } = Yd(), t = Pe("toasts", () => e.get(), []);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    t.map((r) => /* @__PURE__ */ m.jsx(Hve, { toast: r }, r.id)),
    /* @__PURE__ */ m.jsx(oW, { className: "tlui-toast__viewport" })
  ] });
});
function Mc({
  actionId: n = "",
  ...e
}) {
  const r = gg()[n];
  return r ? /* @__PURE__ */ m.jsx(L_, { ...r, ...e }) : null;
}
function BU(n) {
  return /* @__PURE__ */ m.jsx("svg", { width: 16, height: 16, viewBox: "0 0 16 16", ...n, children: /* @__PURE__ */ m.jsxs("g", { strokeWidth: 2, fill: "none", fillRule: "evenodd", children: [
    /* @__PURE__ */ m.jsx("circle", { strokeOpacity: 0.25, cx: 8, cy: 8, r: 7, stroke: "currentColor" }),
    /* @__PURE__ */ m.jsx("path", { strokeLinecap: "round", d: "M15 8c0-4.5-4.5-7-7-7", stroke: "currentColor", children: /* @__PURE__ */ m.jsx(
      "animateTransform",
      {
        attributeName: "transform",
        type: "rotate",
        from: "0 8 8",
        to: "360 8 8",
        dur: "1s",
        repeatCount: "indefinite"
      }
    ) })
  ] }) });
}
function Lo({
  disabled: n = !1,
  spinner: e = !1,
  readonlyOk: t = !1,
  id: r,
  kbd: i,
  label: s,
  icon: l,
  onSelect: c,
  noClose: d,
  isSelected: h
}) {
  const { type: g, sourceId: y } = j_(), v = Ln(), [w, C] = M.useState(!1);
  if (ol() && !t) return null;
  const P = rw(s, g), I = i ? bD(i) : void 0, k = P ? v(P) : void 0, L = k && I ? `${k} ${I}` : k;
  switch (g) {
    case "menu":
      return /* @__PURE__ */ m.jsx(iw, { children: /* @__PURE__ */ m.jsxs(
        Ot,
        {
          type: "menu",
          "data-testid": `${y}.${r}`,
          disabled: n,
          title: L,
          onClick: (O) => {
            d && wn(O), w ? C(!1) : c(y);
          },
          children: [
            /* @__PURE__ */ m.jsx(_i, { children: k }),
            i && /* @__PURE__ */ m.jsx(Lx, { children: i })
          ]
        }
      ) });
    case "context-menu":
      return n ? null : /* @__PURE__ */ m.jsxs(
        yK,
        {
          dir: "ltr",
          title: L,
          draggable: !1,
          className: "tlui-button tlui-button__menu",
          "data-testid": `${y}.${r}`,
          onSelect: (O) => {
            d && wn(O), w ? C(!1) : c(y);
          },
          children: [
            /* @__PURE__ */ m.jsx("span", { className: "tlui-button__label", draggable: !1, children: k }),
            i && /* @__PURE__ */ m.jsx(Lx, { children: i }),
            e && /* @__PURE__ */ m.jsx(BU, {})
          ]
        }
      );
    case "panel":
      return /* @__PURE__ */ m.jsxs(
        Ot,
        {
          "data-testid": `${y}.${r}`,
          type: "menu",
          title: L,
          disabled: n,
          onClick: () => c(y),
          children: [
            /* @__PURE__ */ m.jsx(_i, { children: k }),
            e ? /* @__PURE__ */ m.jsx(BU, {}) : l && /* @__PURE__ */ m.jsx(In, { icon: l })
          ]
        }
      );
    case "small-icons":
    case "icons":
      return /* @__PURE__ */ m.jsx(
        Ot,
        {
          "data-testid": `${y}.${r}`,
          type: "icon",
          title: L,
          disabled: n,
          onClick: () => c(y),
          children: /* @__PURE__ */ m.jsx(In, { icon: l, small: g === "small-icons" })
        }
      );
    case "keyboard-shortcuts":
      return i ? /* @__PURE__ */ m.jsxs("div", { className: "tlui-shortcuts-dialog__key-pair", "data-testid": `${y}.${r}`, children: [
        /* @__PURE__ */ m.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__key", children: k }),
        /* @__PURE__ */ m.jsx("div", { className: "tlui-shortcuts-dialog__key-pair__value", children: /* @__PURE__ */ m.jsx(Lx, { visibleOnMobileLayout: !0, children: i }) })
      ] }) : (console.warn(
        `Menu item '${s}' isn't shown in the keyboard shortcuts dialog because it doesn't have a keyboard shortcut.`
      ), null);
    case "helper-buttons":
      return /* @__PURE__ */ m.jsxs(Ot, { type: "low", onClick: () => c(y), children: [
        /* @__PURE__ */ m.jsx(In, { icon: l }),
        /* @__PURE__ */ m.jsx(_i, { children: k })
      ] });
    case "toolbar":
      return /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "tool",
          "data-testid": `tools.${r}`,
          "aria-label": P,
          "data-value": r,
          onClick: () => c("toolbar"),
          title: L,
          disabled: n,
          onTouchStart: (O) => {
            wn(O), c("toolbar");
          },
          role: "radio",
          "aria-checked": h ? "true" : "false",
          children: /* @__PURE__ */ m.jsx(In, { icon: l })
        }
      );
    case "toolbar-overflow":
      return /* @__PURE__ */ m.jsx(iw, { "aria-label": s, children: /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          className: "tlui-button-grid__button",
          onClick: () => {
            c("toolbar");
          },
          "data-testid": `tools.more.${r}`,
          title: L,
          disabled: n,
          role: "radio",
          "aria-checked": h ? "true" : "false",
          "data-value": r,
          children: /* @__PURE__ */ m.jsx(In, { icon: l })
        }
      ) });
    default:
      throw ro(g);
  }
}
function Fe({ actionId: n = "", ...e }) {
  const r = gg()[n];
  return r ? /* @__PURE__ */ m.jsx(Lo, { ...r, ...e }) : null;
}
const IW = M.createContext(null);
function Kve({ overrides: n, children: e }) {
  const t = be(), r = Vo(), i = qj(), s = M.useMemo(() => {
    const l = [
      {
        id: "select",
        label: "tool.select",
        icon: "tool-pointer",
        kbd: "v",
        readonlyOk: !0,
        onSelect(d) {
          if (t.isIn("select")) {
            const h = t.root.getCurrent();
            h.exit({}, h.id), h.enter({}, h.id);
          }
          t.setCurrentTool("select"), r("select-tool", { source: d, id: "select" });
        }
      },
      {
        id: "hand",
        label: "tool.hand",
        icon: "tool-hand",
        kbd: "h",
        readonlyOk: !0,
        onSelect(d) {
          t.setCurrentTool("hand"), r("select-tool", { source: d, id: "hand" });
        }
      },
      {
        id: "eraser",
        label: "tool.eraser",
        icon: "tool-eraser",
        kbd: "e",
        onSelect(d) {
          t.setCurrentTool("eraser"), r("select-tool", { source: d, id: "eraser" });
        }
      },
      {
        id: "draw",
        label: "tool.draw",
        icon: "tool-pencil",
        kbd: "d,b,x",
        onSelect(d) {
          t.setCurrentTool("draw"), r("select-tool", { source: d, id: "draw" });
        }
      },
      ...[...Sc.values].map((d) => ({
        id: d,
        label: `tool.${d}`,
        meta: {
          geo: d
        },
        kbd: d === "rectangle" ? "r" : d === "ellipse" ? "o" : void 0,
        icon: "geo-" + d,
        onSelect(h) {
          t.run(() => {
            t.setStyleForNextShapes(Sc, d), t.setCurrentTool("geo"), r("select-tool", { source: h, id: `geo-${d}` });
          });
        }
      })),
      {
        id: "arrow",
        label: "tool.arrow",
        icon: "tool-arrow",
        kbd: "a",
        onSelect(d) {
          t.setCurrentTool("arrow"), r("select-tool", { source: d, id: "arrow" });
        }
      },
      {
        id: "line",
        label: "tool.line",
        icon: "tool-line",
        kbd: "l",
        onSelect(d) {
          t.setCurrentTool("line"), r("select-tool", { source: d, id: "line" });
        }
      },
      {
        id: "frame",
        label: "tool.frame",
        icon: "tool-frame",
        kbd: "f",
        onSelect(d) {
          t.setCurrentTool("frame"), r("select-tool", { source: d, id: "frame" });
        }
      },
      {
        id: "text",
        label: "tool.text",
        icon: "tool-text",
        kbd: "t",
        onSelect(d) {
          t.setCurrentTool("text"), r("select-tool", { source: d, id: "text" });
        }
      },
      {
        id: "asset",
        label: "tool.asset",
        icon: "tool-media",
        kbd: "$u",
        onSelect(d) {
          i.insertMedia(), r("select-tool", { source: d, id: "media" });
        }
      },
      {
        id: "note",
        label: "tool.note",
        icon: "tool-note",
        kbd: "n",
        onSelect(d) {
          t.setCurrentTool("note"), r("select-tool", { source: d, id: "note" });
        }
      },
      {
        id: "laser",
        label: "tool.laser",
        readonlyOk: !0,
        icon: "tool-laser",
        kbd: "k",
        onSelect(d) {
          t.setCurrentTool("laser"), r("select-tool", { source: d, id: "laser" });
        }
      },
      {
        id: "embed",
        label: "tool.embed",
        icon: "dot",
        onSelect(d) {
          i.addDialog({ component: JK }), r("select-tool", { source: d, id: "embed" });
        }
      },
      {
        id: "highlight",
        label: "tool.highlight",
        icon: "tool-highlight",
        // TODO: pick a better shortcut
        kbd: "!d",
        onSelect(d) {
          t.setCurrentTool("highlight"), r("select-tool", { source: d, id: "highlight" });
        }
      }
    ];
    l.push();
    const c = Object.fromEntries(l.map((d) => [d.id, d]));
    return n ? n(t, c, i) : c;
  }, [n, t, r, i]);
  return /* @__PURE__ */ m.jsx(IW.Provider, { value: s, children: e });
}
function Yj() {
  const n = M.useContext(IW);
  if (!n)
    throw new Error("useTools must be used within a ToolProvider");
  return n;
}
function ma({ toolId: n = "", ...e }) {
  const r = Yj()[n];
  return r ? /* @__PURE__ */ m.jsx(Lo, { ...r, ...e }) : null;
}
function Wve({ children: n }) {
  const e = be();
  return Pe(
    "shouldDisplayHandles",
    () => {
      if (e.isInAny("select.idle", "select.pointing_handle", "select.pointing_shape"))
        return !0;
      if (e.isInAny("select.editing_shape")) {
        const r = e.getOnlySelectedShape();
        return r && e.isShapeOfType(r, "note");
      }
      return !1;
    },
    [e]
  ) ? /* @__PURE__ */ m.jsx("svg", { className: "tl-user-handles tl-overlays__item", children: n }) : null;
}
const { PI: Gve } = Math, ky = Gve + 1e-4;
function kW(n, e = {}) {
  const { size: t = 16, smoothing: r = 0.5 } = e;
  if (n.length === 0 || t <= 0)
    return { left: [], right: [] };
  const i = n[0], s = n[n.length - 1], l = s.runningLength, c = Math.pow(t * r, 2), d = [], h = [];
  let g = n[0].vector, y = n[0].point, v = y, w = y, C = v, E = !1, P;
  for (let I = 0; I < n.length; I++) {
    P = n[I];
    const { point: k, vector: L } = n[I], O = P.vector.dpr(g), z = (I < n.length - 1 ? n[I + 1] : n[I]).vector, F = I < n.length - 1 ? z.dpr(P.vector) : 1, H = O < 0 && !E, V = F !== null && F < 0.2;
    if (H || V) {
      if (F > -0.62 && l - P.runningLength > P.radius) {
        const q = g.clone().mul(P.radius);
        g.clone().cpr(z) < 0 ? (w = R.Add(k, q), C = R.Sub(k, q)) : (w = R.Sub(k, q), C = R.Add(k, q)), d.push(w), h.push(C);
      } else {
        const q = g.clone().mul(P.radius).per(), J = R.Sub(P.input, q);
        for (let ie = 1 / 13, W = 0; W < 1; W += ie)
          w = R.RotWith(J, P.input, ky * W), d.push(w), C = R.RotWith(J, P.input, ky + ky * -W), h.push(C);
      }
      y = w, v = C, V && (E = !0);
      continue;
    }
    if (E = !1, P === i || P === s) {
      const q = R.Per(L).mul(P.radius);
      d.push(R.Sub(k, q)), h.push(R.Add(k, q));
      continue;
    }
    const re = R.Lrp(z, L, F).per().mul(P.radius);
    w = R.Sub(k, re), (I <= 1 || R.Dist2(y, w) > c) && (d.push(w), y = w), C = R.Add(k, re), (I <= 1 || R.Dist2(v, C) > c) && (h.push(C), v = C), g = L;
  }
  return {
    left: d,
    right: h
  };
}
function Xj(n, e = {}) {
  const { size: t = 16, start: r = {}, end: i = {}, last: s = !1 } = e, { cap: l = !0 } = r, { cap: c = !0 } = i;
  if (n.length === 0 || t <= 0)
    return [];
  const d = n[0], h = n[n.length - 1], g = h.runningLength, y = r.taper === !1 ? 0 : r.taper === !0 ? Math.max(t, g) : r.taper, v = i.taper === !1 ? 0 : i.taper === !0 ? Math.max(t, g) : i.taper, { left: w, right: C } = kW(n, e), E = d.point, P = n.length > 1 ? n[n.length - 1].point : R.AddXY(d.point, 1, 1);
  if (n.length === 1 && (!(y || v) || s)) {
    const O = R.Add(
      E,
      R.Sub(E, P).uni().per().mul(-d.radius)
    ), z = [];
    for (let F = 1 / 13, H = F; H <= 1; H += F)
      z.push(R.RotWith(O, E, ky * 2 * H));
    return z;
  }
  const I = [];
  if (!(y || v && n.length === 1)) if (l)
    for (let O = 1 / 8, z = O; z <= 1; z += O) {
      const F = R.RotWith(C[0], E, ky * z);
      I.push(F);
    }
  else {
    const O = R.Sub(w[0], C[0]), z = R.Mul(O, 0.5), F = R.Mul(O, 0.51);
    I.push(
      R.Sub(E, z),
      R.Sub(E, F),
      R.Add(E, F),
      R.Add(E, z)
    );
  }
  const k = [], L = h.vector.clone().per().neg();
  if (v || y && n.length === 1)
    k.push(P);
  else if (c) {
    const O = R.Add(P, R.Mul(L, h.radius));
    for (let z = 1 / 29, F = z; F < 1; F += z)
      k.push(R.RotWith(O, P, ky * 3 * F));
  } else
    k.push(
      R.Add(P, R.Mul(L, h.radius)),
      R.Add(P, R.Mul(L, h.radius * 0.99)),
      R.Sub(P, R.Mul(L, h.radius * 0.99)),
      R.Sub(P, R.Mul(L, h.radius))
    );
  return w.concat(k, C.reverse(), I);
}
const qve = 0.025, Yve = 0.01;
function Ru(n, e = {}) {
  var P;
  const { streamline: t = 0.5, size: r = 16, simulatePressure: i = !1 } = e;
  if (n.length === 0) return [];
  const s = 0.15 + (1 - t) * 0.85;
  let l = n.map(R.From), c = 0;
  if (!i) {
    let I = l[0];
    for (; I && !(I.z >= qve); )
      l.shift(), I = l[0];
  }
  if (!i) {
    let I = l[l.length - 1];
    for (; I && !(I.z >= Yve); )
      l.pop(), I = l[l.length - 1];
  }
  if (l.length === 0)
    return [
      {
        point: R.From(n[0]),
        input: R.From(n[0]),
        pressure: i ? 0.5 : 0.15,
        vector: new R(1, 1),
        distance: 0,
        runningLength: 0,
        radius: 1
      }
    ];
  let d = l[1];
  for (; d && !(R.Dist2(d, l[0]) > (r / 3) ** 2); )
    l[0].z = Math.max(l[0].z, d.z), l.splice(1, 1), d = l[1];
  const h = l.pop();
  for (d = l[l.length - 1]; d && !(R.Dist2(d, h) > (r / 3) ** 2); )
    l.pop(), d = l[l.length - 1], c++;
  l.push(h);
  const g = e.last || !e.simulatePressure || l.length > 1 && R.Dist2(l[l.length - 1], l[l.length - 2]) < r ** 2 || c > 0;
  if (l.length === 2 && e.simulatePressure) {
    const I = l[1];
    l = l.slice(0, -1);
    for (let k = 1; k < 5; k++) {
      const L = R.Lrp(l[0], I, k / 4);
      L.z = (l[0].z + (I.z - l[0].z)) * k / 4, l.push(L);
    }
  }
  const y = [
    {
      point: l[0],
      input: l[0],
      pressure: i ? 0.5 : l[0].z,
      vector: new R(1, 1),
      distance: 0,
      runningLength: 0,
      radius: 1
    }
  ];
  let v = 0, w = y[0], C, E;
  g && t > 0 && l.push(l[l.length - 1].clone());
  for (let I = 1, k = l.length; I < k; I++)
    C = !s || e.last && I === k - 1 ? l[I].clone() : l[I].clone().lrp(w.point, 1 - s), !w.point.equals(C) && (E = R.Dist(C, w.point), v += E, !(I < 4 && v < r) && (w = {
      input: l[I],
      // The adjusted point
      point: C,
      // The input pressure (or .5 if not specified)
      pressure: i ? 0.5 : l[I].z,
      // The vector from the current point to the previous point
      vector: R.Sub(w.point, C).uni(),
      // The distance between the current point and the previous point
      distance: E,
      // The total distance so far
      runningLength: v,
      // The stroke point's radius
      radius: 1
    }, y.push(w)));
  if ((P = y[1]) != null && P.vector && (y[0].vector = y[1].vector.clone()), v < 1) {
    const I = Math.max(0.5, ...y.map((k) => k.pressure));
    y.forEach((k) => k.pressure = I);
  }
  return y;
}
const { min: eh } = Math, JM = 0.275;
function N_(n, e) {
  const {
    size: t = 16,
    thinning: r = 0.5,
    simulatePressure: i = !0,
    easing: s = (P) => P,
    start: l = {},
    end: c = {}
  } = e, { easing: d = po.easeOutQuad } = l, { easing: h = po.easeOutCubic } = c, g = n[n.length - 1].runningLength;
  let y, v = n[0].pressure, w;
  if (!i && g < t) {
    const P = n.reduce((I, k) => Math.max(I, k.pressure), 0.5);
    return n.forEach((I) => {
      I.pressure = P, I.radius = t * s(0.5 - r * (0.5 - I.pressure));
    }), n;
  } else {
    let P;
    for (let I = 0, k = n.length; I < k && (w = n[I], !(w.runningLength > t * 5)); I++) {
      const L = eh(1, w.distance / t);
      if (i) {
        const O = eh(1, 1 - L);
        P = eh(1, v + (O - v) * (L * JM));
      } else
        P = eh(1, v + (w.pressure - v) * 0.5);
      v = v + (P - v) * 0.5;
    }
    for (let I = 0; I < n.length; I++) {
      if (w = n[I], r) {
        let { pressure: k } = w;
        const L = eh(1, w.distance / t);
        if (i) {
          const O = eh(1, 1 - L);
          k = eh(1, v + (O - v) * (L * JM));
        } else
          k = eh(
            1,
            v + (k - v) * (L * JM)
          );
        w.radius = t * s(0.5 - r * (0.5 - k)), v = k;
      } else
        w.radius = t / 2;
      y === void 0 && (y = w.radius);
    }
  }
  const C = l.taper === !1 ? 0 : l.taper === !0 ? Math.max(t, g) : l.taper, E = c.taper === !1 ? 0 : c.taper === !0 ? Math.max(t, g) : c.taper;
  if (C || E)
    for (let P = 0; P < n.length; P++) {
      w = n[P];
      const { runningLength: I } = w, k = I < C ? d(I / C) : 1, L = g - I < E ? h((g - I) / E) : 1;
      w.radius = Math.max(0.01, w.radius * Math.min(k, L));
    }
  return n;
}
function Xve(n, e = {}) {
  return Xj(
    N_(Ru(n, e), e),
    e
  );
}
function HU({ scribble: n, zoom: e, color: t, opacity: r, className: i }) {
  if (!n.points.length) return null;
  const s = Xve(n.points, {
    size: n.size / e,
    start: { taper: n.taper, easing: po.linear },
    last: n.state === "stopping",
    simulatePressure: !1,
    streamline: 0.32
  });
  let l;
  if (s.length < 4) {
    const c = n.size / e / 2, { x: d, y: h } = n.points[n.points.length - 1];
    l = `M ${d - c},${h} a ${c},${c} 0 1,0 ${c * 2},0 a ${c},${c} 0 1,0 ${-c * 2},0`;
  } else
    l = zO(s);
  return /* @__PURE__ */ m.jsx("svg", { className: i && It("tl-overlays__item", i), children: /* @__PURE__ */ m.jsx(
    "path",
    {
      className: "tl-scribble",
      d: l,
      fill: t ?? `var(--color-${n.color})`,
      opacity: r ?? n.opacity
    }
  ) });
}
const Zve = ({ bounds: n, rotation: e }) => {
  const t = be();
  return Pe(
    "should display",
    () => t.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.pointing_shape",
      "select.pointing_selection",
      "text.resizing"
    ),
    [t]
  ) ? /* @__PURE__ */ m.jsx(hB, { bounds: n, rotation: e }) : null;
};
function Qve({
  size: n,
  width: e,
  height: t,
  hideAlternateHandles: r
}) {
  const i = Se(n / 3), s = i / 2;
  return /* @__PURE__ */ m.jsxs("svg", { className: "tl-overlays__item", children: [
    /* @__PURE__ */ m.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${Se(0 - s)},${Se(n)} 
						${Se(0 - s)},${Se(0 - s)} 
						${Se(n)},${Se(0 - s)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.top_left",
        "aria-label": "top_left handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "line",
      {
        className: It("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: Se(e / 2 - n),
        y1: Se(0 - s),
        x2: Se(e / 2 + n),
        y2: Se(0 - s),
        strokeWidth: i,
        "data-testid": "selection.crop.top",
        "aria-label": "top handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "polyline",
      {
        className: It("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${Se(e - n)},${Se(0 - s)} 
						${Se(e + s)},${Se(0 - s)} 
						${Se(e + s)},${Se(n)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.top_right",
        "aria-label": "top_right handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "line",
      {
        className: It("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: Se(e + s),
        y1: Se(t / 2 - n),
        x2: Se(e + s),
        y2: Se(t / 2 + n),
        strokeWidth: i,
        "data-testid": "selection.crop.right",
        "aria-label": "right handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "polyline",
      {
        className: "tl-corner-crop-handle",
        points: `
						${Se(e + s)},${Se(t - n)} 
						${Se(e + s)},${Se(t + s)}
						${Se(e - n)},${Se(t + s)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.bottom_right",
        "aria-label": "bottom_right handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "line",
      {
        className: It("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: Se(e / 2 - n),
        y1: Se(t + s),
        x2: Se(e / 2 + n),
        y2: Se(t + s),
        strokeWidth: i,
        "data-testid": "selection.crop.bottom",
        "aria-label": "bottom handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "polyline",
      {
        className: It("tl-corner-crop-handle", {
          "tl-hidden": r
        }),
        points: `
						${Se(0 + n)},${Se(t + s)} 
						${Se(0 - s)},${Se(t + s)}
						${Se(0 - s)},${Se(t - n)}`,
        strokeWidth: i,
        "data-testid": "selection.crop.bottom_left",
        "aria-label": "bottom_left handle"
      }
    ),
    /* @__PURE__ */ m.jsx(
      "line",
      {
        className: It("tl-corner-crop-edge-handle", {
          "tl-hidden": r
        }),
        x1: Se(0 - s),
        y1: Se(t / 2 - n),
        x2: Se(0 - s),
        y2: Se(t / 2 + n),
        strokeWidth: i,
        "data-testid": "selection.crop.left",
        "aria-label": "left handle"
      }
    )
  ] });
}
const Jve = Ho(function({
  bounds: e,
  rotation: t
}) {
  const r = be(), i = M.useRef(null), s = ol(), l = gu("top"), c = gu("right"), d = gu("bottom"), h = gu("left"), g = gu("top_left"), y = gu("top_right"), v = gu("bottom_right"), w = gu("bottom_left"), C = r.getInstanceState().cursor.type === "default", E = r.getInstanceState().isCoarsePointer, P = r.getOnlySelectedShape(), I = P && r.isShapeOrAncestorLocked(P), k = P ? r.getShapeUtil(P).expandSelectionOutlinePx(P) : 0, L = k instanceof Xe ? e.clone().expand(k).zeroFix() : e.clone().expandBy(k).zeroFix();
  if (Ky(i, e == null ? void 0 : e.x, e == null ? void 0 : e.y, 1, r.getSelectionRotation(), {
    x: L.x - e.x,
    y: L.y - e.y
  }), P && r.isShapeHidden(P)) return null;
  const O = r.getZoomLevel(), z = r.getInstanceState().isChangingStyle, F = L.width, H = L.height, V = 8 / O, re = F < V * 2, q = H < V * 2, J = F < V * 4, ie = H < V * 4, W = F < V * 5, Y = H < V * 5, oe = E ? 1.75 : 1, le = 6 / O * oe, ce = (J ? le / 2 : le) * (oe * 0.75), Q = (ie ? le / 2 : le) * (oe * 0.75), he = (P ? !r.getShapeUtil(P).hideSelectionBoundsFg(P) : !0) && !z;
  let ke = he && r.isInAny(
    "select.idle",
    "select.brushing",
    "select.scribble_brushing",
    "select.pointing_canvas",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle",
    "select.pointing_resize_handle"
  ) || he && r.isIn("select.resizing") && P && r.isShapeOfType(P, "text");
  P && ke && Er.isFirefox && r.isShapeOfType(P, "embed") && (ke = !1);
  const te = r.isInAny(
    "select.crop.idle",
    "select.crop.pointing_crop",
    "select.crop.pointing_crop_handle"
  ) && !z && !s, me = r.isInAny(
    "select.idle",
    "select.pointing_selection",
    "select.pointing_shape",
    "select.crop.idle"
  ) && !z && !s, Oe = !E && !(re || q) && (me || te) && (P ? !r.getShapeUtil(P).hideRotateHandle(P) : !0) && !I, Ze = E && (!J || !ie) && (me || te) && (P ? !r.getShapeUtil(P).hideRotateHandle(P) : !0) && !I, De = me && (P ? r.getShapeUtil(P).canResize(P) && !r.getShapeUtil(P).hideResizeHandles(P) : !0) && !te && !I, yt = re || q, it = re && q, We = W || Y, Qe = De || te, gt = !Oe, Pt = !me || !Ze, mn = !me || !Qe, Zt = !me || !Qe || yt, an = !me || !Qe || yt, ln = !me || !Qe || it && !te;
  let Yt = !0, Gn = !0;
  if (te)
    Yt = We, Gn = We;
  else if (De) {
    Yt = yt || it || E;
    const Pr = E && P && P.type === "text";
    Gn = Yt && !Pr;
  }
  const xr = Math.min(24 / O, H - Q * 3), Hr = me && E && P && r.isShapeOfType(P, "text") && xr * O >= 4;
  return /* @__PURE__ */ m.jsx("svg", { className: "tl-overlays__item tl-selection__fg", "data-testid": "selection-foreground", children: /* @__PURE__ */ m.jsxs("g", { ref: i, children: [
    ke && /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: "tl-selection__fg__outline",
        width: Se(F),
        height: Se(H)
      }
    ),
    /* @__PURE__ */ m.jsx(
      lC,
      {
        "data-testid": "selection.rotate.top-left",
        cx: 0,
        cy: 0,
        targetSize: le,
        corner: "top_left_rotate",
        cursor: C ? Wa("nwse-rotate", t) : void 0,
        isHidden: gt
      }
    ),
    /* @__PURE__ */ m.jsx(
      lC,
      {
        "data-testid": "selection.rotate.top-right",
        cx: F + le * 3,
        cy: 0,
        targetSize: le,
        corner: "top_right_rotate",
        cursor: C ? Wa("nesw-rotate", t) : void 0,
        isHidden: gt
      }
    ),
    /* @__PURE__ */ m.jsx(
      lC,
      {
        "data-testid": "selection.rotate.bottom-left",
        cx: 0,
        cy: H + le * 3,
        targetSize: le,
        corner: "bottom_left_rotate",
        cursor: C ? Wa("swne-rotate", t) : void 0,
        isHidden: gt
      }
    ),
    /* @__PURE__ */ m.jsx(
      lC,
      {
        "data-testid": "selection.rotate.bottom-right",
        cx: F + le * 3,
        cy: H + le * 3,
        targetSize: le,
        corner: "bottom_right_rotate",
        cursor: C ? Wa("senw-rotate", t) : void 0,
        isHidden: gt
      }
    ),
    /* @__PURE__ */ m.jsx(
      tSe,
      {
        "data-testid": "selection.rotate.mobile",
        cx: J ? -le * 1.5 : F / 2,
        cy: J ? H / 2 : -le * 1.5,
        size: V,
        isHidden: Pt
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": Yt
        }),
        "data-testid": "selection.resize.top",
        "aria-label": "top target",
        pointerEvents: "all",
        x: 0,
        y: Se(0 - (ie ? Q * 2 : Q)),
        width: Se(F),
        height: Se(Math.max(1, Q * 2)),
        style: C ? { cursor: Wa("ns-resize", t) } : void 0,
        ...l
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": Gn
        }),
        "data-testid": "selection.resize.right",
        "aria-label": "right target",
        pointerEvents: "all",
        x: Se(F - (J ? 0 : ce)),
        y: 0,
        height: Se(H),
        width: Se(Math.max(1, ce * 2)),
        style: C ? { cursor: Wa("ew-resize", t) } : void 0,
        ...c
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": Yt
        }),
        "data-testid": "selection.resize.bottom",
        "aria-label": "bottom target",
        pointerEvents: "all",
        x: 0,
        y: Se(H - (ie ? 0 : Q)),
        width: Se(F),
        height: Se(Math.max(1, Q * 2)),
        style: C ? { cursor: Wa("ns-resize", t) } : void 0,
        ...d
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": Gn
        }),
        "data-testid": "selection.resize.left",
        "aria-label": "left target",
        pointerEvents: "all",
        x: Se(0 - (J ? ce * 2 : ce)),
        y: 0,
        height: Se(H),
        width: Se(Math.max(1, ce * 2)),
        style: C ? { cursor: Wa("ew-resize", t) } : void 0,
        ...h
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": mn
        }),
        "data-testid": "selection.target.top-left",
        "aria-label": "top-left target",
        pointerEvents: "all",
        x: Se(0 - (J ? ce * 2 : ce * 1.5)),
        y: Se(0 - (ie ? Q * 2 : Q * 1.5)),
        width: Se(ce * 3),
        height: Se(Q * 3),
        style: C ? { cursor: Wa("nwse-resize", t) } : void 0,
        ...g
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": Zt
        }),
        "data-testid": "selection.target.top-right",
        "aria-label": "top-right target",
        pointerEvents: "all",
        x: Se(F - (J ? 0 : ce * 1.5)),
        y: Se(0 - (ie ? Q * 2 : Q * 1.5)),
        width: Se(ce * 3),
        height: Se(Q * 3),
        style: C ? { cursor: Wa("nesw-resize", t) } : void 0,
        ...y
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": ln
        }),
        "data-testid": "selection.target.bottom-right",
        "aria-label": "bottom-right target",
        pointerEvents: "all",
        x: Se(F - (J ? ce : ce * 1.5)),
        y: Se(H - (ie ? Q : Q * 1.5)),
        width: Se(ce * 3),
        height: Se(Q * 3),
        style: C ? { cursor: Wa("nwse-resize", t) } : void 0,
        ...v
      }
    ),
    /* @__PURE__ */ m.jsx(
      "rect",
      {
        className: It("tl-transparent", {
          "tl-hidden": an
        }),
        "data-testid": "selection.target.bottom-left",
        "aria-label": "bottom-left target",
        pointerEvents: "all",
        x: Se(0 - (J ? ce * 3 : ce * 1.5)),
        y: Se(H - (ie ? 0 : Q * 1.5)),
        width: Se(ce * 3),
        height: Se(Q * 3),
        style: C ? { cursor: Wa("nesw-resize", t) } : void 0,
        ...w
      }
    ),
    De && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-left",
          className: It("tl-corner-handle", {
            "tl-hidden": mn
          }),
          "aria-label": "top_left handle",
          x: Se(0 - V / 2),
          y: Se(0 - V / 2),
          width: Se(V),
          height: Se(V)
        }
      ),
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.resize.top-right",
          className: It("tl-corner-handle", {
            "tl-hidden": Zt
          }),
          "aria-label": "top_right handle",
          x: Se(F - V / 2),
          y: Se(0 - V / 2),
          width: Se(V),
          height: Se(V)
        }
      ),
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-right",
          className: It("tl-corner-handle", {
            "tl-hidden": ln
          }),
          "aria-label": "bottom_right handle",
          x: Se(F - V / 2),
          y: Se(H - V / 2),
          width: Se(V),
          height: Se(V)
        }
      ),
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.resize.bottom-left",
          className: It("tl-corner-handle", {
            "tl-hidden": an
          }),
          "aria-label": "bottom_left handle",
          x: Se(0 - V / 2),
          y: Se(H - V / 2),
          width: Se(V),
          height: Se(V)
        }
      )
    ] }),
    Hr && /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.left.handle",
          className: "tl-text-handle",
          "aria-label": "bottom_left handle",
          x: Se(0 - V / 4),
          y: Se(H / 2 - xr / 2),
          rx: V / 4,
          width: Se(V / 2),
          height: Se(xr)
        }
      ),
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          "data-testid": "selection.text-resize.right.handle",
          className: "tl-text-handle",
          "aria-label": "bottom_left handle",
          rx: V / 4,
          x: Se(F - V / 4),
          y: Se(H / 2 - xr / 2),
          width: Se(V / 2),
          height: Se(xr)
        }
      )
    ] }),
    te && /* @__PURE__ */ m.jsx(
      Qve,
      {
        size: V,
        width: F,
        height: H,
        hideAlternateHandles: We
      }
    )
  ] }) });
}), lC = function({
  cx: e,
  cy: t,
  targetSize: r,
  corner: i,
  cursor: s,
  isHidden: l,
  "data-testid": c
}) {
  const d = gu(i);
  return /* @__PURE__ */ m.jsx(
    "rect",
    {
      className: It("tl-transparent", "tl-rotate-corner", { "tl-hidden": l }),
      "data-testid": c,
      "aria-label": `${i} target`,
      pointerEvents: "all",
      x: Se(e - r * 3),
      y: Se(t - r * 3),
      width: Se(Math.max(1, r * 3)),
      height: Se(Math.max(1, r * 3)),
      cursor: s,
      ...d
    }
  );
}, eSe = Math.sqrt(Math.PI), tSe = function({
  cx: e,
  cy: t,
  size: r,
  isHidden: i,
  "data-testid": s
}) {
  const l = gu("mobile_rotate"), c = be(), d = Pe("zoom level", () => c.getZoomLevel(), [c]), h = Math.max(14 * (1 / d), 20 / Math.max(1, d));
  return /* @__PURE__ */ m.jsxs("g", { children: [
    /* @__PURE__ */ m.jsx(
      "circle",
      {
        "data-testid": s,
        pointerEvents: "all",
        className: It("tl-transparent", "tl-mobile-rotate__bg", { "tl-hidden": i }),
        cx: e,
        cy: t,
        r: h,
        ...l
      }
    ),
    /* @__PURE__ */ m.jsx(
      "circle",
      {
        className: It("tl-mobile-rotate__fg", { "tl-hidden": i }),
        cx: e,
        cy: t,
        r: r / eSe
      }
    )
  ] });
};
function nSe() {
  const n = be();
  return Pe(
    "is in a valid select state",
    () => n.isInAny(
      "select.idle",
      "select.brushing",
      "select.scribble_brushing",
      "select.editing_shape",
      "select.pointing_shape",
      "select.pointing_selection",
      "select.pointing_handle"
    ),
    [n]
  ) ? /* @__PURE__ */ m.jsx(pB, {}) : null;
}
function CD(n, e, t) {
  const { arrowheadStart: r, arrowheadEnd: i } = e.props, s = wy(n, e, t), l = s.start.clone(), c = s.end.clone(), d = R.Med(l, c);
  if (R.Equals(l, c))
    return {
      bindings: t,
      isStraight: !0,
      start: {
        handle: l,
        point: l,
        arrowhead: e.props.arrowheadStart
      },
      end: {
        handle: c,
        point: c,
        arrowhead: e.props.arrowheadEnd
      },
      middle: d,
      isValid: !1,
      length: 0
    };
  const h = R.Sub(c, l).uni(), g = kE(n, e, "start"), y = kE(n, e, "end"), v = n.getShapePageTransform(e);
  VU(
    c,
    // <-- will be mutated
    s.start,
    v,
    y
  ), VU(
    l,
    // <-- will be mutated
    s.end,
    v,
    g
  );
  let w = 0, C = 0, E = 0, P = 0, I = Nx * e.props.scale;
  const k = g && y && g.shape === y.shape, L = g && y ? Zj(n, g.shape.id, y.shape.id) : "safe";
  L === "safe" && g && y && !k && !g.isExact && !y.isExact && (y.didIntersect && !g.didIntersect ? g.isClosed && l.setTo(c.clone().add(h.clone().mul(Nx * e.props.scale))) : y.didIntersect || y.isClosed && c.setTo(l.clone().sub(h.clone().mul(Nx * e.props.scale))));
  const O = R.Sub(c, l), z = R.Len(O) ? O.uni() : R.From(O), F = !R.Equals(z, h);
  k || (L !== "start-contains-end" && g && r !== "none" && !g.isExact && (E = wu[e.props.size] / 2 + ("size" in g.shape.props ? wu[g.shape.props.size] / 2 : 0), w = (RE + E) * e.props.scale, I += E * e.props.scale), L !== "end-contains-start" && y && i !== "none" && !y.isExact && (P = wu[e.props.size] / 2 + ("size" in y.shape.props ? wu[y.shape.props.size] / 2 : 0), C = (RE + P) * e.props.scale, I += P * e.props.scale));
  const H = l.clone().add(z.clone().mul(w * (F ? -1 : 1))), V = c.clone().sub(z.clone().mul(C * (F ? -1 : 1)));
  R.DistMin(H, V, I) && (w !== 0 && C !== 0 ? (w *= -1.5, C *= -1.5) : w !== 0 ? w *= -1 : C !== 0 && (C *= -1)), l.add(z.clone().mul(w * (F ? -1 : 1))), c.sub(z.clone().mul(C * (F ? -1 : 1))), F ? (g && y && c.setTo(R.Add(l, z.clone().mul(-10 * e.props.scale))), d.setTo(R.Med(s.start, s.end))) : d.setTo(R.Med(l, c));
  const re = R.Dist(l, c);
  return {
    bindings: t,
    isStraight: !0,
    start: {
      handle: s.start,
      point: l,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      handle: s.end,
      point: c,
      arrowhead: e.props.arrowheadEnd
    },
    middle: d,
    isValid: re > 0,
    length: re
  };
}
function VU(n, e, t, r) {
  if (r === void 0 || r.isExact)
    return;
  const i = qe.applyToPoint(t, e), s = qe.applyToPoint(t, n), l = qe.applyToPoint(qe.Inverse(r.transform), i), c = qe.applyToPoint(qe.Inverse(r.transform), s), d = r.isClosed, g = (d ? KO : Fle)(l, c, r.outline);
  let y;
  if (g !== null && (y = g.sort((C, E) => R.Dist2(C, l) - R.Dist2(E, l))[0] ?? (d ? void 0 : c)), y === void 0)
    return;
  const v = qe.applyToPoint(r.transform, y), w = qe.applyToPoint(qe.Inverse(t), v);
  n.setTo(w), r.didIntersect = !0;
}
function rSe(n, e, t) {
  const { arrowheadEnd: r, arrowheadStart: i } = e.props, s = e.props.bend;
  if (Math.abs(s) > Math.abs(e.props.bend * (lSe * e.props.scale)))
    return CD(n, e, t);
  const l = wy(n, e, t), c = R.Med(l.start, l.end), d = R.Sub(l.end, l.start), h = R.Len(d) ? d.uni() : R.From(d), g = R.Add(c, h.per().mul(-s)), y = kE(n, e, "start"), v = kE(n, e, "end"), w = l.start.clone(), C = l.end.clone(), E = g.clone();
  if (R.Equals(w, C))
    return {
      bindings: t,
      isStraight: !0,
      start: {
        handle: w,
        point: w,
        arrowhead: e.props.arrowheadStart
      },
      end: {
        handle: C,
        point: C,
        arrowhead: e.props.arrowheadEnd
      },
      middle: E,
      isValid: !1,
      length: 0
    };
  const P = e.props.bend < 0, I = P ? mw : q8, k = KU(w, C, E), L = R.Angle(k.center, w), O = R.Angle(k.center, C), z = I(L, O);
  if (k.length === 0 || k.size === 0 || !v4(k.length) || !v4(k.size))
    return CD(n, e, t);
  const F = w.clone(), H = C.clone(), V = E.clone(), re = n.getShapePageTransform(e);
  let q = 0, J = 0, ie = Nx * e.props.scale;
  if (y && !y.isExact) {
    const ke = qe.applyToPoint(re, F), te = qe.applyToPoint(re, k.center), me = qe.applyToPoint(re, H), Oe = qe.Inverse(y.transform), Ze = qe.applyToPoint(Oe, ke), De = qe.applyToPoint(Oe, te), yt = qe.applyToPoint(Oe, me), { isClosed: it } = y, We = it ? ZA : $4;
    let Qe, gt = We(De, k.radius, y.outline);
    if (gt) {
      const Pt = De.angle(Ze), mn = De.angle(yt), Zt = I(Pt, mn);
      gt = gt.filter(
        (ln) => I(Pt, De.angle(ln)) <= Zt
      );
      const an = Zt * 0.25;
      gt.sort(
        it ? (ln, Yt) => Math.abs(I(Pt, De.angle(ln)) - an) < Math.abs(I(Pt, De.angle(Yt)) - an) ? -1 : 1 : (ln, Yt) => I(Pt, De.angle(ln)) < I(Pt, De.angle(Yt)) ? -1 : 1
      ), Qe = gt[0] ?? (it ? void 0 : Ze);
    } else
      Qe = it ? void 0 : Ze;
    if (Qe && (F.setTo(
      n.getPointInShapeSpace(e, qe.applyToPoint(y.transform, Qe))
    ), y.didIntersect = !0, i !== "none")) {
      const Pt = wu[e.props.size] / 2 + ("size" in y.shape.props ? wu[y.shape.props.size] / 2 : 0);
      q = (RE + Pt) * e.props.scale, ie += Pt * e.props.scale;
    }
  }
  if (v && !v.isExact) {
    const ke = qe.applyToPoint(re, F), te = qe.applyToPoint(re, H), me = qe.applyToPoint(re, k.center), Oe = qe.Inverse(v.transform), Ze = qe.applyToPoint(Oe, ke), De = qe.applyToPoint(Oe, me), yt = qe.applyToPoint(Oe, te), it = v.isClosed, We = it ? ZA : $4;
    let Qe, gt = We(De, k.radius, v.outline);
    if (gt) {
      const Pt = De.angle(Ze), mn = De.angle(yt), Zt = I(Pt, mn), an = Zt * 0.75;
      gt = gt.filter(
        (ln) => I(Pt, De.angle(ln)) <= Zt
      ), gt.sort(
        it ? (ln, Yt) => Math.abs(I(Pt, De.angle(ln)) - an) < Math.abs(I(Pt, De.angle(Yt)) - an) ? -1 : 1 : (ln, Yt) => I(Pt, De.angle(ln)) < I(Pt, De.angle(Yt)) ? -1 : 1
      ), gt[0] ? Qe = gt[0] : Qe = it ? void 0 : yt;
    } else
      Qe = it ? void 0 : yt;
    if (Qe && (H.setTo(
      n.getPointInShapeSpace(e, qe.applyToPoint(v.transform, Qe))
    ), v.didIntersect = !0, r !== "none")) {
      const Pt = wu[e.props.size] / 2 + ("size" in v.shape.props ? wu[v.shape.props.size] / 2 : 0);
      J = (RE + Pt) * e.props.scale, ie += Pt * e.props.scale;
    }
  }
  let W = R.Angle(k.center, F), Y = R.Angle(k.center, H), oe = I(W, Y), le = oe * k.radius;
  const ce = F.clone(), Q = H.clone();
  if (q !== 0 && ce.setTo(k.center).add(
    R.FromAngle(W + oe * (q / le * (P ? 1 : -1))).mul(k.radius)
  ), J !== 0 && Q.setTo(k.center).add(
    R.FromAngle(Y + oe * (J / le * (P ? -1 : 1))).mul(k.radius)
  ), R.DistMin(ce, Q, ie) && (q !== 0 && J !== 0 ? (q *= -1.5, J *= -1.5) : q !== 0 ? q *= -2 : J !== 0 && (J *= -2)), q !== 0 && F.setTo(k.center).add(
    R.FromAngle(W + oe * (q / le * (P ? 1 : -1))).mul(k.radius)
  ), J !== 0 && H.setTo(k.center).add(
    R.FromAngle(Y + oe * (J / le * (P ? -1 : 1))).mul(k.radius)
  ), y && v && !y.isExact && !v.isExact) {
    W = R.Angle(k.center, F), Y = R.Angle(k.center, H), oe = I(W, Y), le = oe * k.radius;
    const ke = Zj(
      n,
      y.shape.id,
      v.shape.id
    );
    ke === "double-bound" && le < 30 ? (F.setTo(w), H.setTo(C), V.setTo(E)) : ke === "safe" && (y && !y.didIntersect && F.setTo(w), (v && !v.didIntersect || I(L, W) > I(L, Y)) && H.setTo(k.center).add(
      R.FromAngle(
        W + oe * (Math.min(0.9, Nx * e.props.scale / le) * (P ? 1 : -1))
      ).mul(k.radius)
    ));
  }
  iSe(
    k.center,
    k.radius,
    F,
    H,
    V,
    z,
    P
  ), F.equals(H) && (F.setTo(V.clone().addXY(1, 1)), H.setTo(V.clone().subXY(1, 1))), w.setTo(F), C.setTo(H), E.setTo(V);
  const he = KU(w, C, E);
  return {
    bindings: t,
    isStraight: !1,
    start: {
      point: w,
      handle: l.start,
      arrowhead: e.props.arrowheadStart
    },
    end: {
      point: C,
      handle: l.end,
      arrowhead: e.props.arrowheadEnd
    },
    middle: E,
    handleArc: k,
    bodyArc: he,
    isValid: he.length !== 0 && isFinite(he.center.x) && isFinite(he.center.y)
  };
}
function KU(n, e, t) {
  const r = DO(n, e, t) ?? R.Med(n, e), i = R.Dist(r, n), s = +R.Clockwise(n, t, e), l = ((n.y - e.y) ** 2 + (n.x - e.x) ** 2) ** 0.5, c = ((e.y - t.y) ** 2 + (e.x - t.x) ** 2) ** 0.5, d = ((t.y - n.y) ** 2 + (t.x - n.x) ** 2) ** 0.5, h = Math.acos((c * c + d * d - l * l) / (2 * c * d)) * 2, g = +(Xn > h), y = (hr - h) * (s ? 1 : -1), v = y * i;
  return {
    center: r,
    radius: i,
    size: y,
    length: v,
    largeArcFlag: g,
    sweepFlag: s
  };
}
function iSe(n, e, t, r, i, s, l) {
  const c = R.Angle(n, t), d = R.Angle(n, r);
  let h = mw(c, d);
  if (l || (h = hr - h), i.setTo(n).add(R.FromAngle(c + h * (0.5 * (l ? 1 : -1))).mul(e)), h > s) {
    i.rotWith(n, Xn);
    const g = r.clone();
    r.setTo(t), t.setTo(g);
  }
}
const oSe = 8;
function sSe(n) {
  return Math.abs(n.props.bend) < oSe * n.props.scale;
}
function kE(n, e, t) {
  const r = n.getBindingsFromShape(e, "arrow").find((d) => d.props.terminal === t);
  if (!r) return;
  const i = n.getShape(r.toId);
  if (!i) return;
  const s = n.getShapePageTransform(i), l = n.getShapeGeometry(i), c = l instanceof jl ? l.children[0].vertices : l.vertices;
  return {
    shape: i,
    transform: s,
    isClosed: l.isClosed,
    isExact: r.props.isExact,
    didIntersect: !1,
    outline: c
  };
}
function WU(n, e, t, r) {
  const i = n.getShape(t.toId);
  if (i) {
    const { point: s, size: l } = n.getShapeGeometry(i).bounds, c = R.Add(
      s,
      R.MulV(
        // if the parent is the bound shape, then it's ALWAYS precise
        t.props.isPrecise || r ? t.props.normalizedAnchor : { x: 0.5, y: 0.5 },
        l
      )
    ), d = qe.applyToPoint(n.getShapePageTransform(i), c);
    return qe.applyToPoint(qe.Inverse(e), d);
  } else
    return new R(0, 0);
}
function wa(n, e) {
  const t = n.getBindingsFromShape(e, "arrow");
  return {
    start: t.find((r) => r.props.terminal === "start"),
    end: t.find((r) => r.props.terminal === "end")
  };
}
const aSe = Qne("arrow info", (n, e) => {
  const t = wa(n, e);
  return sSe(e) ? CD(n, e, t) : rSe(n, e, t);
});
function xu(n, e) {
  const t = typeof e == "string" ? e : e.id;
  return aSe.get(n, t);
}
function wy(n, e, t) {
  var c, d;
  const r = n.getShapePageTransform(e), i = Zj(
    n,
    (c = t.start) == null ? void 0 : c.toId,
    (d = t.end) == null ? void 0 : d.toId
  ), s = t.start ? WU(
    n,
    r,
    t.start,
    i === "double-bound" || i === "start-contains-end"
  ) : R.From(e.props.start), l = t.end ? WU(
    n,
    r,
    t.end,
    i === "double-bound" || i === "end-contains-start"
  ) : R.From(e.props.end);
  return { start: s, end: l };
}
function fx(n, e, t, r) {
  const i = typeof e == "string" ? e : e.id, s = typeof t == "string" ? t : t.id, l = n.getBindingsFromShape(i, "arrow").filter((d) => d.props.terminal === r.terminal);
  l.length > 1 && n.deleteBindings(l.slice(1));
  const c = l[0];
  c ? n.updateBinding({
    ...c,
    toId: s,
    props: r
  }) : n.createBinding({
    type: "arrow",
    fromId: i,
    toId: s,
    props: r
  });
}
function IC(n, e, t) {
  const r = n.getBindingsFromShape(e, "arrow").filter((i) => i.props.terminal === t);
  n.deleteBindings(r);
}
const Nx = 10, RE = 10, lSe = 10, wu = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
};
function Zj(n, e, t) {
  if (!e || !t) return "safe";
  if (e === t) return "double-bound";
  const r = n.getShapePageBounds(e), i = n.getShapePageBounds(t);
  if (r && i) {
    if (r.contains(i)) return "start-contains-end";
    if (i.contains(r)) return "end-contains-start";
  }
  return "safe";
}
class kC extends CC {
  getDefaultProps() {
    return {
      isPrecise: !1,
      isExact: !1,
      normalizedAnchor: { x: 0.5, y: 0.5 }
    };
  }
  // when the binding itself changes
  onAfterCreate({ binding: e }) {
    const t = this.editor.getShape(e.fromId);
    t && eA(this.editor, t);
  }
  // when the binding itself changes
  onAfterChange({ bindingAfter: e }) {
    const t = this.editor.getShape(e.fromId);
    t && eA(this.editor, t);
  }
  // when the arrow itself changes
  onAfterChangeFromShape({
    shapeAfter: e
  }) {
    eA(this.editor, e);
  }
  // when the shape an arrow is bound to changes
  onAfterChangeToShape({ binding: e }) {
    RW(this.editor, e.fromId);
  }
  // when the arrow is isolated we need to update it's x,y positions
  onBeforeIsolateFromShape({
    binding: e
  }) {
    const t = this.editor.getShape(e.fromId);
    t && ME({
      editor: this.editor,
      arrow: t,
      terminal: e.props.terminal
    });
  }
}
U(kC, "type", "arrow"), U(kC, "props", N6), U(kC, "migrations", F6);
function RW(n, e) {
  var P;
  const t = n.getShape(e);
  if (!t) return;
  const r = wa(n, t), { start: i, end: s } = r, l = i ? n.getShape(i.toId) : void 0, c = s ? n.getShape(s.toId) : void 0, d = n.getAncestorPageId(t);
  if (!d) return;
  let h;
  if (l && c)
    h = n.findCommonAncestor([l, c]) ?? d;
  else if (l || c) {
    const I = (P = l || c) == null ? void 0 : P.parentId;
    I && I === t.parentId ? h = t.parentId : h = d;
  } else
    return;
  h && h !== t.parentId && n.reparentShapes([e], h);
  const g = n.getShape(e);
  if (!g) throw Error("no reparented arrow");
  const y = n.getShapeNearestSibling(g, l), v = n.getShapeNearestSibling(g, c);
  let w;
  if (y && v)
    w = y.index > v.index ? y : v;
  else if (y && !v)
    w = y;
  else if (v && !y)
    w = v;
  else
    return;
  let C;
  const E = n.getSortedChildIdsForParent(w.parentId).map((I) => n.getShape(I)).filter((I) => I.index > w.index);
  if (E.length) {
    const I = E.find((k) => k.type !== "arrow");
    if (
      // ...then, if we're above the last shape we want to be above...
      g.index > w.index && // ...but below the next non-arrow sibling...
      (!I || g.index < I.index)
    )
      return;
    C = Hx(w.index, E[0].index);
  } else
    C = vu(w.index);
  C !== g.index && n.updateShapes([{ id: e, type: "arrow", index: C }]);
}
function eA(n, e) {
  const t = wa(n, e);
  for (const r of ["start", "end"]) {
    const i = t[r];
    if (!i) continue;
    const s = n.getShape(i.toId), l = n.getAncestorPageId(e) === n.getAncestorPageId(s);
    (!s || !l) && ME({ editor: n, arrow: e, terminal: r, unbind: !0 });
  }
  RW(n, e.id);
}
function ME({
  editor: n,
  arrow: e,
  terminal: t,
  unbind: r = !1,
  useHandle: i = !1
}) {
  const s = xu(n, e);
  if (!s)
    throw new Error("expected arrow info");
  const l = i ? s.start.handle : s.start.point, c = i ? s.end.handle : s.end.point, d = t === "start" ? l : c, h = {
    id: e.id,
    type: "arrow",
    props: {
      [t]: { x: d.x, y: d.y },
      bend: e.props.bend
    }
  };
  if (!s.isStraight) {
    const g = t === "start" ? l : s.start.handle, y = t === "end" ? c : s.end.handle, v = R.Med(g, y), w = R.Sub(g, y).per().uni().mul(s.handleArc.radius * 2 * Math.sign(e.props.bend)), C = ww(
      s.handleArc.center,
      R.Add(v, w),
      s.handleArc.center,
      s.handleArc.radius
    );
    on((C == null ? void 0 : C.length) === 1);
    const E = R.Dist(v, C[0]) * Math.sign(e.props.bend);
    fh(E, h.props.bend) || (h.props.bend = E);
  }
  n.updateShape(h), r && IC(n, e, t);
}
const MW = [kC], Ss = {
  lineHeight: 1.35,
  fontWeight: "normal",
  fontVariant: "normal",
  fontStyle: "normal",
  padding: "0px"
}, vs = {
  s: 2,
  m: 3.5,
  l: 5,
  xl: 10
}, Dy = {
  s: 18,
  m: 24,
  l: 36,
  xl: 44
}, Bd = {
  s: 18,
  m: 22,
  l: 26,
  xl: 32
}, cSe = {
  s: 18,
  m: 20,
  l: 24,
  xl: 28
}, Kd = {
  draw: "var(--tl-font-draw)",
  sans: "var(--tl-font-sans)",
  serif: "var(--tl-font-serif)",
  mono: "var(--tl-font-mono)"
}, uSe = 20, Qj = 4.25, kl = 16;
function dSe(n, e) {
  const t = n.w / e.w, r = n.h / e.h;
  return t <= 1 && r <= 1 ? n : t > r ? {
    w: n.w / t,
    h: n.h / t
  } : {
    w: n.w / r,
    h: n.h / r
  };
}
/*!
 * MIT License
 * Adapted (mostly copied) the work of https://github.com/fregante/text-field-edit
 * Copyright (c) Federico Brigante <opensource@bfred.it> (bfred.it)
 */
const by = "  ", Bs = class Bs {
  static insertTextFirefox(e, t) {
    e.setRangeText(
      t,
      e.selectionStart || 0,
      e.selectionEnd || 0,
      "end"
      // Without this, the cursor is either at the beginning or text remains selected
    ), e.dispatchEvent(
      new InputEvent("input", {
        data: t,
        inputType: "insertText",
        isComposing: !1
        // TODO: fix @types/jsdom, this shouldn't be required
      })
    );
  }
  /**
   * Inserts text at the cursor’s position, replacing any selection, with **undo** support and by
   * firing the input event.
   */
  static insert(e, t) {
    const r = e.ownerDocument, i = r.activeElement;
    i !== e && e.focus(), r.execCommand("insertText", !1, t) || Bs.insertTextFirefox(e, t), i === r.body ? e.blur() : i instanceof HTMLElement && i !== e && i.focus();
  }
  /**
   * Replaces the entire content, equivalent to field.value = text but with **undo** support and by
   * firing the input event.
   */
  static set(e, t) {
    e.select(), Bs.insert(e, t);
  }
  /** Get the selected text in a field or an empty string if nothing is selected. */
  static getSelection(e) {
    const { selectionStart: t, selectionEnd: r } = e;
    return e.value.slice(
      t || void 0,
      r || void 0
    );
  }
  /**
   * Adds the wrappingText before and after field’s selection (or cursor). If endWrappingText is
   * provided, it will be used instead of wrappingText at on the right.
   */
  static wrapSelection(e, t, r) {
    const { selectionStart: i, selectionEnd: s } = e, l = Bs.getSelection(e);
    Bs.insert(e, t + l + (r ?? t)), e.selectionStart = (i || 0) + t.length, e.selectionEnd = (s || 0) + t.length;
  }
  /** Finds and replaces strings and regex in the field’s value. */
  static replace(e, t, r) {
    let i = 0;
    e.value.replace(t, (...s) => {
      const l = i + s[s.length - 2], c = s[0].length;
      e.selectionStart = l, e.selectionEnd = l + c;
      const d = typeof r == "string" ? r : r(...s);
      return Bs.insert(e, d), e.selectionStart = l, i += d.length - c, d;
    });
  }
  static findLineEnd(e, t) {
    const r = e.lastIndexOf(`
`, t - 1) + 1;
    return e.charAt(r) !== "	" ? t : r + 1;
  }
  static indent(e) {
    var c;
    const { selectionStart: t, selectionEnd: r, value: i } = e, s = i.slice(t, r), l = (c = /\n/g.exec(s)) == null ? void 0 : c.length;
    if (l && l > 0) {
      const d = i.lastIndexOf(`
`, t - 1) + 1, h = e.value.slice(d, r - 1), g = h.replace(
        /^|\n/g,
        // Match all line starts
        `$&${by}`
      ), y = g.length - h.length;
      e.setSelectionRange(d, r - 1), Bs.insert(e, g), e.setSelectionRange(t + 1, r + y);
    } else
      Bs.insert(e, by);
  }
  // The first line should always be unindented
  // The last line should only be unindented if the selection includes any characters after \n
  static unindent(e) {
    const { selectionStart: t, selectionEnd: r, value: i } = e, s = i.lastIndexOf(`
`, t - 1) + 1, l = Bs.findLineEnd(i, r), c = e.value.slice(s, l), d = c.replace(/(^|\n)(\t| {1,2})/g, "$1"), h = c.length - d.length;
    e.setSelectionRange(s, l), Bs.insert(e, d);
    const g = /\t| {1,2}/.exec(i.slice(s, t)), y = g ? g[0].length : 0, v = t - y;
    e.setSelectionRange(
      t - y,
      Math.max(v, r - h)
    );
  }
  static indentCE(e) {
    var d;
    const t = window.getSelection(), r = e.innerText, i = cC(e) ?? 0, s = cC(e) ?? 0, l = r.slice(i, s), c = (d = /\n/g.exec(l)) == null ? void 0 : d.length;
    if (c && c > 0) {
      const h = r.lastIndexOf(`
`, i - 1) + 1, g = r.slice(h, s - 1), v = g.replace(
        /^|\n/g,
        // Match all line starts
        `$&${by}`
      ).length - g.length;
      t && t.setBaseAndExtent(
        e,
        i + 1,
        e,
        s + v
      );
    } else {
      const h = window.getSelection();
      e.innerText = r.slice(0, i) + by + r.slice(i), h == null || h.setBaseAndExtent(e, i + 1, e, i + 2);
    }
  }
  static unindentCE(e) {
    const t = window.getSelection(), r = e.innerText, i = cC(e) ?? 0, s = cC(e) ?? 0, l = r.lastIndexOf(`
`, i - 1) + 1, c = Bs.findLineEnd(r, s), d = r.slice(l, c), h = d.replace(/(^|\n)(\t| {1,2})/g, "$1"), g = d.length - h.length;
    if (t) {
      t.setBaseAndExtent(e, l, e, c);
      const y = /\t| {1,2}/.exec(r.slice(l, i)), v = y ? y[0].length : 0, w = i - v;
      t.setBaseAndExtent(
        e,
        i - v,
        e,
        Math.max(w, s - g)
      );
    }
  }
  static normalizeText(e) {
    return e.replace(Bs.fixNewLines, `
`);
  }
  static normalizeTextForDom(e) {
    return e.replace(Bs.fixNewLines, `
`).split(`
`).map((t) => t || " ").join(`
`);
  }
};
U(Bs, "fixNewLines", /\r?\n|\r/g);
let Oy = Bs;
function cC(n) {
  if (typeof window.getSelection > "u") return;
  const e = window.getSelection();
  if (!e) return;
  let t = 0;
  if (e.rangeCount !== 0) {
    const r = e.getRangeAt(0), i = r.cloneRange();
    i.selectNodeContents(n), i.setEnd(r.endContainer, r.endOffset), t = i.toString().length;
  }
  return t;
}
const fSe = /[\u0590-\u05FF\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\uFB50-\uFDFF\uFE70-\uFEFF]/;
function AW(n) {
  return fSe.test(n);
}
function hSe(n) {
  return n.replace(/\t/g, by);
}
function pSe(n) {
  const e = n.split(`
`);
  for (; e[0] && e[0].trim().length === 0; )
    e.shift();
  let t = 1 / 0;
  for (const r of e)
    if (r.trim().length > 0) {
      const i = r.length - r.trimStart().length;
      t = Math.min(t, i);
    }
  return e.map((r) => r.slice(t)).join(`
`);
}
const DW = {
  "&amp;": "&",
  "&quot;": '"',
  "&apos;": "'",
  "&#34;": '"',
  "&#38;": "&",
  "&#39;": "'",
  "&#8211;": "–",
  "&#8212;": "—",
  "&#8216;": "‘",
  "&#8217;": "’",
  "&#8220;": "“",
  "&#8221;": "”",
  "&#8230;": "…"
}, gSe = new RegExp(Object.keys(DW).join("|"), "g");
function mSe(n) {
  return n.replace(gSe, (e) => DW[e]);
}
function ySe(n) {
  return n.replace(/[ \t]+$/gm, "").replace(/\n+$/, "");
}
function vSe(n) {
  return ySe(pSe(hSe(n)));
}
function SSe(n, {
  maxImageDimension: e,
  maxAssetSize: t,
  acceptedImageMimeTypes: r,
  acceptedVideoMimeTypes: i
}, { toasts: s, msg: l }) {
  n.registerExternalAssetHandler("file", async ({ file: c, assetId: d }) => {
    const h = r.includes(c.type), g = i.includes(c.type);
    !h && !g && s.addToast({
      title: l("assets.files.type-not-allowed"),
      severity: "error"
    }), on(h || g, `File type not allowed: ${c.type}`), c.size > t && s.addToast({
      title: l("assets.files.size-too-big"),
      severity: "error"
    }), on(
      c.size <= t,
      `File size too big: ${(c.size / 1024).toFixed()}kb > ${(t / 1024).toFixed()}kb`
    );
    const y = vF(await c.arrayBuffer());
    d = d ?? ih.createId(y);
    const v = await GU(c, d, h, g);
    if (isFinite(e)) {
      const w = { w: v.props.w, h: v.props.h }, C = dSe(w, { w: e, h: e });
      w !== C && Ya.isStaticImageType(c.type) && (v.props.w = C.w, v.props.h = C.h);
    }
    return v.props.src = await n.uploadAsset(v, c), ih.create(v);
  }), n.registerExternalAssetHandler("url", async ({ url: c }) => {
    var h, g, y, v, w;
    let d;
    try {
      const E = await (await Eu(c, {
        method: "GET",
        mode: "no-cors"
      })).text(), P = new DOMParser().parseFromString(E, "text/html");
      d = {
        image: ((h = P.head.querySelector('meta[property="og:image"]')) == null ? void 0 : h.getAttribute("content")) ?? "",
        favicon: ((g = P.head.querySelector('link[rel="apple-touch-icon"]')) == null ? void 0 : g.getAttribute("href")) ?? ((y = P.head.querySelector('link[rel="icon"]')) == null ? void 0 : y.getAttribute("href")) ?? "",
        title: ((v = P.head.querySelector('meta[property="og:title"]')) == null ? void 0 : v.getAttribute("content")) ?? c,
        description: ((w = P.head.querySelector('meta[property="og:description"]')) == null ? void 0 : w.getAttribute("content")) ?? ""
      }, d.image.startsWith("http") || (d.image = new URL(d.image, c).href), d.favicon.startsWith("http") || (d.favicon = new URL(d.favicon, c).href);
    } catch (C) {
      console.error(C), s.addToast({
        title: l("assets.url.failed"),
        severity: "error"
      }), d = { image: "", favicon: "", title: "", description: "" };
    }
    return {
      id: ih.createId(AA(c)),
      typeName: "asset",
      type: "bookmark",
      props: {
        src: c,
        description: d.description,
        image: d.image,
        favicon: d.favicon,
        title: d.title
      },
      meta: {}
    };
  }), n.registerExternalContentHandler("svg-text", async ({ point: c, text: d }) => {
    const h = c ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), g = new DOMParser().parseFromString(d, "image/svg+xml").querySelector("svg");
    if (!g)
      throw new Error("No <svg/> element present");
    let y = parseFloat(g.getAttribute("width") || "0"), v = parseFloat(g.getAttribute("height") || "0");
    if (!(y && v)) {
      document.body.appendChild(g);
      const C = g.getBoundingClientRect();
      document.body.removeChild(g), y = C.width, v = C.height;
    }
    const w = await n.getAssetForExternalContent({
      type: "file",
      file: new File([d], "asset.svg", { type: "image/svg+xml" })
    });
    if (!w) throw Error("Could not create an asset");
    qU(n, [w], h);
  }), n.registerExternalContentHandler(
    "embed",
    ({ point: c, url: d, embed: h }) => {
      const g = c ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), { width: y, height: v } = h, w = Sr(), C = {
        id: w,
        type: "embed",
        x: g.x - (y || 450) / 2,
        y: g.y - (v || 450) / 2,
        props: {
          w: y,
          h: v,
          url: d
        }
      };
      n.createShapes([C]).select(w);
    }
  ), n.registerExternalContentHandler("files", async ({ point: c, files: d }) => {
    if (d.length > n.options.maxFilesAtOnce)
      throw Error("Too many files");
    const h = c ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), g = new R(h.x, h.y), y = [];
    for (const w of d) {
      if (w.size > t) {
        s.addToast({
          title: l("assets.files.size-too-big"),
          severity: "error"
        }), console.warn(
          `File size too big: ${(w.size / 1024).toFixed()}kb > ${(t / 1024).toFixed()}kb`
        );
        continue;
      }
      if (!w.type) {
        s.addToast({
          title: l("assets.files.upload-failed"),
          severity: "error"
        }), console.error("No mime type");
        continue;
      }
      if (!r.concat(i).includes(w.type)) {
        s.addToast({
          title: l("assets.files.type-not-allowed"),
          severity: "error"
        }), console.warn(`${w.name} not loaded - Mime type not allowed ${w.type}.`);
        continue;
      }
      const C = r.includes(w.type), E = i.includes(w.type), P = vF(await w.arrayBuffer()), I = ih.createId(P), k = await GU(w, I, C, E);
      let L;
      C && (L = n.createTemporaryAssetPreview(I, w)), y.push({ asset: k, file: w, temporaryAssetPreview: L });
    }
    const v = [];
    await Promise.allSettled(
      y.map(async (w) => {
        try {
          const C = await n.getAssetForExternalContent({
            type: "file",
            file: w.file
          });
          if (!C)
            throw Error("Could not create an asset");
          const E = { ...C, id: w.asset.id };
          v.push(E), n.updateAssets([E]);
        } catch (C) {
          s.addToast({
            title: l("assets.files.upload-failed"),
            severity: "error"
          }), console.error(C);
          return;
        }
      })
    ), qU(n, v, g);
  }), n.registerExternalContentHandler("text", async ({ point: c, text: d }) => {
    const h = c ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), g = n.getShapeUtil("text").getDefaultProps(), y = vSe(d), v = n.getOnlySelectedShape();
    if (v && "text" in v.props) {
      n.updateShapes([
        {
          id: v.id,
          type: v.type,
          props: {
            text: y
          }
        }
      ]);
      return;
    }
    let w, C, E, P = "middle";
    const I = y.split(`
`).length > 1, k = AW(y);
    I && (P = I ? k ? "end" : "start" : "middle");
    const L = n.textMeasure.measureText(y, {
      ...Ss,
      fontFamily: Kd[g.font],
      fontSize: Dy[g.size],
      maxWidth: null
    }), O = Math.min(
      I ? n.getViewportPageBounds().width * 0.9 : 920,
      Math.max(200, n.getViewportPageBounds().width * 0.9)
    );
    if (L.w > O) {
      const z = n.textMeasure.measureText(y, {
        ...Ss,
        fontFamily: Kd[g.font],
        fontSize: Dy[g.size],
        maxWidth: O
      });
      w = z.w, C = z.h, E = !1, P = k ? "end" : "start";
    } else
      w = L.w, C = L.h, E = !0;
    h.y - C / 2 < n.getViewportPageBounds().minY + 40 && (h.y = n.getViewportPageBounds().minY + 40 + C / 2), n.createShapes([
      {
        id: Sr(),
        type: "text",
        x: h.x - w / 2,
        y: h.y - C / 2,
        props: {
          text: y,
          // if the text has more than one line, align it to the left
          textAlign: P,
          autoSize: E,
          w
        }
      }
    ]);
  }), n.registerExternalContentHandler("url", async ({ point: c, url: d }) => {
    const h = n.getShapeUtil("embed"), g = h == null ? void 0 : h.getEmbedDefinition(d);
    if (g)
      return n.putExternalContent({
        type: "embed",
        url: g.url,
        point: c,
        embed: g.definition
      });
    const y = c ?? (n.inputs.shiftKey ? n.inputs.currentPagePoint : n.getViewportPageBounds().center), v = ih.createId(AA(d)), w = xSe(n, d, y);
    let C = n.getAsset(v), E = !1;
    if (!C) {
      E = !0;
      try {
        const P = await n.getAssetForExternalContent({ type: "url", url: d });
        if (!P) throw Error("Could not create an asset");
        C = P;
      } catch {
        s.addToast({
          title: l("assets.url.failed"),
          severity: "error"
        });
        return;
      }
    }
    n.run(() => {
      E && n.createAssets([C]), n.updateShapes([
        {
          id: w.id,
          type: w.type,
          props: {
            assetId: C.id
          }
        }
      ]);
    });
  });
}
async function GU(n, e, t, r) {
  let i = n.type;
  n.type === "video/quicktime" && (i = "video/mp4");
  const s = t ? await Ya.getImageSize(n) : await Ya.getVideoSize(n), l = await Ya.isAnimated(n) || r;
  return {
    id: e,
    type: t ? "image" : "video",
    typeName: "asset",
    props: {
      name: n.name,
      src: "",
      w: s.w,
      h: s.h,
      fileSize: n.size,
      mimeType: i,
      isAnimated: l
    },
    meta: {}
  };
}
async function qU(n, e, t) {
  if (!e.length) return [];
  const r = R.From(t), i = [];
  for (let s = 0; s < e.length; s++) {
    const l = e[s];
    switch (l.type) {
      case "image": {
        i.push({
          id: Sr(),
          type: "image",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: l.id,
            w: l.props.w,
            h: l.props.h
          }
        }), r.x += l.props.w;
        break;
      }
      case "video":
        i.push({
          id: Sr(),
          type: "video",
          x: r.x,
          y: r.y,
          opacity: 1,
          props: {
            assetId: l.id,
            w: l.props.w,
            h: l.props.h
          }
        }), r.x += l.props.w;
    }
  }
  return n.run(() => {
    const s = e.filter((l) => !n.getAsset(l.id));
    s.length && n.createAssets(s), n.createShapes(i).select(...i.map((l) => l.id)), OW(n, t);
  }), i.map((s) => s.id);
}
function OW(n, e) {
  const t = n.getViewportPageBounds();
  let r = n.getSelectionPageBounds();
  if (r) {
    const i = r.center.sub(e);
    n.updateShapes(
      n.getSelectedShapes().map((s) => {
        const l = n.getShapeParentTransform(s).decompose().rotation, c = R.Rot(i, -l);
        return {
          id: s.id,
          type: s.type,
          x: s.x - c.x,
          y: s.y - c.y
        };
      })
    );
  }
  if (r = n.getSelectionPageBounds(), r && n.getInstanceState().isGridMode) {
    const i = n.getDocumentSettings().gridSize, s = new R(r.minX, r.minY), l = s.clone().snapToGrid(i), c = R.Sub(s, l);
    n.updateShapes(
      n.getSelectedShapes().map((d) => {
        const h = { x: d.x - c.x, y: d.y - c.y };
        return {
          id: d.id,
          type: d.type,
          x: h.x,
          y: h.y
        };
      })
    );
  }
  r = n.getSelectionPageBounds(), r && !t.contains(r) && n.zoomToSelection({ animation: { duration: n.options.animationMediumMs } });
}
function xSe(n, e, t) {
  const r = {
    id: Sr(),
    type: "bookmark",
    x: t.x - 150,
    y: t.y - 160,
    opacity: 1,
    props: {
      assetId: null,
      url: e
    }
  };
  return n.run(() => {
    n.createShapes([r]).select(r.id), OW(n, t);
  }), n.getShape(r.id);
}
var hA;
let wSe = (hA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
  onKeyUp(e) {
    var t;
    if (e.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const r = this.editor.getOnlySelectedShape();
      r && this.editor.getShapeUtil(r).canEdit(r) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(r.id), (t = this.editor.root.getCurrent()) == null || t.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: r
      }));
    }
  }
}, U(hA, "id", "idle"), hA);
var pA;
let bSe = (pA = class extends Et {
  constructor() {
    super(...arguments);
    U(this, "shape");
    U(this, "markId", "");
    U(this, "preciseTimeout", -1);
    U(this, "didTimeout", !1);
  }
  onEnter() {
    this.markId = "", this.didTimeout = !1;
    const t = this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
      filter: (r) => !r.isLocked && this.editor.canBindShapes({ fromShape: "arrow", toShape: r, binding: "arrow" }),
      margin: 0,
      hitInside: !0,
      renderingOnly: !0
    });
    t ? this.editor.setHintingShapes([t.id]) : this.createArrowShape(), this.startPreciseTimeout();
  }
  onExit() {
    this.shape = void 0, this.editor.setHintingShapes([]), this.clearPreciseTimeout();
  }
  onPointerMove() {
    if (this.editor.inputs.isDragging) {
      if (this.shape || this.createArrowShape(), !this.shape) throw Error("expected shape");
      this.updateArrowShapeEndHandle(), this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        handle: { id: "end", type: "vertex", index: "a3", x: 0, y: 0 },
        isCreating: !0,
        creatingMarkId: this.markId || void 0,
        onInteractionEnd: "arrow"
      });
    }
  }
  onPointerUp() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.shape && this.editor.bailToMark(this.markId), this.editor.setHintingShapes([]), this.parent.transition("idle");
  }
  createArrowShape() {
    var y;
    const { originPagePoint: t } = this.editor.inputs, r = Sr();
    this.markId = this.editor.markHistoryStoppingPoint(`creating_arrow:${r}`);
    const i = Ec(t, this.editor);
    this.editor.createShape({
      id: r,
      type: "arrow",
      x: i.x,
      y: i.y,
      props: {
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const s = this.editor.getShape(r);
    if (!s) throw Error("expected shape");
    const l = this.editor.getShapeHandles(s);
    if (!l) throw Error("expected handles for arrow");
    const c = this.editor.getShapeUtil("arrow"), d = this.shape, h = l.find((v) => v.id === "start"), g = (y = c.onHandleDrag) == null ? void 0 : y.call(c, s, {
      handle: { ...h, x: 0, y: 0 },
      isPrecise: !0,
      initial: d
    });
    g && this.editor.updateShapes([g]), this.shape = this.editor.getShape(r), this.editor.select(r);
  }
  updateArrowShapeEndHandle() {
    var i, s;
    const t = this.shape;
    if (!t) throw Error("expected shape");
    const r = this.editor.getShapeHandles(t);
    if (!r) throw Error("expected handles for arrow");
    {
      const l = this.editor.getShapeUtil("arrow"), c = this.shape, d = r.find((g) => g.id === "start"), h = (i = l.onHandleDrag) == null ? void 0 : i.call(l, t, {
        handle: { ...d, x: 0, y: 0 },
        isPrecise: this.didTimeout,
        // sure about that?
        initial: c
      });
      h && this.editor.updateShapes([h]);
    }
    {
      const l = this.editor.getShapeUtil("arrow"), c = this.shape, d = this.editor.getPointInShapeSpace(t, this.editor.inputs.currentPagePoint), h = r.find((y) => y.id === "end"), g = (s = l.onHandleDrag) == null ? void 0 : s.call(l, this.editor.getShape(t), {
        handle: { ...h, x: d.x, y: d.y },
        isPrecise: !1,
        // sure about that?
        initial: c
      });
      g && this.editor.updateShapes([g]);
    }
    this.shape = this.editor.getShape(t.id);
  }
  startPreciseTimeout() {
    this.preciseTimeout = this.editor.timers.setTimeout(() => {
      this.getIsActive() && (this.didTimeout = !0);
    }, 320);
  }
  clearPreciseTimeout() {
    clearTimeout(this.preciseTimeout);
  }
}, U(pA, "id", "pointing"), pA);
class ED extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "arrow");
  }
  static children() {
    return [wSe, bSe];
  }
}
U(ED, "id", "arrow"), U(ED, "initial", "idle");
class Jj extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "initialShape");
    U(this, "shapeType", this.parent.id === "highlight" ? "highlight" : "draw");
    U(this, "util", this.editor.getShapeUtil(this.shapeType));
    U(this, "isPen", !1);
    U(this, "isPenOrStylus", !1);
    U(this, "segmentMode", "free");
    U(this, "didJustShiftClickToExtendPreviousShapeLine", !1);
    U(this, "pagePointWhereCurrentSegmentChanged", {});
    U(this, "pagePointWhereNextSegmentChanged", null);
    U(this, "lastRecordedPoint", {});
    U(this, "mergeNextPoint", !1);
    U(this, "currentLineLength", 0);
    U(this, "markId", null);
  }
  onEnter(t) {
    this.markId = null, this.info = t, this.lastRecordedPoint = this.editor.inputs.currentPagePoint.clone(), this.startShape();
  }
  onPointerMove() {
    const { inputs: t } = this.editor;
    if (this.isPen && !t.isPen && this.markId) {
      this.editor.bailToMark(this.markId), this.startShape();
      return;
    }
    this.isPenOrStylus ? R.Dist(t.currentPagePoint, this.lastRecordedPoint) >= 1 / this.editor.getZoomLevel() ? (this.lastRecordedPoint = t.currentPagePoint.clone(), this.mergeNextPoint = !1) : this.mergeNextPoint = !0 : this.mergeNextPoint = !1, this.updateDrawingShape();
  }
  onKeyDown(t) {
    if (t.key === "Shift")
      switch (this.segmentMode) {
        case "free": {
          this.segmentMode = "starting_straight", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_free":
          this.segmentMode = "starting_straight";
      }
    this.updateDrawingShape();
  }
  onKeyUp(t) {
    if (t.key === "Shift")
      switch (this.editor.snaps.clearIndicators(), this.segmentMode) {
        case "straight": {
          this.segmentMode = "starting_free", this.pagePointWhereNextSegmentChanged = this.editor.inputs.currentPagePoint.clone();
          break;
        }
        case "starting_straight": {
          this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          break;
        }
      }
    this.updateDrawingShape();
  }
  onExit() {
    this.editor.snaps.clearIndicators(), this.pagePointWhereCurrentSegmentChanged = this.editor.inputs.currentPagePoint.clone();
  }
  canClose() {
    return this.shapeType !== "highlight";
  }
  getIsClosed(t, r, i) {
    if (!this.canClose()) return !1;
    const s = vs[r], l = t[0].points[0], c = t[t.length - 1], d = c.points[c.points.length - 1];
    return l !== d && this.currentLineLength > s * 4 * i && R.DistMin(l, d, s * 2 * i);
  }
  startShape() {
    const {
      inputs: { originPagePoint: t, isPen: r }
    } = this.editor;
    this.markId = this.editor.markHistoryStoppingPoint("draw start");
    const { z: i = 0.5 } = this.info.point;
    this.isPen = r, this.isPenOrStylus = r || i > 0 && i < 0.5 || i > 0.5 && i < 1;
    const s = this.isPenOrStylus ? i * 1.25 : 0.5;
    if (this.segmentMode = this.editor.inputs.shiftKey ? "straight" : "free", this.didJustShiftClickToExtendPreviousShapeLine = !1, this.lastRecordedPoint = t.clone(), this.initialShape) {
      const c = this.editor.getShape(this.initialShape.id);
      if (c && this.segmentMode === "straight") {
        this.didJustShiftClickToExtendPreviousShapeLine = !0;
        const d = jo(c.props.segments);
        if (!d) throw Error("Expected a previous segment!");
        const h = jo(d.points);
        if (!h) throw Error("Expected a previous point!");
        const { x: g, y } = this.editor.getPointInShapeSpace(c, t).toFixed(), v = {
          type: this.segmentMode,
          points: [
            {
              x: h.x,
              y: h.y,
              z: +s.toFixed(2)
            },
            {
              x: g,
              y,
              z: +s.toFixed(2)
            }
          ]
        }, w = qe.applyToPoint(
          this.editor.getShapePageTransform(c.id),
          h
        );
        this.pagePointWhereCurrentSegmentChanged = w, this.pagePointWhereNextSegmentChanged = null;
        const C = [...c.props.segments, v];
        this.currentLineLength < vs[c.props.size] * 4 && (this.currentLineLength = this.getLineLength(C));
        const E = {
          id: c.id,
          type: this.shapeType,
          props: {
            segments: C
          }
        };
        this.canClose() && (E.props.isClosed = this.getIsClosed(
          C,
          c.props.size,
          c.props.scale
        )), this.editor.updateShapes([E]);
        return;
      }
    }
    this.pagePointWhereCurrentSegmentChanged = t.clone();
    const l = Sr();
    this.editor.createShapes([
      {
        id: l,
        type: this.shapeType,
        x: t.x,
        y: t.y,
        props: {
          isPen: this.isPenOrStylus,
          scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1,
          segments: [
            {
              type: this.segmentMode,
              points: [
                {
                  x: 0,
                  y: 0,
                  z: +s.toFixed(2)
                }
              ]
            }
          ]
        }
      }
    ]), this.currentLineLength = 0, this.initialShape = this.editor.getShape(l);
  }
  updateDrawingShape() {
    const { initialShape: t } = this, { inputs: r } = this.editor;
    if (!t) return;
    const {
      id: i,
      props: { size: s, scale: l }
    } = t, c = this.editor.getShape(i);
    if (!c) return;
    const { segments: d } = c.props, { x: h, y: g, z: y } = this.editor.getPointInShapeSpace(c, r.currentPagePoint).toFixed(), v = this.isPenOrStylus ? +(r.currentPagePoint.z * 1.25).toFixed(2) : 0.5, w = { x: h, y: g, z: v };
    switch (this.segmentMode) {
      case "starting_straight": {
        const { pagePointWhereNextSegmentChanged: C } = this;
        if (C === null)
          throw Error("We should have a point where the segment changed");
        if (R.Dist2(C, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "straight";
          const P = jo(d);
          if (!P) throw Error("Expected a previous segment!");
          const I = jo(P.points);
          if (!I) throw Error("Expected a previous last point!");
          let k;
          const L = this.editor.getPointInShapeSpace(c, this.pagePointWhereCurrentSegmentChanged).toFixed().toJson();
          if (P.type === "straight") {
            this.currentLineLength += R.Dist(I, L), k = {
              type: "straight",
              points: [{ ...I }, L]
            };
            const z = this.editor.getShapePageTransform(c);
            this.pagePointWhereCurrentSegmentChanged = qe.applyToPoint(z, I);
          } else
            k = {
              type: "straight",
              points: [L, w]
            };
          const O = {
            id: i,
            type: this.shapeType,
            props: {
              segments: [...d, k]
            }
          };
          this.canClose() && (O.props.isClosed = this.getIsClosed(
            d,
            s,
            l
          )), this.editor.updateShapes([O]);
        }
        break;
      }
      case "starting_free": {
        const { pagePointWhereNextSegmentChanged: C } = this;
        if (C === null)
          throw Error("We should have a point where the segment changed");
        if (R.Dist2(C, r.currentPagePoint) > this.editor.options.dragDistanceSquared) {
          this.pagePointWhereCurrentSegmentChanged = this.pagePointWhereNextSegmentChanged.clone(), this.pagePointWhereNextSegmentChanged = null, this.segmentMode = "free";
          const P = d.slice(), I = P[P.length - 1], k = jo(I.points);
          if (!k)
            throw Error("No previous point!");
          const L = {
            type: "free",
            points: [
              ...R.PointsBetween(k, w, 6).map((F) => ({
                x: jd(F.x),
                y: jd(F.y),
                z: jd(F.z)
              }))
            ]
          }, O = [...P, L];
          this.currentLineLength < vs[c.props.size] * 4 && (this.currentLineLength = this.getLineLength(O));
          const z = {
            id: i,
            type: this.shapeType,
            props: {
              segments: O
            }
          };
          this.canClose() && (z.props.isClosed = this.getIsClosed(
            O,
            s,
            l
          )), this.editor.updateShapes([z]);
        }
        break;
      }
      case "straight": {
        const C = d.slice(), E = C[C.length - 1], { pagePointWhereCurrentSegmentChanged: P } = this, { ctrlKey: I, currentPagePoint: k } = this.editor.inputs;
        if (!P)
          throw Error("We should have a point where the segment changed");
        let L, O = !1;
        this.didJustShiftClickToExtendPreviousShapeLine ? this.editor.inputs.isDragging && (O = !I, this.didJustShiftClickToExtendPreviousShapeLine = !1) : O = !I;
        let z = this.editor.getPointInShapeSpace(c, k).toFixed().toJson(), F = !1, H;
        if ((this.editor.user.getIsSnapMode() ? !I : I) && C.length > 2) {
          let q, J = 8 / this.editor.getZoomLevel();
          for (let ie = 0, W = d.length - 2; ie < W; ie++) {
            const Y = d[ie];
            if (!Y) break;
            if (Y.type === "free") continue;
            const oe = Y.points[0], le = jo(Y.points);
            if (!(oe && le)) continue;
            const ce = R.NearestPointOnLineSegment(
              oe,
              le,
              z
            );
            if (R.DistMin(ce, z, J)) {
              q = ce.toFixed().toJson(), J = R.Dist(ce, z), H = Y;
              break;
            }
          }
          q && (F = !0, z = q);
        }
        if (F && H) {
          const q = this.editor.getShapePageTransform(c), J = H.points[0], ie = jo(H.points);
          if (!ie) throw Error("Expected a last point!");
          const W = qe.applyToPoint(q, J), Y = qe.applyToPoint(q, ie), oe = qe.applyToPoint(q, z);
          this.editor.snaps.setIndicators([
            {
              id: or(),
              type: "points",
              points: [W, oe, Y]
            }
          ]);
        } else {
          if (this.editor.snaps.clearIndicators(), O) {
            const q = R.Angle(P, k), ie = yE(q, 24) - q;
            L = R.RotWith(
              k,
              P,
              ie
            );
          } else
            L = k;
          z = this.editor.getPointInShapeSpace(c, L).toFixed().toJson();
        }
        this.currentLineLength += R.Dist(E.points[0], z), C[C.length - 1] = {
          ...E,
          type: "straight",
          points: [E.points[0], z]
        };
        const re = {
          id: i,
          type: this.shapeType,
          props: {
            segments: C
          }
        };
        this.canClose() && (re.props.isClosed = this.getIsClosed(
          d,
          s,
          l
        )), this.editor.updateShapes([re]);
        break;
      }
      case "free": {
        const C = d.slice(), E = C[C.length - 1], P = [...E.points];
        if (P.length && this.mergeNextPoint) {
          const { z: k } = P[P.length - 1];
          P[P.length - 1] = {
            x: w.x,
            y: w.y,
            z: k ? Math.max(k, w.z) : w.z
          };
        } else
          this.currentLineLength += R.Dist(P[P.length - 1], w), P.push(w);
        C[C.length - 1] = {
          ...E,
          points: P
        }, this.currentLineLength < vs[c.props.size] * 4 && (this.currentLineLength = this.getLineLength(C));
        const I = {
          id: i,
          type: this.shapeType,
          props: {
            segments: C
          }
        };
        if (this.canClose() && (I.props.isClosed = this.getIsClosed(
          C,
          s,
          l
        )), this.editor.updateShapes([I]), P.length > this.editor.options.maxPointsPerDrawShape) {
          this.editor.updateShapes([{ id: i, type: this.shapeType, props: { isComplete: !0 } }]);
          const k = Sr(), L = this.editor.getShape(i).props;
          this.editor.createShapes([
            {
              id: k,
              type: this.shapeType,
              x: jd(r.currentPagePoint.x),
              y: jd(r.currentPagePoint.y),
              props: {
                isPen: this.isPenOrStylus,
                scale: L.scale,
                segments: [
                  {
                    type: "free",
                    points: [{ x: 0, y: 0, z: this.isPenOrStylus ? +(y * 1.25).toFixed() : 0.5 }]
                  }
                ]
              }
            }
          ]), this.initialShape = $r(this.editor.getShape(k)), this.mergeNextPoint = !1, this.lastRecordedPoint = r.currentPagePoint.clone(), this.currentLineLength = 0;
        }
        break;
      }
    }
  }
  getLineLength(t) {
    let r = 0;
    for (const i of t)
      for (let s = 0; s < i.points.length - 1; s++) {
        const l = i.points[s], c = i.points[s + 1];
        r += R.Dist2(c, l);
      }
    return Math.sqrt(r);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.editor.inputs.isDragging || (this.markId && this.editor.bailToMark(this.markId), this.cancel());
  }
  complete() {
    const { initialShape: t } = this;
    t && (this.editor.updateShapes([
      { id: t.id, type: t.type, props: { isComplete: !0 } }
    ]), this.parent.transition("idle"));
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
U(Jj, "id", "drawing");
var gA;
let jW = (gA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("drawing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(gA, "id", "idle"), gA);
class RC extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "draw");
  }
  static children() {
    return [jW, Jj];
  }
  onExit() {
    const t = this.children.drawing;
    t.initialShape = void 0;
  }
}
U(RC, "id", "draw"), U(RC, "initial", "idle"), U(RC, "isLockable", !1);
class _D extends sD {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "frame");
  }
  onCreate(t) {
    if (!t) return;
    const r = this.editor.getShapePageBounds(t), i = [], s = this.editor.getShapeAncestors(t).map((l) => l.id);
    this.editor.getSortedChildIdsForParent(t.parentId).map((l) => {
      const c = this.editor.getShape(l);
      if (!c || c.id === t.id || c.isLocked) return;
      const d = this.editor.getShapePageBounds(c);
      d && r.contains(d) && CSe(c, s, t) && i.push(c.id);
    }), this.editor.reparentShapes(i, t.id), this.editor.getInstanceState().isToolLocked ? this.editor.setCurrentTool("frame") : this.editor.setCurrentTool("select.idle");
  }
}
U(_D, "id", "frame"), U(_D, "initial", "idle");
function CSe(n, e, t) {
  return e.includes(n.id) ? !1 : n.parentId === t.parentId;
}
var mA;
let ESe = (mA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onKeyUp(e) {
    var t;
    if (e.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const r = this.editor.getOnlySelectedShape();
      r && this.editor.getShapeUtil(r).canEdit(r) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(r.id), (t = this.editor.root.getCurrent()) == null || t.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: r
      }));
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(mA, "id", "idle"), mA);
var yA;
let _Se = (yA = class extends Et {
  onPointerUp() {
    this.complete();
  }
  onPointerMove(e) {
    if (this.editor.inputs.isDragging) {
      const { originPagePoint: t } = this.editor.inputs, r = Sr(), i = this.editor.markHistoryStoppingPoint(`creating_geo:${r}`), s = Ec(t, this.editor);
      this.editor.createShapes([
        {
          id: r,
          type: "geo",
          x: s.x,
          y: s.y,
          props: {
            w: 1,
            h: 1,
            geo: this.editor.getStyleForNextShape(Sc),
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]).select(r).setCurrentTool("select.resizing", {
        ...e,
        target: "selection",
        handle: "bottom_right",
        isCreating: !0,
        creatingMarkId: i,
        creationCursorOffset: { x: 1, y: 1 },
        onInteractionEnd: "geo"
      });
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    const { originPagePoint: e } = this.editor.inputs, t = Sr();
    this.editor.markHistoryStoppingPoint(`creating_geo:${t}`);
    const r = this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1, i = this.editor.getStyleForNextShape(Sc), s = i === "star" ? { w: 200, h: 190 } : i === "cloud" ? { w: 300, h: 180 } : { w: 200, h: 200 };
    this.editor.createShapes([
      {
        id: t,
        type: "geo",
        x: e.x,
        y: e.y,
        props: {
          geo: this.editor.getStyleForNextShape(Sc),
          scale: r,
          ...s
        }
      }
    ]);
    const l = this.editor.getShape(t);
    if (!l) return;
    const { w: c, h: d } = l.props, h = new R(c / 2, d / 2).mul(r), g = this.editor.getShapeParentTransform(l);
    g && h.rot(-g.rotation());
    const y = Ec(new R(l.x - h.x, l.y - h.y), this.editor);
    this.editor.select(t), this.editor.updateShape({
      id: l.id,
      type: "geo",
      x: y.x,
      y: y.y,
      props: {
        geo: this.editor.getStyleForNextShape(Sc),
        w: c * r,
        h: d * r
      }
    }), this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : this.editor.setCurrentTool("select", {});
  }
  cancel() {
    this.parent.transition("idle");
  }
}, U(yA, "id", "pointing"), yA);
class PD extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "geo");
  }
  static children() {
    return [ESe, _Se];
  }
}
U(PD, "id", "geo"), U(PD, "initial", "idle");
class MC extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "highlight");
  }
  static children() {
    return [jW, Jj];
  }
  onExit() {
    const t = this.children.drawing;
    t.initialShape = void 0;
  }
}
U(MC, "id", "highlight"), U(MC, "initial", "idle"), U(MC, "isLockable", !1);
var vA;
let PSe = (vA = class extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeId", "");
  }
  onEnter(t) {
    this.shapeId = t.shapeId, this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onPointerDown() {
    this.parent.transition("pointing", { shapeId: this.shapeId });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(vA, "id", "idle"), vA);
const YU = 2;
var SA;
let TSe = (SA = class extends Et {
  constructor() {
    super(...arguments);
    U(this, "shape", {});
    U(this, "markId");
  }
  onEnter(t) {
    const { inputs: r } = this.editor, { currentPagePoint: i } = r;
    this.markId = void 0;
    const s = t.shapeId && this.editor.getShape(t.shapeId);
    if (s && r.shiftKey) {
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${s.id}`), this.shape = s;
      const l = this.editor.getShapeHandles(this.shape);
      if (!l) return;
      const c = l.filter((C) => C.type === "vertex").sort(gs), d = c[c.length - 1], h = c[c.length - 2], g = qe.applyToPoint(
        this.editor.getShapeParentTransform(this.shape),
        new R(this.shape.x, this.shape.y)
      ), y = R.Sub(i, g).addXY(0.1, 0.1), v = Ec(y, this.editor), w = $r(this.shape.props.points);
      if (R.DistMin(d, h, YU) || R.DistMin(v, d, YU))
        w[d.id] = {
          id: d.id,
          index: d.index,
          x: v.x,
          y: v.y
        };
      else {
        const C = vu(d.index);
        w[C] = {
          id: C,
          index: C,
          x: v.x,
          y: v.y
        };
      }
      this.editor.updateShapes([
        {
          id: this.shape.id,
          type: this.shape.type,
          props: {
            points: w
          }
        }
      ]);
    } else {
      const l = Sr();
      this.markId = this.editor.markHistoryStoppingPoint(`creating_line:${l}`);
      const c = Ec(i, this.editor);
      this.editor.createShapes([
        {
          id: l,
          type: "line",
          x: c.x,
          y: c.y,
          props: {
            scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
          }
        }
      ]), this.editor.select(l), this.shape = this.editor.getShape(l);
    }
  }
  onPointerMove() {
    if (this.shape && this.editor.inputs.isDragging) {
      const t = this.editor.getShapeHandles(this.shape);
      if (!t)
        throw this.markId && this.editor.bailToMark(this.markId), Error("No handles found");
      const r = jo(t);
      this.editor.setCurrentTool("select.dragging_handle", {
        shape: this.shape,
        isCreating: !0,
        creatingMarkId: this.markId,
        // remove the offset that we added to the handle when we created it
        handle: { ...r, x: r.x - 0.1, y: r.y - 0.1 },
        onInteractionEnd: "line"
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle"), this.markId && this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
  }
  complete() {
    this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
  cancel() {
    this.markId && this.editor.bailToMark(this.markId), this.parent.transition("idle", { shapeId: this.shape.id }), this.editor.snaps.clearIndicators();
  }
}, U(SA, "id", "pointing"), SA);
class TD extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "line");
  }
  static children() {
    return [PSe, TSe];
  }
}
U(TD, "id", "line"), U(TD, "initial", "idle");
var xA;
let ISe = (xA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(xA, "id", "idle"), xA);
const kSe = 0, vr = 200, F_ = new R(vr / 2, vr / 2), LW = 10, RSe = (n) => [
  [
    ["a1"],
    new R(vr * 0.5, vr * -0.5 - n.options.adjacentShapeMargin)
  ],
  // t
  [
    ["a2"],
    new R(vr * 1.5 + n.options.adjacentShapeMargin, vr * 0.5)
  ],
  // r
  [
    ["a3"],
    new R(vr * 0.5, vr * 1.5 + n.options.adjacentShapeMargin)
  ],
  // b
  [
    ["a4"],
    new R(vr * -0.5 - n.options.adjacentShapeMargin, vr * 0.5)
  ]
  // l
];
function MSe(n, e) {
  if (e === 1) return RSe(n);
  const t = vr * e, r = n.options.adjacentShapeMargin * e;
  return [
    [["a1"], new R(t * 0.5, t * -0.5 - r)],
    // t
    [["a2"], new R(t * 1.5 + r, t * 0.5)],
    // r
    [["a3"], new R(t * 0.5, t * 1.5 + r)],
    // b
    [["a4"], new R(t * -0.5 - r, t * 0.5)]
    // l
  ];
}
function NW(n, e, t, r, i, s) {
  return Object.fromEntries(
    MSe(n, s).map(([l, c], d) => {
      const h = c.clone();
      return d === 0 && i ? h.y -= i : d === 2 && r && (h.y += r), [l, h.rot(t).add(e)];
    })
  );
}
function FW(n, e, t, r) {
  const i = new Set(n.getSelectedShapeIds()), s = (vr + n.options.adjacentShapeMargin + r) ** 2, l = /* @__PURE__ */ new Map(), c = [];
  for (const g of n.getCurrentPageShapes()) {
    if (!n.isShapeOfType(g, "note") || t !== g.props.scale || i.has(g.id))
      continue;
    const y = n.getShapePageTransform(g.id);
    e === y.rotation() && (l.set(g, n.getShapePageBounds(g).center), c.push(
      ...Object.values(
        NW(
          n,
          y.point(),
          e,
          g.props.growY,
          r,
          t
        )
      )
    ));
  }
  const d = c.length;
  let h;
  for (const [g, y] of l)
    for (let v = 0; v < d; v++)
      h = c[v], h && (R.Dist2(y, h) > s || n.isPointInShape(g, h) && (c[v] = void 0));
  return rn(c);
}
function zW(n, e, t, r, i = !1) {
  let s;
  const l = n.getCurrentPageShapesSorted(), c = (vr + n.options.adjacentShapeMargin ** 2) ** e.props.scale;
  for (let d = l.length - 1; d >= 0; d--) {
    const h = l[d];
    if (h.type === "note" && h.id !== e.id) {
      const g = n.getShapePageBounds(h);
      if (g && R.Dist2(g.center, t) < c && n.isPointInShape(h, t)) {
        s = h;
        break;
      }
    }
  }
  if (n.complete(), !s || i) {
    n.markHistoryStoppingPoint("creating note shape");
    const d = Sr();
    n.createShape({
      id: d,
      type: "note",
      x: t.x,
      y: t.y,
      rotation: r,
      opacity: e.opacity,
      props: {
        // Use the props of the shape we're cloning
        ...e.props,
        // ...except for these values, which should reset to their defaults
        text: "",
        growY: 0,
        fontSizeAdjustment: 0,
        url: ""
      }
    });
    const h = n.getShape(d);
    if (!h) return;
    const g = n.getPointInParentSpace(
      h,
      R.Sub(
        t,
        R.Rot(F_.clone().mul(h.props.scale), r)
      )
    );
    n.updateShape({
      id: d,
      type: "note",
      x: g.x,
      y: g.y
    }), s = n.getShape(d);
  }
  return DSe(n), s;
}
const ASe = 16;
function DSe(n) {
  const e = n.getSelectionPageBounds(), t = n.getViewportPageBounds();
  if (e && !t.contains(e)) {
    const r = e.clone().expandBy(ASe / n.getZoomLevel()).expand(t), i = t.clone().translate({
      x: (r.center.x - t.center.x) * 2,
      y: (r.center.y - t.center.y) * 2
    });
    n.zoomToBounds(i, {
      animation: {
        duration: n.options.animationMediumMs
      },
      inset: 0
    });
  }
}
var wA;
let OSe = (wA = class extends Et {
  constructor() {
    super(...arguments);
    U(this, "dragged", !1);
    U(this, "info", {});
    U(this, "markId", "");
    U(this, "shape", {});
  }
  onEnter() {
    const { editor: t } = this, r = Sr();
    this.markId = t.markHistoryStoppingPoint(`creating_note:${r}`);
    const i = this.editor.inputs.originPagePoint.clone(), s = jSe(
      this.editor,
      i,
      this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
    );
    s && i.sub(s), this.shape = LSe(this.editor, r, i);
  }
  onPointerMove(t) {
    this.editor.inputs.isDragging && this.editor.setCurrentTool("select.translating", {
      ...t,
      target: "shape",
      shape: this.shape,
      onInteractionEnd: "note",
      isCreating: !0,
      creatingMarkId: this.markId,
      onCreate: () => {
        this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape");
      }
    });
  }
  onPointerUp() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    this.editor.getInstanceState().isToolLocked ? this.parent.transition("idle") : (this.editor.setEditingShape(this.shape.id), this.editor.setCurrentTool("select.editing_shape", {
      ...this.info,
      target: "shape",
      shape: this.shape
    }));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}, U(wA, "id", "pointing"), wA);
function jSe(n, e, t) {
  let r = LW / n.getZoomLevel(), i;
  for (const s of FW(n, 0, t, 0)) {
    const l = R.Sub(e, s), c = l.len();
    c < r && (r = c, i = l);
  }
  return i;
}
function LSe(n, e, t) {
  n.createShape({
    id: e,
    type: "note",
    x: t.x,
    y: t.y,
    props: {
      scale: n.user.getIsDynamicResizeMode() ? 1 / n.getZoomLevel() : 1
    }
  }).select(e);
  const r = n.getShape(e), i = n.getShapeGeometry(r).bounds, s = Ec(
    new R(r.x - i.width / 2, r.y - i.height / 2),
    n
  );
  return n.updateShapes([
    {
      id: e,
      type: "note",
      x: s.x,
      y: s.y
    }
  ]), n.getShape(e);
}
class ID extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "note");
  }
  static children() {
    return [ISe, OSe];
  }
}
U(ID, "id", "note"), U(ID, "initial", "idle");
var NSe = {};
function FSe(n) {
  const e = n.getShapeAtPoint(n.inputs.currentPagePoint, {
    hitInside: !1,
    hitLabels: !1,
    margin: n.options.hitTestMargin / n.getZoomLevel(),
    renderingOnly: !0
  });
  if (!e) return n.setHoveredShape(null);
  let t;
  const r = n.getOutermostSelectableShape(e);
  return r === e || r.id === n.getFocusedGroupId() || n.getSelectedShapeIds().includes(r.id) ? t = e : t = r, n.setHoveredShape(t.id);
}
const Nd = N$(
  FSe,
  NSe.NODE_ENV === "test" ? 0 : 32
);
var bA;
let zSe = (bA = class extends Et {
  onPointerMove(e) {
    switch (e.target) {
      case "shape":
      case "canvas":
        Nd(this.editor);
    }
  }
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
  onExit() {
    Nd.cancel();
  }
  onKeyDown(e) {
    var t;
    if (e.key === "Enter") {
      if (this.editor.getIsReadonly()) return null;
      const r = this.editor.getOnlySelectedShape();
      r && this.editor.getShapeUtil(r).canEdit(r) && (this.editor.setCurrentTool("select"), this.editor.setEditingShape(r.id), (t = this.editor.root.getCurrent()) == null || t.transition("editing_shape", {
        ...e,
        target: "shape",
        shape: r
      }));
    }
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(bA, "id", "idle"), bA);
var CA;
let USe = (CA = class extends Et {
  constructor() {
    super(...arguments);
    U(this, "shape");
    U(this, "markId", "");
    U(this, "enterTime", 0);
  }
  onEnter() {
    this.enterTime = Date.now();
  }
  onExit() {
    this.editor.setHintingShapes([]);
  }
  onPointerMove(t) {
    if (Date.now() - this.enterTime < 150) return;
    const { editor: r } = this, { isPointing: i } = r.inputs;
    if (!i) return;
    const { originPagePoint: s, currentPagePoint: l } = r.inputs, c = Math.abs(s.x - l.x), h = Math.sqrt(
      r.getInstanceState().isCoarsePointer ? r.options.coarseDragDistanceSquared : r.options.dragDistanceSquared
    ) * 6 / r.getZoomLevel();
    if (c > h) {
      const g = Sr();
      this.markId = r.markHistoryStoppingPoint(`creating_text:${g}`);
      const y = this.createTextShape(g, s, !1, c);
      if (!y) {
        this.cancel();
        return;
      }
      this.shape = r.getShape(y), r.select(g), r.setCurrentTool("select.resizing", {
        ...t,
        target: "selection",
        handle: "right",
        isCreating: !0,
        creatingMarkId: this.markId,
        // Make sure the cursor offset takes into account how far we've already dragged
        creationCursorOffset: { x: c, y: 1 },
        onInteractionEnd: "text",
        onCreate: () => {
          r.setEditingShape(y.id);
        }
      });
    }
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.cancel();
  }
  onCancel() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.editor.markHistoryStoppingPoint("creating text shape");
    const t = Sr(), { originPagePoint: r } = this.editor.inputs;
    this.createTextShape(t, r, !0, 20) && (this.editor.select(t), this.editor.setEditingShape(t));
  }
  cancel() {
    this.parent.transition("idle"), this.editor.bailToMark(this.markId);
  }
  createTextShape(t, r, i, s) {
    this.editor.createShape({
      id: t,
      type: "text",
      x: r.x,
      y: r.y,
      props: {
        text: "",
        autoSize: i,
        w: s,
        scale: this.editor.user.getIsDynamicResizeMode() ? 1 / this.editor.getZoomLevel() : 1
      }
    });
    const l = this.editor.getShape(t);
    if (!l) {
      this.cancel();
      return;
    }
    const c = this.editor.getShapePageBounds(l), d = new R();
    if (i)
      switch (l.props.textAlign) {
        case "start": {
          d.x = 0;
          break;
        }
        case "middle": {
          d.x = -c.width / 2;
          break;
        }
        case "end": {
          d.x = -c.width;
          break;
        }
      }
    else
      d.x = 0;
    if (d.y = -c.height / 2, va(l.parentId)) {
      const y = this.editor.getShapeParentTransform(l);
      d.rot(-y.rotation());
    }
    const h = l.x + d.x, g = l.y + d.y;
    if (this.editor.getInstanceState().isGridMode) {
      const y = new R(h, g), v = Ec(y, this.editor), w = R.Sub(y, v);
      this.editor.updateShape({
        ...l,
        x: h - w.x,
        y: g - w.y
      });
    } else
      this.editor.updateShape({
        ...l,
        x: h,
        y: g
      });
    return l;
  }
}, U(CA, "id", "pointing"), CA);
class kD extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeType", "text");
  }
  static children() {
    return [zSe, USe];
  }
}
U(kD, "id", "text"), U(kD, "initial", "idle");
const $Se = [
  kD,
  RC,
  PD,
  ID,
  TD,
  _D,
  ED,
  MC
];
function Fl() {
  return Wd({ isDarkMode: Pw() });
}
var BSe = {};
function z_(n) {
  return {
    key: `${_u.id}:${n}`,
    async getElement() {
      const e = HSe(n);
      if (!e) return null;
      const { url: t, fontFaceRule: r } = e, i = await (await Eu(t)).blob(), s = await yc.blobToDataUrl(i), l = r.replace(t, s);
      return /* @__PURE__ */ m.jsx("style", { children: l });
    }
  };
}
function HSe(n) {
  const e = D6[n];
  for (const t of document.fonts)
    if (e.includes(t.family) && "$$_url" in t && typeof t.$$_url == "string" && "$$_fontface" in t && typeof t.$$_fontface == "string")
      return { url: t.$$_url, fontFaceRule: t.$$_fontface };
  return null;
}
function eL(n) {
  return {
    key: `${_u.id}:${n}`,
    async getElement() {
      return n !== "pattern" ? null : /* @__PURE__ */ m.jsx(VSe, {});
    }
  };
}
function VSe() {
  const n = nL(), e = Vy(), t = Fl(), r = 8 / 12;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs("mask", { id: e, children: [
      /* @__PURE__ */ m.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: "white" }),
      /* @__PURE__ */ m.jsxs("g", { strokeLinecap: "round", stroke: "black", children: [
        /* @__PURE__ */ m.jsx("line", { x1: r * 1, y1: r * 3, x2: r * 3, y2: r * 1 }),
        /* @__PURE__ */ m.jsx("line", { x1: r * 5, y1: r * 7, x2: r * 7, y2: r * 5 }),
        /* @__PURE__ */ m.jsx("line", { x1: r * 9, y1: r * 11, x2: r * 11, y2: r * 9 })
      ] })
    ] }),
    /* @__PURE__ */ m.jsx(
      "pattern",
      {
        id: n(1, t.id),
        width: "8",
        height: "8",
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ m.jsx("rect", { x: "0", y: "0", width: "8", height: "8", fill: t.solid, mask: `url(#${e})` })
      }
    )
  ] });
}
function tL() {
  return {
    key: `${_u.id}:pattern`,
    component: qSe
  };
}
const Px = 8, XU = (n, e, t) => new Promise((r, i) => {
  const s = Px * e * n, l = document.createElement("canvas");
  l.width = s, l.height = s;
  const c = l.getContext("2d");
  if (!c) return;
  c.fillStyle = t ? uE.darkMode.solid : uE.lightMode.solid, c.fillRect(0, 0, s, s), c.globalCompositeOperation = "destination-out", c.lineCap = "round", c.lineWidth = 1.25 * e * n;
  const d = 8 / 12, h = (g) => g * e * n;
  c.beginPath(), c.moveTo(h(d * 1), h(d * 3)), c.lineTo(h(d * 3), h(d * 1)), c.moveTo(h(d * 5), h(d * 7)), c.lineTo(h(d * 7), h(d * 5)), c.moveTo(h(d * 9), h(d * 11)), c.lineTo(h(d * 11), h(d * 9)), c.stroke(), l.toBlob((g) => {
    !g || Ei.throwToBlob.get() ? i() : r(g);
  });
}), ZU = (n, e) => {
  const t = document.createElement("canvas");
  t.width = n[0], t.height = n[1];
  const r = t.getContext("2d");
  return r ? (e(r), t.toDataURL()) : "";
};
let tA = null;
function KSe() {
  return tA || (tA = {
    white: ZU([1, 1], (n) => {
      n.fillStyle = "#f8f9fa", n.fillRect(0, 0, 1, 1);
    }),
    black: ZU([1, 1], (n) => {
      n.fillStyle = "#212529", n.fillRect(0, 0, 1, 1);
    })
  }), tA;
}
function UW(n) {
  return Math.ceil(Math.log2(Math.max(1, n)));
}
function nL() {
  const n = bc("hash_pattern");
  return M.useCallback(
    (e, t) => {
      const r = UW(e);
      return RO(n, `${t}_${r}`);
    },
    [n]
  );
}
function $W(n) {
  const e = [], r = UW(n);
  for (let i = 0; i <= r; i++)
    e.push(Math.pow(2, i));
  return e;
}
function WSe(n) {
  const e = KSe();
  return $W(n).flatMap((t) => [
    { zoom: t, url: e.white, theme: "light" },
    { zoom: t, url: e.black, theme: "dark" }
  ]);
}
function GSe() {
  const n = be(), e = Pe("devicePixelRatio", () => n.getInstanceState().devicePixelRatio, [
    n
  ]), t = Pe("maxZoom", () => Math.ceil(jo(n.getCameraOptions().zoomSteps)), [
    n
  ]), [r, i] = M.useState(!1), [s, l] = M.useState(
    () => WSe(t)
  ), c = nL();
  return M.useEffect(() => {
    if (BSe.NODE_ENV === "test") {
      i(!0);
      return;
    }
    const h = Promise.all(
      $W(t).flatMap((y) => [
        XU(e, y, !1).then((v) => ({
          zoom: y,
          theme: "light",
          url: URL.createObjectURL(v)
        })),
        XU(e, y, !0).then((v) => ({
          zoom: y,
          theme: "dark",
          url: URL.createObjectURL(v)
        }))
      ])
    );
    let g = !1;
    return h.then((y) => {
      g || (l(y), i(!0));
    }), () => {
      g = !0, i(!1), h.then((y) => {
        for (const { url: v } of y)
          URL.revokeObjectURL(v);
      });
    };
  }, [e, t]), { defs: /* @__PURE__ */ m.jsx(m.Fragment, { children: s.map((h) => {
    const g = c(h.zoom, h.theme);
    return /* @__PURE__ */ m.jsx(
      "pattern",
      {
        id: g,
        width: Px,
        height: Px,
        patternUnits: "userSpaceOnUse",
        children: /* @__PURE__ */ m.jsx("image", { href: h.url, width: Px, height: Px })
      },
      g
    );
  }) }), isReady: r };
}
function qSe() {
  const n = be(), e = M.useRef(null), { defs: t, isReady: r } = GSe();
  return M.useEffect(() => {
    if (r && Er.isSafari) {
      const i = BW(e.current);
      i && n.timers.requestAnimationFrame(() => {
        i.style.display = "none", n.timers.requestAnimationFrame(() => {
          i.style.display = "";
        });
      });
    }
  }, [n, r]), /* @__PURE__ */ m.jsx("g", { ref: e, "data-testid": r ? "ready-pattern-fill-defs" : void 0, children: t });
}
function BW(n) {
  return n.classList.contains("tl-html-layer") ? n : n.parentElement ? BW(n.parentElement) : null;
}
const us = Bt.memo(function({
  theme: e,
  d: t,
  color: r,
  fill: i,
  scale: s
}) {
  switch (i) {
    case "none":
      return null;
    case "solid":
      return /* @__PURE__ */ m.jsx("path", { fill: e[r].semi, d: t });
    case "semi":
      return /* @__PURE__ */ m.jsx("path", { fill: e.solid, d: t });
    case "fill":
      return /* @__PURE__ */ m.jsx("path", { fill: e[r].fill, d: t });
    case "pattern":
      return /* @__PURE__ */ m.jsx(YSe, { theme: e, color: r, fill: i, d: t, scale: s });
  }
});
function YSe({ d: n, color: e, theme: t }) {
  const r = be(), i = bw(), s = Pe("zoomLevel", () => r.getZoomLevel(), [r]), l = nL(), c = r.getZoomLevel() <= 0.18;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx("path", { fill: t[e].pattern, d: n }),
    /* @__PURE__ */ m.jsx(
      "path",
      {
        fill: i ? `url(#${l(1, t.id)})` : c ? t[e].semi : `url(#${l(s, t.id)})`,
        d: n
      }
    )
  ] });
}
function XSe(n) {
  return n.replace(/\s/g, " ");
}
function RD(n, e, t) {
  const { padding: r = 0 } = t;
  if (e.length === 0) return null;
  const i = Xe.From(e[0].box);
  for (const { box: h } of e)
    i.union(h);
  const s = r + (t.offsetX ?? 0), l = (t.offsetY ?? 0) + t.fontSize / 2 + (t.verticalTextAlign === "start" ? r : t.verticalTextAlign === "end" ? t.height - r - i.height : (Math.ceil(t.height) - i.height) / 2);
  let c = null;
  const d = [];
  for (const { text: h, box: g } of e)
    c !== null && g.y > c && d.push(
      /* @__PURE__ */ m.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: s,
          y: g.y + l,
          children: `
`
        },
        d.length
      )
    ), d.push(
      /* @__PURE__ */ m.jsx(
        "tspan",
        {
          alignmentBaseline: "mathematical",
          x: g.x + s,
          y: g.y + l,
          unicodeBidi: "plaintext",
          children: XSe(h)
        },
        d.length
      )
    ), c = g.y;
  return /* @__PURE__ */ m.jsx(
    "text",
    {
      fontSize: t.fontSize,
      fontFamily: t.fontFamily,
      fontStyle: t.fontStyle,
      fontWeight: t.fontWeight,
      dominantBaseline: "mathematical",
      alignmentBaseline: "mathematical",
      stroke: t.stroke,
      strokeWidth: t.strokeWidth,
      fill: t.fill,
      children: d
    }
  );
}
function ZSe(n, e, t, r) {
  if ((n === "start-legacy" || n === "end-legacy") && t.length !== 0) {
    const i = Xe.From(t[0].box);
    for (const { box: s } of t)
      i.union(s);
    if (n === "start-legacy")
      return (r - 2 * e - i.width) / 2;
    if (n === "end-legacy")
      return -(r - 2 * e - i.width) / 2;
  }
}
function QSe(n) {
  return n === "start-legacy" || n === "middle-legacy" || n === "end-legacy";
}
function U_({
  fontSize: n,
  font: e,
  align: t,
  verticalAlign: r,
  text: i,
  labelColor: s,
  bounds: l,
  padding: c = 16,
  stroke: d = !0
}) {
  const h = be(), g = Fl(), y = {
    fontSize: n,
    fontFamily: D6[e],
    textAlign: t,
    verticalTextAlign: r,
    width: Math.ceil(l.width),
    height: Math.ceil(l.height),
    padding: c,
    lineHeight: Ss.lineHeight,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "wrap",
    offsetX: 0,
    offsetY: 0,
    fill: s,
    stroke: void 0,
    strokeWidth: void 0
  }, v = h.textMeasure.measureTextSpans(i, y), w = ZSe(t, c, v, l.width);
  w && (y.offsetX = w), y.offsetX += l.x, y.offsetY += l.y;
  const C = RD(h, v, y);
  let E = null;
  return d && (y.fill = g.background, y.stroke = g.background, y.strokeWidth = 2, E = RD(h, v, y)), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    E,
    C
  ] });
}
const JSe = M.forwardRef(function({
  isEditing: e,
  text: t,
  handleFocus: r,
  handleChange: i,
  handleKeyDown: s,
  handleBlur: l,
  handleInputPointerDown: c,
  handleDoubleClick: d
}, h) {
  return /* @__PURE__ */ m.jsx(
    "textarea",
    {
      ref: h,
      className: "tl-text tl-text-input",
      name: "text",
      tabIndex: -1,
      readOnly: !e,
      autoComplete: "off",
      autoCapitalize: "off",
      autoCorrect: "off",
      autoSave: "off",
      placeholder: "",
      spellCheck: "true",
      wrap: "off",
      dir: "auto",
      defaultValue: t,
      onFocus: r,
      onChange: i,
      onKeyDown: s,
      onBlur: l,
      onTouchEnd: Ti,
      onContextMenu: e ? Ti : void 0,
      onPointerDown: c,
      onDoubleClick: d,
      onDragStart: wn
    }
  );
});
function exe(n, e, t) {
  const r = be(), i = M.useRef(null), s = Pe("isEditing", () => r.getEditingShapeId() === n, [r]), l = Pe("isEditingAnything", () => !!r.getEditingShapeId(), [
    r
  ]);
  M.useEffect(() => {
    function g(y) {
      var v;
      y.shapeId === n && ((v = i.current) == null || v.select());
    }
    return r.on("select-all-text", g), () => {
      r.off("select-all-text", g);
    };
  }, [r, n, s]), M.useEffect(() => {
    var g, y, v, w;
    s && (document.activeElement !== i.current && ((g = i.current) == null || g.focus()), r.getInstanceState().isCoarsePointer && ((y = i.current) == null || y.select()), Er.isSafari && ((v = i.current) == null || v.blur(), (w = i.current) == null || w.focus()));
  }, [r, s]);
  const c = M.useCallback(
    (g) => {
      if (r.getEditingShapeId() === n)
        switch (g.key) {
          case "Enter": {
            (g.ctrlKey || g.metaKey) && r.complete();
            break;
          }
        }
    },
    [r, n]
  ), d = M.useCallback(
    (g) => {
      if (r.getEditingShapeId() !== n) return;
      let y = Oy.normalizeText(g.currentTarget.value);
      const v = y.replace(/\t/g, by);
      if (v !== y) {
        const w = g.currentTarget.selectionStart;
        g.currentTarget.value = v, g.currentTarget.selectionStart = w + (v.length - y.length), g.currentTarget.selectionEnd = w + (v.length - y.length), y = v;
      }
      r.updateShape({
        id: n,
        type: e,
        props: { text: y }
      });
    },
    [r, n, e]
  ), h = M.useCallback(
    (g) => {
      r.dispatch({
        ...Xa(g),
        type: "pointer",
        name: "pointer_down",
        target: "shape",
        shape: r.getShape(n)
      }), Ti(g);
    },
    [r, n]
  );
  return {
    rInput: i,
    handleFocus: $x,
    handleBlur: $x,
    handleKeyDown: c,
    handleChange: d,
    handleInputPointerDown: h,
    handleDoubleClick: Ti,
    isEmpty: t.trim().length === 0,
    isEditing: s,
    isEditingAnything: l
  };
}
const $_ = Bt.memo(function({
  shapeId: e,
  type: t,
  text: r,
  labelColor: i,
  font: s,
  fontSize: l,
  lineHeight: c,
  align: d,
  verticalAlign: h,
  wrap: g,
  isSelected: y,
  padding: v = 0,
  onKeyDown: w,
  classNamePrefix: C,
  style: E,
  textWidth: P,
  textHeight: I
}) {
  const { rInput: k, isEmpty: L, isEditing: O, isEditingAnything: z, ...F } = exe(
    e,
    t,
    r
  ), [H, V] = M.useState(r);
  M.useEffect(() => {
    O || V(r);
  }, [O, r]);
  const re = Oy.normalizeTextForDom(r), q = re.length > 0, J = QSe(d);
  if (!O && !q)
    return null;
  const ie = C || "tl-text";
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      className: `${ie}-label tl-text-wrapper`,
      "data-font": s,
      "data-align": d,
      "data-hastext": !L,
      "data-isediting": O,
      "data-iseditinganything": z,
      "data-textwrap": !!g,
      "data-isselected": y,
      style: {
        justifyContent: d === "middle" || J ? "center" : d,
        alignItems: h === "middle" ? "center" : h,
        padding: v,
        ...E
      },
      children: /* @__PURE__ */ m.jsxs(
        "div",
        {
          className: `${ie}-label__inner tl-text-content__wrapper`,
          style: {
            fontSize: l,
            lineHeight: Math.floor(l * c) + "px",
            minHeight: Math.floor(l * c) + "px",
            minWidth: Math.ceil(P || 0),
            color: i,
            width: P ? Math.ceil(P) : void 0,
            height: I ? Math.ceil(I) : void 0
          },
          children: [
            /* @__PURE__ */ m.jsx("div", { className: `${ie} tl-text tl-text-content`, dir: "auto", children: re.split(`
`).map((W, Y) => /* @__PURE__ */ m.jsx("div", { dir: "auto", children: W }, Y)) }),
            (z || y) && /* @__PURE__ */ m.jsx(
              JSe,
              {
                ref: k,
                text: r,
                isEditing: O,
                ...F,
                handleKeyDown: w ?? F.handleKeyDown
              },
              H
            )
          ]
        }
      )
    }
  );
}), txe = new Cu();
function nxe(n) {
  return txe.get(n, () => n.store.createComputedCache("arrowLabelSize", (e) => {
    const t = xu(n, e);
    let r = 0, i = 0;
    const s = t.isStraight ? new Ld({
      start: R.From(t.start.point),
      end: R.From(t.end.point)
    }) : new Sy({
      center: R.Cast(t.handleArc.center),
      start: R.Cast(t.start.point),
      end: R.Cast(t.end.point),
      sweepFlag: t.bodyArc.sweepFlag,
      largeArcFlag: t.bodyArc.largeArcFlag
    });
    if (e.props.text.trim()) {
      const l = s.bounds, c = MD(e), { w: d, h } = n.textMeasure.measureText(e.props.text, {
        ...Ss,
        fontFamily: Kd[e.props.font],
        fontSize: c,
        maxWidth: null
      });
      r = d, i = h;
      let g = !1;
      if (l.width > l.height ? (r = Math.max(Math.min(d, 64), Math.min(l.width - 64, d)), g = !0) : r > 16 * c && (r = 16 * c, g = !0), g) {
        const { w: y, h: v } = n.textMeasure.measureText(
          e.props.text,
          {
            ...Ss,
            fontFamily: Kd[e.props.font],
            fontSize: c,
            maxWidth: r
          }
        );
        r = y, i = v;
      }
    }
    return new R(r, i).addScalar(Qj * 2 * e.props.scale);
  }));
}
function rL(n, e) {
  return e.props.text.trim() === "" ? new R(0, 0).addScalar(Qj * 2 * e.props.scale) : nxe(n).get(e.id) ?? new R(0, 0);
}
function HW(n) {
  const e = vs[n.props.size];
  return (uSe + (e - vs.s) * 2 + (e === vs.xl ? 20 : 0)) * n.props.scale;
}
function rxe(n, e, t) {
  const r = rL(n, e), i = HW(e), s = R.Nudge(t.start.point, t.end.point, i), l = R.Nudge(t.end.point, t.start.point, i), c = KO(
    s,
    l,
    Xe.FromCenter(t.middle, r).corners
  );
  if (!c || c.length !== 2)
    return { start: 0.5, end: 0.5 };
  let [d, h] = c;
  R.Dist2(d, s) > R.Dist2(h, s) && ([h, d] = c);
  const g = s.add(R.Sub(t.middle, d)), y = l.add(R.Sub(t.middle, h)), v = R.Dist(t.start.point, g) / t.length, w = R.Dist(t.start.point, y) / t.length;
  return { start: v, end: w };
}
function ixe(n, e, t) {
  const r = rL(n, e), i = HW(e), s = Math.sign(e.props.bend), l = i / t.handleArc.radius * s, c = R.Angle(t.bodyArc.center, t.start.point) - l, d = R.Angle(t.bodyArc.center, t.end.point) + l, h = tg(t.bodyArc.center, t.bodyArc.radius, c), g = tg(t.bodyArc.center, t.bodyArc.radius, d), y = [], v = JU(
    t.bodyArc.center,
    t.bodyArc.radius,
    c,
    d,
    s,
    Xe.FromCenter(h, r).corners
  );
  y.push(
    new Ci({
      points: Xe.FromCenter(h, r).corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    })
  );
  const w = JU(
    t.bodyArc.center,
    t.bodyArc.radius,
    c,
    d,
    s,
    Xe.FromCenter(g, r).corners
  );
  y.push(
    new Ci({
      points: Xe.FromCenter(g, r).corners,
      debugColor: "lime",
      isFilled: !1,
      ignore: !0
    })
  );
  for (const H of [
    ...v ?? [],
    ...w ?? [],
    h,
    g
  ])
    y.push(
      new oj({
        x: H.x - 3,
        y: H.y - 3,
        radius: 3,
        isFilled: !1,
        debugColor: "magenta",
        ignore: !0
      })
    );
  const C = (v && e$(t.start.point, v)) ?? t.middle, E = (w && e$(t.end.point, w)) ?? t.middle, P = R.Angle(t.bodyArc.center, t.start.point), I = R.Angle(t.bodyArc.center, t.end.point), k = R.Angle(t.bodyArc.center, C), L = R.Angle(t.bodyArc.center, E);
  if (oh(P, k, s) > oh(P, L, s))
    return { start: 0.5, end: 0.5, dbg: y };
  const O = oh(P, I, s), z = oh(P, k, s) / O, F = oh(P, L, s) / O;
  return { start: z, end: F, dbg: y };
}
function AC(n, e) {
  let t;
  const r = [], i = xu(n, e), s = {
    hasStartBinding: !!i.bindings.start,
    hasEndBinding: !!i.bindings.end,
    hasStartArrowhead: i.start.arrowhead !== "none",
    hasEndArrowhead: i.end.arrowhead !== "none"
  };
  if (i.isStraight) {
    const c = rxe(n, e, i), d = QU(n, e, c, s);
    t = R.Lrp(i.start.point, i.end.point, d);
  } else {
    const c = ixe(n, e, i);
    c.dbg && r.push(...c.dbg);
    const d = QU(n, e, c, s), h = oxe(
      R.Angle(i.bodyArc.center, i.start.point),
      R.Angle(i.bodyArc.center, i.end.point),
      Math.sign(e.props.bend),
      d
    );
    t = tg(i.bodyArc.center, i.bodyArc.radius, h);
  }
  const l = rL(n, e);
  return { box: Xe.FromCenter(t, l), debugGeom: r };
}
function QU(n, e, t, r) {
  const { hasEndArrowhead: i, hasEndBinding: s, hasStartBinding: l, hasStartArrowhead: c } = r, d = GW(n, e);
  let h = Do(
    e.props.labelPosition,
    c || l ? t.start : 0,
    i || s ? t.end : 1
  );
  const g = Math.min(0.02, 500 / d * 0.02);
  return h = h >= 0.5 - g && h <= 0.5 + g ? 0.5 : h, h;
}
function JU(n, e, t, r, i, s) {
  const l = ZA(n, e, s), c = oh(t, r, i);
  return l == null ? void 0 : l.filter((d) => {
    const h = oh(t, R.Angle(n, d), i);
    return h >= 0 && h <= c;
  });
}
function e$(n, e) {
  let t = null, r = -1 / 0;
  for (const i of e) {
    const s = R.Dist2(n, i);
    s > r && (t = i, r = s);
  }
  return t;
}
function oxe(n, e, t, r) {
  const i = oh(n, e, t);
  return n + i * r * t * -1;
}
function MD(n) {
  return cSe[n.props.size] * n.props.scale;
}
function sxe(n, e, t) {
  const r = e === "end" ? n.end.point : n.start.point, i = e === "end" ? n.start.point : n.end.point, s = n.isStraight ? R.Dist(i, r) : Math.abs(n.bodyArc.length), l = Math.max(Math.min(s / 5, t * 3), t);
  let c;
  if (n.isStraight)
    c = R.Nudge(r, i, l);
  else {
    const d = zle(r, l, n.handleArc.center, n.handleArc.radius);
    c = e === "end" ? n.handleArc.sweepFlag ? d[0] : d[1] : n.handleArc.sweepFlag ? d[1] : d[0];
  }
  return R.IsNaN(c) && (c = n.start.point), {
    point: r,
    int: c
  };
}
function axe({ point: n, int: e }) {
  const t = R.RotWith(e, n, Xn / 6), r = R.RotWith(e, n, -Xn / 6);
  return `M ${t.x} ${t.y} L ${n.x} ${n.y} L ${r.x} ${r.y}`;
}
function lxe({ point: n, int: e }) {
  const t = R.RotWith(e, n, Xn / 6), r = R.RotWith(e, n, -Xn / 6);
  return `M ${t.x} ${t.y} L ${r.x} ${r.y} L ${n.x} ${n.y} Z`;
}
function cxe({ point: n, int: e }) {
  const t = R.Sub(e, n).div(2), r = R.Add(n, R.Rot(t, Or)), i = R.Sub(n, R.Rot(t, Or));
  return `M ${r.x} ${r.y} L ${e.x} ${e.y} L ${i.x} ${i.y} Z`;
}
function uxe({ point: n, int: e }) {
  const t = R.Lrp(n, e, 0.45), r = R.Dist(t, n);
  return `M ${t.x - r},${t.y}
  a ${r},${r} 0 1,0 ${r * 2},0
  a ${r},${r} 0 1,0 -${r * 2},0 `;
}
function dxe({ point: n, int: e }) {
  const t = R.Lrp(n, e, 0.75), r = R.RotWith(t, n, Xn / 4), i = R.RotWith(t, n, -Xn / 4), s = R.Lrp(r, i, 0.5);
  return s.add(R.Sub(s, n)), `M ${s.x} ${s.y} L ${i.x} ${i.y} ${n.x} ${n.y} L ${r.x} ${r.y} Z`;
}
function fxe({ int: n, point: e }) {
  const t = R.Lrp(e, n, 0.85), r = R.Sub(t, e).div(2), i = R.Add(e, R.Rot(r, Or)), s = R.Sub(e, R.Rot(r, Or)), l = R.Add(t, R.Rot(r, Or)), c = R.Sub(t, R.Rot(r, Or));
  return `M ${i.x} ${i.y} L ${l.x} ${l.y} L ${c.x} ${c.y} L ${s.x} ${s.y} Z`;
}
function hxe({ int: n, point: e }) {
  const t = R.Sub(n, e).div(2), r = R.Add(e, R.Rot(t, Or)), i = R.Sub(e, R.Rot(t, Or));
  return `M ${r.x} ${r.y} L ${i.x} ${i.y}`;
}
function AE(n, e, t) {
  const r = e === "end" ? n.end.arrowhead : n.start.arrowhead;
  if (r === "none") return;
  const i = sxe(n, e, t);
  if (i) {
    switch (r) {
      case "bar":
        return hxe(i);
      case "square":
        return fxe(i);
      case "diamond":
        return dxe(i);
      case "dot":
        return uxe(i);
      case "inverted":
        return cxe(i);
      case "arrow":
        return axe(i);
      case "triangle":
        return lxe(i);
    }
    return "";
  }
}
function pxe(n) {
  const {
    start: e,
    end: t,
    handleArc: { radius: r, largeArcFlag: i, sweepFlag: s }
  } = n;
  return `M${e.handle.x},${e.handle.y} A${r} ${r} 0 ${i} ${s} ${t.handle.x},${t.handle.y}`;
}
function VW(n) {
  const {
    start: e,
    end: t,
    bodyArc: { radius: r, largeArcFlag: i, sweepFlag: s }
  } = n;
  return `M${e.point.x},${e.point.y} A${r} ${r} 0 ${i} ${s} ${t.point.x},${t.point.y}`;
}
function KW(n, e) {
  return `M${n.x},${n.y}L${e.x},${e.y}`;
}
function gxe(n) {
  return KW(n.start.handle, n.end.handle);
}
function WW(n) {
  return KW(n.start.point, n.end.point);
}
class DC extends Cc {
  constructor() {
    super(...arguments);
    U(this, "_resizeInitialBindings", new Cu());
  }
  canEdit() {
    return !0;
  }
  canBind({ toShapeType: t }) {
    return t !== "arrow";
  }
  canSnap() {
    return !1;
  }
  hideResizeHandles() {
    return !0;
  }
  hideRotateHandle() {
    return !0;
  }
  hideSelectionBoundsBg() {
    return !0;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  canBeLaidOut(t) {
    const r = wa(this.editor, t);
    return !r.start && !r.end;
  }
  getDefaultProps() {
    return {
      dash: "draw",
      size: "m",
      fill: "none",
      color: "black",
      labelColor: "black",
      bend: 0,
      start: { x: 0, y: 0 },
      end: { x: 2, y: 0 },
      arrowheadStart: "none",
      arrowheadEnd: "arrow",
      text: "",
      labelPosition: 0.5,
      font: "draw",
      scale: 1
    };
  }
  getGeometry(t) {
    const r = xu(this.editor, t), i = [], s = r.isStraight ? new Ld({
      start: R.From(r.start.point),
      end: R.From(r.end.point)
    }) : new Sy({
      center: R.Cast(r.handleArc.center),
      start: R.Cast(r.start.point),
      end: R.Cast(r.end.point),
      sweepFlag: r.bodyArc.sweepFlag,
      largeArcFlag: r.bodyArc.largeArcFlag
    });
    let l;
    if (t.props.text.trim()) {
      const c = AC(this.editor, t);
      i.push(...c.debugGeom), l = new Tu({
        x: c.box.x,
        y: c.box.y,
        width: c.box.w,
        height: c.box.h,
        isFilled: !0,
        isLabel: !0
      });
    }
    return new jl({
      children: [...l ? [s, l] : [s], ...i]
    });
  }
  getHandles(t) {
    const r = xu(this.editor, t);
    return [
      {
        id: "start",
        type: "vertex",
        index: "a0",
        x: r.start.handle.x,
        y: r.start.handle.y
      },
      {
        id: "middle",
        type: "virtual",
        index: "a2",
        x: r.middle.x,
        y: r.middle.y
      },
      {
        id: "end",
        type: "vertex",
        index: "a3",
        x: r.end.handle.x,
        y: r.end.handle.y
      }
    ].filter(Boolean);
  }
  getText(t) {
    return t.props.text;
  }
  onHandleDrag(t, { handle: r, isPrecise: i }) {
    const s = r.id, l = wa(this.editor, t);
    if (s === "middle") {
      const { start: F, end: H } = wy(this.editor, t, l), V = R.Sub(H, F), re = R.Per(V), q = R.Med(H, F), J = R.Sub(q, re), ie = R.Add(q, re), W = R.NearestPointOnLineSegment(J, ie, r, !1);
      let Y = R.Dist(W, q);
      return R.Clockwise(W, H, q) && (Y *= -1), { id: t.id, type: t.type, props: { bend: Y } };
    }
    const c = { id: t.id, type: "arrow", props: {} }, d = l[s], g = l[s === "start" ? "end" : "start"];
    if (this.editor.inputs.ctrlKey)
      return IC(this.editor, t, s), c.props[s] = {
        x: r.x,
        y: r.y
      }, c;
    const y = this.editor.getShapePageTransform(t.id).applyToPoint(r), v = this.editor.getShapeAtPoint(y, {
      hitInside: !0,
      hitFrameInside: !0,
      margin: 0,
      filter: (F) => !F.isLocked && this.editor.canBindShapes({ fromShape: t, toShape: F, binding: "arrow" })
    });
    if (!v) {
      IC(this.editor, t, s);
      const F = Ec(new R(r.x, r.y), this.editor);
      return c.props[s] = {
        x: F.x,
        y: F.y
      }, c;
    }
    const w = this.editor.getShapeGeometry(v), C = Xe.ZeroFix(w.bounds), P = this.editor.getShapePageTransform(c.id).applyToPoint(r), I = this.editor.getPointInShapeSpace(v, P);
    let k = i;
    k || (!d || d && v.id !== d.toId) && (k = this.editor.inputs.pointerVelocity.len() < 0.5), i || (w.isClosed || (k = !0), g && v.id === g.toId && g.props.isPrecise && (k = !0));
    const L = {
      x: (I.x - C.minX) / C.width,
      y: (I.y - C.minY) / C.height
    };
    k && R.Dist(I, C.center) < Math.max(4, Math.min(Math.min(C.width, C.height) * 0.15, 16)) / this.editor.getZoomLevel() && (L.x = 0.5, L.y = 0.5);
    const O = {
      terminal: s,
      normalizedAnchor: L,
      isPrecise: k,
      isExact: this.editor.inputs.altKey
    };
    fx(this.editor, t, v.id, O), this.editor.setHintingShapes([v.id]);
    const z = wa(this.editor, t);
    return z.start && z.end && z.start.toId === z.end.toId && R.Equals(z.start.props.normalizedAnchor, z.end.props.normalizedAnchor) && fx(this.editor, t, z.end.toId, {
      ...z.end.props,
      normalizedAnchor: {
        x: z.end.props.normalizedAnchor.x + 0.05,
        y: z.end.props.normalizedAnchor.y
      }
    }), c;
  }
  onTranslateStart(t) {
    const r = wa(this.editor, t), i = wy(this.editor, t, r), s = this.editor.getShapePageTransform(t.id), l = this.editor.getSelectedShapeIds();
    if (!(r.start && (l.includes(r.start.toId) || this.editor.isAncestorSelected(r.start.toId)) || r.end && (l.includes(r.end.toId) || this.editor.isAncestorSelected(r.end.toId)))) {
      n$.set(t, {
        pagePosition: s.applyToPoint(t),
        terminalBindings: lw(i, (c, d) => {
          const h = r[c];
          return h ? {
            binding: h,
            shapePosition: d,
            pagePosition: s.applyToPoint(d)
          } : null;
        })
      }), r.start && (ME({
        editor: this.editor,
        arrow: t,
        terminal: "start",
        useHandle: !0
      }), t = this.editor.getShape(t.id)), r.end && ME({
        editor: this.editor,
        arrow: t,
        terminal: "end",
        useHandle: !0
      });
      for (const c of [
        "start",
        "end"
        /* END */
      ]) {
        const d = r[c];
        d && this.editor.updateBinding({
          ...d,
          props: { ...d.props, isPrecise: !0 }
        });
      }
    }
  }
  onTranslate(t, r) {
    const i = n$.get(t);
    if (!i) return;
    const s = this.editor.getShapePageTransform(r.id), l = R.Sub(
      s.applyToPoint(r),
      i.pagePosition
    );
    for (const c of Object.values(i.terminalBindings)) {
      if (!c) continue;
      const d = R.Add(c.pagePosition, R.Mul(l, 0.5)), h = this.editor.getShapeAtPoint(d, {
        hitInside: !0,
        hitFrameInside: !0,
        margin: 0,
        filter: (g) => !g.isLocked && this.editor.canBindShapes({ fromShape: r, toShape: g, binding: "arrow" })
      });
      if ((h == null ? void 0 : h.id) === c.binding.toId) {
        const g = Xe.ZeroFix(this.editor.getShapeGeometry(h).bounds), y = this.editor.getPointInShapeSpace(h, d), v = {
          x: (y.x - g.minX) / g.width,
          y: (y.y - g.minY) / g.height
        };
        fx(this.editor, r, h.id, {
          ...c.binding.props,
          normalizedAnchor: v,
          isPrecise: !0
        });
      } else
        IC(this.editor, r, c.binding.props.terminal);
    }
  }
  onResize(t, r) {
    const { scaleX: i, scaleY: s } = r, l = this._resizeInitialBindings.get(
      t,
      () => wa(this.editor, t)
    ), c = wy(this.editor, t, l), { start: d, end: h } = $r(t.props);
    let { bend: g } = t.props;
    l.start || (d.x = c.start.x * i, d.y = c.start.y * s), l.end || (h.x = c.end.x * i, h.y = c.end.y * s);
    const y = Math.abs(i), v = Math.abs(s), w = l != null && l.start ? R.From(l.start.props.normalizedAnchor) : null, C = l != null && l.end ? R.From(l.end.props.normalizedAnchor) : null;
    return i < 0 && s >= 0 ? (g !== 0 && (g *= -1, g *= Math.max(y, v)), w && (w.x = 1 - w.x), C && (C.x = 1 - C.x)) : i >= 0 && s < 0 ? (g !== 0 && (g *= -1, g *= Math.max(y, v)), w && (w.y = 1 - w.y), C && (C.y = 1 - C.y)) : i >= 0 && s >= 0 ? g !== 0 && (g *= Math.max(y, v)) : i < 0 && s < 0 && (g !== 0 && (g *= Math.max(y, v)), w && (w.x = 1 - w.x, w.y = 1 - w.y), C && (C.x = 1 - C.x, C.y = 1 - C.y)), l.start && w && fx(this.editor, t, l.start.toId, {
      ...l.start.props,
      normalizedAnchor: w.toJson()
    }), l.end && C && fx(this.editor, t, l.end.toId, {
      ...l.end.props,
      normalizedAnchor: C.toJson()
    }), {
      props: {
        start: d,
        end: h,
        bend: g
      }
    };
  }
  onDoubleClickHandle(t, r) {
    switch (r.id) {
      case "start":
        return {
          id: t.id,
          type: t.type,
          props: {
            ...t.props,
            arrowheadStart: t.props.arrowheadStart === "none" ? "arrow" : "none"
          }
        };
      case "end":
        return {
          id: t.id,
          type: t.type,
          props: {
            ...t.props,
            arrowheadEnd: t.props.arrowheadEnd === "none" ? "arrow" : "none"
          }
        };
    }
  }
  component(t) {
    const r = Fl(), i = this.editor.getOnlySelectedShape(), s = this.editor.isInAny(
      "select.idle",
      "select.pointing_handle",
      "select.dragging_handle",
      "select.translating",
      "arrow.dragging"
    ) && !this.editor.getIsReadonly(), l = xu(this.editor, t);
    if (!(l != null && l.isValid)) return null;
    const c = AC(this.editor, t), d = t.id === this.editor.getOnlySelectedShapeId(), g = this.editor.getEditingShapeId() === t.id || t.props.text;
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(mh, { style: { minWidth: 50, minHeight: 50 }, children: /* @__PURE__ */ m.jsx(
        t$,
        {
          shape: t,
          shouldDisplayHandles: s && (i == null ? void 0 : i.id) === t.id
        }
      ) }),
      g && /* @__PURE__ */ m.jsx(
        $_,
        {
          shapeId: t.id,
          classNamePrefix: "tl-arrow",
          type: "arrow",
          font: t.props.font,
          fontSize: MD(t),
          lineHeight: Ss.lineHeight,
          align: "middle",
          verticalAlign: "middle",
          text: t.props.text,
          labelColor: r[t.props.labelColor].solid,
          textWidth: c.box.w - Qj * 2 * t.props.scale,
          isSelected: d,
          padding: 0,
          style: {
            transform: `translate(${c.box.center.x}px, ${c.box.center.y}px)`
          }
        }
      )
    ] });
  }
  indicator(t) {
    const r = p_(t.id), i = bc(t.id + "_clip"), s = xu(this.editor, t);
    if (!s) return null;
    const { start: l, end: c } = wy(this.editor, t, s == null ? void 0 : s.bindings), d = this.editor.getShapeGeometry(t), h = d.bounds, g = t.props.text.trim() ? d.children[1] : null;
    if (R.Equals(l, c)) return null;
    const y = vs[t.props.size] * t.props.scale, v = s.start.arrowhead && AE(s, "start", y), w = s.end.arrowhead && AE(s, "end", y), C = s.isStraight ? WW(s) : VW(s), E = v && s.start.arrowhead !== "arrow" || w && s.end.arrowhead !== "arrow" || !!g;
    if (r && g)
      return /* @__PURE__ */ m.jsx(
        "rect",
        {
          x: Se(g.x),
          y: Se(g.y),
          width: g.w,
          height: g.h,
          rx: 3.5 * t.props.scale,
          ry: 3.5 * t.props.scale
        }
      );
    const P = !(s.start.arrowhead === "none" || s.start.arrowhead === "arrow"), I = !(s.end.arrowhead === "none" || s.end.arrowhead === "arrow");
    return /* @__PURE__ */ m.jsxs("g", { children: [
      E && /* @__PURE__ */ m.jsx("defs", { children: /* @__PURE__ */ m.jsx(
        qW,
        {
          hasText: t.props.text.trim().length > 0,
          bounds: h,
          labelBounds: g ? g.getBounds() : new Xe(0, 0, 0, 0),
          as: P && v ? v : "",
          ae: I && w ? w : ""
        }
      ) }),
      /* @__PURE__ */ m.jsxs(
        "g",
        {
          style: {
            clipPath: E ? `url(#${i})` : void 0,
            WebkitClipPath: E ? `url(#${i})` : void 0
          },
          children: [
            E && /* @__PURE__ */ m.jsx(
              "rect",
              {
                x: h.minX - 100,
                y: h.minY - 100,
                width: h.width + 200,
                height: h.height + 200,
                opacity: 0
              }
            ),
            /* @__PURE__ */ m.jsx("path", { d: C })
          ]
        }
      ),
      v && /* @__PURE__ */ m.jsx("path", { d: v }),
      w && /* @__PURE__ */ m.jsx("path", { d: w }),
      g && /* @__PURE__ */ m.jsx(
        "rect",
        {
          x: Se(g.x),
          y: Se(g.y),
          width: g.w,
          height: g.h,
          rx: 3.5,
          ry: 3.5
        }
      )
    ] });
  }
  onEditEnd(t) {
    const {
      id: r,
      type: i,
      props: { text: s }
    } = t;
    s.trimEnd() !== t.props.text && this.editor.updateShapes([
      {
        id: r,
        type: i,
        props: {
          text: s.trimEnd()
        }
      }
    ]);
  }
  toSvg(t, r) {
    r.addExportDef(eL(t.props.fill)), t.props.text && r.addExportDef(z_(t.props.font));
    const i = Wd(r), s = 1 / t.props.scale;
    return /* @__PURE__ */ m.jsxs("g", { transform: `scale(${s})`, children: [
      /* @__PURE__ */ m.jsx(t$, { shape: t, shouldDisplayHandles: !1 }),
      /* @__PURE__ */ m.jsx(
        U_,
        {
          fontSize: MD(t),
          font: t.props.font,
          align: "middle",
          verticalAlign: "middle",
          text: t.props.text,
          labelColor: i[t.props.labelColor].solid,
          bounds: AC(this.editor, t).box.clone().expandBy(-4.25 * t.props.scale),
          padding: 0
        }
      )
    ] });
  }
  getCanvasSvgDefs() {
    return [
      tL(),
      {
        key: "arrow:dot",
        component: mxe
      },
      {
        key: "arrow:cross",
        component: yxe
      }
    ];
  }
  getInterpolatedProps(t, r, i) {
    return {
      ...i > 0.5 ? r.props : t.props,
      scale: jn(t.props.scale, r.props.scale, i),
      start: {
        x: jn(t.props.start.x, r.props.start.x, i),
        y: jn(t.props.start.y, r.props.start.y, i)
      },
      end: {
        x: jn(t.props.end.x, r.props.end.x, i),
        y: jn(t.props.end.y, r.props.end.y, i)
      },
      bend: jn(t.props.bend, r.props.bend, i),
      labelPosition: jn(t.props.labelPosition, r.props.labelPosition, i)
    };
  }
}
U(DC, "type", "arrow"), U(DC, "props", j6), U(DC, "migrations", L6);
function GW(n, e) {
  const t = xu(n, e);
  return t.isStraight ? R.Dist(t.start.handle, t.end.handle) : Math.abs(t.handleArc.length);
}
const t$ = Ho(function({
  shape: e,
  shouldDisplayHandles: t
}) {
  const r = be(), i = Fl(), s = xu(r, e), l = Xe.ZeroFix(r.getShapeGeometry(e).bounds), c = wa(r, e), d = Pe(
    "force solid",
    () => r.getZoomLevel() < 0.2,
    [r]
  ), h = bc(e.id + "_clip"), g = bc("arrowhead-dot"), y = bc("arrowhead-cross");
  if (!(s != null && s.isValid)) return null;
  const v = vs[e.props.size] * e.props.scale, w = s.start.arrowhead && AE(s, "start", v), C = s.end.arrowhead && AE(s, "end", v), E = s.isStraight ? WW(s) : VW(s);
  let P = null;
  if (t) {
    const F = 2 / r.getZoomLevel(), { strokeDasharray: H, strokeDashoffset: V } = mc(
      GW(r, e),
      F,
      {
        end: "skip",
        start: "skip",
        lengthRatio: 2.5
      }
    );
    P = c.start || c.end ? /* @__PURE__ */ m.jsx(
      "path",
      {
        className: "tl-arrow-hint",
        d: s.isStraight ? gxe(s) : pxe(s),
        strokeDasharray: H,
        strokeDashoffset: V,
        strokeWidth: F,
        markerStart: c.start ? c.start.props.isExact ? "" : c.start.props.isPrecise ? `url(#${y})` : `url(#${g})` : "",
        markerEnd: c.end ? c.end.props.isExact ? "" : c.end.props.isPrecise ? `url(#${y})` : `url(#${g})` : "",
        opacity: 0.16
      }
    ) : null;
  }
  const { strokeDasharray: I, strokeDashoffset: k } = mc(
    s.isStraight ? s.length : Math.abs(s.bodyArc.length),
    v,
    {
      style: e.props.dash,
      forceSolid: d
    }
  ), L = AC(r, e), O = !(s.start.arrowhead === "none" || s.start.arrowhead === "arrow"), z = !(s.end.arrowhead === "none" || s.end.arrowhead === "arrow");
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx("defs", { children: /* @__PURE__ */ m.jsx("clipPath", { id: h, children: /* @__PURE__ */ m.jsx(
      qW,
      {
        hasText: e.props.text.trim().length > 0,
        bounds: l,
        labelBounds: L.box,
        as: O && w ? w : "",
        ae: z && C ? C : ""
      }
    ) }) }),
    /* @__PURE__ */ m.jsxs(
      "g",
      {
        fill: "none",
        stroke: i[e.props.color].solid,
        strokeWidth: v,
        strokeLinejoin: "round",
        strokeLinecap: "round",
        pointerEvents: "none",
        children: [
          P,
          /* @__PURE__ */ m.jsxs(
            "g",
            {
              style: {
                clipPath: `url(#${h})`,
                WebkitClipPath: `url(#${h})`
              },
              children: [
                /* @__PURE__ */ m.jsx(
                  "rect",
                  {
                    x: Se(l.minX - 100),
                    y: Se(l.minY - 100),
                    width: Se(l.width + 200),
                    height: Se(l.height + 200),
                    opacity: 0
                  }
                ),
                /* @__PURE__ */ m.jsx("path", { d: E, strokeDasharray: I, strokeDashoffset: k })
              ]
            }
          ),
          w && O && e.props.fill !== "none" && /* @__PURE__ */ m.jsx(
            us,
            {
              theme: i,
              d: w,
              color: e.props.color,
              fill: e.props.fill,
              scale: e.props.scale
            }
          ),
          C && z && e.props.fill !== "none" && /* @__PURE__ */ m.jsx(
            us,
            {
              theme: i,
              d: C,
              color: e.props.color,
              fill: e.props.fill,
              scale: e.props.scale
            }
          ),
          w && /* @__PURE__ */ m.jsx("path", { d: w }),
          C && /* @__PURE__ */ m.jsx("path", { d: C })
        ]
      }
    )
  ] });
});
function qW({
  hasText: n,
  bounds: e,
  labelBounds: t,
  as: r,
  ae: i
}) {
  const s = `M${Se(e.minX - 100)},${Se(e.minY - 100)} h${e.width + 200} v${e.height + 200} h-${e.width + 200} Z`, l = `M${Se(t.minX)},${Se(t.minY)} v${t.height} h${t.width} v-${t.height} Z`;
  return /* @__PURE__ */ m.jsx("path", { d: `${s}${n ? l : ""}${r}${i}` });
}
const n$ = /* @__PURE__ */ new WeakMap();
function mxe() {
  const n = bc("arrowhead-dot");
  return /* @__PURE__ */ m.jsx("marker", { id: n, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "0", children: /* @__PURE__ */ m.jsx("circle", { cx: "3", cy: "3", r: "2", strokeDasharray: "100%" }) });
}
function yxe() {
  const n = bc("arrowhead-cross");
  return /* @__PURE__ */ m.jsxs("marker", { id: n, className: "tl-arrow-hint", refX: "3.0", refY: "3.0", orient: "auto", children: [
    /* @__PURE__ */ m.jsx("line", { x1: "1.5", y1: "1.5", x2: "4.5", y2: "4.5", strokeDasharray: "100%" }),
    /* @__PURE__ */ m.jsx("line", { x1: "1.5", y1: "4.5", x2: "4.5", y2: "1.5", strokeDasharray: "100%" })
  ] });
}
const r$ = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E";
function jy({ url: n }) {
  const e = be(), t = Pe("zoomLevel", () => e.getZoomLevel() < 0.32, [e]);
  return /* @__PURE__ */ m.jsx(
    "a",
    {
      className: It("tl-hyperlink-button", {
        "tl-hyperlink-button__hidden": t
      }),
      href: n,
      target: "_blank",
      rel: "noopener noreferrer",
      onPointerDown: Ti,
      onPointerUp: Ti,
      title: n,
      draggable: !1,
      children: /* @__PURE__ */ m.jsx(
        "div",
        {
          className: "tl-hyperlink__icon",
          style: {
            mask: `url("${r$}") center 100% / 100% no-repeat`,
            WebkitMask: `url("${r$}") center 100% / 100% no-repeat`
          }
        }
      )
    }
  );
}
const i$ = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='30' height='30' fill='none'%3E%3Cpath stroke='%23000' stroke-linecap='round' stroke-linejoin='round' stroke-width='2' d='M13 5H7a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6M19 5h6m0 0v6m0-6L13 17'/%3E%3C/svg%3E", vxe = [
  {
    offsetX: 0,
    offsetY: 2,
    blur: 4,
    spread: 0,
    color: "#00000029"
  },
  {
    offsetX: 0,
    offsetY: 3,
    blur: 6,
    spread: 0,
    color: "#0000001f"
  }
];
function DE(n) {
  return vxe.map((t) => {
    const { offsetX: r, offsetY: i, blur: s, spread: l, color: c } = t, d = new R(r, i), { x: h, y: g } = d.rot(-n);
    return `${h}px ${g}px ${s}px ${l}px ${c}`;
  }).join(", ");
}
const Sxe = 300, YW = 320, xxe = 46, wxe = 101;
class OC extends Xy {
  canResize() {
    return !1;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  getText(e) {
    return e.props.url;
  }
  getDefaultProps() {
    return {
      url: "",
      w: Sxe,
      h: YW,
      assetId: null
    };
  }
  component(e) {
    return /* @__PURE__ */ m.jsx(bxe, { shape: e, util: this });
  }
  indicator(e) {
    return /* @__PURE__ */ m.jsx(
      "rect",
      {
        width: Se(e.props.w),
        height: Se(e.props.h),
        rx: "6",
        ry: "6"
      }
    );
  }
  onBeforeCreate(e) {
    return o$(this.editor, e);
  }
  onBeforeUpdate(e, t) {
    if (e.props.url !== t.props.url)
      if (tl.isValid(t.props.url))
        Exe(this.editor, t);
      else
        return { ...t, props: { ...t.props, url: e.props.url } };
    if (e.props.assetId !== t.props.assetId)
      return o$(this.editor, t);
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r)
    };
  }
}
U(OC, "type", "bookmark"), U(OC, "props", B6), U(OC, "migrations", H6);
function bxe({
  shape: n,
  util: e
}) {
  const t = n.props.assetId ? e.editor.getAsset(n.props.assetId) : null, r = !!bw() && Er.isSafari, i = e.editor.getShapePageTransform(n).rotation(), s = Cxe(n), [l, c] = M.useState(!0), d = () => c(!1);
  return /* @__PURE__ */ m.jsx(hh, { children: /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: It(
        "tl-bookmark__container",
        r && "tl-bookmark__container--safariExport"
      ),
      style: {
        boxShadow: r ? void 0 : DE(i),
        maxHeight: n.props.h
      },
      children: [
        (!t || t.props.image) && /* @__PURE__ */ m.jsxs("div", { className: "tl-bookmark__image_container", children: [
          t ? /* @__PURE__ */ m.jsx(
            "img",
            {
              className: "tl-bookmark__image",
              draggable: !1,
              referrerPolicy: "strict-origin-when-cross-origin",
              src: t == null ? void 0 : t.props.image,
              alt: (t == null ? void 0 : t.props.title) || ""
            }
          ) : /* @__PURE__ */ m.jsx("div", { className: "tl-bookmark__placeholder" }),
          (t == null ? void 0 : t.props.image) && /* @__PURE__ */ m.jsx(jy, { url: n.props.url })
        ] }),
        /* @__PURE__ */ m.jsxs("div", { className: "tl-bookmark__copy_container", children: [
          t != null && t.props.title ? /* @__PURE__ */ m.jsx("h2", { className: "tl-bookmark__heading", children: mSe(t.props.title) }) : null,
          t != null && t.props.description && (t != null && t.props.image) ? /* @__PURE__ */ m.jsx("p", { className: "tl-bookmark__description", children: t.props.description }) : null,
          /* @__PURE__ */ m.jsxs(
            "a",
            {
              className: "tl-bookmark__link",
              href: n.props.url || "",
              target: "_blank",
              rel: "noopener noreferrer",
              onPointerDown: Ti,
              onPointerUp: Ti,
              onClick: Ti,
              children: [
                l && (t != null && t.props.favicon) ? /* @__PURE__ */ m.jsx(
                  "img",
                  {
                    className: "tl-bookmark__favicon",
                    src: t == null ? void 0 : t.props.favicon,
                    referrerPolicy: "strict-origin-when-cross-origin",
                    onError: d,
                    alt: `favicon of ${s}`
                  }
                ) : /* @__PURE__ */ m.jsx(
                  "div",
                  {
                    className: "tl-hyperlink__icon",
                    style: {
                      mask: `url("${i$}") center 100% / 100% no-repeat`,
                      WebkitMask: `url("${i$}") center 100% / 100% no-repeat`
                    }
                  }
                ),
                /* @__PURE__ */ m.jsx("span", { children: s })
              ]
            }
          )
        ] })
      ]
    }
  ) });
}
function o$(n, e) {
  const t = e.props.assetId ? n.getAsset(e.props.assetId) : null;
  let r = YW;
  return t && (t.props.image || (t.props.title ? r = wxe : r = xxe)), {
    ...e,
    props: {
      ...e.props,
      h: r
    }
  };
}
const Cxe = (n) => {
  try {
    return new URL(n.props.url).hostname.replace(/^www\./, "");
  } catch {
    return n.props.url;
  }
};
function Exe(n, e) {
  const { url: t } = e.props, r = ih.createId(AA(t));
  n.getAsset(r) ? e.props.assetId !== r && n.updateShapes([
    {
      id: e.id,
      type: e.type,
      props: { assetId: r }
    }
  ]) : (n.updateShapes([
    {
      id: e.id,
      type: e.type,
      props: { assetId: null }
    }
  ]), _xe(n, e));
}
const _xe = LE(async (n, e) => {
  if (n.isDisposed) return;
  const { url: t } = e.props, r = await n.getAssetForExternalContent({ type: "url", url: t });
  r && n.run(() => {
    n.createAssets([r]), n.updateShapes([
      {
        id: e.id,
        type: e.type,
        props: { assetId: r.id }
      }
    ]);
  });
}, 500);
function lg(n, e = !1) {
  const t = n.length;
  if (t < 2)
    return "";
  let r = n[0].point, i = n[1].point;
  if (t === 2)
    return `M${Yn(r)}L${Yn(i)}`;
  let s = "";
  for (let l = 2, c = t - 1; l < c; l++)
    r = n[l].point, i = n[l + 1].point, s += xa(r, i);
  return e ? `M${xa(n[0].point, n[1].point)}Q${Yn(n[1].point)}${xa(
    n[1].point,
    n[2].point
  )}T${s}${xa(n[t - 1].point, n[0].point)}${xa(
    n[0].point,
    n[1].point
  )}Z` : `M${Yn(n[0].point)}Q${Yn(n[1].point)}${xa(
    n[1].point,
    n[2].point
  )}${n.length > 3 ? "T" : ""}${s}L${Yn(n[t - 1].point)}`;
}
function Pxe(n, e = {}) {
  const { start: t = {}, end: r = {} } = e, { cap: i = !0 } = t, { cap: s = !0 } = r;
  on(!t.taper && !r.taper, "cap taper not supported here"), on(!t.easing && !r.easing, "cap easing not supported here"), on(i && s, "cap must be true");
  const l = Ru(n, e);
  N_(l, e);
  const c = Txe(l);
  let d = "";
  for (const h of c)
    d += kxe(h, e);
  return d;
}
function Txe(n) {
  if (n.length <= 2) return [n];
  const e = [];
  let t = [n[0]], r = R.Sub(n[1].point, n[0].point).uni(), i, s, l, c, d;
  for (let h = 1, g = n.length; h < g - 1; h++) {
    if (l = n[h - 1], c = n[h], d = n[h + 1], i = R.Sub(d.point, c.point).uni(), s = R.Dpr(r, i), r = i, s < -0.8) {
      const y = {
        ...c,
        point: c.input
      };
      t.push(y), e.push(nA(t)), t = [y];
      continue;
    }
    if (t.push(c), !(s > 0.7) && (R.Dist2(l.point, c.point) + R.Dist2(c.point, d.point)) / ((l.radius + c.radius + d.radius) / 3) ** 2 < 1.5) {
      t.push(c), e.push(nA(t)), t = [c];
      continue;
    }
  }
  return t.push(n[n.length - 1]), e.push(nA(t)), e;
}
function nA(n) {
  const e = n[0];
  let t;
  for (; n.length > 2 && (t = n[1], R.Dist2(e.point, t.point) < ((e.radius + t.radius) / 2 * 0.5) ** 2); )
    n.splice(1, 1);
  const r = n[n.length - 1];
  let i;
  for (; n.length > 2 && (i = n[n.length - 2], R.Dist2(r.point, i.point) < ((r.radius + i.radius) / 2 * 0.5) ** 2); )
    n.splice(n.length - 2, 1);
  return n.length > 1 && (n[0] = {
    ...n[0],
    vector: R.Sub(n[0].point, n[1].point).uni()
  }, n[n.length - 1] = {
    ...n[n.length - 1],
    vector: R.Sub(
      n[n.length - 2].point,
      n[n.length - 1].point
    ).uni()
  }), n;
}
function Ixe(n, e, t) {
  return "M " + n + " " + e + " m -" + t + ", 0 a " + t + "," + t + " 0 1,1 " + t * 2 + ",0 a " + t + "," + t + " 0 1,1 -" + t * 2 + ",0";
}
function kxe(n, e = {}) {
  if (n.length === 0) return "";
  if (n.length === 1)
    return Ixe(n[0].point.x, n[0].point.y, n[0].radius);
  const { left: t, right: r } = kW(n, e);
  r.reverse();
  let i = `M${Yn(t[0])}T`;
  for (let s = 1; s < t.length; s++)
    i += xa(t[s - 1], t[s]);
  {
    const s = n[n.length - 1], l = s.radius, c = s.vector.clone().per().neg(), d = R.Add(s.point, R.Mul(c, l)), h = R.Add(s.point, R.Mul(c, -l));
    i += `${Yn(d)}A${Se(l)},${Se(
      l
    )} 0 0 1 ${Yn(h)}T`;
  }
  for (let s = 1; s < r.length; s++)
    i += xa(r[s - 1], r[s]);
  {
    const s = n[0], l = s.radius, c = s.vector.clone().per(), d = R.Add(s.point, R.Mul(c, l)), h = R.Add(s.point, R.Mul(c, -l));
    i += `${Yn(d)}A${Se(l)},${Se(
      l
    )} 0 0 1 ${Yn(h)}Z`;
  }
  return i;
}
const XW = (n, e, t) => {
  const r = [], i = [];
  n.forEach((h) => r.push(...h.points)), e.forEach((h) => i.push(...h.points));
  const s = Math.max(r.length, i.length), l = [], c = [];
  for (let h = 0; h < s; h++)
    l.push(r[h] || r[r.length - 1]), c.push(i[h] || i[i.length - 1]);
  return [
    {
      type: "free",
      points: l.map((h, g) => {
        let y = 0.5;
        return c[g].z !== void 0 && h.z !== void 0 && (y = jn(h.z, c[g].z, t)), {
          x: jn(h.x, c[g].x, t),
          y: jn(h.y, c[g].y, t),
          z: y
        };
      })
    }
  ];
}, Rxe = (n) => n * 0.65 + rse(n * Xn / 2) * 0.35, Mxe = (n) => ({
  size: n,
  thinning: 0.5,
  streamline: Ry(n, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  easing: po.easeOutSine,
  simulatePressure: !0
}), Axe = (n) => ({
  size: 1 + n * 1.2,
  thinning: 0.62,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: Rxe
}), s$ = (n) => ({
  size: n,
  thinning: 0,
  streamline: Ry(n, [9, 16], [0.64, 0.74], !0),
  // 0.62 + ((1 + strokeWidth) / 8) * 0.06,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: po.linear
}), Dxe = (n) => ({
  size: n,
  thinning: 0,
  streamline: 0.62,
  smoothing: 0.62,
  simulatePressure: !1,
  easing: po.linear
});
function iL({
  strokeWidth: n,
  showAsComplete: e
}) {
  return {
    size: 1 + n,
    thinning: 0,
    streamline: 0.5,
    smoothing: 0.5,
    simulatePressure: !1,
    easing: po.easeOutSine,
    last: e
  };
}
function AD(n, e, t, r) {
  const i = n.isComplete || t;
  return r ? n.isPen ? { ...Dxe(e), last: i } : { ...s$(e), last: i } : n.dash === "draw" ? n.isPen ? { ...Axe(e), last: i } : { ...Mxe(e), last: i } : { ...s$(e), last: i };
}
function Ly(n) {
  const e = [];
  for (const t of n)
    if (t.type === "free" || t.points.length < 2)
      e.push(...t.points.map(R.Cast));
    else {
      const r = Math.max(
        4,
        Math.floor(R.Dist(t.points[0], t.points[1]) / 16)
      );
      e.push(...R.PointsBetween(t.points[0], t.points[1], r));
    }
  return e;
}
function Oxe(n, e, t) {
  return {
    draw: "none",
    solid: "none",
    dotted: `${t} ${e * 2}`,
    dashed: `${e * 2} ${e * 2}`
  }[n.props.dash];
}
class jC extends Cc {
  hideResizeHandles(e) {
    return rA(e);
  }
  hideRotateHandle(e) {
    return rA(e);
  }
  hideSelectionBoundsFg(e) {
    return rA(e);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      isComplete: !1,
      isClosed: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(e) {
    const t = Ly(e.props.segments), r = (vs[e.props.size] + 1) * e.props.scale;
    if (e.props.segments.length === 1) {
      const s = Xe.FromPoints(t);
      if (s.width < r * 2 && s.height < r * 2)
        return new oj({
          x: -r,
          y: -r,
          radius: r,
          isFilled: !0
        });
    }
    const i = Ru(
      t,
      AD(e.props, r, e.props.isPen, !0)
    ).map((s) => s.point);
    return e.props.isClosed ? new Ci({
      points: i,
      isFilled: e.props.fill !== "none"
    }) : new Wy({
      points: i
    });
  }
  component(e) {
    return /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(a$, { shape: e }) });
  }
  indicator(e) {
    var g;
    const t = Ly(e.props.segments);
    let r = (vs[e.props.size] + 1) * e.props.scale;
    const i = this.editor.getZoomLevel();
    !(i < 0.5 && i < 1.5 / r) && !e.props.isPen && e.props.dash === "draw" && t.length === 1 && (r += Tc(e.id)() * (r / 6));
    const l = e.props.isComplete || ((g = jo(e.props.segments)) == null ? void 0 : g.type) === "straight", c = AD(e.props, r, l, !0), d = Ru(t, c), h = d.length > 1 ? lg(d, e.props.isClosed) : ZW(t[0], r);
    return /* @__PURE__ */ m.jsx("path", { d: h });
  }
  toSvg(e, t) {
    t.addExportDef(eL(e.props.fill));
    const r = 1 / e.props.scale;
    return /* @__PURE__ */ m.jsx("g", { transform: `scale(${r})`, children: /* @__PURE__ */ m.jsx(a$, { shape: e, zoomOverride: 1 }) });
  }
  getCanvasSvgDefs() {
    return [tL()];
  }
  onResize(e, t) {
    const { scaleX: r, scaleY: i } = t, s = [];
    for (const l of e.props.segments)
      s.push({
        ...l,
        points: l.points.map(({ x: c, y: d, z: h }) => ({
          x: jd(r * c),
          y: jd(i * d),
          z: h
        }))
      });
    return {
      props: {
        segments: s
      }
    };
  }
  expandSelectionOutlinePx(e) {
    const t = e.props.dash === "draw" ? 1.6 : 1;
    return vs[e.props.size] * t / 2 * e.props.scale;
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      segments: XW(e.props.segments, t.props.segments, r),
      scale: jn(e.props.scale, t.props.scale, r)
    };
  }
}
U(jC, "type", "draw"), U(jC, "props", K6), U(jC, "migrations", W6);
function ZW(n, e) {
  const t = (e + 1) * 0.5;
  return `M ${n.x} ${n.y} m -${t}, 0 a ${t},${t} 0 1,0 ${t * 2},0 a ${t},${t} 0 1,0 -${t * 2},0`;
}
function rA(n) {
  return n.props.segments.length === 1 && n.props.segments[0].points.length < 2;
}
function a$({ shape: n, zoomOverride: e }) {
  var w;
  const t = Fl(), r = be(), i = Ly(n.props.segments), s = n.props.isComplete || ((w = jo(n.props.segments)) == null ? void 0 : w.type) === "straight";
  let l = (vs[n.props.size] + 1) * n.props.scale;
  const c = Pe(
    "force solid",
    () => {
      const C = e ?? r.getZoomLevel();
      return C < 0.5 && C < 1.5 / l;
    },
    [r, l, e]
  ), d = Pe(
    "dot adjustment",
    () => (e ?? r.getZoomLevel()) < 0.2 ? 0 : 0.1,
    [r, e]
  );
  !c && !n.props.isPen && n.props.dash === "draw" && i.length === 1 && (l += Tc(n.id)() * (l / 6));
  const h = AD(n.props, l, s, c);
  if (!c && n.props.dash === "draw")
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      n.props.isClosed && n.props.fill && i.length > 1 ? /* @__PURE__ */ m.jsx(
        us,
        {
          d: lg(
            Ru(i, h),
            n.props.isClosed
          ),
          theme: t,
          color: n.props.color,
          fill: n.props.isClosed ? n.props.fill : "none",
          scale: n.props.scale
        }
      ) : null,
      /* @__PURE__ */ m.jsx(
        "path",
        {
          d: Pxe(i, h),
          strokeLinecap: "round",
          fill: t[n.props.color].solid
        }
      )
    ] });
  const g = Ru(i, h), y = g.length < 2, v = y ? ZW(i[0], 0) : lg(g, n.props.isClosed);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(
      us,
      {
        d: v,
        theme: t,
        color: n.props.color,
        fill: y || n.props.isClosed ? n.props.fill : "none",
        scale: n.props.scale
      }
    ),
    /* @__PURE__ */ m.jsx(
      "path",
      {
        d: v,
        strokeLinecap: "round",
        fill: y ? t[n.props.color].solid : "none",
        stroke: t[n.props.color].solid,
        strokeWidth: l,
        strokeDasharray: y ? "none" : Oxe(n, l, d),
        strokeDashoffset: "0"
      }
    )
  ] });
}
function jxe(n) {
  if (typeof n != "string")
    throw new TypeError("Expected a string");
  return n.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d");
}
function Lxe(n, e) {
  const t = Wt(e);
  if (!t) return;
  const r = t.host.replace("www.", "");
  for (const i of n)
    if (QW(i.hostnames, r)) {
      const s = i.fromEmbedUrl(e);
      if (s)
        return {
          definition: i,
          url: s,
          embedUrl: e
        };
    }
}
const Nxe = (n) => n.split("*").map((e) => jxe(e)).join(".+"), QW = (n, e) => !!n.find((t) => {
  const r = new RegExp(Nxe(t));
  return e.match(r);
});
function Fxe(n, e) {
  const t = Wt(e);
  if (!t) return;
  const r = t.host.replace("www.", "");
  for (const i of n)
    if (QW(i.hostnames, r)) {
      const s = i.toEmbedUrl(e);
      if (s)
        return {
          definition: i,
          embedUrl: s,
          url: e
        };
    }
}
function zxe(n, e) {
  try {
    return Fxe(n, e) ?? Lxe(n, e);
  } catch {
    return;
  }
}
const Uxe = (n) => Object.entries(n).filter(([e, t]) => t).map(([e]) => e).join(" "), Dd = class Dd extends Xy {
  static setEmbedDefinitions(e) {
    Dd.embedDefinitions = e;
  }
  getEmbedDefinitions() {
    return Dd.embedDefinitions;
  }
  getEmbedDefinition(e) {
    return zxe(Dd.embedDefinitions, e);
  }
  getText(e) {
    return e.props.url;
  }
  hideSelectionBoundsFg(e) {
    return !this.canResize(e);
  }
  canEdit() {
    return !0;
  }
  canResize(e) {
    var t, r;
    return !!((r = (t = this.getEmbedDefinition(e.props.url)) == null ? void 0 : t.definition) != null && r.doesResize);
  }
  canEditInReadOnly() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 300,
      h: 300,
      url: ""
    };
  }
  isAspectRatioLocked(e) {
    const t = this.getEmbedDefinition(e.props.url);
    return (t == null ? void 0 : t.definition.isAspectRatioLocked) ?? !1;
  }
  onResize(e, t) {
    const r = this.isAspectRatioLocked(e), i = this.getEmbedDefinition(e.props.url);
    let s = (i == null ? void 0 : i.definition.minWidth) ?? 200, l = (i == null ? void 0 : i.definition.minHeight) ?? 200;
    if (r) {
      const c = e.props.w / e.props.h;
      c > 1 ? s *= c : l /= c;
    }
    return h_(e, t, { minWidth: s, minHeight: l });
  }
  component(e) {
    const t = bw(), { w: r, h: i, url: s } = e.props, l = p_(e.id), c = this.getEmbedDefinition(s), d = Pe(
      "is hovering",
      () => {
        const { editingShapeId: w, hoveredShapeId: C } = this.editor.getCurrentPageState();
        if (w && C !== w) {
          const E = this.editor.getShape(w);
          if (E && this.editor.isShapeOfType(E, "embed"))
            return !0;
        }
        return !1;
      },
      []
    ), h = this.editor.getShapePageTransform(e).rotation();
    if (t)
      return /* @__PURE__ */ m.jsx(hh, { className: "tl-embed-container", id: e.id, children: /* @__PURE__ */ m.jsx(
        "div",
        {
          className: "tl-embed",
          style: {
            border: 0,
            boxShadow: DE(h),
            borderRadius: (c == null ? void 0 : c.definition.overrideOutlineRadius) ?? 8,
            background: (c == null ? void 0 : c.definition.backgroundColor) ?? "var(--color-background)",
            width: r,
            height: i
          }
        }
      ) });
    const g = l || d;
    if (typeof window < "u" && (window !== window.top || window.self !== window.parent) && (c == null ? void 0 : c.definition.type) === "tldraw") return null;
    if ((c == null ? void 0 : c.definition.type) === "github_gist") {
      const w = c.url.split("/").pop();
      if (!w) throw Error("No gist id!");
      return /* @__PURE__ */ m.jsx(hh, { className: "tl-embed-container", id: e.id, children: /* @__PURE__ */ m.jsx(
        $xe,
        {
          id: w,
          width: Se(r),
          height: Se(i),
          isInteractive: g,
          pageRotation: h
        }
      ) });
    }
    const v = Uxe({
      ...Vme,
      ...(c == null ? void 0 : c.definition.overridePermissions) ?? {}
    });
    return /* @__PURE__ */ m.jsx(hh, { className: "tl-embed-container", id: e.id, children: c != null && c.definition ? /* @__PURE__ */ m.jsx(
      "iframe",
      {
        className: "tl-embed",
        sandbox: v,
        src: c.embedUrl,
        width: Se(r),
        height: Se(i),
        draggable: !1,
        frameBorder: "0",
        referrerPolicy: "no-referrer-when-downgrade",
        style: {
          border: 0,
          pointerEvents: g ? "auto" : "none",
          // Fix for safari <https://stackoverflow.com/a/49150908>
          zIndex: g ? "" : "-1",
          boxShadow: DE(h),
          borderRadius: (c == null ? void 0 : c.definition.overrideOutlineRadius) ?? 8,
          background: c == null ? void 0 : c.definition.backgroundColor
        }
      }
    ) : null });
  }
  indicator(e) {
    const t = this.getEmbedDefinition(e.props.url);
    return /* @__PURE__ */ m.jsx(
      "rect",
      {
        width: Se(e.props.w),
        height: Se(e.props.h),
        rx: (t == null ? void 0 : t.definition.overrideOutlineRadius) ?? 8,
        ry: (t == null ? void 0 : t.definition.overrideOutlineRadius) ?? 8
      }
    );
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r)
    };
  }
};
U(Dd, "type", "embed"), U(Dd, "props", G6), U(Dd, "migrations", q6), U(Dd, "embedDefinitions", $j);
let OE = Dd;
function $xe({
  id: n,
  isInteractive: e,
  width: t,
  height: r,
  style: i,
  pageRotation: s
}) {
  if (!n.match(/^[0-9a-f]+$/)) throw Error("No gist id!");
  return /* @__PURE__ */ m.jsx(
    "iframe",
    {
      className: "tl-embed",
      draggable: !1,
      width: Se(t),
      height: Se(r),
      frameBorder: "0",
      scrolling: "no",
      referrerPolicy: "no-referrer-when-downgrade",
      style: {
        ...i,
        pointerEvents: e ? "all" : "none",
        // Fix for safari <https://stackoverflow.com/a/49150908>
        zIndex: e ? "" : "-1",
        boxShadow: DE(s)
      },
      srcDoc: `
			<html>
				<head>
					<base target="_blank">
				</head>
				<body>
					<script src=${`https://gist.github.com/${n}.js`}><\/script>
					<style type="text/css">
						* { margin: 0px; }
						table { height: 100%; background-color: red; }
						.gist { background-color: none; height: 100%;  }
						.gist .gist-file { height: calc(100vh - 2px); padding: 0px; display: grid; grid-template-rows: 1fr auto; }
					</style>
				</body>
			</html>`
    }
  );
}
var Bxe = {};
function DD(n, e) {
  const i = ((Yp(n.getShapePageTransform(e.id).rotation()) + Math.PI / 4) * (2 / Math.PI) + 4) % 4;
  return Math.floor(i);
}
function l$(n, e, t) {
  if (Bxe.NODE_ENV === "test")
    return {
      box: new Xe(0, -t.height, e.props.w, t.height),
      spans: []
    };
  const r = n.textMeasure.measureTextSpans(
    eG(e.props.name, "Frame") + "​",
    t
  ), i = r[0], s = jo(r), l = s.box.w + s.box.x - i.box.x;
  return {
    box: new Xe(0, -t.height, l, t.height),
    spans: r
  };
}
function c$(n, e) {
  return {
    fontSize: 12,
    fontFamily: "Inter, sans-serif",
    textAlign: "start",
    width: n.props.w,
    height: 32,
    padding: 0,
    lineHeight: 1,
    fontStyle: "normal",
    fontWeight: "normal",
    overflow: "truncate-ellipsis",
    verticalTextAlign: "middle",
    fill: e,
    offsetY: -34,
    offsetX: 2
  };
}
function JW(n, e, t) {
  const r = t ? "" : "px", i = t ? "" : "deg";
  let s;
  switch (e) {
    case 0:
      s = "";
      break;
    case 3:
      s = `translate(${Se(n.props.w)}${r}, 0${r}) rotate(90${i})`;
      break;
    case 2:
      s = `translate(${Se(n.props.w)}${r}, ${Se(
        n.props.h
      )}${r}) rotate(180${i})`;
      break;
    case 1:
      s = `translate(0${r}, ${Se(n.props.h)}${r}) rotate(270${i})`;
      break;
    default:
      throw Error("labelSide out of bounds");
  }
  return s;
}
const Hxe = M.forwardRef(({ id: n, name: e, isEditing: t }, r) => {
  const i = be(), s = M.useCallback(
    (d) => {
      d.key === "Enter" && !d.nativeEvent.isComposing && (Ti(d), d.currentTarget.blur(), i.setEditingShape(null));
    },
    [i]
  ), l = M.useCallback(
    (d) => {
      const h = i.getShape(n);
      if (!h) return;
      const g = h.props.name, y = d.currentTarget.value.trim();
      g !== y && i.updateShapes([
        {
          id: n,
          type: "frame",
          props: { name: y }
        }
      ]);
    },
    [n, i]
  ), c = M.useCallback(
    (d) => {
      const h = i.getShape(n);
      if (!h) return;
      const g = h.props.name, y = d.currentTarget.value;
      g !== y && i.updateShapes([
        {
          id: n,
          type: "frame",
          props: { name: y }
        }
      ]);
    },
    [n, i]
  );
  return /* @__PURE__ */ m.jsxs("div", { className: `tl-frame-label ${t ? "tl-frame-label__editing" : ""}`, children: [
    /* @__PURE__ */ m.jsx(
      "input",
      {
        className: "tl-frame-name-input",
        ref: r,
        style: { display: t ? void 0 : "none" },
        value: e,
        autoFocus: !0,
        onKeyDown: s,
        onBlur: l,
        onChange: c
      }
    ),
    eG(e, "Frame") + "​"
  ] });
});
function Vxe({
  id: n,
  name: e,
  width: t,
  height: r
}) {
  const i = be(), { side: s, translation: l } = Pe(
    "shape rotation",
    () => {
      const h = i.getShape(n);
      if (!h)
        return {
          side: 0,
          translation: "translate(0, 0)"
        };
      const g = DD(i, h);
      return {
        side: g,
        translation: JW(h, g, !1)
      };
    },
    [i, n]
  ), c = M.useRef(null), d = p_(n);
  return M.useEffect(() => {
    const h = c.current;
    h && d && (h.focus(), h.select());
  }, [c, d]), /* @__PURE__ */ m.jsx(
    "div",
    {
      className: "tl-frame-heading",
      style: {
        overflow: d ? "visible" : "hidden",
        maxWidth: `calc(var(--tl-zoom) * ${Math.ceil(s === 0 || s === 2 ? t : r)}px + var(--space-5))`,
        bottom: "100%",
        transform: `${l} scale(var(--tl-scale)) translateX(calc(-1 * var(--space-3))`
      },
      children: /* @__PURE__ */ m.jsx("div", { className: "tl-frame-heading-hit-area", children: /* @__PURE__ */ m.jsx(Hxe, { ref: c, id: n, name: e, isEditing: d }) })
    }
  );
}
function eG(n, e) {
  return n.match(/^\s*$/) ? e : n;
}
class LC extends Xy {
  canEdit() {
    return !0;
  }
  getDefaultProps() {
    return { w: 160 * 2, h: 90 * 2, name: "" };
  }
  getGeometry(e) {
    const { editor: t } = this, r = t.getZoomLevel(), i = c$(e, "black"), s = l$(t, e, i), l = DD(t, e);
    let c, d, h, g;
    const { w: y, h: v } = s.box, w = Math.min(y, e.props.w * r), C = Math.min(v, e.props.h * r);
    switch (l) {
      case 0: {
        c = -8 / r, d = (-v - 4) / r, h = (w + 16) / r, g = v / r;
        break;
      }
      case 1: {
        c = (-v - 4) / r, g = (C + 16) / r, d = e.props.h - g + 8 / r, h = v / r;
        break;
      }
      case 2: {
        c = e.props.w - (w + 8) / r, d = e.props.h + 4 / r, h = (C + 16) / r, g = v / r;
        break;
      }
      case 3: {
        c = e.props.w + 4 / r, g = (C + 16) / r, d = -8 / r, h = v / r;
        break;
      }
    }
    return new jl({
      children: [
        new Tu({
          width: e.props.w,
          height: e.props.h,
          isFilled: !1
        }),
        new Tu({
          x: c,
          y: d,
          width: h,
          height: g,
          isFilled: !0,
          isLabel: !0
        })
      ]
    });
  }
  getText(e) {
    return e.props.name;
  }
  component(e) {
    const t = this.editor.getShapeGeometry(e).bounds, r = Fl(), i = Pe(
      "is creating this shape",
      () => {
        const s = this.editor.getStateDescendant("select.resizing");
        if (!s || !s.getIsActive()) return !1;
        const l = s == null ? void 0 : s.info;
        return l ? l.isCreating && this.editor.getOnlySelectedShapeId() === e.id : !1;
      },
      [e.id]
    );
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(
        "rect",
        {
          className: It("tl-frame__body", { "tl-frame__creating": i }),
          width: t.width,
          height: t.height,
          fill: r.solid,
          stroke: r.text
        }
      ) }),
      i ? null : /* @__PURE__ */ m.jsx(
        Vxe,
        {
          id: e.id,
          name: e.props.name,
          width: t.width,
          height: t.height
        }
      )
    ] });
  }
  toSvg(e, t) {
    const r = Wd({ isDarkMode: t.isDarkMode }), i = DD(this.editor, e), s = JW(e, i, !0), l = c$(e, r.text), { box: c, spans: d } = l$(this.editor, e, l), h = RD(this.editor, d, l);
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          width: e.props.w,
          height: e.props.h,
          fill: r.solid,
          stroke: r.black.solid,
          strokeWidth: 1,
          rx: 1,
          ry: 1
        }
      ),
      /* @__PURE__ */ m.jsxs("g", { transform: s, children: [
        /* @__PURE__ */ m.jsx(
          "rect",
          {
            x: c.x - 8,
            y: c.y - 4,
            width: c.width + 20,
            height: c.height,
            fill: r.background,
            rx: 4,
            ry: 4
          }
        ),
        h
      ] })
    ] });
  }
  indicator(e) {
    const t = this.editor.getShapeGeometry(e).bounds;
    return /* @__PURE__ */ m.jsx(
      "rect",
      {
        width: Se(t.width),
        height: Se(t.height),
        className: "tl-frame-indicator"
      }
    );
  }
  canReceiveNewChildrenOfType(e, t) {
    return !e.isLocked;
  }
  providesBackgroundForChildren() {
    return !0;
  }
  canDropShapes(e, t) {
    return !e.isLocked;
  }
  onDragShapesOver(e, t) {
    t.every((r) => r.parentId === e.id) || this.editor.reparentShapes(t, e.id);
  }
  onDragShapesOut(e, t) {
    const r = this.editor.getShape(e.parentId);
    r && this.editor.isShapeOfType(r, "group") ? this.editor.reparentShapes(t, r.id) : this.editor.reparentShapes(t, this.editor.getCurrentPageId());
  }
  onResize(e, t) {
    return h_(e, t);
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r)
    };
  }
}
U(LC, "type", "frame"), U(LC, "props", Y6), U(LC, "migrations", X6);
function u$(n, e) {
  return n > e ? (Xn * (e / 2) + (n - e)) * 2 : (Xn * (n / 2) + (e - n)) * 2;
}
function tG(n, e) {
  return oL(n, e).map((t, r) => t.getSvgPathData(r === 0)).join(" ") + " Z";
}
function Kxe(n, e, t, r) {
  const i = n / 4, s = e / 4, l = Tc(r), c = t * 0.75, d = (k) => k.addXY(l() * c, l() * c), h = new R(n / 2, e), g = new R(0, s * 1.2), y = new R(n / 2, s * 0.9), v = new R(n, s * 1.2), w = d(new R(n / 2, e)), C = d(new R(0, s * 1.2)), E = d(new R(n / 2, s * 0.9)), P = d(new R(n, s * 1.2));
  return [
    new fs({
      start: h,
      cp1: new R(i * 1.5, s * 3),
      cp2: new R(0, s * 2.5),
      end: g
    }),
    new fs({
      start: g,
      cp1: new R(0, -s * 0.32),
      cp2: new R(i * 1.85, -s * 0.32),
      end: y
    }),
    new fs({
      start: y,
      cp1: new R(i * 2.15, -s * 0.32),
      cp2: new R(n, -s * 0.32),
      end: v
    }),
    new fs({
      start: v,
      cp1: new R(n, s * 2.5),
      cp2: new R(i * 2.5, s * 3),
      end: w
    }),
    new fs({
      start: w,
      cp1: new R(i * 1.5, s * 3),
      cp2: new R(0, s * 2.5),
      end: C
    }),
    new fs({
      start: C,
      cp1: new R(0, -s * 0.32),
      cp2: new R(i * 1.85, -s * 0.32),
      end: E
    }),
    new fs({
      start: E,
      cp1: new R(i * 2.15, -s * 0.32),
      cp2: new R(n, -s * 0.32),
      end: P
    }),
    new fs({
      start: P,
      cp1: new R(n, s * 2.5),
      cp2: new R(i * 2.5, s * 3),
      end: h
    })
  ].map((k, L) => k.getSvgPathData(L === 0)).join(" ") + " Z";
}
function oL(n, e) {
  const t = n / 4, r = e / 4;
  return [
    new fs({
      start: new R(n / 2, e),
      cp1: new R(t * 1.5, r * 3),
      cp2: new R(0, r * 2.5),
      end: new R(0, r * 1.2)
    }),
    new fs({
      start: new R(0, r * 1.2),
      cp1: new R(0, -r * 0.32),
      cp2: new R(t * 1.85, -r * 0.32),
      end: new R(n / 2, r * 0.9)
    }),
    new fs({
      start: new R(n / 2, r * 0.9),
      cp1: new R(t * 2.15, -r * 0.32),
      cp2: new R(n, -r * 0.32),
      end: new R(n, r * 1.2)
    }),
    new fs({
      start: new R(n, r * 1.2),
      cp1: new R(n, r * 2.5),
      cp2: new R(t * 2.5, r * 3),
      end: new R(n / 2, e)
    })
  ];
}
function Wxe(n) {
  return {
    size: 1 + n,
    thinning: 0.25,
    end: { taper: n },
    start: { taper: n },
    streamline: 0,
    smoothing: 1,
    simulatePressure: !1
  };
}
function Gxe(n, e, t, r) {
  const i = Tc(n), s = e / 2, l = t / 2, c = G8(s, l), d = [], h = hr * i(), g = hr + Or / 2 + Math.abs(i()) * Or, y = Math.max(16, c / 10);
  for (let v = 0; v < y; v++) {
    const w = v / (y - 1), C = h + w * g, E = Math.cos(C), P = Math.sin(C);
    d.push(
      new R(
        s * E + e * 0.5 + 0.05 * i(),
        l * P + t / 2 + 0.05 * i(),
        Math.min(
          1,
          0.5 + Math.abs(0.5 - (i() > 0 ? po.easeInOutSine(w) : po.easeInExpo(w))) / 2
        )
      )
    );
  }
  return Ru(d, Wxe(r));
}
function qxe(n, e, t, r) {
  return lg(Gxe(n, e, t, r));
}
function OD(n) {
  let e = "M";
  const t = n.length;
  let r, i, s;
  for (let l = 0, c = t; l < c; l += 3)
    r = n[l], i = n[l + 1], s = n[l + 2], e += `${Yn(r)}L${Yn(i)}Q${Yn(s)}`;
  return e += `${Yn(n[0])}`, e;
}
function jD(n, e, t, r, i) {
  const s = [], l = Tc(n);
  let c = e[0], d;
  const h = e.length;
  for (let g = 0, y = h * i; g < y; g++) {
    d = R.AddXY(e[(g + 1) % h], l() * t, l() * t);
    const v = R.Sub(d, c), w = R.Len(v), C = R.Div(v, w).mul(Math.min(w / 4, r));
    s.push(R.Add(c, C), R.Add(d, C.neg()), d), c = d;
  }
  return s;
}
function Yxe(n, e, t) {
  const r = Math.min(n, e) / 2, i = Math.max(n, e) - r * 2, l = (Math.PI * (r * 2) + 2 * i) / t, c = n > e ? [
    {
      type: "straight",
      start: new R(r, 0),
      delta: new R(1, 0)
    },
    {
      type: "arc",
      center: new R(n - r, r),
      startAngle: -Xn / 2
    },
    {
      type: "straight",
      start: new R(n - r, e),
      delta: new R(-1, 0)
    },
    {
      type: "arc",
      center: new R(r, r),
      startAngle: Xn / 2
    }
  ] : [
    {
      type: "straight",
      start: new R(n, r),
      delta: new R(0, 1)
    },
    {
      type: "arc",
      center: new R(r, e - r),
      startAngle: 0
    },
    {
      type: "straight",
      start: new R(0, e - r),
      delta: new R(0, -1)
    },
    {
      type: "arc",
      center: new R(r, r),
      startAngle: Xn
    }
  ];
  let d = 0;
  const h = [];
  for (let g = 0; g < t; g++) {
    const y = c[0];
    y.type === "straight" ? h.push(R.Add(y.start, R.Mul(y.delta, d))) : h.push(
      tg(y.center, r, y.startAngle + d / r)
    ), d += l;
    let v = y.type === "straight" ? i : Xn * r;
    for (; d > v; )
      d -= v, c.push(c.shift()), v = c[0].type === "straight" ? i : Xn * r;
  }
  return h;
}
const Xxe = {
  s: 50,
  m: 70,
  l: 100,
  xl: 130
}, Zxe = 0.2;
function B_(n, e, t, r, i) {
  const s = Tc(t), l = u$(n, e), c = Math.max(
    Math.ceil(l / Xxe[r]),
    6,
    Math.ceil(l / Math.min(n, e))
  ), d = l / c * Zxe, h = Math.max(n - d * 2, 1), g = Math.max(e - d * 2, 1), v = u$(h, g) / c, w = (n - h) / 2, C = (e - g) / 2, E = Yxe(h, g, c).map((O) => O.addXY(w, C)), P = n < 20 ? 0 : d * 0.3, I = e < 20 ? 0 : d * 0.3, k = E.slice(0);
  for (let O = 0; O < Math.floor(c / 2); O++)
    k[O] = R.AddXY(
      k[O],
      s() * P * i,
      s() * I * i
    ), k[c - O - 1] = R.AddXY(
      k[c - O - 1],
      s() * P * i,
      s() * I * i
    );
  const L = [];
  for (let O = 0; O < k.length; O++) {
    const z = O === k.length - 1 ? 0 : O + 1, F = k[O], H = k[z], V = E[O], re = E[z], q = R.Dist(V, re), J = v - q, W = R.Dist(F, H) / q, Y = (Math.max(w, C) + J) * W, oe = R.Lrp(V, re, 0.5).add(
      R.Sub(re, V).uni().per().mul(Y)
    );
    oe.x < 0 ? oe.x = 0 : oe.x > n && (oe.x = n), oe.y < 0 ? oe.y = 0 : oe.y > e && (oe.y = e);
    const le = DO(F, H, oe), ce = R.Dist(
      le || R.Average([F, H]),
      F
    );
    L.push({
      leftPoint: F,
      rightPoint: H,
      arcPoint: oe,
      center: le,
      radius: ce
    });
  }
  return L;
}
function Qxe(n, e, t, r, i) {
  const s = [], l = B_(n, e, t, r, i);
  for (const { center: c, radius: d, leftPoint: h, rightPoint: g } of l)
    s.push(...ase(h, g, c, d, 10));
  return s;
}
function LD(n, e, t, r, i) {
  const s = B_(n, e, t, r, i);
  let l = `M${s[0].leftPoint.toFixed()}`;
  for (const { leftPoint: c, rightPoint: d, radius: h, center: g } of s) {
    if (g === null) {
      l += ` L${d.toFixed()}`;
      continue;
    }
    const y = R.Clockwise(c, d, g) ? "0" : "1";
    l += ` A${Se(h)},${Se(h)} 0 ${y},1 ${d.toFixed()}`;
  }
  return l += " Z", l;
}
const Jxe = {
  s: 0.5,
  m: 0.7,
  l: 0.9,
  xl: 1.6
};
function ewe(n, e, t, r, i) {
  const s = Tc(t), l = Jxe[r] * i, c = B_(n, e, t, r, i), g = c.reduce((C, E) => C + R.Dist2(E.leftPoint, E.rightPoint), 0) / c.length > (l * 15) ** 2 ? (C) => R.AddXY(C, s() * l * 2, s() * l * 2) : (C) => C;
  let y = `M${c[0].leftPoint.toFixed()}`, v = g(c[0].leftPoint), w = `M${v.toFixed()}`;
  for (const { leftPoint: C, center: E, rightPoint: P, radius: I, arcPoint: k } of c) {
    if (E === null) {
      y += ` L${P.toFixed()}`;
      const V = g(P);
      w += ` L${V.toFixed()}`, v = V;
      continue;
    }
    const L = R.Clockwise(C, P, E) ? "0" : "1";
    y += ` A${Se(I)},${Se(I)} 0 ${L},1 ${P.toFixed()}`;
    const O = g(P), z = g(k), F = DO(v, O, z);
    if (!F) {
      w += ` L${O.toFixed()}`, v = O;
      continue;
    }
    const H = Math.abs(R.Dist(F, v));
    w += ` A${Se(H)},${Se(
      H
    )} 0 ${L},1 ${O.toFixed()}`, v = O;
  }
  return y + w + " Z";
}
function ND(n, e) {
  switch (n.geo) {
    case "x-box":
      return twe(n.w, n.h, e, n.dash);
    case "check-box":
      return nwe(n.w, n.h);
    default:
      return;
  }
}
function twe(n, e, t, r) {
  const i = r === "draw" ? 0.62 : 0;
  if (r === "dashed")
    return [
      [new R(0, 0), new R(n / 2, e / 2)],
      [new R(n, e), new R(n / 2, e / 2)],
      [new R(0, e), new R(n / 2, e / 2)],
      [new R(n, 0), new R(n / 2, e / 2)]
    ];
  const s = (c) => Math.max(0, Math.min(n, c)), l = (c) => Math.max(0, Math.min(e, c));
  return [
    [
      new R(s(t * i), l(t * i)),
      new R(s(n - t * i), l(e - t * i))
    ],
    [
      new R(s(t * i), l(e - t * i)),
      new R(s(n - t * i), l(t * i))
    ]
  ];
}
function nwe(n, e) {
  const t = Math.min(n, e) * 0.82, r = (n - t) / 2, i = (e - t) / 2, s = (c) => Math.max(0, Math.min(n, c)), l = (c) => Math.max(0, Math.min(e, c));
  return [
    [
      new R(s(r + t * 0.25), l(i + t * 0.52)),
      new R(s(r + t * 0.45), l(i + t * 0.82))
    ],
    [
      new R(s(r + t * 0.45), l(i + t * 0.82)),
      new R(s(r + t * 0.82), l(i + t * 0.22))
    ]
  ];
}
function d$({
  shape: n,
  shouldScale: e,
  forceSolid: t
}) {
  const r = e ? n.props.scale : 1, i = be(), s = Fl(), { id: l, props: c } = n, { w: d, color: h, fill: g, dash: y, growY: v, size: w, scale: C } = c, E = vs[w] * r, P = c.h + v;
  switch (c.geo) {
    case "cloud":
      if (y === "solid") {
        const I = LD(d, P, l, w, C);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: I, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: I, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      } else if (y === "draw") {
        const I = ewe(d, P, l, w, C);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: I, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: I, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      } else {
        const I = LD(d, P, l, w, C), k = B_(d, P, l, w, C);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: I, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx(
            "g",
            {
              strokeWidth: E,
              stroke: s[h].solid,
              fill: "none",
              pointerEvents: "all",
              children: k.map(({ leftPoint: L, rightPoint: O, center: z, radius: F }, H) => {
                const V = z ? F * Yp(
                  Yp(R.Angle(z, O)) - Yp(R.Angle(z, L))
                ) : R.Dist(L, O), { strokeDasharray: re, strokeDashoffset: q } = mc(
                  V,
                  E,
                  {
                    style: y,
                    start: "outset",
                    end: "outset",
                    forceSolid: t
                  }
                );
                return /* @__PURE__ */ m.jsx(
                  "path",
                  {
                    d: z ? `M${L.x},${L.y}A${F},${F},0,0,1,${O.x},${O.y}` : `M${L.x},${L.y}L${O.x},${O.y}`,
                    strokeDasharray: re,
                    strokeDashoffset: q
                  },
                  H
                );
              })
            }
          )
        ] });
      }
    case "ellipse": {
      const I = e ? (
        // cached
        i.getShapeGeometry(n)
      ) : (
        // not cached
        i.getShapeUtil(n).getGeometry(n)
      ), k = I.getSvgPathData(!0);
      if (y === "dashed" || y === "dotted") {
        const L = I.length, { strokeDasharray: O, strokeDashoffset: z } = mc(
          L < 64 ? L * 2 : L,
          E,
          {
            style: y,
            snap: 4,
            closed: !0,
            forceSolid: t
          }
        );
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: k, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx(
            "path",
            {
              d: k,
              strokeWidth: E,
              fill: "none",
              stroke: s[h].solid,
              strokeDasharray: O,
              strokeDashoffset: z
            }
          )
        ] });
      } else {
        const O = (e ? (
          // cached
          i.getShapeGeometry(n)
        ) : (
          // not cached
          i.getShapeUtil(n).getGeometry(n)
        )).getSvgPathData(!0);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: O, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: O, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      }
    }
    case "oval": {
      const I = e ? (
        // cached
        i.getShapeGeometry(n)
      ) : (
        // not cached
        i.getShapeUtil(n).getGeometry(n)
      ), k = I.getSvgPathData(!0);
      if (y === "dashed" || y === "dotted") {
        const L = I.getLength(), { strokeDasharray: O, strokeDashoffset: z } = mc(
          L < 64 ? L * 2 : L,
          E,
          {
            style: y,
            snap: 4,
            start: "outset",
            end: "outset",
            closed: !0,
            forceSolid: t
          }
        );
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: k, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx(
            "path",
            {
              d: k,
              strokeWidth: E,
              fill: "none",
              stroke: s[h].solid,
              strokeDasharray: O,
              strokeDashoffset: z
            }
          )
        ] });
      } else
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: k, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: k, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
    }
    case "heart":
      if (y === "dashed" || y === "dotted" || y === "solid") {
        const I = tG(d, P), k = oL(d, P);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: I, color: h, fill: g, scale: r }),
          k.map((L, O) => {
            const { strokeDasharray: z, strokeDashoffset: F } = mc(
              L.length,
              E,
              {
                style: y,
                snap: 1,
                start: "outset",
                end: "outset",
                closed: !0,
                forceSolid: t
              }
            );
            return /* @__PURE__ */ m.jsx(
              "path",
              {
                d: L.getSvgPathData(),
                strokeWidth: E,
                fill: "none",
                stroke: s[h].solid,
                strokeDasharray: z,
                strokeDashoffset: F,
                pointerEvents: "all"
              },
              `curve_${O}`
            );
          })
        ] });
      } else {
        const I = Kxe(d, P, E, n.id);
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: I, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: I, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      }
    default: {
      const I = e ? (
        // cached
        i.getShapeGeometry(n)
      ) : (
        // not cached
        i.getShapeUtil(n).getGeometry(n)
      ), k = I instanceof jl ? I.children[0].vertices : I.vertices, L = ND(n.props, E);
      if (y === "solid") {
        let O = "M" + k[0] + "L" + k.slice(1) + "Z";
        if (L)
          for (const [z, F] of L)
            O += `M${z.x},${z.y}L${F.x},${F.y}`;
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: O, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsx("path", { d: O, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      } else if (y === "dashed" || y === "dotted") {
        const O = "M" + k[0] + "L" + k.slice(1) + "Z";
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(us, { theme: s, d: O, color: h, fill: g, scale: r }),
          /* @__PURE__ */ m.jsxs(
            "g",
            {
              strokeWidth: E,
              stroke: s[h].solid,
              fill: "none",
              pointerEvents: "all",
              children: [
                Array.from(Array(k.length)).map((z, F) => {
                  const H = R.ToFixed(k[F]), V = R.ToFixed(k[(F + 1) % k.length]), re = R.Dist(H, V), { strokeDasharray: q, strokeDashoffset: J } = mc(
                    re,
                    E,
                    {
                      style: y,
                      start: "outset",
                      end: "outset",
                      forceSolid: t
                    }
                  );
                  return /* @__PURE__ */ m.jsx(
                    "line",
                    {
                      x1: H.x,
                      y1: H.y,
                      x2: V.x,
                      y2: V.y,
                      strokeDasharray: q,
                      strokeDashoffset: J
                    },
                    F
                  );
                }),
                L && L.map(([z, F], H) => {
                  const V = R.Dist(z, F), { strokeDasharray: re, strokeDashoffset: q } = mc(
                    V,
                    E,
                    {
                      style: y,
                      start: "skip",
                      end: "skip",
                      snap: y === "dotted" ? 4 : void 0,
                      forceSolid: t
                    }
                  );
                  return /* @__PURE__ */ m.jsx(
                    "path",
                    {
                      d: `M${z.x},${z.y}L${F.x},${F.y}`,
                      stroke: s[h].solid,
                      strokeWidth: E,
                      fill: "none",
                      strokeDasharray: re,
                      strokeDashoffset: q
                    },
                    `line_fg_${H}`
                  );
                })
              ]
            }
          )
        ] });
      } else if (y === "draw") {
        let O = OD(
          jD(l, k, E / 3, E * 2, 2)
        );
        if (L)
          for (const [F, H] of L)
            O += `M${F.toFixed()}L${H.toFixed()}`;
        const z = OD(
          jD(l, k, 0, E * 2, 1)
        );
        return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(
            us,
            {
              theme: s,
              d: z,
              color: h,
              fill: g,
              scale: r
            }
          ),
          /* @__PURE__ */ m.jsx("path", { d: O, stroke: s[h].solid, strokeWidth: E, fill: "none" })
        ] });
      }
    }
  }
}
const f$ = 17 * 3;
class NC extends Xy {
  canEdit() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      geo: "rectangle",
      color: "black",
      labelColor: "black",
      fill: "none",
      dash: "draw",
      size: "m",
      font: "draw",
      text: "",
      align: "middle",
      verticalAlign: "middle",
      growY: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(e) {
    const t = Math.max(1, e.props.w), r = Math.max(1, e.props.h + e.props.growY), i = t / 2, s = r / 2, l = e.props.fill !== "none";
    let c;
    switch (e.props.geo) {
      case "cloud": {
        c = new Ci({
          points: Qxe(t, r, e.id, e.props.size, e.props.scale),
          isFilled: l
        });
        break;
      }
      case "triangle": {
        c = new Ci({
          points: [new R(i, 0), new R(t, r), new R(0, r)],
          isFilled: l
        });
        break;
      }
      case "diamond": {
        c = new Ci({
          points: [new R(i, 0), new R(t, s), new R(i, r), new R(0, s)],
          isFilled: l
        });
        break;
      }
      case "pentagon": {
        c = new Ci({
          points: wM(t, r, 5),
          isFilled: l
        });
        break;
      }
      case "hexagon": {
        c = new Ci({
          points: wM(t, r, 6),
          isFilled: l
        });
        break;
      }
      case "octagon": {
        c = new Ci({
          points: wM(t, r, 8),
          isFilled: l
        });
        break;
      }
      case "ellipse": {
        c = new ufe({
          width: t,
          height: r,
          isFilled: l
        });
        break;
      }
      case "oval": {
        c = new dfe({
          width: t,
          height: r,
          isFilled: l
        });
        break;
      }
      case "star": {
        const k = hr / 5 / 2, L = Math.floor(5 / 4) * 2, O = 5 * 2 - L, z = 0, F = Math.floor(5 / 2) * 2, H = Math.cos(-Or + L * k) * t / 2, V = Math.cos(-Or + O * k) * t / 2, re = Math.sin(-Or + z * k) * r / 2, q = Math.sin(-Or + F * k) * r / 2, J = t - Math.abs(H - V), ie = r - Math.abs(q - re), W = t / 2 + V - (t / 2 - H), Y = r / 2 + re - (r / 2 - q), oe = 1, le = (t - W) / 2, ce = (r - Y) / 2, Q = (t + J) / 2, he = (r + ie) / 2, ke = Q * oe / 2, te = he * oe / 2;
        c = new Ci({
          points: Array.from(Array(5 * 2)).map((me, Oe) => {
            const Ze = -Or + Oe * k;
            return new R(
              le + (Oe % 2 ? ke : Q) * Math.cos(Ze),
              ce + (Oe % 2 ? te : he) * Math.sin(Ze)
            );
          }),
          isFilled: l
        });
        break;
      }
      case "rhombus": {
        const I = Math.min(t * 0.38, r * 0.38);
        c = new Ci({
          points: [new R(I, 0), new R(t, 0), new R(t - I, r), new R(0, r)],
          isFilled: l
        });
        break;
      }
      case "rhombus-2": {
        const I = Math.min(t * 0.38, r * 0.38);
        c = new Ci({
          points: [new R(0, 0), new R(t - I, 0), new R(t, r), new R(I, r)],
          isFilled: l
        });
        break;
      }
      case "trapezoid": {
        const I = Math.min(t * 0.38, r * 0.38);
        c = new Ci({
          points: [new R(I, 0), new R(t - I, 0), new R(t, r), new R(0, r)],
          isFilled: l
        });
        break;
      }
      case "arrow-right": {
        const I = Math.min(t, r) * 0.38, k = r * 0.16;
        c = new Ci({
          points: [
            new R(0, k),
            new R(t - I, k),
            new R(t - I, 0),
            new R(t, r / 2),
            new R(t - I, r),
            new R(t - I, r - k),
            new R(0, r - k)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-left": {
        const I = Math.min(t, r) * 0.38, k = r * 0.16;
        c = new Ci({
          points: [
            new R(I, 0),
            new R(I, k),
            new R(t, k),
            new R(t, r - k),
            new R(I, r - k),
            new R(I, r),
            new R(0, r / 2)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-up": {
        const I = t * 0.16, k = Math.min(t, r) * 0.38;
        c = new Ci({
          points: [
            new R(t / 2, 0),
            new R(t, k),
            new R(t - I, k),
            new R(t - I, r),
            new R(I, r),
            new R(I, k),
            new R(0, k)
          ],
          isFilled: l
        });
        break;
      }
      case "arrow-down": {
        const I = t * 0.16, k = Math.min(t, r) * 0.38;
        c = new Ci({
          points: [
            new R(I, 0),
            new R(t - I, 0),
            new R(t - I, r - k),
            new R(t, r - k),
            new R(t / 2, r),
            new R(0, r - k),
            new R(I, r - k)
          ],
          isFilled: l
        });
        break;
      }
      case "check-box":
      case "x-box":
      case "rectangle": {
        c = new Tu({
          width: t,
          height: r,
          isFilled: l
        });
        break;
      }
      case "heart": {
        const k = oL(t, r).reduce((L, O) => (L.push(...O.vertices), L), []);
        c = new Ci({
          points: k,
          isFilled: l
        });
        break;
      }
      default:
        ro(e.props.geo);
    }
    const d = uC(this.editor, e), h = t / e.props.scale, g = r / e.props.scale, y = Math.min(100, h / 2), v = Math.min(
      Bd[e.props.size] * Ss.lineHeight + kl * 2,
      g / 2
    ), w = Math.min(
      h,
      Math.max(d.w, Math.min(y, Math.max(1, h - 8)))
    ), C = Math.min(
      g,
      Math.max(d.h, Math.min(v, Math.max(1, g - 8)))
    ), E = ND(e.props, vs[e.props.size] * e.props.scale), P = E ? E.map((I) => new Wy({ points: I })) : [];
    return new jl({
      children: [
        c,
        new Tu({
          x: e.props.align === "start" ? 0 : e.props.align === "end" ? (h - w) * e.props.scale : (h - w) / 2 * e.props.scale,
          y: e.props.verticalAlign === "start" ? 0 : e.props.verticalAlign === "end" ? (g - C) * e.props.scale : (g - C) / 2 * e.props.scale,
          width: w * e.props.scale,
          height: C * e.props.scale,
          isFilled: !0,
          isLabel: !0
        }),
        ...P
      ]
    });
  }
  getHandleSnapGeometry(e) {
    const t = this.getGeometry(e), r = t.children[0];
    switch (e.props.geo) {
      case "arrow-down":
      case "arrow-left":
      case "arrow-right":
      case "arrow-up":
      case "check-box":
      case "diamond":
      case "hexagon":
      case "octagon":
      case "pentagon":
      case "rectangle":
      case "rhombus":
      case "rhombus-2":
      case "star":
      case "trapezoid":
      case "triangle":
      case "x-box":
        return { outline: r, points: [...r.getVertices(), t.bounds.center] };
      case "cloud":
      case "ellipse":
      case "heart":
      case "oval":
        return { outline: r, points: [t.bounds.center] };
      default:
        ro(e.props.geo);
    }
  }
  getText(e) {
    return e.props.text;
  }
  onEditEnd(e) {
    const {
      id: t,
      type: r,
      props: { text: i }
    } = e;
    i.trimEnd() !== e.props.text && this.editor.updateShapes([
      {
        id: t,
        type: r,
        props: {
          text: i.trimEnd()
        }
      }
    ]);
  }
  component(e) {
    const { id: t, type: r, props: i } = e, { fill: s, font: l, align: c, verticalAlign: d, size: h, text: g } = i, y = Fl(), { editor: v } = this, w = Pe(
      "isGeoOnlySelected",
      () => e.id === v.getOnlySelectedShapeId(),
      []
    ), E = v.getEditingShapeId() !== null || e.props.text, P = Pe(
      "force solid",
      () => v.getZoomLevel() < 0.2,
      [v]
    );
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(d$, { shape: e, shouldScale: !0, forceSolid: P }) }),
      E && /* @__PURE__ */ m.jsx(
        hh,
        {
          style: {
            overflow: "hidden",
            width: e.props.w,
            height: e.props.h + i.growY
          },
          children: /* @__PURE__ */ m.jsx(
            $_,
            {
              shapeId: t,
              type: r,
              font: l,
              fontSize: Bd[h] * e.props.scale,
              lineHeight: Ss.lineHeight,
              padding: kl * e.props.scale,
              fill: s,
              align: c,
              verticalAlign: d,
              text: g,
              isSelected: w,
              labelColor: y[i.labelColor].solid,
              wrap: !0
            }
          )
        }
      ),
      e.props.url && /* @__PURE__ */ m.jsx(jy, { url: e.props.url })
    ] });
  }
  indicator(e) {
    const { id: t, props: r } = e, { w: i, size: s } = r, l = r.h + r.growY, c = vs[s], d = this.editor.getShapeGeometry(e);
    switch (r.geo) {
      case "ellipse":
        return r.dash === "draw" ? /* @__PURE__ */ m.jsx("path", { d: qxe(t, i, l, c) }) : /* @__PURE__ */ m.jsx("path", { d: d.getSvgPathData(!0) });
      case "heart":
        return /* @__PURE__ */ m.jsx("path", { d: tG(i, l) });
      case "oval":
        return /* @__PURE__ */ m.jsx("path", { d: d.getSvgPathData(!0) });
      case "cloud":
        return /* @__PURE__ */ m.jsx("path", { d: LD(i, l, t, s, e.props.scale) });
      default: {
        const h = this.editor.getShapeGeometry(e), g = h instanceof jl ? h.children[0].vertices : h.vertices;
        let y;
        if (r.dash === "draw") {
          const w = jD(
            t,
            g,
            0,
            c * 2 * e.props.scale,
            1
          );
          y = OD(w);
        } else
          y = "M" + g[0] + "L" + g.slice(1) + "Z";
        const v = ND(e.props, c);
        if (v)
          for (const [w, C] of v)
            y += `M${w.x},${w.y}L${C.x},${C.y}`;
        return /* @__PURE__ */ m.jsx("path", { d: y });
      }
    }
  }
  toSvg(e, t) {
    const r = {
      ...e,
      props: {
        ...e.props,
        w: e.props.w / e.props.scale,
        h: e.props.h / e.props.scale
      }
    }, i = r.props;
    t.addExportDef(eL(i.fill));
    let s;
    if (i.text) {
      t.addExportDef(z_(i.font));
      const l = Wd(t), c = new Xe(0, 0, i.w, i.h + i.growY);
      s = /* @__PURE__ */ m.jsx(
        U_,
        {
          fontSize: Bd[i.size],
          font: i.font,
          align: i.align,
          verticalAlign: i.verticalAlign,
          text: i.text,
          labelColor: l[i.labelColor].solid,
          bounds: c,
          padding: 16
        }
      );
    }
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(d$, { shouldScale: !1, shape: r, forceSolid: !1 }),
      s
    ] });
  }
  getCanvasSvgDefs() {
    return [tL()];
  }
  onResize(e, { handle: t, newPoint: r, scaleX: i, scaleY: s, initialShape: l }) {
    const c = l.props.w / l.props.scale, d = l.props.h / l.props.scale, h = l.props.growY / l.props.scale;
    let g = c * i, y = (d + h) * s, v = 0, w = 0;
    const C = f$;
    if (e.props.text.trim()) {
      let O = Math.max(Math.abs(g), C), z = Math.max(Math.abs(y), C);
      O < C && z === C && (O = C), O === C && z < C && (z = C);
      const F = uC(this.editor, {
        ...e,
        props: {
          ...e.props,
          w: O * e.props.scale,
          h: z * e.props.scale
        }
      }), H = Math.max(Math.abs(g), F.w) * Math.sign(g), V = Math.max(Math.abs(y), F.h) * Math.sign(y);
      v = Math.abs(H) - Math.abs(g), w = Math.abs(V) - Math.abs(y), g = H, y = V;
    }
    const E = g * e.props.scale, P = y * e.props.scale, I = new R(0, 0);
    i < 0 && (I.x += E), (t === "left" || t === "top_left" || t === "bottom_left") && (I.x += i < 0 ? v : -v), s < 0 && (I.y += P), (t === "top" || t === "top_left" || t === "top_right") && (I.y += s < 0 ? w : -w);
    const { x: k, y: L } = I.rot(e.rotation).add(r);
    return {
      x: k,
      y: L,
      props: {
        w: Math.max(Math.abs(E), 1),
        h: Math.max(Math.abs(P), 1),
        growY: 0
      }
    };
  }
  onBeforeCreate(e) {
    if (!e.props.text)
      return e.props.growY ? {
        ...e,
        props: {
          ...e.props,
          growY: 0
        }
      } : void 0;
    const t = e.props.h / e.props.scale, r = uC(this.editor, e).h;
    let i = null;
    if (r > t ? i = r - t : e.props.growY && (i = 0), i !== null)
      return {
        ...e,
        props: {
          ...e.props,
          // scale the growY
          growY: i * e.props.scale
        }
      };
  }
  onBeforeUpdate(e, t) {
    const r = e.props.text, i = t.props.text;
    if (r === i && e.props.font === t.props.font && e.props.size === t.props.size)
      return;
    if (r && !i)
      return {
        ...t,
        props: {
          ...t.props,
          growY: 0
        }
      };
    const s = e.props.w / e.props.scale, l = e.props.h / e.props.scale, c = e.props.growY / e.props.scale, d = uC(this.editor, t);
    if (!r && i && i.length === 1) {
      let g = Math.max(s, d.w), y = Math.max(l, d.h);
      const v = f$;
      return s < v && l < v && (g = Math.max(g, v), y = Math.max(y, v), g = Math.max(g, y), y = Math.max(g, y)), {
        ...t,
        props: {
          ...t.props,
          // Scale the results
          w: g * t.props.scale,
          h: y * t.props.scale,
          growY: 0
        }
      };
    }
    let h = null;
    if (d.h > l ? h = d.h - l : c && (h = 0), h !== null) {
      const g = t.props.w / t.props.scale;
      return {
        ...t,
        props: {
          ...t.props,
          // Scale the results
          growY: h * t.props.scale,
          w: Math.max(g, d.w) * t.props.scale
        }
      };
    }
    if (d.w > s)
      return {
        ...t,
        props: {
          ...t.props,
          // Scale the results
          w: d.w * t.props.scale
        }
      };
  }
  onDoubleClick(e) {
    if (this.editor.inputs.altKey)
      switch (e.props.geo) {
        case "rectangle":
          return {
            ...e,
            props: {
              geo: "check-box"
            }
          };
        case "check-box":
          return {
            ...e,
            props: {
              geo: "rectangle"
            }
          };
      }
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r),
      scale: jn(e.props.scale, t.props.scale, r)
    };
  }
}
U(NC, "type", "geo"), U(NC, "props", Z6), U(NC, "migrations", Q6);
function uC(n, e) {
  const { text: t, font: r, size: i, w: s } = e.props;
  if (!t)
    return { w: 0, h: 0 };
  const l = n.textMeasure.measureText("w", {
    ...Ss,
    fontFamily: Kd[r],
    fontSize: Bd[i],
    maxWidth: 100
    // ?
  }), c = {
    s: 2,
    m: 3.5,
    l: 5,
    xl: 10
  }, d = n.textMeasure.measureText(t, {
    ...Ss,
    fontFamily: Kd[r],
    fontSize: Bd[i],
    minWidth: l.w,
    maxWidth: Math.max(
      // Guard because a DOM nodes can't be less 0
      0,
      // A 'w' width that we're setting as the min-width
      Math.ceil(l.w + c[i]),
      // The actual text size
      Math.ceil(s / e.props.scale - kl * 2)
    )
  });
  return {
    w: d.w + kl * 2,
    h: d.h + kl * 2
  };
}
function rwe() {
  const [n, e] = M.useState(!1);
  return M.useEffect(() => {
    const r = CSS.supports("color", "color(display-p3 1 1 1)"), i = matchMedia("(color-gamut: p3)");
    e(r && i.matches);
    const s = () => e(r && i.matches);
    return i.addEventListener("change", s), () => i.removeEventListener("change", s);
  }, []), Pe(Ei.forceSrgb) || !n ? "srgb" : "p3";
}
const h$ = 0.35, p$ = 0.82;
class FC extends Cc {
  hideResizeHandles(e) {
    return dC(e);
  }
  hideRotateHandle(e) {
    return dC(e);
  }
  hideSelectionBoundsFg(e) {
    return dC(e);
  }
  getDefaultProps() {
    return {
      segments: [],
      color: "black",
      size: "m",
      isComplete: !1,
      isPen: !1,
      scale: 1
    };
  }
  getGeometry(e) {
    const t = Vp(e);
    if (dC(e))
      return new oj({
        x: -t / 2,
        y: -t / 2,
        radius: t / 2,
        isFilled: !0
      });
    const { strokePoints: r, sw: i } = g$(e, t, !0), s = iL({ strokeWidth: i, showAsComplete: !0 });
    return N_(r, s), new Ci({
      points: Xj(r, s),
      isFilled: !0
    });
  }
  component(e) {
    const t = iA(this.editor, e), r = Vp(e);
    return /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(
      fC,
      {
        shape: e,
        forceSolid: t,
        strokeWidth: r,
        opacity: h$
      }
    ) });
  }
  backgroundComponent(e) {
    const t = iA(this.editor, e), r = Vp(e);
    return /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(
      fC,
      {
        shape: e,
        forceSolid: t,
        strokeWidth: r,
        opacity: p$
      }
    ) });
  }
  indicator(e) {
    const t = iA(this.editor, e), r = Vp(e), { strokePoints: i, sw: s } = g$(e, r, t), l = Ly(e.props.segments);
    let c;
    return i.length < 2 ? c = owe(l[0], s) : c = lg(i, !1), /* @__PURE__ */ m.jsx("path", { d: c });
  }
  toSvg(e) {
    const t = Vp(e), r = t < 1.5, i = 1 / e.props.scale;
    return /* @__PURE__ */ m.jsx("g", { transform: `scale(${i})`, children: /* @__PURE__ */ m.jsx(
      fC,
      {
        forceSolid: r,
        strokeWidth: t,
        shape: e,
        opacity: h$
      }
    ) });
  }
  toBackgroundSvg(e) {
    const t = Vp(e), r = t < 1.5, i = 1 / e.props.scale;
    return /* @__PURE__ */ m.jsx("g", { transform: `scale(${i})`, children: /* @__PURE__ */ m.jsx(
      fC,
      {
        forceSolid: r,
        strokeWidth: t,
        shape: e,
        opacity: p$
      }
    ) });
  }
  onResize(e, t) {
    const { scaleX: r, scaleY: i } = t, s = [];
    for (const l of e.props.segments)
      s.push({
        ...l,
        points: l.points.map(({ x: c, y: d, z: h }) => ({
          x: r * c,
          y: i * d,
          z: h
        }))
      });
    return {
      props: {
        segments: s
      }
    };
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      ...t.props,
      segments: XW(e.props.segments, t.props.segments, r),
      scale: jn(e.props.scale, t.props.scale, r)
    };
  }
}
U(FC, "type", "highlight"), U(FC, "props", t8), U(FC, "migrations", n8);
function iwe(n) {
  return `M ${n.x} ${n.y} m -${0.1}, 0 a ${0.1},${0.1} 0 1,0 ${0.1 * 2},0 a ${0.1},${0.1} 0 1,0 -${0.1 * 2},0`;
}
function owe(n, e) {
  const t = e / 2;
  return `M ${n.x} ${n.y} m -${t}, 0 a ${t},${t} 0 1,0 ${t * 2},0 a ${t},${t} 0 1,0 -${t * 2},0`;
}
function g$(n, e, t) {
  var d;
  const r = Ly(n.props.segments), i = n.props.isComplete || ((d = jo(n.props.segments)) == null ? void 0 : d.type) === "straight";
  let s = e;
  !t && !n.props.isPen && r.length === 1 && (s += Tc(n.id)() * (e / 6));
  const l = iL({
    strokeWidth: s,
    showAsComplete: i
  });
  return { strokePoints: Ru(r, l), sw: s };
}
function Vp(n) {
  return Dy[n.props.size] * 1.12 * n.props.scale;
}
function dC(n) {
  return n.props.segments.length === 1 && n.props.segments[0].points.length < 2;
}
function fC({
  strokeWidth: n,
  forceSolid: e,
  shape: t,
  opacity: r
}) {
  var v;
  const i = Fl(), s = Ly(t.props.segments);
  let l = n;
  !e && !t.props.isPen && s.length === 1 && (l += Tc(t.id)() * (l / 6));
  const c = iL({
    strokeWidth: l,
    showAsComplete: t.props.isComplete || ((v = jo(t.props.segments)) == null ? void 0 : v.type) === "straight"
  }), d = Ru(s, c), h = d.length > 1 ? lg(d, !1) : iwe(t.props.segments[0].points[0]), g = rwe(), y = i[t.props.color].highlight[g];
  return /* @__PURE__ */ m.jsx(
    "path",
    {
      d: h,
      strokeLinecap: "round",
      fill: "none",
      pointerEvents: "all",
      stroke: y,
      strokeWidth: l,
      opacity: r
    }
  );
}
function iA(n, e) {
  return Pe(
    "forceSolid",
    () => {
      const t = Vp(e), r = n.getZoomLevel();
      return t / r < 1.5;
    },
    [n]
  );
}
function nG() {
  return /* @__PURE__ */ m.jsxs(
    "svg",
    {
      width: "15",
      height: "15",
      viewBox: "0 0 30 30",
      xmlns: "http://www.w3.org/2000/svg",
      fill: "none",
      stroke: "currentColor",
      strokeLinecap: "round",
      strokeLinejoin: "round",
      children: [
        /* @__PURE__ */ m.jsx("path", { d: "M3,11 L3,3 11,3", strokeWidth: "2" }),
        /* @__PURE__ */ m.jsx("path", { d: "M19,27 L27,27 L27,19", strokeWidth: "2" }),
        /* @__PURE__ */ m.jsx("path", { d: "M27,3 L3,27", strokeWidth: "2" })
      ]
    }
  );
}
function rG({
  shapeId: n,
  assetId: e
}) {
  const t = be(), r = !!bw(), i = bce(), s = M.useMemo(() => LE(m$, 500), []), [l, c] = M.useState(() => ({
    asset: e ? t.getAsset(e) ?? null : null,
    url: null
  })), d = M.useRef(!1), h = M.useRef(null);
  return M.useEffect(() => {
    if (!e) return;
    let g = !1, y;
    const v = wc("update state", () => {
      if (!r && t.getCulledShapes().has(n)) return;
      const w = t.getAsset(e);
      if (!w) return;
      const C = t.getShape(n);
      if (!C) return;
      if (!w.props.src) {
        const I = t.getTemporaryAssetPreview(w.id);
        if (I) {
          h.current !== I && (h.current = I, c((k) => ({ ...k, isPlaceholder: !0, url: I })), i());
          return;
        }
      }
      const E = t.getZoomLevel() * (C.props.w / w.props.w);
      function P(I, k) {
        g || h.current !== k && (d.current = !0, h.current = k, c({ asset: I, url: k }), i());
      }
      d.current ? (s(
        t,
        e,
        E,
        r,
        (I) => P(w, I)
      ), y = s.cancel) : m$(t, e, E, r, (I) => P(w, I));
    });
    return () => {
      v(), y == null || y(), g = !0;
    };
  }, [t, e, r, i, n, s]), l;
}
function m$(n, e, t, r, i) {
  n.resolveAssetUrl(e, {
    screenScale: t,
    shouldResolveToOriginal: r
  }).then((s) => {
    i(s);
  });
}
async function swe(n) {
  const t = await (await Eu(n)).blob();
  return yc.blobToDataUrl(t);
}
class zC extends Xy {
  isAspectRatioLocked() {
    return !0;
  }
  canCrop() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      playing: !0,
      url: "",
      crop: null,
      flipX: !1,
      flipY: !1
    };
  }
  onResize(e, t) {
    let r = h_(e, t);
    const { flipX: i, flipY: s } = t.initialShape.props, { scaleX: l, scaleY: c, mode: d } = t;
    if (r = {
      ...r,
      props: {
        ...r.props,
        flipX: l < 0 !== i,
        flipY: c < 0 !== s
      }
    }, !e.props.crop) return r;
    const h = (
      // We used the flip horizontally feature
      // We resized the shape past it's bounds, so it flipped
      d === "scale_shape" && l === -1 || d === "resize_bounds" && i !== r.props.flipX
    ), g = (
      // We used the flip vertically feature
      // We resized the shape past it's bounds, so it flipped
      d === "scale_shape" && c === -1 || d === "resize_bounds" && s !== r.props.flipY
    ), { topLeft: y, bottomRight: v } = e.props.crop;
    return r.props.crop = {
      topLeft: {
        x: h ? 1 - v.x : y.x,
        y: g ? 1 - v.y : y.y
      },
      bottomRight: {
        x: h ? 1 - y.x : v.x,
        y: g ? 1 - y.y : v.y
      }
    }, r;
  }
  component(e) {
    return /* @__PURE__ */ m.jsx(awe, { shape: e });
  }
  indicator(e) {
    return this.editor.getCroppingShapeId() === e.id ? null : /* @__PURE__ */ m.jsx("rect", { width: Se(e.props.w), height: Se(e.props.h) });
  }
  async toSvg(e) {
    if (!e.props.assetId || !this.editor.getAsset(e.props.assetId)) return null;
    let r = await this.editor.resolveAssetUrl(e.props.assetId, {
      shouldResolveToOriginal: !0
    });
    return r ? ((r.startsWith("blob:") || r.startsWith("http") || r.startsWith("/") || r.startsWith("./")) && (r = await swe(r) || ""), /* @__PURE__ */ m.jsx(cwe, { shape: e, src: r })) : null;
  }
  onDoubleClickEdge(e) {
    const t = e.props;
    if (!t || this.editor.getCroppingShapeId() !== e.id)
      return;
    const r = $r(t.crop) || {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    }, i = 1 / (r.bottomRight.x - r.topLeft.x) * e.props.w, s = 1 / (r.bottomRight.y - r.topLeft.y) * e.props.h, l = new R(r.topLeft.x * i, r.topLeft.y * s).rot(e.rotation), c = {
      id: e.id,
      type: e.type,
      x: e.x - l.x,
      y: e.y - l.y,
      props: {
        crop: {
          topLeft: { x: 0, y: 0 },
          bottomRight: { x: 1, y: 1 }
        },
        w: i,
        h: s
      }
    };
    this.editor.updateShapes([c]);
  }
  getInterpolatedProps(e, t, r) {
    function i(s, l) {
      var y, v, w, C;
      if (s.props.crop === null && l.props.crop === null) return null;
      const c = ((y = s.props.crop) == null ? void 0 : y.topLeft) || { x: 0, y: 0 }, d = ((v = s.props.crop) == null ? void 0 : v.bottomRight) || { x: 1, y: 1 }, h = ((w = l.props.crop) == null ? void 0 : w.topLeft) || { x: 0, y: 0 }, g = ((C = l.props.crop) == null ? void 0 : C.bottomRight) || { x: 1, y: 1 };
      return {
        topLeft: { x: jn(c.x, h.x, r), y: jn(c.y, h.y, r) },
        bottomRight: { x: jn(d.x, g.x, r), y: jn(d.y, g.y, r) }
      };
    }
    return {
      ...r > 0.5 ? t.props : e.props,
      w: jn(e.props.w, t.props.w, r),
      h: jn(e.props.h, t.props.h, r),
      crop: i(e, t)
    };
  }
}
U(zC, "type", "image"), U(zC, "props", r8), U(zC, "migrations", i8);
const awe = M.memo(function({ shape: e }) {
  var I;
  const t = be(), { asset: r, url: i } = rG({
    shapeId: e.id,
    assetId: e.props.assetId
  }), s = OH(), [l, c] = M.useState(""), [d, h] = M.useState(null), g = lwe(t, e);
  M.useEffect(() => {
    if (i && g) {
      let k = !1;
      const L = Bx();
      return L.onload = () => {
        if (k) return;
        const O = document.createElement("canvas");
        O.width = L.width, O.height = L.height;
        const z = O.getContext("2d");
        z && (z.drawImage(L, 0, 0), c(O.toDataURL()), h(i));
      }, L.crossOrigin = "anonymous", L.src = i, () => {
        k = !0;
      };
    }
  }, [t, g, s, i]);
  const y = Pe(
    "show crop preview",
    () => e.id === t.getOnlySelectedShapeId() && t.getCroppingShapeId() === e.id && t.isIn("select.crop"),
    [t, e.id]
  ), v = s && (((I = r == null ? void 0 : r.props.mimeType) == null ? void 0 : I.includes("video")) || g), w = iG(e), C = i === d ? null : i, E = v ? l : d;
  if (!i && !(r != null && r.props.src))
    return /* @__PURE__ */ m.jsxs(
      hh,
      {
        id: e.id,
        style: {
          overflow: "hidden",
          width: e.props.w,
          height: e.props.h,
          color: "var(--color-text-3)",
          backgroundColor: "var(--color-low)",
          border: "1px solid var(--color-low-border)"
        },
        children: [
          /* @__PURE__ */ m.jsx(
            "div",
            {
              className: It("tl-image-container", r && "tl-image-container-loading"),
              style: w,
              children: r ? null : /* @__PURE__ */ m.jsx(nG, {})
            }
          ),
          "url" in e.props && e.props.url && /* @__PURE__ */ m.jsx(jy, { url: e.props.url })
        ]
      }
    );
  const P = g ? "anonymous" : void 0;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    y && E && /* @__PURE__ */ m.jsx("div", { style: w, children: /* @__PURE__ */ m.jsx(
      "img",
      {
        className: "tl-image",
        style: { ...Fx(e), opacity: 0.1 },
        crossOrigin: P,
        src: E,
        referrerPolicy: "strict-origin-when-cross-origin",
        draggable: !1
      }
    ) }),
    /* @__PURE__ */ m.jsxs(
      hh,
      {
        id: e.id,
        style: { overflow: "hidden", width: e.props.w, height: e.props.h },
        children: [
          /* @__PURE__ */ m.jsxs("div", { className: It("tl-image-container"), style: w, children: [
            E && /* @__PURE__ */ m.jsx(
              "img",
              {
                className: "tl-image",
                style: Fx(e),
                crossOrigin: P,
                src: E,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: !1
              },
              E
            ),
            C && /* @__PURE__ */ m.jsx(
              "img",
              {
                className: "tl-image",
                style: Fx(e),
                crossOrigin: P,
                src: C,
                referrerPolicy: "strict-origin-when-cross-origin",
                draggable: !1,
                onLoad: () => h(C)
              },
              C
            )
          ] }),
          e.props.url && /* @__PURE__ */ m.jsx(jy, { url: e.props.url })
        ]
      }
    )
  ] });
});
function lwe(n, e) {
  const t = e.props.assetId ? n.getAsset(e.props.assetId) : void 0;
  return t ? "mimeType" in t.props && Ya.isAnimatedImageType(t == null ? void 0 : t.props.mimeType) || "isAnimated" in t.props && t.props.isAnimated : !1;
}
function iG(n) {
  const e = n.props.crop, t = e == null ? void 0 : e.topLeft;
  if (!t)
    return {
      width: n.props.w,
      height: n.props.h
    };
  const r = 1 / (e.bottomRight.x - e.topLeft.x) * n.props.w, i = 1 / (e.bottomRight.y - e.topLeft.y) * n.props.h, s = -t.x * r, l = -t.y * i;
  return {
    transform: `translate(${s}px, ${l}px)`,
    width: r,
    height: i
  };
}
function Fx(n, e) {
  const { flipX: t, flipY: r } = n.props;
  if (!t && !r) return;
  const i = `scale(${t ? -1 : 1}, ${r ? -1 : 1})`;
  return {
    transform: `${e ? `translate(${t ? e.width : 0}px, ${r ? e.height : 0}px)` : ""} ${i}`,
    // in SVG, flipping around the center doesn't work so we use explicit width/height
    transformOrigin: e ? "0 0" : "center center"
  };
}
function cwe({ shape: n, src: e }) {
  const t = Vy(), r = iG(n), i = n.props.crop;
  if (r.transform && i) {
    const { transform: s, width: l, height: c } = r, d = (i.bottomRight.x - i.topLeft.x) * l, h = (i.bottomRight.y - i.topLeft.y) * c, g = [
      new R(0, 0),
      new R(d, 0),
      new R(d, h),
      new R(0, h)
    ], y = Fx(n, { width: l, height: c });
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx("defs", { children: /* @__PURE__ */ m.jsx("clipPath", { id: t, children: /* @__PURE__ */ m.jsx("polygon", { points: g.map((v) => `${v.x},${v.y}`).join(" ") }) }) }),
      /* @__PURE__ */ m.jsx("g", { clipPath: `url(#${t})`, children: /* @__PURE__ */ m.jsx(
        "image",
        {
          href: e,
          width: l,
          height: c,
          style: y ? { ...y, transform: `${s} ${y.transform}` } : { transform: s }
        }
      ) })
    ] });
  } else
    return /* @__PURE__ */ m.jsx(
      "image",
      {
        href: e,
        width: n.props.w,
        height: n.props.h,
        style: Fx(n, { width: n.props.w, height: n.props.h })
      }
    );
}
function oG(n) {
  return {
    size: n,
    thinning: 0.4,
    streamline: 0,
    smoothing: 0.5,
    simulatePressure: !0,
    last: !0
  };
}
function sG(n, e, t) {
  const r = e.vertices, i = oG(t);
  return Ru(r, i);
}
function uwe(n, e, t) {
  const r = oG(t);
  return Xj(
    N_(sG(n, e, t), r),
    r
  );
}
function dwe(n, e, t) {
  const r = uwe(n, e, t);
  return zO(r);
}
function fwe(n, e, t) {
  if (n.props.dash === "draw") {
    const r = sG(n, e, t);
    return lg(r);
  }
  return e.getSvgPathData();
}
function aG(n, e, t) {
  let r = `M ${Yn(e[0])}L`, i = `M ${Yn(e[0])}L`;
  const s = t / 3, l = t * 2, c = Tc(n);
  let d = e[0], h, g = e[0], y;
  const v = e.length;
  for (let w = 0, C = v - 1; w < C; w++) {
    h = e[w + 1], y = R.AddXY(e[w + 1], c() * s, c() * s);
    const E = R.Sub(h, d), P = R.Len(E), I = R.Div(E, P).mul(Math.min(P / 4, l)), k = R.Add(d, I), L = R.Add(h, I.neg()), O = R.Sub(y, g), z = R.Len(O), F = R.Div(O, z).mul(Math.min(z / 4, l)), H = R.Add(g, F), V = R.Add(y, F.neg());
    w === C - 1 ? (r += `${Yn(k)}L ${Yn(h)}`, i += `${Yn(H)}L ${Yn(y)}`) : (r += `${Yn(k)}L ${Yn(L)}Q ${Yn(h)}`, i += `${Yn(H)}L ${Yn(V)}Q ${Yn(y)}`, d = h, g = y);
  }
  return [r, r + i];
}
const hwe = new Cu();
class UC extends Cc {
  hideResizeHandles() {
    return !0;
  }
  hideRotateHandle() {
    return !0;
  }
  hideSelectionBoundsFg() {
    return !0;
  }
  hideSelectionBoundsBg() {
    return !0;
  }
  getDefaultProps() {
    const [e, t] = Vx(2);
    return {
      dash: "draw",
      size: "m",
      color: "black",
      spline: "line",
      points: {
        [e]: { id: e, index: e, x: 0, y: 0 },
        [t]: { id: t, index: t, x: 0.1, y: 0.1 }
      },
      scale: 1
    };
  }
  getGeometry(e) {
    return Ix(e);
  }
  getHandles(e) {
    return hwe.get(e.props, () => {
      const t = Ix(e), r = Tx(e), i = r.map((s) => ({
        ...s,
        id: s.index,
        type: "vertex",
        canSnap: !0
      }));
      for (let s = 0; s < r.length - 1; s++) {
        const l = Hx(r[s].index, r[s + 1].index), d = t.segments[s].midPoint();
        i.push({
          id: l,
          type: "create",
          index: l,
          x: d.x,
          y: d.y,
          canSnap: !0
        });
      }
      return i.sort(gs);
    });
  }
  //   Events
  onResize(e, t) {
    const { scaleX: r, scaleY: i } = t;
    return {
      props: {
        points: lw(e.props.points, (s, { id: l, index: c, x: d, y: h }) => ({
          id: l,
          index: c,
          x: d * r,
          y: h * i
        }))
      }
    };
  }
  onBeforeCreate(e) {
    const {
      props: { points: t }
    } = e, r = Object.keys(t);
    if (r.length < 2)
      return;
    const i = t[r[0]];
    if (r.every((l) => {
      const c = t[l];
      return c.x === i.x && c.y === i.y;
    })) {
      const l = r[r.length - 1];
      return t[l] = {
        ...t[l],
        x: t[l].x + 0.1,
        y: t[l].y + 0.1
      }, e;
    }
  }
  onHandleDrag(e, { handle: t }) {
    if (t.type !== "vertex") return;
    const r = Ec(new R(t.x, t.y), this.editor);
    return {
      ...e,
      props: {
        ...e.props,
        points: {
          ...e.props.points,
          [t.id]: { id: t.id, index: t.index, x: r.x, y: r.y }
        }
      }
    };
  }
  component(e) {
    return /* @__PURE__ */ m.jsx(mh, { children: /* @__PURE__ */ m.jsx(y$, { shape: e }) });
  }
  indicator(e) {
    const t = wu[e.props.size] * e.props.scale, r = Ix(e), { dash: i } = e.props;
    let s;
    if (e.props.spline === "line") {
      const l = r.points;
      if (i === "solid" || i === "dotted" || i === "dashed")
        s = "M" + l[0] + "L" + l.slice(1);
      else {
        const [c] = aG(e.id, l, t);
        s = c;
      }
    } else
      s = fwe(e, r, t);
    return /* @__PURE__ */ m.jsx("path", { d: s });
  }
  toSvg(e) {
    return /* @__PURE__ */ m.jsx(y$, { shouldScale: !0, shape: e });
  }
  getHandleSnapGeometry(e) {
    const t = Tx(e);
    return {
      points: t,
      getSelfSnapPoints: (r) => {
        const i = this.getHandles(e).filter((s) => s.type === "vertex").findIndex((s) => s.id === r.id);
        return t.filter((s, l) => Math.abs(l - i) > 1).map(R.From);
      },
      getSelfSnapOutline: (r) => {
        const i = this.getHandles(e).filter((l) => l.type === "vertex").findIndex((l) => l.id === r.id), s = Ix(e).segments.filter(
          (l, c) => c !== i - 1 && c !== i
        );
        return s.length ? new jl({ children: s }) : null;
      }
    };
  }
  getInterpolatedProps(e, t, r) {
    const i = Tx(e), s = Tx(t), l = [], c = [];
    let d = i6;
    if (i.length > s.length)
      for (let h = 0; h < i.length; h++)
        l[h] = { ...i[h] }, s[h] === void 0 ? c[h] = { ...s[s.length - 1], id: d } : c[h] = { ...s[h], id: d }, d = vu(d);
    else if (s.length > i.length)
      for (let h = 0; h < s.length; h++)
        c[h] = { ...s[h] }, i[h] === void 0 ? l[h] = {
          ...i[i.length - 1],
          id: d
        } : l[h] = { ...i[h], id: d }, d = vu(d);
    else
      for (let h = 0; h < s.length; h++)
        l[h] = i[h], c[h] = s[h];
    return {
      ...r > 0.5 ? t.props : e.props,
      points: Object.fromEntries(
        l.map((h, g) => {
          const y = c[g];
          return [
            h.id,
            {
              ...h,
              x: jn(h.x, y.x, r),
              y: jn(h.y, y.y, r)
            }
          ];
        })
      ),
      scale: jn(e.props.scale, t.props.scale, r)
    };
  }
}
U(UC, "type", "line"), U(UC, "props", o8), U(UC, "migrations", s8);
function Tx(n) {
  return Object.values(n.props.points).sort(gs);
}
function Ix(n) {
  const e = Tx(n).map(R.From);
  switch (n.props.spline) {
    case "cubic":
      return new cfe({ points: e });
    case "line":
      return new Wy({ points: e });
  }
}
function y$({
  shape: n,
  shouldScale: e = !1,
  forceSolid: t = !1
}) {
  const r = Fl(), i = Ix(n), { dash: s, color: l, size: c } = n.props, d = 1 / n.props.scale, h = e ? d : 1, g = wu[c] * n.props.scale;
  if (n.props.spline === "line") {
    if (s === "solid") {
      const y = i.points, v = "M" + y[0] + "L" + y.slice(1);
      return /* @__PURE__ */ m.jsx(
        "path",
        {
          d: v,
          stroke: r[l].solid,
          strokeWidth: g,
          fill: "none",
          transform: `scale(${h})`
        }
      );
    }
    if (s === "dashed" || s === "dotted")
      return /* @__PURE__ */ m.jsx("g", { stroke: r[l].solid, strokeWidth: g, transform: `scale(${h})`, children: i.segments.map((y, v) => {
        const { strokeDasharray: w, strokeDashoffset: C } = t ? { strokeDasharray: "none", strokeDashoffset: "none" } : mc(y.length, g, {
          style: s,
          start: v > 0 ? "outset" : "none",
          end: v < i.segments.length - 1 ? "outset" : "none"
        });
        return /* @__PURE__ */ m.jsx(
          "path",
          {
            strokeDasharray: w,
            strokeDashoffset: C,
            d: y.getSvgPathData(!0),
            fill: "none"
          },
          v
        );
      }) });
    if (s === "draw") {
      const y = i.points, [v, w] = aG(n.id, y, g);
      return /* @__PURE__ */ m.jsx(
        "path",
        {
          d: w,
          stroke: r[l].solid,
          strokeWidth: g,
          fill: "none",
          transform: `scale(${h})`
        }
      );
    }
  }
  if (n.props.spline === "cubic") {
    const y = i.getSvgPathData();
    if (s === "solid")
      return /* @__PURE__ */ m.jsx(
        "path",
        {
          strokeWidth: g,
          stroke: r[l].solid,
          fill: "none",
          d: y,
          transform: `scale(${h})`
        }
      );
    if (s === "dashed" || s === "dotted")
      return /* @__PURE__ */ m.jsx("g", { stroke: r[l].solid, strokeWidth: g, transform: `scale(${h})`, children: i.segments.map((v, w) => {
        const { strokeDasharray: C, strokeDashoffset: E } = mc(
          v.length,
          g,
          {
            style: s,
            start: w > 0 ? "outset" : "none",
            end: w < i.segments.length - 1 ? "outset" : "none",
            forceSolid: t
          }
        );
        return /* @__PURE__ */ m.jsx(
          "path",
          {
            strokeDasharray: C,
            strokeDashoffset: E,
            d: v.getSvgPathData(),
            fill: "none"
          },
          w
        );
      }) });
    if (s === "draw")
      return /* @__PURE__ */ m.jsx(
        "path",
        {
          d: dwe(n, i, g),
          strokeWidth: 1,
          stroke: r[l].solid,
          fill: r[l].solid,
          transform: `scale(${h})`
        }
      );
  }
}
class $C extends Cc {
  canEdit() {
    return !0;
  }
  hideResizeHandles() {
    return !0;
  }
  hideSelectionBoundsFg() {
    return !1;
  }
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      text: "",
      font: "draw",
      align: "middle",
      verticalAlign: "middle",
      labelColor: "black",
      growY: 0,
      fontSizeAdjustment: 0,
      url: "",
      scale: 1
    };
  }
  getGeometry(e) {
    const { labelHeight: t, labelWidth: r } = lG(this.editor, e), { scale: i } = e.props, s = t * i, l = r * i, c = vr * i, d = hC(e);
    return new jl({
      children: [
        new Tu({ width: c, height: d, isFilled: !0 }),
        new Tu({
          x: e.props.align === "start" ? 0 : e.props.align === "end" ? c - l : (c - l) / 2,
          y: e.props.verticalAlign === "start" ? 0 : e.props.verticalAlign === "end" ? d - s : (d - s) / 2,
          width: l,
          height: s,
          isFilled: !0,
          isLabel: !0
        })
      ]
    });
  }
  getHandles(e) {
    const { scale: t } = e.props;
    if (this.editor.getInstanceState().isCoarsePointer) return [];
    const i = this.editor.getZoomLevel();
    if (i * t < 0.25) return [];
    const s = hC(e), l = vr * t, c = kSe / i * t;
    return i * t < 0.5 ? [
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: l / 2,
        y: s + c
      }
    ] : [
      {
        id: "top",
        index: "a1",
        type: "clone",
        x: l / 2,
        y: -c
      },
      {
        id: "right",
        index: "a2",
        type: "clone",
        x: l + c,
        y: s / 2
      },
      {
        id: "bottom",
        index: "a3",
        type: "clone",
        x: l / 2,
        y: s + c
      },
      {
        id: "left",
        index: "a4",
        type: "clone",
        x: -c,
        y: s / 2
      }
    ];
  }
  getText(e) {
    return e.props.text;
  }
  component(e) {
    const {
      id: t,
      type: r,
      props: {
        labelColor: i,
        scale: s,
        color: l,
        font: c,
        size: d,
        align: h,
        text: g,
        verticalAlign: y,
        fontSizeAdjustment: v
      }
    } = e, w = mwe(t), C = Fl(), E = vr * s, P = hC(e), I = Pe(
      "shape rotation",
      () => {
        var z;
        return ((z = this.editor.getShapePageTransform(t)) == null ? void 0 : z.rotation()) ?? 0;
      },
      [this.editor]
    ), k = Pe("zoom", () => this.editor.getZoomLevel() < 0.35 / s, [
      s,
      this.editor
    ]), L = Pe("dark mode", () => this.editor.user.getIsDarkMode(), [this.editor]), O = e.id === this.editor.getOnlySelectedShapeId();
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "div",
        {
          id: t,
          className: "tl-note__container",
          style: {
            width: E,
            height: P,
            backgroundColor: C[l].note.fill,
            borderBottom: k ? L ? `${2 * s}px solid rgb(20, 20, 20)` : `${2 * s}px solid rgb(144, 144, 144)` : "none",
            boxShadow: k ? "none" : ywe(e.id, I, s)
          },
          children: /* @__PURE__ */ m.jsx(
            $_,
            {
              shapeId: t,
              type: r,
              font: c,
              fontSize: (v || Bd[d]) * s,
              lineHeight: Ss.lineHeight,
              align: h,
              verticalAlign: y,
              text: g,
              isNote: !0,
              isSelected: O,
              labelColor: i === "black" ? C[l].note.text : C[i].fill,
              wrap: !0,
              padding: 16 * s,
              onKeyDown: w
            }
          )
        }
      ),
      "url" in e.props && e.props.url && /* @__PURE__ */ m.jsx(jy, { url: e.props.url })
    ] });
  }
  indicator(e) {
    const { scale: t } = e.props;
    return /* @__PURE__ */ m.jsx(
      "rect",
      {
        rx: t,
        width: Se(vr * t),
        height: Se(hC(e))
      }
    );
  }
  toSvg(e, t) {
    e.props.text && t.addExportDef(z_(e.props.font));
    const r = Wd({ isDarkMode: t.isDarkMode }), i = vwe(e);
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx("rect", { x: 5, y: 5, rx: 1, width: vr - 10, height: i.h, fill: "rgba(0,0,0,.1)" }),
      /* @__PURE__ */ m.jsx(
        "rect",
        {
          rx: 1,
          width: vr,
          height: i.h,
          fill: r[e.props.color].note.fill
        }
      ),
      /* @__PURE__ */ m.jsx(
        U_,
        {
          fontSize: e.props.fontSizeAdjustment || Bd[e.props.size],
          font: e.props.font,
          align: e.props.align,
          verticalAlign: e.props.verticalAlign,
          text: e.props.text,
          labelColor: r[e.props.color].note.text,
          bounds: i,
          stroke: !1
        }
      )
    ] });
  }
  onBeforeCreate(e) {
    return v$(this.editor, e);
  }
  onBeforeUpdate(e, t) {
    if (!(e.props.text === t.props.text && e.props.font === t.props.font && e.props.size === t.props.size))
      return v$(this.editor, t);
  }
  onEditEnd(e) {
    const {
      id: t,
      type: r,
      props: { text: i }
    } = e;
    i.trimEnd() !== e.props.text && this.editor.updateShapes([
      {
        id: t,
        type: r,
        props: {
          text: i.trimEnd()
        }
      }
    ]);
  }
  getInterpolatedProps(e, t, r) {
    return {
      ...r > 0.5 ? t.props : e.props,
      scale: jn(e.props.scale, t.props.scale, r)
    };
  }
}
U($C, "type", "note"), U($C, "props", a8), U($C, "migrations", l8);
function v$(n, e) {
  const { labelHeight: t, fontSizeAdjustment: r } = lG(n, e), i = Math.max(0, t - vr);
  if (i !== e.props.growY || r !== e.props.fontSizeAdjustment)
    return {
      ...e,
      props: {
        ...e.props,
        growY: i,
        fontSizeAdjustment: r
      }
    };
}
function pwe(n, e) {
  const { text: t } = e.props;
  if (!t)
    return { labelHeight: Bd[e.props.size] * Ss.lineHeight + kl * 2, labelWidth: 100, fontSizeAdjustment: 0 };
  const r = Bd[e.props.size];
  let i = 0, s = 0, l = vr, c = vr;
  const d = 1;
  do {
    i = Math.min(r, r - s);
    const h = n.textMeasure.measureText(t, {
      ...Ss,
      fontFamily: Kd[e.props.font],
      fontSize: i,
      maxWidth: vr - kl * 2 - d,
      disableOverflowWrapBreaking: !0
    });
    if (l = h.h + kl * 2, c = h.w + kl * 2, i <= 14) {
      const g = n.textMeasure.measureText(t, {
        ...Ss,
        fontFamily: Kd[e.props.font],
        fontSize: i,
        maxWidth: vr - kl * 2 - d
      });
      l = g.h + kl * 2, c = g.w + kl * 2;
      break;
    }
    if (h.scrollWidth.toFixed(0) === h.w.toFixed(0))
      break;
  } while (s++ < 50);
  return {
    labelHeight: l,
    labelWidth: c,
    fontSizeAdjustment: i
  };
}
const gwe = new Cu();
function lG(n, e) {
  return gwe.get(e, () => pwe(n, e));
}
function mwe(n) {
  const e = be(), t = NK();
  return M.useCallback(
    (r) => {
      const i = e.getShape(n);
      if (!i) return;
      const s = r.key === "Tab", l = (r.metaKey || r.ctrlKey) && r.key === "Enter";
      if (s || l) {
        r.preventDefault();
        const c = e.getShapePageTransform(n), d = c.rotation(), h = !!(t.dir === "rtl" || AW(i.props.text)), g = (vr + e.options.adjacentShapeMargin + // If we're growing down, we need to account for the current shape's growY
        (l && !r.shiftKey ? i.props.growY : 0)) * i.props.scale, y = new R(
          s ? r.shiftKey != h ? -1 : 1 : 0,
          l ? r.shiftKey ? -1 : 1 : 0
        ).mul(g).add(F_.clone().mul(i.props.scale)).rot(d).add(c.point()), v = zW(e, i, y, d);
        v && (e.markHistoryStoppingPoint("editing adjacent shape"), PE(
          e,
          v,
          !0
          /* selectAll */
        ));
      }
    },
    [n, e, t.dir]
  );
}
function hC(n) {
  return (vr + n.props.growY) * n.props.scale;
}
function ywe(n, e, t) {
  const r = Tc(n), i = Math.abs(r()) + 0.5, s = Math.cos(e), l = 5 * t, c = 4 * t, d = 6 * t, h = 7 * t;
  return `0px ${l - i}px ${l}px -${l}px rgba(15, 23, 31, .6),
	0px ${(c + i * h) * Math.max(0, s)}px ${d + i * h}px -${c + i * d}px rgba(15, 23, 31, ${(0.3 + i * 0.1).toFixed(2)}), 
	0px ${48 * t}px ${10 * t}px -${10 * t}px inset rgba(15, 23, 44, ${((0.022 + r() * 5e-3) * ((1 + s) / 2)).toFixed(2)})`;
}
function vwe(n) {
  return new Xe(0, 0, vr, vr + n.props.growY);
}
function Swe(n, {
  initialBounds: e,
  scaleX: t,
  scaleY: r,
  newPoint: i
}) {
  const s = Math.max(0.01, Math.min(Math.abs(t), Math.abs(r))), l = new R(0, 0);
  t < 0 && (l.x = -(e.width * s)), r < 0 && (l.y = -(e.height * s));
  const { x: c, y: d } = R.Add(i, l.rot(n.rotation));
  return {
    x: c,
    y: d,
    props: {
      scale: s * n.props.scale
    }
  };
}
const xwe = new Cu();
class BC extends Cc {
  getDefaultProps() {
    return {
      color: "black",
      size: "m",
      w: 8,
      text: "",
      font: "draw",
      textAlign: "start",
      autoSize: !0,
      scale: 1
    };
  }
  getMinDimensions(e) {
    return xwe.get(e.props, (t) => S$(this.editor, t));
  }
  getGeometry(e) {
    const { scale: t } = e.props, { width: r, height: i } = this.getMinDimensions(e);
    return new Tu({
      width: r * t,
      height: i * t,
      isFilled: !0,
      isLabel: !0
    });
  }
  getText(e) {
    return e.props.text;
  }
  canEdit() {
    return !0;
  }
  isAspectRatioLocked() {
    return !0;
  }
  // WAIT NO THIS IS HARD CODED IN THE RESIZE HANDLER
  component(e) {
    const {
      id: t,
      props: { font: r, size: i, text: s, color: l, scale: c, textAlign: d }
    } = e, { width: h, height: g } = this.getMinDimensions(e), y = e.id === this.editor.getOnlySelectedShapeId(), v = Fl(), w = wwe(t);
    return /* @__PURE__ */ m.jsx(
      $_,
      {
        shapeId: t,
        classNamePrefix: "tl-text-shape",
        type: "text",
        font: r,
        fontSize: Dy[i],
        lineHeight: Ss.lineHeight,
        align: d,
        verticalAlign: "middle",
        text: s,
        labelColor: v[l].solid,
        isSelected: y,
        textWidth: h,
        textHeight: g,
        style: {
          transform: `scale(${c})`,
          transformOrigin: "top left"
        },
        wrap: !0,
        onKeyDown: w
      }
    );
  }
  indicator(e) {
    const t = this.editor.getShapeGeometry(e).bounds, r = be();
    return e.props.autoSize && r.getEditingShapeId() === e.id ? null : /* @__PURE__ */ m.jsx("rect", { width: Se(t.width), height: Se(t.height) });
  }
  toSvg(e, t) {
    e.props.text && t.addExportDef(z_(e.props.font));
    const r = this.editor.getShapeGeometry(e).bounds, i = r.width / (e.props.scale ?? 1), s = r.height / (e.props.scale ?? 1), l = Wd(t);
    return /* @__PURE__ */ m.jsx(
      U_,
      {
        fontSize: Dy[e.props.size],
        font: e.props.font,
        align: e.props.textAlign,
        verticalAlign: "middle",
        text: e.props.text,
        labelColor: l[e.props.color].solid,
        bounds: new Xe(0, 0, i, s),
        padding: 0
      }
    );
  }
  onResize(e, t) {
    const { newPoint: r, initialBounds: i, initialShape: s, scaleX: l, handle: c } = t;
    if (t.mode === "scale_shape" || c !== "right" && c !== "left")
      return {
        id: e.id,
        type: e.type,
        ...Swe(e, t)
      };
    {
      const d = Math.max(1, Math.abs(i.width * l)), { x: h, y: g } = l < 0 ? R.Sub(r, R.FromAngle(e.rotation).mul(d)) : r;
      return {
        id: e.id,
        type: e.type,
        x: h,
        y: g,
        props: {
          w: d / s.props.scale,
          autoSize: !1
        }
      };
    }
  }
  onEditEnd(e) {
    const {
      id: t,
      type: r,
      props: { text: i }
    } = e, s = e.props.text.trimEnd();
    s.length === 0 ? this.editor.deleteShapes([e.id]) : s !== e.props.text && this.editor.updateShapes([
      {
        id: t,
        type: r,
        props: {
          text: i.trimEnd()
        }
      }
    ]);
  }
  onBeforeUpdate(e, t) {
    if (!t.props.autoSize) return;
    const r = e.props.size !== t.props.size || e.props.textAlign !== t.props.textAlign || e.props.font !== t.props.font || e.props.scale !== 1 && t.props.scale === 1, i = e.props.text !== t.props.text;
    if (!r && !i) return;
    const s = this.getMinDimensions(e), l = S$(this.editor, t.props), c = s.width * e.props.scale, d = s.height * e.props.scale, h = l.width * t.props.scale, g = l.height * t.props.scale;
    let y;
    switch (t.props.textAlign) {
      case "middle": {
        y = new R((h - c) / 2, i ? 0 : (g - d) / 2);
        break;
      }
      case "end": {
        y = new R(h - c, i ? 0 : (g - d) / 2);
        break;
      }
      default: {
        if (i) break;
        y = new R(0, (g - d) / 2);
        break;
      }
    }
    if (y) {
      y.rot(t.rotation);
      const { x: v, y: w } = t;
      return {
        ...t,
        x: v - y.x,
        y: w - y.y,
        props: { ...t.props, w: h }
      };
    } else
      return {
        ...t,
        props: { ...t.props, w: h }
      };
  }
  // 	todo: The edge doubleclicking feels like a mistake more often than
  //  not, especially on multiline text. Removed June 16 2024
  // override onDoubleClickEdge = (shape: TLTextShape) => {
  // 	// If the shape has a fixed width, set it to autoSize.
  // 	if (!shape.props.autoSize) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				autoSize: true,
  // 			},
  // 		}
  // 	}
  // 	// If the shape is scaled, reset the scale to 1.
  // 	if (shape.props.scale !== 1) {
  // 		return {
  // 			id: shape.id,
  // 			type: shape.type,
  // 			props: {
  // 				scale: 1,
  // 			},
  // 		}
  // 	}
  // }
}
U(BC, "type", "text"), U(BC, "props", c8), U(BC, "migrations", u8);
function S$(n, e) {
  const { font: t, text: r, autoSize: i, size: s, w: l } = e, c = i ? 16 : Math.max(16, l), d = Dy[s], h = i ? null : (
    // `measureText` floors the number so we need to do the same here to avoid issues.
    Math.floor(Math.max(c, l))
  ), g = n.textMeasure.measureText(r, {
    ...Ss,
    fontFamily: Kd[t],
    fontSize: d,
    maxWidth: h
  });
  return i && (g.w += 1), {
    width: Math.max(c, g.w),
    height: Math.max(d, g.h)
  };
}
function wwe(n) {
  const e = be();
  return M.useCallback(
    (t) => {
      if (e.getEditingShapeId() === n)
        switch (t.key) {
          case "Enter": {
            (t.ctrlKey || t.metaKey) && e.complete();
            break;
          }
          case "Tab": {
            wn(t), t.shiftKey ? Oy.unindent(t.currentTarget) : Oy.indent(t.currentTarget);
            break;
          }
        }
    },
    [e, n]
  );
}
class HC extends Xy {
  canEdit() {
    return !0;
  }
  isAspectRatioLocked() {
    return !0;
  }
  getDefaultProps() {
    return {
      w: 100,
      h: 100,
      assetId: null,
      time: 0,
      playing: !0,
      url: ""
    };
  }
  component(e) {
    return /* @__PURE__ */ m.jsx(bwe, { shape: e });
  }
  indicator(e) {
    return /* @__PURE__ */ m.jsx("rect", { width: Se(e.props.w), height: Se(e.props.h) });
  }
  async toSvg(e) {
    const t = await Cwe(this.editor, e);
    return t ? /* @__PURE__ */ m.jsx("image", { href: t, width: e.props.w, height: e.props.h }) : null;
  }
}
U(HC, "type", "video"), U(HC, "props", d8), U(HC, "migrations", f8);
const bwe = M.memo(function({ shape: e }) {
  const t = be(), r = t.getShapeGeometry(e).bounds.w * t.getZoomLevel() >= 110, i = p_(e.id), s = OH(), { Spinner: l } = Br(), { asset: c, url: d } = rG({
    shapeId: e.id,
    assetId: e.props.assetId
  }), h = M.useRef(null), [g, y] = M.useState(!1), [v, w] = M.useState(!1);
  M.useEffect(() => {
    const E = () => w(document.fullscreenElement === h.current);
    return document.addEventListener("fullscreenchange", E), () => document.removeEventListener("fullscreenchange", E);
  });
  const C = M.useCallback((E) => {
    E.currentTarget && y(!0);
  }, []);
  return M.useEffect(() => {
    const E = h.current;
    E && i && document.activeElement !== E && E.focus();
  }, [i, g]), M.useEffect(() => {
    if (s) {
      const E = h.current;
      if (!E) return;
      E.pause(), E.currentTime = 0;
    }
  }, [h, s]), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(
      hh,
      {
        id: e.id,
        style: {
          color: "var(--color-text-3)",
          backgroundColor: c ? "transparent" : "var(--color-low)",
          border: c ? "none" : "1px solid var(--color-low-border)"
        },
        children: /* @__PURE__ */ m.jsx("div", { className: "tl-counter-scaled", children: /* @__PURE__ */ m.jsx("div", { className: "tl-video-container", children: c ? l && !c.props.src ? /* @__PURE__ */ m.jsx(l, {}) : d ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsx(
            "video",
            {
              ref: h,
              style: i ? { pointerEvents: "all" } : g ? void 0 : { display: "none" },
              className: It("tl-video", `tl-video-shape-${e.id.split(":")[1]}`, {
                "tl-video-is-fullscreen": v
              }),
              width: "100%",
              height: "100%",
              draggable: !1,
              playsInline: !0,
              autoPlay: !0,
              muted: !0,
              loop: !0,
              disableRemotePlayback: !0,
              disablePictureInPicture: !0,
              controls: i && r,
              onLoadedData: C,
              hidden: !g,
              children: /* @__PURE__ */ m.jsx("source", { src: d })
            }
          ),
          !g && l && /* @__PURE__ */ m.jsx(l, {})
        ] }) : null : /* @__PURE__ */ m.jsx(nG, {}) }) })
      }
    ),
    "url" in e.props && e.props.url && /* @__PURE__ */ m.jsx(jy, { url: e.props.url })
  ] });
});
async function Cwe(n, e) {
  const t = await n.resolveAssetUrl(e.props.assetId, {
    shouldResolveToOriginal: !0
  });
  if (!t) return null;
  const r = await Ya.loadVideo(t);
  return Ya.getVideoFrameAsDataUrl(r, 0);
}
const cG = [
  BC,
  OC,
  jC,
  NC,
  $C,
  UC,
  LC,
  DC,
  FC,
  OE,
  zC,
  HC
];
function Ewe(n) {
  return n.sideEffects.register({
    instance_page_state: {
      afterChange: (e, t) => {
        if (e.croppingShapeId !== t.croppingShapeId) {
          const r = n.isIn("select.crop");
          !e.croppingShapeId && t.croppingShapeId ? r || n.setCurrentTool("select.crop.idle") : e.croppingShapeId && !t.croppingShapeId && r && n.setCurrentTool("select.idle");
        }
        if (e.editingShapeId !== t.editingShapeId)
          if (!e.editingShapeId && t.editingShapeId) {
            if (!n.isIn("select.editing_shape")) {
              const r = n.getEditingShape();
              r && r.type === "text" && n.isInAny("text.pointing", "select.resizing") && n.getInstanceState().isToolLocked ? n.setCurrentTool("select.editing_shape", {
                isCreatingTextWhileToolLocked: !0
              }) : n.setCurrentTool("select.editing_shape");
            }
          } else e.editingShapeId && !t.editingShapeId && n.isIn("select.editing_shape") && n.setCurrentTool("select.idle");
      }
    }
  });
}
class uG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "scribbleId", "id");
    U(this, "markId", "");
    U(this, "excludedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter(t) {
    this.markId = this.editor.markHistoryStoppingPoint("erase scribble begin"), this.info = t;
    const { originPagePoint: r } = this.editor.inputs;
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter((s) => {
        if (this.editor.isShapeOrAncestorLocked(s)) return !0;
        if (this.editor.isShapeOfType(s, "group") || this.editor.isShapeOfType(s, "frame")) {
          const l = this.editor.getPointInShapeSpace(s, r);
          return this.editor.getShapeGeometry(s).bounds.containsPoint(l);
        }
        return !1;
      }).map((s) => s.id)
    );
    const i = this.editor.scribbles.addScribble({
      color: "muted-1",
      size: 12
    });
    this.scribbleId = i.id, this.update();
  }
  pushPointToScribble() {
    const { x: t, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, t, r);
  }
  onExit() {
    this.editor.setErasingShapes([]), this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { editor: t, excludedShapeIds: r } = this, i = t.getErasingShapeIds(), s = t.getZoomLevel(), l = t.getCurrentPageRenderingShapesSorted(), {
      inputs: { currentPagePoint: c, previousPagePoint: d }
    } = t;
    this.pushPointToScribble();
    const h = new Set(i), g = this.editor.options.hitTestMargin / s;
    for (const y of l) {
      if (t.isShapeOfType(y, "group")) continue;
      const v = t.getShapeMask(y.id);
      if (v && !Ja(c, v))
        continue;
      const w = t.getShapeGeometry(y), C = t.getShapePageTransform(y);
      if (!w || !C) continue;
      const E = C.clone().invert(), P = E.applyToPoint(d), I = E.applyToPoint(c), { bounds: k } = w;
      k.minX - g > Math.max(P.x, I.x) || k.minY - g > Math.max(P.y, I.y) || k.maxX + g < Math.min(P.x, I.x) || k.maxY + g < Math.min(P.y, I.y) || w.hitTestLineSegment(P, I, g) && h.add(t.getOutermostSelectableShape(y).id);
    }
    this.editor.setErasingShapes([...h].filter((y) => !r.has(y)));
  }
  complete() {
    const { editor: t } = this;
    t.deleteShapes(t.getCurrentPageState().erasingShapeIds), this.parent.transition("idle");
  }
  cancel() {
    const { editor: t } = this;
    t.bailToMark(this.markId), this.parent.transition("idle", this.info);
  }
}
U(uG, "id", "erasing");
var EA;
let _we = (EA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(EA, "id", "idle"), EA);
var _A;
let Pwe = (_A = class extends Et {
  onEnter() {
    const e = this.editor.getZoomLevel(), t = this.editor.getCurrentPageRenderingShapesSorted(), {
      inputs: { currentPagePoint: r }
    } = this.editor, i = /* @__PURE__ */ new Set(), s = i.size;
    for (let l = t.length, c = l - 1; c >= 0; c--) {
      const d = t[c];
      if (!(this.editor.isShapeOrAncestorLocked(d) || this.editor.isShapeOfType(d, "group")) && this.editor.isPointInShape(d, r, {
        hitInside: !1,
        margin: this.editor.options.hitTestMargin / e
      })) {
        const h = this.editor.getOutermostSelectableShape(d);
        if (this.editor.isShapeOfType(h, "frame") && i.size > s)
          break;
        i.add(h.id);
      }
    }
    this.editor.setErasingShapes([...i]);
  }
  onLongPress(e) {
    this.startErasing(e);
  }
  onExit(e, t) {
    t !== "erasing" && this.editor.setErasingShapes([]);
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.startErasing(e);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.cancel();
  }
  startErasing(e) {
    this.parent.transition("erasing", e);
  }
  complete() {
    const e = this.editor.getErasingShapeIds();
    e.length && (this.editor.markHistoryStoppingPoint("erase end"), this.editor.deleteShapes(e)), this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}, U(_A, "id", "pointing"), _A);
class VC extends Et {
  static children() {
    return [_we, Pwe, uG];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
U(VC, "id", "eraser"), U(VC, "initial", "idle"), U(VC, "isLockable", !1);
class dG extends Et {
  constructor() {
    super(...arguments);
    U(this, "initialCamera", new R());
  }
  onEnter() {
    this.initialCamera = R.From(this.editor.getCamera()), this.update();
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.parent.transition("idle");
  }
  onComplete() {
    this.complete();
  }
  update() {
    const { initialCamera: t, editor: r } = this, { currentScreenPoint: i, originScreenPoint: s } = r.inputs, l = R.Sub(i, s).div(r.getZoomLevel());
    l.len2() !== 0 && r.setCamera(t.clone().add(l));
  }
  complete() {
    const { editor: t } = this, { pointerVelocity: r } = t.inputs, i = Math.min(r.len(), 2);
    i > 0.1 && this.editor.slideCamera({ speed: i, direction: r }), this.parent.transition("idle");
  }
}
U(dG, "id", "dragging");
var PA;
let Twe = (PA = class extends Et {
  onEnter() {
    this.editor.setCursor({ type: "grab", rotation: 0 });
  }
  onPointerDown(e) {
    this.parent.transition("pointing", e);
  }
  onCancel() {
    this.editor.setCurrentTool("select");
  }
}, U(PA, "id", "idle"), PA);
var TA;
let Iwe = (TA = class extends Et {
  onEnter() {
    this.editor.stopCameraAnimation(), this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onLongPress() {
    this.startDragging();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startDragging();
  }
  startDragging() {
    this.parent.transition("dragging");
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
}, U(TA, "id", "pointing"), TA);
class KC extends Et {
  static children() {
    return [Twe, Iwe, dG];
  }
  onDoubleClick(e) {
    if (e.phase === "settle") {
      const { currentScreenPoint: t } = this.editor.inputs;
      this.editor.zoomIn(t, {
        animation: { duration: 220, easing: po.easeOutQuint }
      });
    }
  }
  onTripleClick(e) {
    if (e.phase === "settle") {
      const { currentScreenPoint: t } = this.editor.inputs;
      this.editor.zoomOut(t, {
        animation: { duration: 320, easing: po.easeOutQuint }
      });
    }
  }
  onQuadrupleClick(e) {
    if (e.phase === "settle") {
      const t = this.editor.getZoomLevel(), {
        inputs: { currentScreenPoint: r }
      } = this.editor;
      t === 1 ? this.editor.zoomToFit({ animation: { duration: 400, easing: po.easeOutQuint } }) : this.editor.resetZoom(r, {
        animation: { duration: 320, easing: po.easeOutQuint }
      });
    }
  }
}
U(KC, "id", "hand"), U(KC, "initial", "idle"), U(KC, "isLockable", !1);
var IA;
let kwe = (IA = class extends Et {
  onPointerDown(e) {
    this.parent.transition("lasering", e);
  }
}, U(IA, "id", "idle"), IA);
class fG extends Et {
  constructor() {
    super(...arguments);
    U(this, "scribbleId", "id");
  }
  onEnter() {
    const t = this.editor.scribbles.addScribble({
      color: "laser",
      opacity: 0.7,
      size: 4,
      delay: this.editor.options.laserDelayMs,
      shrink: 0.05,
      taper: !0
    });
    this.scribbleId = t.id, this.pushPointToScribble();
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.pushPointToScribble();
  }
  onPointerUp() {
    this.complete();
  }
  pushPointToScribble() {
    const { x: t, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, t, r);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  complete() {
    this.parent.transition("idle");
  }
  cancel() {
    this.parent.transition("idle");
  }
}
U(fG, "id", "lasering");
class WC extends Et {
  static children() {
    return [kwe, fG];
  }
  onEnter() {
    this.editor.setCursor({ type: "cross", rotation: 0 });
  }
}
U(WC, "id", "laser"), U(WC, "initial", "idle"), U(WC, "isLockable", !1);
class hG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "initialSelectedShapeIds", []);
    U(this, "excludedShapeIds", /* @__PURE__ */ new Set());
    U(this, "isWrapMode", !1);
    // The shape that the brush started on
    U(this, "initialStartShape", null);
  }
  onEnter(t) {
    const { altKey: r, currentPagePoint: i } = this.editor.inputs;
    if (this.isWrapMode = this.editor.user.getIsWrapMode(), r) {
      this.parent.transition("scribble_brushing", t);
      return;
    }
    this.excludedShapeIds = new Set(
      this.editor.getCurrentPageShapes().filter(
        (s) => this.editor.isShapeOfType(s, "group") || this.editor.isShapeOrAncestorLocked(s)
      ).map((s) => s.id)
    ), this.info = t, this.initialSelectedShapeIds = this.editor.getSelectedShapeIds().slice(), this.initialStartShape = this.editor.getShapesAtPoint(i)[0], this.hitTestShapes();
  }
  onExit() {
    this.initialSelectedShapeIds = [], this.editor.updateInstanceState({ brush: null });
  }
  onTick({ elapsed: t }) {
    const { editor: r } = this;
    r.edgeScrollManager.updateEdgeScrolling(t);
  }
  onPointerMove() {
    this.hitTestShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel(t) {
    this.editor.setSelectedShapes(this.initialSelectedShapeIds), this.parent.transition("idle", t);
  }
  onKeyDown(t) {
    this.editor.inputs.altKey ? this.parent.transition("scribble_brushing", t) : this.hitTestShapes();
  }
  onKeyUp() {
    this.hitTestShapes();
  }
  complete() {
    this.hitTestShapes(), this.parent.transition("idle");
  }
  hitTestShapes() {
    const { editor: t, excludedShapeIds: r, isWrapMode: i } = this, {
      inputs: { originPagePoint: s, currentPagePoint: l, shiftKey: c, ctrlKey: d }
    } = t, h = new Set(c ? this.initialSelectedShapeIds : []), g = i ? !d : d, y = Xe.FromPoints([s, l]), { corners: v } = y;
    let w, C, E, P, I, k;
    const L = t.getCurrentPageRenderingShapesSorted(), O = t.getCurrentPageId();
    e: for (let H = 0, V = L.length; H < V; H++) {
      if (E = L[H], r.has(E.id) || h.has(E.id) || (P = t.getShapePageBounds(E), !P)) continue e;
      if (y.contains(P)) {
        this.handleHit(E, l, O, h, v);
        continue e;
      }
      if (g || t.isShapeOfType(E, "frame"))
        continue e;
      if (y.collides(P)) {
        if (I = t.getShapePageTransform(E), !I) continue e;
        k = I.clone().invert().applyToPoints(v);
        const re = t.getShapeGeometry(E);
        t: for (let q = 0; q < 4; q++)
          if (w = k[q], C = k[(q + 1) % 4], re.hitTestLineSegment(w, C, 0)) {
            this.handleHit(E, l, O, h, v);
            break t;
          }
      }
    }
    const z = t.getInstanceState().brush;
    (!z || !y.equals(z)) && t.updateInstanceState({ brush: { ...y.toJson() } });
    const F = t.getSelectedShapeIds();
    (F.length !== h.size || F.some((H) => !h.has(H))) && t.setSelectedShapes(Array.from(h));
  }
  onInterrupt() {
    this.editor.updateInstanceState({ brush: null });
  }
  handleHit(t, r, i, s, l) {
    if (t.parentId === i) {
      s.add(t.id);
      return;
    }
    const c = this.editor.getOutermostSelectableShape(t), d = this.editor.getShapeMask(c.id);
    d && !GO(d, l) && !Ja(r, d) || s.add(c.id);
  }
}
U(hG, "id", "brushing");
const Ny = {
  bottom: "ns-resize",
  top: "ns-resize",
  left: "ew-resize",
  right: "ew-resize",
  bottom_left: "nesw-resize",
  bottom_right: "nwse-resize",
  top_left: "nwse-resize",
  top_right: "nesw-resize",
  bottom_left_rotate: "swne-rotate",
  bottom_right_rotate: "senw-rotate",
  top_left_rotate: "nwse-rotate",
  top_right_rotate: "nesw-rotate",
  mobile_rotate: "grabbing"
};
class pG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  updateCursor() {
    const t = this.editor.getSelectedShapes(), r = Ny[this.info.handle];
    this.editor.setCursor({
      type: r,
      rotation: t.length === 1 ? this.editor.getSelectionRotation() : 0
    });
  }
  onEnter(t) {
    this.info = t, this.updateCursor();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startResizing();
  }
  onLongPress() {
    this.startResizing();
  }
  startResizing() {
    this.editor.getIsReadonly() || this.parent.transition("resizing", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
U(pG, "id", "pointing_resize_handle");
const Pl = 8;
class sL extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "markId", "");
    U(this, "snapshot", {});
  }
  onEnter(t) {
    this.info = t, this.markId = this.editor.markHistoryStoppingPoint("cropping"), this.snapshot = this.createSnapshot(), this.updateShapes();
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  updateCursor() {
    if (!this.editor.getSelectedShapes()[0]) return;
    const r = Ny[this.info.handle];
    this.editor.setCursor({ type: r, rotation: this.editor.getSelectionRotation() });
  }
  getDefaultCrop() {
    return {
      topLeft: { x: 0, y: 0 },
      bottomRight: { x: 1, y: 1 }
    };
  }
  updateShapes() {
    const { shape: t, cursorHandleOffset: r } = this.snapshot;
    if (!t || !this.editor.getShapeUtil("image")) return;
    const s = t.props, l = this.editor.inputs.currentPagePoint.clone().sub(r), c = this.editor.inputs.originPagePoint.clone().sub(r), d = l.clone().sub(c).rot(-t.rotation), h = s.crop ?? this.getDefaultCrop(), g = $r(h), y = new R(t.x, t.y), v = new R(0, 0), w = 1 / (h.bottomRight.x - h.topLeft.x) * s.w, C = 1 / (h.bottomRight.y - h.topLeft.y) * s.h;
    let E = !1;
    switch (this.info.handle) {
      case "top":
      case "top_left":
      case "top_right": {
        if (C < Pl) break;
        E = !0, g.topLeft.y = g.topLeft.y + d.y / C, C * (g.bottomRight.y - g.topLeft.y) < Pl ? (g.topLeft.y = g.bottomRight.y - Pl / C, v.y = (g.topLeft.y - h.topLeft.y) * C) : g.topLeft.y <= 0 ? (g.topLeft.y = 0, v.y = (g.topLeft.y - h.topLeft.y) * C) : v.y = d.y;
        break;
      }
      case "bottom":
      case "bottom_left":
      case "bottom_right": {
        if (C < Pl) break;
        E = !0, g.bottomRight.y = Math.min(1, g.bottomRight.y + d.y / C), C * (g.bottomRight.y - g.topLeft.y) < Pl && (g.bottomRight.y = g.topLeft.y + Pl / C);
        break;
      }
    }
    switch (this.info.handle) {
      case "left":
      case "top_left":
      case "bottom_left": {
        if (w < Pl) break;
        E = !0, g.topLeft.x = g.topLeft.x + d.x / w, w * (g.bottomRight.x - g.topLeft.x) < Pl ? (g.topLeft.x = g.bottomRight.x - Pl / w, v.x = (g.topLeft.x - h.topLeft.x) * w) : g.topLeft.x <= 0 ? (g.topLeft.x = 0, v.x = (g.topLeft.x - h.topLeft.x) * w) : v.x = d.x;
        break;
      }
      case "right":
      case "top_right":
      case "bottom_right": {
        if (w < Pl) break;
        E = !0, g.bottomRight.x = Math.min(1, g.bottomRight.x + d.x / w), w * (g.bottomRight.x - g.topLeft.x) < Pl && (g.bottomRight.x = g.topLeft.x + Pl / w);
        break;
      }
    }
    if (!E) return;
    y.add(v.rot(t.rotation));
    const P = {
      id: t.id,
      type: t.type,
      x: y.x,
      y: y.y,
      props: {
        crop: g,
        w: (g.bottomRight.x - g.topLeft.x) * w,
        h: (g.bottomRight.y - g.topLeft.y) * C
      }
    };
    this.editor.updateShapes([P]), this.updateCursor();
  }
  complete() {
    this.updateShapes(), Dr(this.editor, [this.snapshot.shape.id]), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  createSnapshot() {
    const t = this.editor.getSelectionRotation(), {
      inputs: { originPagePoint: r }
    } = this.editor, i = this.editor.getOnlySelectedShape(), s = this.editor.getSelectionRotatedPageBounds(), l = R.RotWith(
      s.getHandlePoint(this.info.handle),
      s.point,
      t
    ), c = R.Sub(r, l);
    return {
      shape: i,
      cursorHandleOffset: c
    };
  }
}
U(sL, "id", "cropping");
function gG(n, e = !1) {
  const t = n.getZoomLevel(), {
    inputs: { currentPagePoint: r }
  } = n;
  return (
    // hovered shape at point
    // selected shape at point
    n.getShapeAtPoint(r, {
      hitInside: !1,
      hitLabels: e,
      margin: n.options.hitTestMargin / t,
      renderingOnly: !0
    }) ?? n.getSelectedShapeAtPoint(r)
  );
}
function mG(n, e, t) {
  if (!e)
    throw Error("Needs to translate a cropped shape!");
  const { crop: r } = e.props;
  if (!r)
    return;
  const i = n.inputs.shiftKey ? Math.abs(t.x) < Math.abs(t.y) ? "x" : "y" : null;
  i === "x" ? t.x = 0 : i === "y" && (t.y = 0), t.rot(-e.rotation);
  const s = 1 / (r.bottomRight.x - r.topLeft.x) * e.props.w, l = 1 / (r.bottomRight.y - r.topLeft.y) * e.props.h, c = r.bottomRight.y - r.topLeft.y, d = r.bottomRight.x - r.topLeft.x, h = $r(r);
  return h.topLeft.x = Math.min(1 - d, Math.max(0, h.topLeft.x - t.x / s)), h.topLeft.y = Math.min(1 - c, Math.max(0, h.topLeft.y - t.y / l)), h.bottomRight.x = h.topLeft.x + d, h.bottomRight.y = h.topLeft.y + c, {
    id: e.id,
    type: e.type,
    props: {
      crop: h
    }
  };
}
var kA;
let Rwe = (kA = class extends Et {
  onEnter() {
    this.editor.setCursor({ type: "default", rotation: 0 });
    const e = this.editor.getOnlySelectedShape();
    e && this.editor.setCroppingShape(e.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onCancel() {
    this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
  }
  onPointerDown(e) {
    var t;
    if (e.accelKey) {
      this.cancel(), this.editor.root.handleEvent(e);
      return;
    }
    switch (e.target) {
      case "canvas": {
        const r = gG(this.editor);
        if (r && !this.editor.isShapeOfType(r, "group")) {
          this.onPointerDown({
            ...e,
            shape: r,
            target: "shape"
          });
          return;
        }
        this.cancel(), this.editor.root.handleEvent(e);
        break;
      }
      case "shape": {
        if (e.shape.id === this.editor.getCroppingShapeId()) {
          this.editor.setCurrentTool("select.crop.pointing_crop", e);
          return;
        } else
          (t = this.editor.getShapeUtil(e.shape)) != null && t.canCrop(e.shape) ? (this.editor.setCroppingShape(e.shape.id), this.editor.setSelectedShapes([e.shape.id]), this.editor.setCurrentTool("select.crop.pointing_crop", e)) : (this.cancel(), this.editor.root.handleEvent(e));
        break;
      }
      case "selection": {
        switch (e.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            this.editor.setCurrentTool("select.pointing_rotate_handle", {
              ...e,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            this.editor.setCurrentTool("select.crop.pointing_crop_handle", {
              ...e,
              onInteractionEnd: "select.crop.idle"
            });
            break;
          }
          default:
            this.cancel();
        }
        break;
      }
    }
  }
  onDoubleClick(e) {
    var s;
    if (this.editor.inputs.shiftKey || e.phase !== "up") return;
    const t = this.editor.getCroppingShapeId();
    if (!t) return;
    const r = this.editor.getShape(t);
    if (!r) return;
    const i = this.editor.getShapeUtil(r);
    if (i) {
      if (e.target === "selection") {
        (s = i.onDoubleClickEdge) == null || s.call(i, r);
        return;
      }
      this.cancel(), this.editor.root.handleEvent(e);
    }
  }
  onKeyDown() {
    this.nudgeCroppingImage(!1);
  }
  onKeyRepeat() {
    this.nudgeCroppingImage(!0);
  }
  onKeyUp(e) {
    switch (e.code) {
      case "Enter": {
        this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
        break;
      }
    }
  }
  cancel() {
    this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle", {});
  }
  nudgeCroppingImage(e = !1) {
    const {
      editor: {
        inputs: { keys: t }
      }
    } = this, r = t.has("ShiftLeft"), i = new R(0, 0);
    if (t.has("ArrowLeft") && (i.x += 1), t.has("ArrowRight") && (i.x -= 1), t.has("ArrowUp") && (i.y += 1), t.has("ArrowDown") && (i.y -= 1), i.equals(new R(0, 0))) return;
    r && i.mul(10);
    const s = this.editor.getShape(this.editor.getCroppingShapeId());
    if (!s) return;
    const l = mG(this.editor, s, i);
    l && (e || this.editor.markHistoryStoppingPoint("translate crop"), this.editor.updateShapes([l]));
  }
}, U(kA, "id", "idle"), kA);
class yG extends Et {
  onCancel() {
    this.editor.setCurrentTool("select.crop.idle", {});
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.editor.setCurrentTool("select.crop.translating_crop", e);
  }
  onPointerUp(e) {
    this.editor.setCurrentTool("select.crop.idle", e);
  }
}
U(yG, "id", "pointing_crop");
class aL extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  onEnter(t) {
    this.info = t, this.parent.setCurrentToolIdMask(t.onInteractionEnd);
    const r = this.editor.getSelectedShapes()[0];
    if (!r) return;
    const i = Ny[this.info.handle];
    this.editor.setCursor({ type: i, rotation: this.editor.getSelectionRotation() }), this.editor.setCroppingShape(r.id);
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0);
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startCropping();
  }
  onLongPress() {
    this.startCropping();
  }
  startCropping() {
    this.editor.getIsReadonly() || this.parent.transition("cropping", {
      ...this.info,
      onInteractionEnd: this.info.onInteractionEnd
    });
  }
  onPointerUp() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : (this.editor.setCroppingShape(null), this.editor.setCurrentTool("select.idle"));
  }
}
U(aL, "id", "pointing_crop_handle");
class vG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "markId", "");
    U(this, "snapshot", {});
  }
  onEnter(t) {
    this.info = t, this.snapshot = this.createSnapshot(), this.markId = this.editor.markHistoryStoppingPoint("translating_crop"), this.editor.setCursor({ type: "move", rotation: 0 }), this.updateShapes();
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onKeyDown(t) {
    switch (t.key) {
      case "Alt":
      case "Shift": {
        this.updateShapes();
        return;
      }
    }
  }
  onKeyUp(t) {
    switch (t.key) {
      case "Enter": {
        this.complete();
        return;
      }
      case "Alt":
      case "Shift":
        this.updateShapes();
    }
  }
  complete() {
    this.updateShapes(), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.editor.setCurrentTool("select.crop.idle", this.info);
  }
  createSnapshot() {
    return { shape: this.editor.getOnlySelectedShape() };
  }
  updateShapes() {
    const t = this.snapshot.shape;
    if (!t) return;
    const { originPagePoint: r, currentPagePoint: i } = this.editor.inputs, s = i.clone().sub(r), l = mG(this.editor, t, s);
    l && this.editor.updateShapes([l]);
  }
}
U(vG, "id", "translating_crop");
class FD extends Et {
  constructor() {
    super(...arguments);
    U(this, "markId", "");
    U(this, "didExit", !1);
  }
  static children() {
    return [Rwe, vG, yG, aL, sL];
  }
  onEnter() {
    this.didExit = !1, this.markId = this.editor.markHistoryStoppingPoint("crop");
  }
  onExit() {
    this.didExit || (this.didExit = !0, this.editor.squashToMark(this.markId));
  }
  onCancel() {
    this.didExit || (this.didExit = !0, this.editor.bailToMark(this.markId));
  }
}
U(FD, "id", "crop"), U(FD, "initial", "idle");
class SG extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeId", "");
    U(this, "initialHandle", {});
    U(this, "initialAdjacentHandle", null);
    U(this, "initialPagePoint", {});
    U(this, "markId", "");
    U(this, "initialPageTransform");
    U(this, "initialPageRotation");
    U(this, "info", {});
    U(this, "isPrecise", !1);
    U(this, "isPreciseId", null);
    U(this, "pointingId", null);
    // Only relevant to arrows
    U(this, "exactTimeout", -1);
  }
  onEnter(t) {
    const { shape: r, isCreating: i, creatingMarkId: s, handle: l } = t;
    if (this.info = t, this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.shapeId = r.id, this.markId = "", i)
      if (s)
        this.markId = s;
      else {
        const h = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        h && (this.markId = h);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("dragging handle");
    if (this.initialHandle = $r(l), this.editor.isShapeOfType(r, "line") && this.initialHandle.type === "create") {
      this.editor.updateShape({
        ...r,
        props: {
          points: {
            ...r.props.points,
            [l.index]: { id: l.index, index: l.index, x: l.x, y: l.y }
          }
        }
      });
      const g = this.editor.getShapeHandles(r).find((y) => y.index === l.index);
      this.initialHandle = $r(g);
    }
    this.initialPageTransform = this.editor.getShapePageTransform(r), this.initialPageRotation = this.initialPageTransform.rotation(), this.initialPagePoint = this.editor.inputs.originPagePoint.clone(), this.editor.setCursor({ type: i ? "cross" : "grabbing", rotation: 0 });
    const c = this.editor.getShapeHandles(r).sort(gs), d = c.findIndex((h) => h.id === t.handle.id);
    this.initialAdjacentHandle = null;
    for (let h = d + 1; h < c.length; h++) {
      const g = c[h];
      if (g.type === "vertex" && g.id !== "middle" && g.id !== t.handle.id) {
        this.initialAdjacentHandle = g;
        break;
      }
    }
    if (!this.initialAdjacentHandle)
      for (let h = c.length - 1; h >= 0; h--) {
        const g = c[h];
        if (g.type === "vertex" && g.id !== "middle" && g.id !== t.handle.id) {
          this.initialAdjacentHandle = g;
          break;
        }
      }
    if (this.editor.isShapeOfType(r, "arrow")) {
      const h = wa(this.editor, r)[t.handle.id];
      this.isPrecise = !1, h ? (this.editor.setHintingShapes([h.toId]), this.isPrecise = h.props.isPrecise, this.isPrecise ? this.isPreciseId = h.toId : this.resetExactTimeout()) : this.editor.setHintingShapes([]);
    }
    this.update(), this.editor.select(this.shapeId);
  }
  // Only relevant to arrows
  resetExactTimeout() {
    this.exactTimeout !== -1 && this.clearExactTimeout(), this.exactTimeout = this.editor.timers.setTimeout(() => {
      this.getIsActive() && !this.isPrecise && (this.isPrecise = !0, this.isPreciseId = this.pointingId, this.update()), this.exactTimeout = -1;
    }, 750);
  }
  // Only relevant to arrows
  clearExactTimeout() {
    this.exactTimeout !== -1 && (clearTimeout(this.exactTimeout), this.exactTimeout = -1);
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.update(), this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setHintingShapes([]), this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  complete() {
    this.editor.snaps.clearIndicators(), Dr(this.editor, [this.shapeId]);
    const { onInteractionEnd: t } = this.info;
    if (this.editor.getInstanceState().isToolLocked && t) {
      this.editor.setCurrentTool(t, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.editor.snaps.clearIndicators();
    const { onInteractionEnd: t } = this.info;
    if (t) {
      this.editor.setCurrentTool(t, { shapeId: this.shapeId });
      return;
    }
    this.parent.transition("idle");
  }
  update() {
    var H;
    const { editor: t, shapeId: r, initialPagePoint: i } = this, { initialHandle: s, initialPageRotation: l, initialAdjacentHandle: c } = this, d = this.editor.getHintingShapeIds(), h = this.editor.user.getIsSnapMode(), {
      snaps: g,
      inputs: { currentPagePoint: y, shiftKey: v, ctrlKey: w, altKey: C, pointerVelocity: E }
    } = t, P = this.info.shape, I = t.getShape(r);
    if (!I) return;
    const k = t.getShapeUtil(I);
    let L = y.clone().sub(i).rot(-l).add(s);
    if (v && c && s.id !== "middle") {
      const V = R.Angle(c, L), q = yE(V, 24) - V;
      L = R.RotWith(L, c, q);
    }
    t.snaps.clearIndicators();
    let O = { ...s, x: L.x, y: L.y };
    if (s.canSnap && (h ? !w : w)) {
      if (!t.getShapePageTransform(I.id)) throw Error("Expected a page transform");
      const re = g.handles.snapHandle({ currentShapeId: r, handle: O });
      re && (re.nudge.rot(-t.getShapeParentTransform(I).rotation()), L.add(re.nudge), O = { ...s, x: L.x, y: L.y });
    }
    const z = (H = k.onHandleDrag) == null ? void 0 : H.call(k, I, {
      handle: O,
      isPrecise: this.isPrecise || C,
      initial: P
    }), F = { id: I.id, type: I.type, ...z };
    if (s.type === "vertex" && this.editor.isShapeOfType(I, "arrow")) {
      const V = wa(t, I)[s.id];
      V ? d[0] !== V.toId && (t.setHintingShapes([V.toId]), this.pointingId = V.toId, this.isPrecise = E.len() < 0.5 || C, this.isPreciseId = this.isPrecise ? V.toId : null, this.resetExactTimeout()) : d.length > 0 && (t.setHintingShapes([]), this.pointingId = null, this.isPrecise = !1, this.isPreciseId = null, this.resetExactTimeout());
    }
    z && t.updateShapes([F]);
  }
}
U(SG, "id", "dragging_handle");
function xG(n) {
  return n.isLabel ? [n] : n instanceof jl ? n.children.filter((e) => e.isLabel) : [];
}
class wG extends Et {
  constructor() {
    super(...arguments);
    U(this, "hitShapeForPointerUp", null);
    U(this, "info", {});
  }
  onEnter(t) {
    const r = this.editor.getEditingShape();
    if (!r) throw Error("Entered editing state without an editing shape");
    this.hitShapeForPointerUp = null, this.info = t, t.isCreatingTextWhileToolLocked && this.parent.setCurrentToolIdMask("text"), Nd(this.editor), this.editor.select(r);
  }
  onExit() {
    var s;
    const { editingShapeId: t } = this.editor.getCurrentPageState();
    if (!t) return;
    this.editor.setEditingShape(null), Nd.cancel();
    const r = this.editor.getShape(t), i = this.editor.getShapeUtil(r);
    (s = i.onEditEnd) == null || s.call(i, r), this.info.isCreatingTextWhileToolLocked && (this.parent.setCurrentToolIdMask(void 0), this.editor.setCurrentTool("text", {}));
  }
  onPointerMove(t) {
    if (this.hitShapeForPointerUp && this.editor.inputs.isDragging) {
      if (this.editor.getIsReadonly() || this.hitShapeForPointerUp.isLocked) return;
      this.editor.select(this.hitShapeForPointerUp), this.parent.transition("translating", t), this.hitShapeForPointerUp = null;
      return;
    }
    switch (t.target) {
      case "shape":
      case "canvas": {
        Nd(this.editor);
        return;
      }
    }
  }
  onPointerDown(t) {
    switch (this.hitShapeForPointerUp = null, t.target) {
      case "shape": {
        const { shape: r } = t, i = this.editor.getEditingShape();
        if (!i)
          throw Error("Expected an editing shape!");
        const s = this.editor.getShapeUtil(r).getGeometry(r), l = xG(s), c = l.length === 1 ? l[0] : void 0, d = this.editor.isShapeOfType(i, "text") && i.props.text.trim() === "";
        if (c && !d) {
          const h = this.editor.getPointInShapeSpace(
            r,
            this.editor.inputs.currentPagePoint
          );
          if (c.bounds.containsPoint(h, 0) && c.hitTestPoint(h)) {
            if (r.id === i.id)
              return;
            this.hitShapeForPointerUp = r, this.editor.markHistoryStoppingPoint("editing on pointer up"), this.editor.select(r.id);
            return;
          }
        } else {
          if (r.id === i.id)
            this.editor.isShapeOfType(r, "frame") && (this.editor.setEditingShape(null), this.parent.transition("idle", t));
          else {
            this.parent.transition("pointing_shape", t);
            return;
          }
          return;
        }
        break;
      }
    }
    this.parent.transition("idle", t), this.editor.root.handleEvent(t);
  }
  onPointerUp(t) {
    const r = this.hitShapeForPointerUp;
    if (!r) return;
    this.hitShapeForPointerUp = null;
    const i = this.editor.getShapeUtil(r);
    if (!r.isLocked) {
      if (this.editor.getIsReadonly() && !i.canEditInReadOnly(r)) {
        this.parent.transition("pointing_shape", t);
        return;
      }
      this.editor.select(r.id), this.editor.setEditingShape(r.id), Nd(this.editor);
    }
  }
  onComplete(t) {
    this.parent.transition("idle", t);
  }
  onCancel(t) {
    this.parent.transition("idle", t);
  }
}
U(wG, "id", "editing_shape");
function x$(n) {
  const e = n.getOnlySelectedShape();
  return !!(e && !n.isShapeOrAncestorLocked(e) && n.getShapeUtil(e).canCrop(e));
}
function jE(n, e) {
  const t = n.getSelectedShapeIds(), { currentPagePoint: r } = n.inputs, { shiftKey: i, altKey: s, accelKey: l } = e, c = i || l, d = n.getShapeAtPoint(r, {
    hitInside: !1,
    margin: n.options.hitTestMargin / n.getZoomLevel(),
    hitLabels: !0,
    renderingOnly: !0,
    filter: (h) => !h.isLocked
  });
  if (d) {
    const h = n.getOutermostSelectableShape(d);
    if (c && !s)
      n.cancelDoubleClick(), t.includes(h.id) ? (n.markHistoryStoppingPoint("deselecting shape"), n.deselect(h)) : (n.markHistoryStoppingPoint("shift selecting shape"), n.setSelectedShapes([...t, h.id]));
    else {
      let g;
      h === d || h.id === n.getFocusedGroupId() || t.includes(h.id) ? g = d : g = h, g && !t.includes(g.id) && (n.markHistoryStoppingPoint("selecting shape"), n.select(g.id));
    }
  } else {
    if (c)
      return;
    {
      t.length > 0 && (n.markHistoryStoppingPoint("selecting none"), n.selectNone());
      const h = n.getFocusedGroupId();
      if (va(h)) {
        const g = n.getShape(h);
        n.isPointInShape(g, r, { margin: 0, hitInside: !0 }) || n.setFocusedGroup(null);
      }
    }
  }
}
const Mwe = [
  "Delete",
  "Backspace",
  "[",
  "]",
  "Enter",
  " ",
  "Shift",
  "Tab"
];
var RA;
let Awe = (RA = class extends Et {
  onEnter() {
    this.parent.setCurrentToolIdMask(void 0), Nd(this.editor), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onExit() {
    Nd.cancel();
  }
  onPointerMove() {
    Nd(this.editor);
  }
  onPointerDown(e) {
    const t = e.ctrlKey && x$(this.editor);
    switch (e.target) {
      case "canvas": {
        const r = gG(this.editor);
        if (r && !r.isLocked) {
          this.onPointerDown({
            ...e,
            shape: r,
            target: "shape"
          });
          return;
        }
        const i = this.editor.getSelectedShapeIds(), s = this.editor.getOnlySelectedShape(), {
          inputs: { currentPagePoint: l }
        } = this.editor;
        if ((i.length > 1 || s && !this.editor.getShapeUtil(s).hideSelectionBoundsBg(s)) && w$(this.editor, l)) {
          this.onPointerDown({
            ...e,
            target: "selection"
          });
          return;
        }
        this.parent.transition("pointing_canvas", e);
        break;
      }
      case "shape": {
        const { shape: r } = e;
        if (this.isOverArrowLabelTest(r)) {
          this.parent.transition("pointing_arrow_label", e);
          break;
        }
        if (this.editor.isShapeOrAncestorLocked(r)) {
          this.parent.transition("pointing_canvas", e);
          break;
        }
        this.parent.transition("pointing_shape", e);
        break;
      }
      case "handle": {
        if (this.editor.getIsReadonly()) break;
        this.editor.inputs.altKey ? this.parent.transition("pointing_shape", e) : this.parent.transition("pointing_handle", e);
        break;
      }
      case "selection": {
        switch (e.handle) {
          case "mobile_rotate":
          case "top_left_rotate":
          case "top_right_rotate":
          case "bottom_left_rotate":
          case "bottom_right_rotate": {
            if (e.accelKey) {
              this.parent.transition("brushing", e);
              break;
            }
            this.parent.transition("pointing_rotate_handle", e);
            break;
          }
          case "top":
          case "right":
          case "bottom":
          case "left":
          case "top_left":
          case "top_right":
          case "bottom_left":
          case "bottom_right": {
            if (t)
              this.parent.transition("crop.pointing_crop_handle", e);
            else {
              if (e.accelKey) {
                this.parent.transition("brushing", e);
                break;
              }
              this.parent.transition("pointing_resize_handle", e);
            }
            break;
          }
          default: {
            const r = this.editor.getHoveredShape();
            if (r && !this.editor.getSelectedShapeIds().includes(r.id) && !r.isLocked) {
              this.onPointerDown({
                ...e,
                shape: r,
                target: "shape"
              });
              return;
            }
            this.parent.transition("pointing_selection", e);
          }
        }
        break;
      }
    }
  }
  onDoubleClick(e) {
    var t, r, i, s;
    if (!(this.editor.inputs.shiftKey || e.phase !== "up") && !(e.ctrlKey || e.shiftKey))
      switch (e.target) {
        case "canvas": {
          const l = this.editor.getHoveredShape(), c = l && !this.editor.isShapeOfType(l, "group") ? l : this.editor.getSelectedShapeAtPoint(this.editor.inputs.currentPagePoint) ?? this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
            margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
            hitInside: !1
          }), d = this.editor.getFocusedGroupId();
          if (c) {
            if (this.editor.isShapeOfType(c, "group")) {
              jE(this.editor, e);
              return;
            } else {
              const h = this.editor.getShape(c.parentId);
              if (h && this.editor.isShapeOfType(h, "group") && !(d && h.id === d)) {
                jE(this.editor, e);
                return;
              }
            }
            this.onDoubleClick({
              ...e,
              shape: c,
              target: "shape"
            });
            return;
          }
          this.editor.inputs.shiftKey || this.handleDoubleClickOnCanvas(e);
          break;
        }
        case "selection": {
          if (this.editor.getIsReadonly()) break;
          const l = this.editor.getOnlySelectedShape();
          if (l) {
            const c = this.editor.getShapeUtil(l);
            if (!this.canInteractWithShapeInReadOnly(l))
              return;
            if (e.handle === "right" || e.handle === "left" || e.handle === "top" || e.handle === "bottom") {
              const d = (t = c.onDoubleClickEdge) == null ? void 0 : t.call(c, l);
              if (d) {
                this.editor.markHistoryStoppingPoint("double click edge"), this.editor.updateShapes([d]), Dr(this.editor, [l.id]);
                return;
              }
            }
            if (c.canCrop(l) && !this.editor.isShapeOrAncestorLocked(l)) {
              this.parent.transition("crop", e);
              return;
            }
            this.shouldStartEditingShape(l) && this.startEditingShape(
              l,
              e,
              !0
              /* select all */
            );
          }
          break;
        }
        case "shape": {
          const { shape: l } = e, c = this.editor.getShapeUtil(l);
          if (l.type !== "video" && l.type !== "embed" && this.editor.getIsReadonly()) break;
          if (c.onDoubleClick) {
            const d = (r = c.onDoubleClick) == null ? void 0 : r.call(c, l);
            if (d) {
              this.editor.updateShapes([d]);
              return;
            }
          }
          if (c.canCrop(l) && !this.editor.isShapeOrAncestorLocked(l)) {
            this.editor.markHistoryStoppingPoint("select and crop"), this.editor.select((i = e.shape) == null ? void 0 : i.id), this.parent.transition("crop", e);
            return;
          }
          this.shouldStartEditingShape(l) ? this.startEditingShape(
            l,
            e,
            !0
            /* select all */
          ) : this.handleDoubleClickOnCanvas(e);
          break;
        }
        case "handle": {
          if (this.editor.getIsReadonly()) break;
          const { shape: l, handle: c } = e, d = this.editor.getShapeUtil(l), h = (s = d.onDoubleClickHandle) == null ? void 0 : s.call(d, l, c);
          h ? this.editor.updateShapes([h]) : this.shouldStartEditingShape(l) && this.startEditingShape(
            l,
            e,
            !0
            /* select all */
          );
        }
      }
  }
  onRightClick(e) {
    switch (e.target) {
      case "canvas": {
        const t = this.editor.getHoveredShape(), r = t && !this.editor.isShapeOfType(t, "group") ? t : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
          margin: this.editor.options.hitTestMargin / this.editor.getZoomLevel(),
          hitInside: !1,
          hitLabels: !0,
          hitLocked: !0,
          hitFrameInside: !0,
          renderingOnly: !0
        });
        if (r) {
          this.onRightClick({
            ...e,
            shape: r,
            target: "shape"
          });
          return;
        }
        const i = this.editor.getSelectedShapeIds(), s = this.editor.getOnlySelectedShape(), {
          inputs: { currentPagePoint: l }
        } = this.editor;
        if ((i.length > 1 || s && !this.editor.getShapeUtil(s).hideSelectionBoundsBg(s)) && w$(this.editor, l)) {
          this.onRightClick({
            ...e,
            target: "selection"
          });
          return;
        }
        this.editor.selectNone();
        break;
      }
      case "shape": {
        const { selectedShapeIds: t } = this.editor.getCurrentPageState(), { shape: r } = e, i = this.editor.getOutermostSelectableShape(
          r,
          (s) => !t.includes(s.id)
        );
        !t.includes(i.id) && !this.editor.findShapeAncestor(
          i,
          (s) => t.includes(s.id)
        ) && (this.editor.markHistoryStoppingPoint("selecting shape"), this.editor.setSelectedShapes([i.id]));
        break;
      }
    }
  }
  onCancel() {
    this.editor.getFocusedGroupId() !== this.editor.getCurrentPageId() && this.editor.getSelectedShapeIds().length > 0 ? this.editor.popFocusedGroupId() : (this.editor.markHistoryStoppingPoint("clearing selection"), this.editor.selectNone());
  }
  onKeyDown(e) {
    switch (e.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        this.nudgeSelectedShapes(!1);
        return;
      }
    }
    if (Ei.editOnType.get() && !Mwe.includes(e.key) && !e.altKey && !e.ctrlKey) {
      const t = this.editor.getOnlySelectedShape();
      if (t && // If it's a note shape, then edit on type
      this.editor.isShapeOfType(t, "note") && // If it's not locked or anything
      this.shouldStartEditingShape(t)) {
        this.startEditingShape(
          t,
          {
            ...e,
            target: "shape",
            shape: t
          },
          !0
          /* select all */
        );
        return;
      }
    }
  }
  onKeyRepeat(e) {
    switch (e.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "ArrowUp":
      case "ArrowDown": {
        this.nudgeSelectedShapes(!0);
        break;
      }
    }
  }
  onKeyUp(e) {
    switch (e.code) {
      case "Enter": {
        const t = this.editor.getSelectedShapes();
        if (t.every((i) => this.editor.isShapeOfType(i, "group"))) {
          this.editor.setSelectedShapes(
            t.flatMap((i) => this.editor.getSortedChildIdsForParent(i.id))
          );
          return;
        }
        const r = this.editor.getOnlySelectedShape();
        if (r && this.shouldStartEditingShape(r)) {
          this.startEditingShape(
            r,
            {
              ...e,
              target: "shape",
              shape: r
            },
            !0
            /* select all */
          );
          return;
        }
        x$(this.editor) && this.parent.transition("crop", e);
        break;
      }
    }
  }
  shouldStartEditingShape(e = this.editor.getOnlySelectedShape()) {
    return !e || this.editor.isShapeOrAncestorLocked(e) && e.type !== "embed" || !this.canInteractWithShapeInReadOnly(e) ? !1 : this.editor.getShapeUtil(e).canEdit(e);
  }
  startEditingShape(e, t, r) {
    this.editor.isShapeOrAncestorLocked(e) && e.type !== "embed" || (this.editor.markHistoryStoppingPoint("editing shape"), PE(this.editor, e, r), this.parent.transition("editing_shape", t));
  }
  isOverArrowLabelTest(e) {
    if (!e) return !1;
    const t = this.editor.getPointInShapeSpace(
      e,
      this.editor.inputs.currentPagePoint
    );
    if (this.editor.isShapeOfType(e, "arrow")) {
      const r = this.editor.getShapeGeometry(e).children[1];
      if (r && Ja(t, r.vertices))
        return !0;
    }
    return !1;
  }
  handleDoubleClickOnCanvas(e) {
    if (this.editor.getIsReadonly() || !this.editor.options.createTextOnCanvasDoubleClick) return;
    this.editor.markHistoryStoppingPoint("creating text shape");
    const t = Sr(), { x: r, y: i } = this.editor.inputs.currentPagePoint;
    this.editor.createShapes([
      {
        id: t,
        type: "text",
        x: r,
        y: i,
        props: {
          text: "",
          autoSize: !0
        }
      }
    ]);
    const s = this.editor.getShape(t);
    if (!s) return;
    const l = this.editor.getShapeUtil(s);
    this.editor.getIsReadonly() && !l.canEditInReadOnly(s) || (this.editor.setEditingShape(t), this.editor.select(t), this.parent.transition("editing_shape", e));
  }
  nudgeSelectedShapes(e = !1) {
    const {
      editor: {
        inputs: { keys: t }
      }
    } = this, r = t.has("ShiftLeft"), i = new R(0, 0);
    if (t.has("ArrowLeft") && (i.x -= 1), t.has("ArrowRight") && (i.x += 1), t.has("ArrowUp") && (i.y -= 1), t.has("ArrowDown") && (i.y += 1), i.equals(new R(0, 0))) return;
    e || this.editor.markHistoryStoppingPoint("nudge shapes");
    const { gridSize: s } = this.editor.getDocumentSettings(), l = this.editor.getInstanceState().isGridMode ? r ? s * jwe : s : r ? Dwe : Owe, c = this.editor.getSelectedShapeIds();
    this.editor.nudgeShapes(c, i.mul(l)), Dr(this.editor, c);
  }
  canInteractWithShapeInReadOnly(e) {
    return !!(!this.editor.getIsReadonly() || this.editor.getShapeUtil(e).canEditInReadOnly(e));
  }
}, U(RA, "id", "idle"), RA);
const Dwe = 10, Owe = 1, jwe = 5;
function w$(n, e) {
  const t = n.getSelectionRotatedPageBounds();
  if (!t) return !1;
  const r = n.getSelectionRotation();
  return r ? Ja(
    e,
    t.corners.map((i) => R.RotWith(i, t.point, r))
  ) : t.containsPoint(e);
}
class bG extends Et {
  constructor() {
    super(...arguments);
    U(this, "shapeId", "");
    U(this, "markId", "");
    U(this, "wasAlreadySelected", !1);
    U(this, "didDrag", !1);
    U(this, "didCtrlOnEnter", !1);
    U(this, "info", {});
    U(this, "_labelDragOffset", new R(0, 0));
  }
  updateCursor() {
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onEnter(t) {
    const { shape: r } = t;
    this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.info = t, this.shapeId = r.id, this.didDrag = !1, this.didCtrlOnEnter = t.accelKey, this.wasAlreadySelected = this.editor.getOnlySelectedShapeId() === r.id, this.updateCursor();
    const s = this.editor.getShapeGeometry(r).children[1];
    if (!s)
      throw Error(`Expected to find an arrow label geometry for shape: ${r.id}`);
    const { currentPagePoint: l } = this.editor.inputs, c = this.editor.getPointInShapeSpace(r, l);
    this._labelDragOffset = R.Sub(s.center, c), this.markId = this.editor.markHistoryStoppingPoint("label-drag start"), this.editor.setSelectedShapes([this.shapeId]);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    const { isDragging: t } = this.editor.inputs;
    if (!t) return;
    if (this.didCtrlOnEnter) {
      this.parent.transition("brushing", this.info);
      return;
    }
    const r = this.editor.getShape(this.shapeId);
    if (!r) return;
    const i = xu(this.editor, r), s = this.editor.getShapeGeometry(r), l = s.children[0], c = this.editor.getPointInShapeSpace(
      r,
      this.editor.inputs.currentPagePoint
    ), d = l.nearestPoint(
      R.Add(c, this._labelDragOffset)
    );
    let h;
    if (i.isStraight) {
      const g = R.Dist(i.start.point, i.end.point);
      h = 1 - R.Dist(i.end.point, d) / g;
    } else {
      const { _center: g, measure: y, angleEnd: v, angleStart: w } = s.children[0];
      h = WA(y, w, v, g.angle(d));
    }
    isNaN(h) && (h = 0.5), this.didDrag = !0, this.editor.updateShape({
      id: r.id,
      type: r.type,
      props: { labelPosition: h }
    });
  }
  onPointerUp() {
    const t = this.editor.getShape(this.shapeId);
    t && (this.didDrag || !this.wasAlreadySelected ? this.complete() : this.editor.getIsReadonly() || (this.editor.setEditingShape(t.id), this.editor.setCurrentTool("select.editing_shape")));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
U(bG, "id", "pointing_arrow_label");
class CG extends Et {
  onEnter(e) {
    e.shiftKey || e.accelKey || this.editor.getSelectedShapeIds().length > 0 && (this.editor.markHistoryStoppingPoint("selecting none"), this.editor.selectNone());
  }
  onPointerMove(e) {
    this.editor.inputs.isDragging && this.parent.transition("brushing", e);
  }
  onPointerUp(e) {
    jE(this.editor, e), this.complete();
  }
  onComplete() {
    this.complete();
  }
  onInterrupt() {
    this.parent.transition("idle");
  }
  complete() {
    this.parent.transition("idle");
  }
}
U(CG, "id", "pointing_canvas");
class EG extends Et {
  constructor() {
    super(...arguments);
    U(this, "didCtrlOnEnter", !1);
    U(this, "info", {});
  }
  onEnter(t) {
    this.info = t, this.didCtrlOnEnter = t.accelKey;
    const { shape: r } = t;
    if (this.editor.isShapeOfType(r, "arrow")) {
      const i = wa(this.editor, r)[t.handle.id];
      i && this.editor.setHintingShapes([i.toId]);
    }
    this.editor.setCursor({ type: "grabbing", rotation: 0 });
  }
  onExit() {
    this.editor.setHintingShapes([]), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerUp() {
    const { shape: t, handle: r } = this.info;
    if (this.editor.isShapeOfType(t, "note")) {
      const { editor: i } = this, s = b$(i, t, r, !1);
      if (s) {
        PE(
          i,
          s,
          !0
          /* selectAll */
        );
        return;
      }
    }
    this.parent.transition("idle", this.info);
  }
  onPointerMove(t) {
    const { editor: r } = this;
    r.inputs.isDragging && (this.didCtrlOnEnter ? this.parent.transition("brushing", t) : this.startDraggingHandle());
  }
  onLongPress() {
    this.startDraggingHandle();
  }
  startDraggingHandle() {
    const { editor: t } = this;
    if (t.getIsReadonly()) return;
    const { shape: r, handle: i } = this.info;
    if (t.isShapeOfType(r, "note")) {
      const s = b$(t, r, i, !0);
      if (s) {
        const l = t.getPointInParentSpace(s, t.inputs.originPagePoint).sub(R.Rot(F_.clone().mul(r.props.scale), s.rotation));
        t.updateShape({ ...s, x: l.x, y: l.y }), t.setHoveredShape(s.id).select(s.id).setCurrentTool("select.translating", {
          ...this.info,
          target: "shape",
          shape: t.getShape(s),
          onInteractionEnd: "note",
          isCreating: !0,
          onCreate: () => {
            PE(
              t,
              s,
              !0
              /* selectAll */
            );
          }
        });
        return;
      }
    }
    this.parent.transition("dragging_handle", this.info);
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
U(EG, "id", "pointing_handle");
function b$(n, e, t, r) {
  const i = n.getShapePageTransform(e.id), s = i.point(), l = i.rotation(), d = NW(
    n,
    s,
    l,
    e.props.growY,
    0,
    e.props.scale
  )[t.index];
  if (d)
    return zW(n, e, d, l, r);
}
class _G extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  updateCursor() {
    this.editor.setCursor({
      type: Ny[this.info.handle],
      rotation: this.editor.getSelectionRotation()
    });
  }
  onEnter(t) {
    this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.info = t, this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 });
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.startRotating();
  }
  onLongPress() {
    this.startRotating();
  }
  startRotating() {
    this.editor.getIsReadonly() || this.parent.transition("rotating", this.info);
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  complete() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  cancel() {
    this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
}
U(_G, "id", "pointing_rotate_handle");
class PG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  onEnter(t) {
    this.info = t;
  }
  onPointerUp(t) {
    jE(this.editor, t), this.parent.transition("idle", t);
  }
  onPointerMove(t) {
    this.editor.inputs.isDragging && this.startTranslating(t);
  }
  onLongPress(t) {
    this.startTranslating(t);
  }
  startTranslating(t) {
    this.editor.getIsReadonly() || this.parent.transition("translating", t);
  }
  onDoubleClick(t) {
    var s, l;
    const r = this.editor.getHoveredShape(), i = r && !this.editor.isShapeOfType(r, "group") ? r : this.editor.getShapeAtPoint(this.editor.inputs.currentPagePoint, {
      hitInside: !0,
      margin: 0,
      renderingOnly: !0
    });
    if (i) {
      this.parent.transition("idle"), (l = (s = this.parent).onDoubleClick) == null || l.call(s, {
        ...t,
        target: "shape",
        shape: this.editor.getShape(i)
      });
      return;
    }
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
U(PG, "id", "pointing_selection");
class TG extends Et {
  constructor() {
    super(...arguments);
    U(this, "hitShape", {});
    U(this, "hitShapeForPointerUp", {});
    U(this, "isDoubleClick", !1);
    U(this, "didCtrlOnEnter", !1);
    U(this, "didSelectOnEnter", !1);
  }
  onEnter(t) {
    const r = this.editor.getSelectedShapeIds(), i = this.editor.getSelectionRotatedPageBounds(), s = this.editor.getFocusedGroupId(), {
      inputs: { currentPagePoint: l }
    } = this.editor, { shiftKey: c, altKey: d, accelKey: h } = t;
    this.hitShape = t.shape, this.isDoubleClick = !1, this.didCtrlOnEnter = h;
    const g = this.editor.getOutermostSelectableShape(t.shape), y = this.editor.findShapeAncestor(
      g,
      (v) => r.includes(v.id)
    );
    if (this.didCtrlOnEnter || // If the shape has an onClick handler
    this.editor.getShapeUtil(t.shape).onClick || // ...or if the shape is the focused layer (e.g. group)
    g.id === s || // ...or if the shape is within the selection
    r.includes(g.id) || // ...or if an ancestor of the shape is selected
    y || // ...or if the current point is NOT within the selection bounds
    r.length > 1 && (i != null && i.containsPoint(l))) {
      this.didSelectOnEnter = !1, this.hitShapeForPointerUp = g;
      return;
    }
    this.didSelectOnEnter = !0, c && !d ? (this.editor.cancelDoubleClick(), r.includes(g.id) || (this.editor.markHistoryStoppingPoint("shift selecting shape"), this.editor.setSelectedShapes([...r, g.id]))) : (this.editor.markHistoryStoppingPoint("selecting shape"), this.editor.setSelectedShapes([g.id]));
  }
  onPointerUp(t) {
    var g;
    const r = this.editor.getSelectedShapeIds(), i = this.editor.getFocusedGroupId(), s = this.editor.getZoomLevel(), {
      inputs: { currentPagePoint: l }
    } = this.editor, c = t.shiftKey || t.accelKey, d = this.editor.getShapeAtPoint(l, {
      margin: this.editor.options.hitTestMargin / s,
      hitInside: !0,
      renderingOnly: !0
    }) ?? this.hitShape, h = d ? this.editor.getOutermostSelectableShape(d) : this.hitShapeForPointerUp;
    if (h) {
      const y = this.editor.getShapeUtil(h);
      if (y.onClick) {
        const v = (g = y.onClick) == null ? void 0 : g.call(y, h);
        if (v) {
          this.editor.markHistoryStoppingPoint("shape on click"), this.editor.updateShapes([v]), this.parent.transition("idle", t);
          return;
        }
      }
      if (h.id === i) {
        r.length > 0 ? (this.editor.markHistoryStoppingPoint("clearing shape ids"), this.editor.setSelectedShapes([])) : this.editor.popFocusedGroupId(), this.parent.transition("idle", t);
        return;
      }
    }
    if (!this.didSelectOnEnter) {
      const y = this.editor.getOutermostSelectableShape(
        d,
        // if a group is selected, we want to stop before reaching that group
        // so we can drill down into the group
        (v) => !r.includes(v.id)
      );
      if (r.includes(y.id))
        if (c)
          this.editor.markHistoryStoppingPoint("deselecting on pointer up"), this.editor.deselect(h);
        else if (r.includes(h.id)) {
          if (r.length === 1) {
            const v = this.editor.getShapeUtil(h).getGeometry(h), w = xG(v), C = w.length === 1 ? w[0] : void 0;
            if (C) {
              const E = this.editor.getPointInShapeSpace(
                h,
                l
              );
              if (C.bounds.containsPoint(E, 0) && C.hitTestPoint(E)) {
                this.editor.run(() => {
                  this.editor.markHistoryStoppingPoint("editing on pointer up"), this.editor.select(h.id);
                  const P = this.editor.getShapeUtil(h);
                  this.editor.getIsReadonly() && !P.canEditInReadOnly(h) || (this.editor.setEditingShape(h.id), this.editor.setCurrentTool("select.editing_shape"), this.isDoubleClick && this.editor.emit("select-all-text", { shapeId: h.id }));
                });
                return;
              }
            }
          }
          this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.select(h.id);
        } else
          this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.select(h);
      else if (c) {
        const v = this.editor.getShapeAncestors(y);
        this.editor.markHistoryStoppingPoint("shift deselecting on pointer up"), this.editor.setSelectedShapes([
          ...this.editor.getSelectedShapeIds().filter((w) => !v.find((C) => C.id === w)),
          y.id
        ]);
      } else
        this.editor.markHistoryStoppingPoint("selecting on pointer up"), this.editor.setSelectedShapes([y.id]);
    }
    this.parent.transition("idle", t);
  }
  onDoubleClick() {
    this.isDoubleClick = !0;
  }
  onPointerMove(t) {
    this.editor.inputs.isDragging && (this.didCtrlOnEnter ? this.parent.transition("brushing", t) : this.startTranslating(t));
  }
  onLongPress(t) {
    this.startTranslating(t);
  }
  startTranslating(t) {
    this.editor.getIsReadonly() || (this.editor.focus(), this.parent.transition("translating", t));
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.cancel();
  }
  onInterrupt() {
    this.cancel();
  }
  cancel() {
    this.parent.transition("idle");
  }
}
U(TG, "id", "pointing_shape");
class IG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "markId", "");
    // A switch to detect when the user is holding ctrl
    U(this, "didHoldCommand", !1);
    // we transition into the resizing state from the geo pointing state, which starts with a shape of size w: 1, h: 1,
    // so if the user drags x: +50, y: +50 after mouseDown, the shape will be w: 51, h: 51, which is too many pixels, alas
    // so we allow passing a further offset into this state to negate such issues
    U(this, "creationCursorOffset", { x: 0, y: 0 });
    U(this, "snapshot", {});
  }
  onEnter(t) {
    const { isCreating: r = !1, creatingMarkId: i, creationCursorOffset: s = { x: 0, y: 0 } } = t;
    if (this.info = t, this.didHoldCommand = !1, this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.creationCursorOffset = s, this.snapshot = this._createSnapshot(), this.markId = "", r)
      if (i)
        this.markId = i;
      else {
        const l = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        l && (this.markId = l);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("starting resizing");
    r && this.editor.setCursor({ type: "cross", rotation: 0 }), this.handleResizeStart(), this.updateShapes();
  }
  onTick({ elapsed: t }) {
    const { editor: r } = this;
    r.edgeScrollManager.updateEdgeScrolling(t);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    this.updateShapes();
  }
  onKeyUp() {
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, {}) : this.parent.transition("idle");
  }
  complete() {
    var t, r;
    if (Dr(this.editor, this.snapshot.selectedShapeIds), this.handleResizeEnd(), this.info.isCreating && this.info.onCreate) {
      (r = (t = this.info).onCreate) == null || r.call(t, this.editor.getOnlySelectedShape());
      return;
    }
    if (this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd) {
      this.editor.setCurrentTool(this.info.onInteractionEnd, {});
      return;
    }
    this.parent.transition("idle");
  }
  handleResizeStart() {
    const { shapeSnapshots: t } = this.snapshot, r = [];
    t.forEach(({ shape: i }) => {
      var c;
      const s = this.editor.getShapeUtil(i), l = (c = s.onResizeStart) == null ? void 0 : c.call(s, i);
      l && r.push(l);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  handleResizeEnd() {
    const { shapeSnapshots: t } = this.snapshot, r = [];
    t.forEach(({ shape: i }) => {
      var d;
      const s = this.editor.getShape(i.id), l = this.editor.getShapeUtil(i), c = (d = l.onResizeEnd) == null ? void 0 : d.call(l, i, s);
      c && r.push(c);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateShapes() {
    const { altKey: t, shiftKey: r } = this.editor.inputs, {
      frames: i,
      shapeSnapshots: s,
      selectionBounds: l,
      cursorHandleOffset: c,
      selectedShapeIds: d,
      selectionRotation: h,
      canShapesDeform: g
    } = this.snapshot;
    let y = r || !g;
    if (s.size === 1) {
      const V = [...s.values()][0];
      this.editor.isShapeOfType(V.shape, "text") && (y = !(this.info.handle === "left" || this.info.handle === "right"));
    }
    const { ctrlKey: v } = this.editor.inputs, w = this.editor.inputs.currentPagePoint.clone().sub(c).sub(this.creationCursorOffset), C = this.editor.inputs.originPagePoint.clone().sub(c);
    if (this.editor.getInstanceState().isGridMode && !v) {
      const { gridSize: V } = this.editor.getDocumentSettings();
      w.snapToGrid(V);
    }
    const E = this.info.handle, P = C$(E, Math.PI);
    if (this.editor.snaps.clearIndicators(), (this.editor.user.getIsSnapMode() ? !v : v) && h % Or === 0) {
      const { nudge: V } = this.editor.snaps.shapeBounds.snapResizeShapes({
        dragDelta: R.Sub(w, C),
        initialSelectionPageBounds: this.snapshot.initialSelectionPageBounds,
        handle: C$(E, h),
        isAspectRatioLocked: y,
        isResizingFromCenter: t
      });
      w.add(V);
    }
    const k = R.RotWith(
      t ? l.center : l.getHandlePoint(P),
      l.point,
      h
    ), L = R.Sub(w, k).rot(
      -h
    ), O = R.Sub(C, k).rot(
      -h
    ), z = R.DivV(L, O);
    Number.isFinite(z.x) || (z.x = 1), Number.isFinite(z.y) || (z.y = 1);
    const F = E === "top" || E === "bottom", H = E === "left" || E === "right";
    y ? H ? z.y = Math.abs(z.x) : F ? z.x = Math.abs(z.y) : Math.abs(z.x) > Math.abs(z.y) ? z.y = Math.abs(z.x) * (z.y < 0 ? -1 : 1) : z.x = Math.abs(z.y) * (z.x < 0 ? -1 : 1) : (F && (z.x = 1), H && (z.y = 1)), this.info.isCreating || this.updateCursor({
      dragHandle: E,
      isFlippedX: z.x < 0,
      isFlippedY: z.y < 0,
      rotation: h
    });
    for (const V of s.keys()) {
      const re = s.get(V);
      this.editor.resizeShape(V, z, {
        initialShape: re.shape,
        initialBounds: re.bounds,
        initialPageTransform: re.pageTransform,
        dragHandle: E,
        mode: d.length === 1 && V === d[0] ? "resize_bounds" : "scale_shape",
        scaleOrigin: k,
        isAspectRatioLocked: y,
        scaleAxisRotation: h,
        skipStartAndEndCallbacks: !0
      });
    }
    if (this.editor.inputs.ctrlKey) {
      this.didHoldCommand = !0;
      for (const { id: V, children: re } of i) {
        if (!re.length) continue;
        const q = s.get(V).shape, J = this.editor.getShape(V);
        if (!(q && J)) continue;
        const ie = J.x - q.x, W = J.y - q.y, Y = new R(ie, W).rot(-q.rotation);
        if (Y.x !== 0 || Y.y !== 0)
          for (const oe of re)
            this.editor.updateShape({
              id: oe.id,
              type: oe.type,
              x: oe.x - Y.x,
              y: oe.y - Y.y
            });
      }
    } else if (this.didHoldCommand) {
      this.didHoldCommand = !1;
      for (const { children: V } of i)
        if (V.length)
          for (const re of V)
            this.editor.updateShape({
              id: re.id,
              type: re.type,
              x: re.x,
              y: re.y
            });
    }
  }
  // ---
  updateCursor({
    dragHandle: t,
    isFlippedX: r,
    isFlippedY: i,
    rotation: s
  }) {
    const l = { ...this.editor.getInstanceState().cursor };
    switch (t) {
      case "top_left":
      case "bottom_right": {
        l.type = "nwse-resize", r !== i && (l.type = "nesw-resize");
        break;
      }
      case "top_right":
      case "bottom_left": {
        l.type = "nesw-resize", r !== i && (l.type = "nwse-resize");
        break;
      }
    }
    l.rotation = s, this.editor.setCursor(l);
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.setCursor({ type: "default", rotation: 0 }), this.editor.snaps.clearIndicators();
  }
  _createSnapshot() {
    const t = this.editor.getSelectedShapeIds(), r = this.editor.getSelectionRotation(), {
      inputs: { originPagePoint: i }
    } = this.editor, s = this.editor.getSelectionRotatedPageBounds(), l = R.RotWith(
      s.getHandlePoint(this.info.handle),
      s.point,
      r
    ), c = R.Sub(i, l), d = /* @__PURE__ */ new Map(), h = [];
    t.forEach((y) => {
      const v = this.editor.getShape(y);
      if (v) {
        if (v.type === "frame" && h.push({
          id: y,
          children: rn(
            this.editor.getSortedChildIdsForParent(v).map((w) => this.editor.getShape(w))
          )
        }), d.set(v.id, this._createShapeSnapshot(v)), this.editor.isShapeOfType(v, "frame") && t.length === 1)
          return;
        this.editor.visitDescendants(v.id, (w) => {
          const C = this.editor.getShape(w);
          if (C && (d.set(C.id, this._createShapeSnapshot(C)), this.editor.isShapeOfType(C, "frame")))
            return !1;
        });
      }
    });
    const g = ![...d.values()].some(
      (y) => !Y8(y.pageRotation, r) || y.isAspectRatioLocked
    );
    return {
      shapeSnapshots: d,
      selectionBounds: s,
      cursorHandleOffset: c,
      selectionRotation: r,
      selectedShapeIds: t,
      canShapesDeform: g,
      initialSelectionPageBounds: this.editor.getSelectionPageBounds(),
      frames: h
    };
  }
  _createShapeSnapshot(t) {
    const r = this.editor.getShapePageTransform(t), i = this.editor.getShapeUtil(t);
    return {
      shape: t,
      bounds: this.editor.getShapeGeometry(t).bounds,
      pageTransform: r,
      pageRotation: qe.Decompose(r).rotation,
      isAspectRatioLocked: i.isAspectRatioLocked(t)
    };
  }
}
U(IG, "id", "resizing");
const oA = [
  "top",
  "top_right",
  "right",
  "bottom_right",
  "bottom",
  "bottom_left",
  "left",
  "top_left"
];
function C$(n, e) {
  e = e % hr;
  const t = Math.round(e / (Xn / 4)), r = oA.indexOf(n);
  return oA[(r + t) % oA.length];
}
const E$ = Math.PI / 180;
class kG extends Et {
  constructor() {
    super(...arguments);
    U(this, "snapshot", {});
    U(this, "info", {});
    U(this, "markId", "");
  }
  onEnter(t) {
    this.info = t, this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.markId = this.editor.markHistoryStoppingPoint("rotate start");
    const r = t9({
      editor: this.editor,
      ids: this.editor.getSelectedShapeIds()
    });
    if (!r) return this.parent.transition("idle", this.info);
    this.snapshot = r;
    const i = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    bC({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !1 }),
      snapshot: this.snapshot,
      stage: "start"
    }), this.editor.setCursor({
      type: Ny[this.info.handle],
      rotation: i + this.snapshot.initialShapesRotation
    });
  }
  onExit() {
    this.editor.setCursor({ type: "default", rotation: 0 }), this.parent.setCurrentToolIdMask(void 0), this.snapshot = {};
  }
  onPointerMove() {
    this.update();
  }
  onKeyDown() {
    this.update();
  }
  onKeyUp() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  // ---
  update() {
    const t = this._getRotationFromPointerPosition({
      snapToNearestDegree: !1
    });
    bC({
      editor: this.editor,
      delta: t,
      snapshot: this.snapshot,
      stage: "update"
    }), this.editor.setCursor({
      type: Ny[this.info.handle],
      rotation: t + this.snapshot.initialShapesRotation
    });
  }
  cancel() {
    this.editor.bailToMark(this.markId), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
  }
  complete() {
    bC({
      editor: this.editor,
      delta: this._getRotationFromPointerPosition({ snapToNearestDegree: !0 }),
      snapshot: this.snapshot,
      stage: "end"
    }), Dr(
      this.editor,
      this.snapshot.shapeSnapshots.map((t) => t.shape.id)
    ), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("idle", this.info);
  }
  _getRotationFromPointerPosition({ snapToNearestDegree: t }) {
    const r = this.editor.getSelectionRotation(), i = this.editor.getSelectionRotatedPageBounds(), {
      inputs: { shiftKey: s, currentPagePoint: l }
    } = this.editor, { initialCursorAngle: c, initialShapesRotation: d } = this.snapshot;
    if (!i) return d;
    const g = i.center.clone().rotWith(i.point, r).angle(l) - c;
    let y = d + g;
    if (s)
      y = yE(y, 24);
    else if (t && (y = Math.round(y / E$) * E$, this.editor.getInstanceState().isCoarsePointer)) {
      const v = yE(y, 4), w = SC(y, v);
      Math.abs(w) < ise(5) && (y = v);
    }
    return y - d;
  }
}
U(kG, "id", "rotating");
class RG extends Et {
  constructor() {
    super(...arguments);
    U(this, "hits", /* @__PURE__ */ new Set());
    U(this, "size", 0);
    U(this, "scribbleId", "id");
    U(this, "initialSelectedShapeIds", /* @__PURE__ */ new Set());
    U(this, "newlySelectedShapeIds", /* @__PURE__ */ new Set());
  }
  onEnter() {
    this.initialSelectedShapeIds = new Set(
      this.editor.inputs.shiftKey ? this.editor.getSelectedShapeIds() : []
    ), this.newlySelectedShapeIds = /* @__PURE__ */ new Set(), this.size = 0, this.hits.clear();
    const t = this.editor.scribbles.addScribble({
      color: "selection-stroke",
      opacity: 0.32,
      size: 12
    });
    this.scribbleId = t.id, this.updateScribbleSelection(!0), this.editor.updateInstanceState({ brush: null });
  }
  onExit() {
    this.editor.scribbles.stop(this.scribbleId);
  }
  onPointerMove() {
    this.updateScribbleSelection(!0);
  }
  onPointerUp() {
    this.complete();
  }
  onKeyDown() {
    this.updateScribbleSelection(!1);
  }
  onKeyUp() {
    this.editor.inputs.altKey ? this.updateScribbleSelection(!1) : this.parent.transition("brushing");
  }
  onCancel() {
    this.cancel();
  }
  onComplete() {
    this.complete();
  }
  pushPointToScribble() {
    const { x: t, y: r } = this.editor.inputs.currentPagePoint;
    this.editor.scribbles.addPoint(this.scribbleId, t, r);
  }
  updateScribbleSelection(t) {
    const { editor: r } = this, i = this.editor.getCurrentPageRenderingShapesSorted(), {
      inputs: { shiftKey: s, originPagePoint: l, previousPagePoint: c, currentPagePoint: d }
    } = this.editor, { newlySelectedShapeIds: h, initialSelectedShapeIds: g } = this;
    t && this.pushPointToScribble();
    const y = i;
    let v, w, C, E;
    const P = 0;
    for (let L = 0, O = y.length; L < O; L++) {
      if (v = y[L], r.isShapeOfType(v, "group") || h.has(v.id) || r.isShapeOrAncestorLocked(v) || (w = r.getShapeGeometry(v), r.isShapeOfType(v, "frame") && w.bounds.containsPoint(r.getPointInShapeSpace(v, l))))
        continue;
      const z = r.getShapePageTransform(v);
      if (!w || !z) continue;
      const F = z.clone().invert();
      C = F.applyToPoint(c), E = F.applyToPoint(d);
      const { bounds: H } = w;
      if (!(H.minX - P > Math.max(C.x, E.x) || H.minY - P > Math.max(C.y, E.y) || H.maxX + P < Math.min(C.x, E.x) || H.maxY + P < Math.min(C.y, E.y)) && w.hitTestLineSegment(C, E, P)) {
        const V = this.editor.getOutermostSelectableShape(v), re = this.editor.getShapeMask(V.id);
        if (re && KO(
          c,
          d,
          re
        ) !== null && !Ja(d, re))
          continue;
        h.add(V.id);
      }
    }
    const I = r.getSelectedShapeIds(), k = new Set(
      s ? [...h, ...g] : [...h]
    );
    (I.length !== k.size || I.some((L) => !k.has(L))) && this.editor.setSelectedShapes(Array.from(k));
  }
  complete() {
    this.updateScribbleSelection(!0), this.parent.transition("idle");
  }
  cancel() {
    this.editor.setSelectedShapes([...this.initialSelectedShapeIds]), this.parent.transition("idle");
  }
}
U(RG, "id", "scribble_brushing");
var Lwe = Object.create, MG = Object.defineProperty, Nwe = Object.getOwnPropertyDescriptor, Fwe = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), AG = (n) => {
  throw TypeError(n);
}, DG = (n, e, t) => e in n ? MG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, zwe = (n) => [, , , Lwe(null)], OG = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], jG = (n) => n !== void 0 && typeof n != "function" ? AG("Function expected") : n, Uwe = (n, e, t, r, i) => ({ kind: OG[n], name: e, metadata: r, addInitializer: (s) => t._ ? AG("Already initialized") : i.push(jG(s || null)) }), $we = (n, e) => DG(e, Fwe("metadata"), n[3]), Bwe = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Hwe = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = OG[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Nwe(i, t)), I = r.length - 1; I >= 0; I--)
    d = Uwe(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, jG(l) && (P[C] = l);
  return P && MG(i, t, P), i;
}, sA = (n, e, t) => DG(n, typeof e != "symbol" ? e + "" : e, t), LG, H_;
const Vwe = 20, Kwe = 100;
LG = [Ca];
class lL {
  constructor(e) {
    this.editor = e, Bwe(H_, 5, this), sA(this, "prevDroppingShapeId", null), sA(this, "droppingNodeTimer", null), sA(this, "first", !0), e.disposables.add(this.dispose);
  }
  updateDroppingNode(e, t) {
    var r;
    this.first && (this.editor.setHintingShapes(
      e.map((i) => this.editor.findShapeAncestor(i, (s) => s.type !== "group")).filter((i) => i)
    ), this.prevDroppingShapeId = ((r = this.editor.getDroppingOverShape(this.editor.inputs.originPagePoint, e)) == null ? void 0 : r.id) ?? null, this.first = !1), this.droppingNodeTimer === null ? this.setDragTimer(e, Vwe, t) : this.editor.inputs.pointerVelocity.len() > 0.5 && (clearTimeout(this.droppingNodeTimer), this.setDragTimer(e, Kwe, t));
  }
  setDragTimer(e, t, r) {
    this.droppingNodeTimer = this.editor.timers.setTimeout(() => {
      this.editor.run(() => {
        this.handleDrag(this.editor.inputs.currentPagePoint, e, r);
      }), this.droppingNodeTimer = null;
    }, t);
  }
  handleDrag(e, t, r) {
    var d, h, g, y, v;
    t = rn(t.map((w) => this.editor.getShape(w.id)));
    const i = ((d = this.editor.getDroppingOverShape(e, t)) == null ? void 0 : d.id) ?? null;
    if (i === this.prevDroppingShapeId) {
      this.hintParents(t);
      return;
    }
    const { prevDroppingShapeId: s } = this, l = s && this.editor.getShape(s), c = i && this.editor.getShape(i);
    l && ((g = (h = this.editor.getShapeUtil(l)).onDragShapesOut) == null || g.call(h, l, t)), c && ((v = (y = this.editor.getShapeUtil(c)).onDragShapesOver) == null || v.call(y, c, t)), this.hintParents(t), r == null || r(), this.prevDroppingShapeId = i;
  }
  hintParents(e) {
    const t = /* @__PURE__ */ new Map();
    for (const i of e) {
      const s = this.editor.findShapeAncestor(i, (l) => l.type !== "group");
      s && (t.has(s.id) || t.set(s.id, []), t.get(s.id).push(i.id));
    }
    const r = [];
    for (const [i, s] of t) {
      const l = this.editor.getShape(i);
      l && OK(this.editor, l).length < s.length && r.push(l.id);
    }
    this.editor.setHintingShapes(r);
  }
  dropShapes(e) {
    var r, i;
    const { prevDroppingShapeId: t } = this;
    if (this.handleDrag(this.editor.inputs.currentPagePoint, e), t) {
      const s = this.editor.getShape(t);
      if (!s) return;
      (i = (r = this.editor.getShapeUtil(s)).onDropShapesOver) == null || i.call(r, s, e);
    }
  }
  clear() {
    this.prevDroppingShapeId = null, this.droppingNodeTimer !== null && clearTimeout(this.droppingNodeTimer), this.droppingNodeTimer = null, this.editor.setHintingShapes([]), this.first = !0;
  }
  dispose() {
    this.clear();
  }
}
H_ = zwe();
Hwe(H_, 1, "dispose", LG, lL);
$we(H_, lL);
var Wwe = Object.create, NG = Object.defineProperty, Gwe = Object.getOwnPropertyDescriptor, FG = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), zG = (n) => {
  throw TypeError(n);
}, UG = (n, e, t) => e in n ? NG(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, qwe = (n) => [, , , Wwe((n == null ? void 0 : n[FG("metadata")]) ?? null)], $G = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], BG = (n) => n !== void 0 && typeof n != "function" ? zG("Function expected") : n, Ywe = (n, e, t, r, i) => ({ kind: $G[n], name: e, metadata: r, addInitializer: (s) => t._ ? zG("Already initialized") : i.push(BG(s || null)) }), Xwe = (n, e) => UG(e, FG("metadata"), n[3]), Zwe = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Qwe = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = $G[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, Gwe(i, t)), I = r.length - 1; I >= 0; I--)
    d = Ywe(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, BG(l) && (P[C] = l);
  return P && NG(i, t, P), i;
}, rh = (n, e, t) => UG(n, typeof e != "symbol" ? e + "" : e, t), HG, zD, V_;
class K_ extends (zD = Et, HG = [Ca], zD) {
  constructor() {
    super(...arguments), Zwe(V_, 5, this), rh(this, "info", {}), rh(this, "selectionSnapshot", {}), rh(this, "snapshot", {}), rh(this, "markId", ""), rh(this, "isCloning", !1), rh(this, "isCreating", !1), rh(this, "dragAndDropManager", new lL(this.editor));
  }
  onCreate(e) {
  }
  onEnter(e) {
    var s;
    const { isCreating: t = !1, creatingMarkId: r, onCreate: i = () => {
    } } = e;
    if (!((s = this.editor.getSelectedShapeIds()) != null && s.length)) {
      this.parent.transition("idle");
      return;
    }
    if (this.info = e, this.parent.setCurrentToolIdMask(e.onInteractionEnd), this.isCreating = t, this.markId = "", t)
      if (r)
        this.markId = r;
      else {
        const l = this.editor.getMarkIdMatching(
          `creating:${this.editor.getOnlySelectedShapeId()}`
        );
        l && (this.markId = l);
      }
    else
      this.markId = this.editor.markHistoryStoppingPoint("translating");
    if (this.onCreate = i, this.isCloning = !1, this.info = e, this.editor.setCursor({ type: "move", rotation: 0 }), this.selectionSnapshot = _$(this.editor), !this.isCreating && this.editor.inputs.altKey) {
      this.startCloning();
      return;
    }
    this.snapshot = this.selectionSnapshot, this.handleStart(), this.updateShapes();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.selectionSnapshot = {}, this.snapshot = {}, this.editor.snaps.clearIndicators(), this.editor.setCursor({ type: "default", rotation: 0 }), this.dragAndDropManager.clear();
  }
  onTick({ elapsed: e }) {
    const { editor: t } = this;
    this.dragAndDropManager.updateDroppingNode(
      this.snapshot.movingShapes,
      this.updateParentTransforms
    ), t.edgeScrollManager.updateEdgeScrolling(e);
  }
  onPointerMove() {
    this.updateShapes();
  }
  onKeyDown() {
    if (this.editor.inputs.altKey && !this.isCloning) {
      this.startCloning();
      return;
    }
    this.updateShapes();
  }
  onKeyUp() {
    if (!this.editor.inputs.altKey && this.isCloning) {
      this.stopCloning();
      return;
    }
    this.updateShapes();
  }
  onPointerUp() {
    this.complete();
  }
  onComplete() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  startCloning() {
    this.isCreating || (this.isCloning = !0, this.reset(), this.markId = this.editor.markHistoryStoppingPoint("translate cloning"), this.editor.duplicateShapes(Array.from(this.editor.getSelectedShapeIds())), this.snapshot = _$(this.editor), this.handleStart(), this.updateShapes());
  }
  stopCloning() {
    this.isCloning = !1, this.snapshot = this.selectionSnapshot, this.reset(), this.markId = this.editor.markHistoryStoppingPoint("translate"), this.updateShapes();
  }
  reset() {
    this.editor.bailToMark(this.markId);
  }
  complete() {
    var e;
    this.updateShapes(), this.dragAndDropManager.dropShapes(this.snapshot.movingShapes), Dr(
      this.editor,
      this.snapshot.movingShapes.map((t) => t.id)
    ), this.handleEnd(), this.editor.getInstanceState().isToolLocked && this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.isCreating ? (e = this.onCreate) == null || e.call(this, this.editor.getOnlySelectedShape()) : this.parent.transition("idle");
  }
  cancel() {
    this.reset(), this.info.onInteractionEnd ? this.editor.setCurrentTool(this.info.onInteractionEnd) : this.parent.transition("idle", this.info);
  }
  handleStart() {
    const { movingShapes: e } = this.snapshot, t = [];
    e.forEach((r) => {
      var l;
      const i = this.editor.getShapeUtil(r), s = (l = i.onTranslateStart) == null ? void 0 : l.call(i, r);
      s && t.push(s);
    }), t.length > 0 && this.editor.updateShapes(t), this.editor.setHoveredShape(null);
  }
  handleEnd() {
    const { movingShapes: e } = this.snapshot;
    if (this.isCloning && e.length > 0) {
      const r = R.Average(
        e.map((s) => this.editor.getShapePageTransform(s.id).point())
      ), i = R.Sub(r, this.selectionSnapshot.averagePagePoint);
      R.IsNaN(i) || this.editor.updateInstanceState({
        duplicateProps: {
          shapeIds: e.map((s) => s.id),
          offset: { x: i.x, y: i.y }
        }
      });
    }
    const t = [];
    e.forEach((r) => {
      var c;
      const i = this.editor.getShape(r.id), s = this.editor.getShapeUtil(r), l = (c = s.onTranslateEnd) == null ? void 0 : c.call(s, r, i);
      l && t.push(l);
    }), t.length > 0 && this.editor.updateShapes(t);
  }
  updateShapes() {
    const { snapshot: e } = this;
    this.dragAndDropManager.updateDroppingNode(e.movingShapes, this.updateParentTransforms), Jwe({
      editor: this.editor,
      snapshot: e
    });
    const { movingShapes: t } = e, r = [];
    t.forEach((i) => {
      var d;
      const s = this.editor.getShape(i.id), l = this.editor.getShapeUtil(i), c = (d = l.onTranslate) == null ? void 0 : d.call(l, i, s);
      c && r.push(c);
    }), r.length > 0 && this.editor.updateShapes(r);
  }
  updateParentTransforms() {
    const {
      editor: e,
      snapshot: { shapeSnapshots: t }
    } = this;
    t.forEach((r) => {
      const i = e.getShape(r.shape.id);
      if (!i) return null;
      const s = ga(i.parentId) ? null : qe.Inverse(e.getShapePageTransform(i.parentId));
      r.parentTransform = s;
    });
  }
}
V_ = qwe(zD);
Qwe(V_, 1, "updateParentTransforms", HG, K_);
Xwe(V_, K_);
rh(K_, "id", "translating");
function _$(n) {
  var y;
  const e = [], t = [], r = n.getSelectedShapeIds(), i = rn(
    r.map((v) => {
      const w = n.getShape(v);
      if (!w) return null;
      e.push(w);
      const C = n.getShapePageTransform(v), E = C.point(), P = C.rotation();
      t.push(E);
      const I = rl.isId(w.parentId) ? null : qe.Inverse(n.getShapePageTransform(w.parentId));
      return {
        shape: w,
        pagePoint: E,
        pageRotation: P,
        parentTransform: I
      };
    })
  ), s = n.getOnlySelectedShape();
  let l = [];
  if (s)
    l = n.snaps.shapeBounds.getSnapPoints(s.id);
  else {
    const v = n.getSelectionPageBounds();
    v && (l = v.cornersAndCenter.map((w, C) => ({
      id: "selection:" + C,
      x: w.x,
      y: w.y
    })));
  }
  let c, d;
  const { originPagePoint: h } = n.inputs, g = i.filter(
    (v) => n.isShapeOfType(v.shape, "note") && n.isPointInShape(v.shape, h)
  );
  if (g.length !== 0) if (g.length === 1)
    d = g[0];
  else {
    const v = n.getCurrentPageShapesSorted();
    d = (y = g.map((w) => ({
      snapshot: w,
      index: v.findIndex((C) => C.id === w.shape.id)
    })).sort((w, C) => C.index - w.index)[0]) == null ? void 0 : y.snapshot;
  }
  return d && (c = FW(
    n,
    d.pageRotation,
    d.shape.props.scale,
    d.shape.props.growY ?? 0
  )), {
    averagePagePoint: R.Average(t),
    movingShapes: e,
    shapeSnapshots: i,
    initialPageBounds: n.getSelectionPageBounds(),
    initialSnapPoints: l,
    noteAdjacentPositions: c,
    noteSnapshot: d
  };
}
function Jwe({
  editor: n,
  snapshot: e
}) {
  const { inputs: t } = n, {
    noteSnapshot: r,
    noteAdjacentPositions: i,
    initialPageBounds: s,
    initialSnapPoints: l,
    shapeSnapshots: c,
    averagePagePoint: d
  } = e, h = n.getInstanceState().isGridMode, g = n.getDocumentSettings().gridSize, y = R.Sub(t.currentPagePoint, t.originPagePoint), v = n.inputs.shiftKey ? Math.abs(y.x) < Math.abs(y.y) ? "x" : "y" : null;
  v === "x" ? y.x = 0 : v === "y" && (y.y = 0), n.snaps.clearIndicators();
  const w = n.user.getIsSnapMode() ? !t.ctrlKey : t.ctrlKey;
  let C = !1;
  if (w && n.inputs.pointerVelocity.len() < 0.5) {
    const { nudge: k } = n.snaps.shapeBounds.snapTranslateShapes({
      dragDelta: y,
      initialSelectionPageBounds: s,
      lockedAxis: v,
      initialSelectionSnapPoints: l
    });
    y.add(k);
  } else if (r && i) {
    const { scale: k } = r.shape.props, L = r.pagePoint.clone().add(y).add(F_.clone().mul(k).rot(r.pageRotation));
    let O = LW / n.getZoomLevel(), z = new R(0, 0);
    for (const F of i) {
      const H = R.Sub(L, F), V = H.len();
      V < O && (C = !0, O = V, z = H);
    }
    y.sub(z);
  }
  const E = R.Add(d, y), P = n.snaps.getIndicators();
  h && !t.ctrlKey && !C && P.length === 0 && E.snapToGrid(g);
  const I = R.Sub(E, d);
  n.updateShapes(
    rn(
      c.map(({ shape: k, pagePoint: L, parentTransform: O }) => {
        const z = R.Add(L, I), F = O ? qe.applyToPoint(O, z) : z;
        return {
          id: k.id,
          type: k.type,
          x: F.x,
          y: F.y
        };
      })
    )
  );
}
var ebe = {};
class GC extends Et {
  constructor() {
    super(...arguments);
    U(this, "reactor");
  }
  static children() {
    return [
      FD,
      sL,
      Awe,
      CG,
      TG,
      K_,
      hG,
      RG,
      aL,
      PG,
      pG,
      wG,
      IG,
      kG,
      _G,
      bG,
      EG,
      SG
    ];
  }
  // We want to clean up the duplicate props when the selection changes
  cleanUpDuplicateProps() {
    const t = this.editor.getSelectedShapeIds(), r = this.editor.getInstanceState();
    if (!r.duplicateProps) return;
    const i = new Set(r.duplicateProps.shapeIds);
    t.length === i.size && t.every((s) => i.has(s)) || this.editor.updateInstanceState({
      duplicateProps: null
    });
  }
  onEnter() {
    this.reactor = wc("clean duplicate props", () => {
      try {
        this.cleanUpDuplicateProps();
      } catch (t) {
        typeof process < "u" && ebe.NODE_ENV === "test" || console.error(t);
      }
    });
  }
  onExit() {
    var t;
    (t = this.reactor) == null || t.call(this), this.editor.getCurrentPageState().editingShapeId && this.editor.setEditingShape(null);
  }
}
U(GC, "id", "select"), U(GC, "initial", "idle"), U(GC, "isLockable", !1);
class VG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  onEnter(t) {
    this.info = t;
  }
  onPointerDown() {
    this.parent.transition("pointing", this.info);
  }
}
U(VG, "id", "idle");
class KG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  onEnter(t) {
    this.info = t;
  }
  onPointerUp() {
    this.complete();
  }
  onPointerMove() {
    this.editor.inputs.isDragging && this.parent.transition("zoom_brushing", this.info);
  }
  onCancel() {
    this.cancel();
  }
  complete() {
    const { currentScreenPoint: t } = this.editor.inputs;
    this.editor.inputs.altKey ? this.editor.zoomOut(t, { animation: { duration: 220 } }) : this.editor.zoomIn(t, { animation: { duration: 220 } }), this.parent.transition("idle", this.info);
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
}
U(KG, "id", "pointing");
class WG extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
    U(this, "zoomBrush", new Xe());
  }
  onEnter(t) {
    this.info = t, this.update();
  }
  onExit() {
    this.editor.updateInstanceState({ zoomBrush: null });
  }
  onPointerMove() {
    this.update();
  }
  onPointerUp() {
    this.complete();
  }
  onCancel() {
    this.cancel();
  }
  update() {
    const {
      inputs: { originPagePoint: t, currentPagePoint: r }
    } = this.editor;
    this.zoomBrush.setTo(Xe.FromPoints([t, r])), this.editor.updateInstanceState({ zoomBrush: this.zoomBrush.toJson() });
  }
  cancel() {
    this.parent.transition("idle", this.info);
  }
  complete() {
    const { zoomBrush: t } = this, r = 8 / this.editor.getZoomLevel();
    if (t.width < r && t.height < r) {
      const i = this.editor.inputs.currentScreenPoint;
      this.editor.inputs.altKey ? this.editor.zoomOut(i, { animation: { duration: 220 } }) : this.editor.zoomIn(i, { animation: { duration: 220 } });
    } else {
      const i = this.editor.inputs.altKey ? this.editor.getZoomLevel() / 2 : void 0;
      this.editor.zoomToBounds(t, { targetZoom: i, animation: { duration: 220 } });
    }
    this.parent.transition("idle", this.info);
  }
}
U(WG, "id", "zoom_brushing");
class qC extends Et {
  constructor() {
    super(...arguments);
    U(this, "info", {});
  }
  static children() {
    return [VG, WG, KG];
  }
  onEnter(t) {
    this.info = t, this.parent.setCurrentToolIdMask(t.onInteractionEnd), this.updateCursor();
  }
  onExit() {
    this.parent.setCurrentToolIdMask(void 0), this.editor.updateInstanceState({ zoomBrush: null, cursor: { type: "default", rotation: 0 } }), this.parent.setCurrentToolIdMask(void 0);
  }
  onKeyDown() {
    this.updateCursor();
  }
  onKeyUp(t) {
    this.updateCursor(), t.code === "KeyZ" && this.complete();
  }
  onInterrupt() {
    this.complete();
  }
  complete() {
    this.info.onInteractionEnd && this.info.onInteractionEnd !== "select" ? this.editor.setCurrentTool(this.info.onInteractionEnd, this.info) : this.parent.transition("select");
  }
  updateCursor() {
    this.editor.inputs.altKey ? this.editor.setCursor({ type: "zoom-out", rotation: 0 }) : this.editor.setCursor({ type: "zoom-in", rotation: 0 });
  }
}
U(qC, "id", "zoom"), U(qC, "initial", "idle"), U(qC, "isLockable", !1);
const tbe = [VC, KC, WC, qC, GC];
function nbe() {
  const n = be(), e = Pe("follow", () => n.getInstanceState().followingUserId, [
    n
  ]);
  return e ? /* @__PURE__ */ m.jsx(rbe, { userId: e }) : null;
}
function rbe({ userId: n }) {
  const e = JE(n);
  return e ? /* @__PURE__ */ m.jsx("div", { className: "tlui-following-indicator", style: { borderColor: e.color } }) : null;
}
let UD = {
  fonts: {
    draw: `${ch()}/fonts/Shantell_Sans-Tldrawish.woff2`,
    serif: `${ch()}/fonts/IBMPlexSerif-Medium.woff2`,
    sansSerif: `${ch()}/fonts/IBMPlexSans-Medium.woff2`,
    monospace: `${ch()}/fonts/IBMPlexMono-Medium.woff2`
  }
};
function GG(n) {
  return M.useMemo(() => n ? {
    fonts: { ...UD.fonts, ...n == null ? void 0 : n.fonts }
  } : UD, [n]);
}
const ibe = [
  "align-bottom",
  "align-center-horizontal",
  "align-center-vertical",
  "align-left",
  "align-right",
  "align-top",
  "arrow-left",
  "arrowhead-arrow",
  "arrowhead-bar",
  "arrowhead-diamond",
  "arrowhead-dot",
  "arrowhead-none",
  "arrowhead-square",
  "arrowhead-triangle-inverted",
  "arrowhead-triangle",
  "blob",
  "bring-forward",
  "bring-to-front",
  "broken",
  "check-circle",
  "check",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevron-up",
  "chevrons-ne",
  "chevrons-sw",
  "clipboard-copied",
  "clipboard-copy",
  "color",
  "cross-2",
  "cross-circle",
  "dash-dashed",
  "dash-dotted",
  "dash-draw",
  "dash-solid",
  "disconnected",
  "discord",
  "distribute-horizontal",
  "distribute-vertical",
  "dot",
  "dots-horizontal",
  "dots-vertical",
  "drag-handle-dots",
  "duplicate",
  "edit",
  "external-link",
  "fill-fill",
  "fill-none",
  "fill-pattern",
  "fill-semi",
  "fill-solid",
  "follow",
  "following",
  "font-draw",
  "font-mono",
  "font-sans",
  "font-serif",
  "geo-arrow-down",
  "geo-arrow-left",
  "geo-arrow-right",
  "geo-arrow-up",
  "geo-check-box",
  "geo-cloud",
  "geo-diamond",
  "geo-ellipse",
  "geo-heart",
  "geo-hexagon",
  "geo-octagon",
  "geo-oval",
  "geo-pentagon",
  "geo-rectangle",
  "geo-rhombus-2",
  "geo-rhombus",
  "geo-star",
  "geo-trapezoid",
  "geo-triangle",
  "geo-x-box",
  "github",
  "group",
  "horizontal-align-end",
  "horizontal-align-middle",
  "horizontal-align-start",
  "info-circle",
  "leading",
  "link",
  "lock",
  "menu",
  "minus",
  "mixed",
  "pack",
  "plus",
  "question-mark-circle",
  "question-mark",
  "redo",
  "reset-zoom",
  "rotate-ccw",
  "rotate-cw",
  "send-backward",
  "send-to-back",
  "share-1",
  "size-extra-large",
  "size-large",
  "size-medium",
  "size-small",
  "spline-cubic",
  "spline-line",
  "stack-horizontal",
  "stack-vertical",
  "status-offline",
  "stretch-horizontal",
  "stretch-vertical",
  "text-align-center",
  "text-align-left",
  "text-align-right",
  "toggle-off",
  "toggle-on",
  "tool-arrow",
  "tool-eraser",
  "tool-frame",
  "tool-hand",
  "tool-highlight",
  "tool-laser",
  "tool-line",
  "tool-media",
  "tool-note",
  "tool-pencil",
  "tool-pointer",
  "tool-screenshot",
  "tool-text",
  "trash",
  "twitter",
  "undo",
  "ungroup",
  "unlock",
  "vertical-align-end",
  "vertical-align-middle",
  "vertical-align-start",
  "warning-triangle",
  "zoom-in",
  "zoom-out"
];
let hx = {
  ...UD,
  icons: Object.fromEntries(
    ibe.map((n) => [n, `${ch()}/icons/icon/0_merged.svg#${n}`])
  ),
  translations: Object.fromEntries(
    qx.map((n) => [
      n.locale,
      `${ch()}/translations/${n.locale}.json`
    ])
  ),
  embedIcons: Object.fromEntries(
    $j.map((n) => [
      n.type,
      `${ch()}/embed-icons/${n.type}.png`
    ])
  )
};
function obe(n) {
  return n ? {
    fonts: Object.assign({ ...hx.fonts }, { ...n == null ? void 0 : n.fonts }),
    icons: Object.assign({ ...hx.icons }, { ...n == null ? void 0 : n.icons }),
    embedIcons: Object.assign({ ...hx.embedIcons }, { ...n == null ? void 0 : n.embedIcons }),
    translations: Object.assign(
      { ...hx.translations },
      { ...n == null ? void 0 : n.translations }
    )
  } : hx;
}
var cL = "Popover", [qG, jEe] = ju(cL, [
  w_
]), Ow = w_(), [sbe, Rh] = qG(cL), YG = (n) => {
  const {
    __scopePopover: e,
    children: t,
    open: r,
    defaultOpen: i,
    onOpenChange: s,
    modal: l = !1
  } = n, c = Ow(e), d = M.useRef(null), [h, g] = M.useState(!1), [y = !1, v] = Ih({
    prop: r,
    defaultProp: i,
    onChange: s
  });
  return /* @__PURE__ */ m.jsx(vj, { ...c, children: /* @__PURE__ */ m.jsx(
    sbe,
    {
      scope: e,
      contentId: $d(),
      triggerRef: d,
      open: y,
      onOpenChange: v,
      onOpenToggle: M.useCallback(() => v((w) => !w), [v]),
      hasCustomAnchor: h,
      onCustomAnchorAdd: M.useCallback(() => g(!0), []),
      onCustomAnchorRemove: M.useCallback(() => g(!1), []),
      modal: l,
      children: t
    }
  ) });
};
YG.displayName = cL;
var XG = "PopoverAnchor", abe = M.forwardRef(
  (n, e) => {
    const { __scopePopover: t, ...r } = n, i = Rh(XG, t), s = Ow(t), { onCustomAnchorAdd: l, onCustomAnchorRemove: c } = i;
    return M.useEffect(() => (l(), () => c()), [l, c]), /* @__PURE__ */ m.jsx(Sj, { ...s, ...r, ref: e });
  }
);
abe.displayName = XG;
var ZG = "PopoverTrigger", QG = M.forwardRef(
  (n, e) => {
    const { __scopePopover: t, ...r } = n, i = Rh(ZG, t), s = Ow(t), l = jr(e, i.triggerRef), c = /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": i.open,
        "aria-controls": i.contentId,
        "data-state": rq(i.open),
        ...r,
        ref: l,
        onClick: bt(n.onClick, i.onOpenToggle)
      }
    );
    return i.hasCustomAnchor ? c : /* @__PURE__ */ m.jsx(Sj, { asChild: !0, ...s, children: c });
  }
);
QG.displayName = ZG;
var uL = "PopoverPortal", [lbe, cbe] = qG(uL, {
  forceMount: void 0
}), JG = (n) => {
  const { __scopePopover: e, forceMount: t, children: r, container: i } = n, s = Rh(uL, e);
  return /* @__PURE__ */ m.jsx(lbe, { scope: e, forceMount: t, children: /* @__PURE__ */ m.jsx(kc, { present: t || s.open, children: /* @__PURE__ */ m.jsx(kw, { asChild: !0, container: i, children: r }) }) });
};
JG.displayName = uL;
var Fy = "PopoverContent", eq = M.forwardRef(
  (n, e) => {
    const t = cbe(Fy, n.__scopePopover), { forceMount: r = t.forceMount, ...i } = n, s = Rh(Fy, n.__scopePopover);
    return /* @__PURE__ */ m.jsx(kc, { present: r || s.open, children: s.modal ? /* @__PURE__ */ m.jsx(ube, { ...i, ref: e }) : /* @__PURE__ */ m.jsx(dbe, { ...i, ref: e }) });
  }
);
eq.displayName = Fy;
var ube = M.forwardRef(
  (n, e) => {
    const t = Rh(Fy, n.__scopePopover), r = M.useRef(null), i = jr(e, r), s = M.useRef(!1);
    return M.useEffect(() => {
      const l = r.current;
      if (l) return xj(l);
    }, []), /* @__PURE__ */ m.jsx(E_, { as: ng, allowPinchZoom: !0, children: /* @__PURE__ */ m.jsx(
      tq,
      {
        ...n,
        ref: i,
        trapFocus: t.open,
        disableOutsidePointerEvents: !0,
        onCloseAutoFocus: bt(n.onCloseAutoFocus, (l) => {
          var c;
          l.preventDefault(), s.current || (c = t.triggerRef.current) == null || c.focus();
        }),
        onPointerDownOutside: bt(
          n.onPointerDownOutside,
          (l) => {
            const c = l.detail.originalEvent, d = c.button === 0 && c.ctrlKey === !0, h = c.button === 2 || d;
            s.current = h;
          },
          { checkForDefaultPrevented: !1 }
        ),
        onFocusOutside: bt(
          n.onFocusOutside,
          (l) => l.preventDefault(),
          { checkForDefaultPrevented: !1 }
        )
      }
    ) });
  }
), dbe = M.forwardRef(
  (n, e) => {
    const t = Rh(Fy, n.__scopePopover), r = M.useRef(!1), i = M.useRef(!1);
    return /* @__PURE__ */ m.jsx(
      tq,
      {
        ...n,
        ref: e,
        trapFocus: !1,
        disableOutsidePointerEvents: !1,
        onCloseAutoFocus: (s) => {
          var l, c;
          (l = n.onCloseAutoFocus) == null || l.call(n, s), s.defaultPrevented || (r.current || (c = t.triggerRef.current) == null || c.focus(), s.preventDefault()), r.current = !1, i.current = !1;
        },
        onInteractOutside: (s) => {
          var d, h;
          (d = n.onInteractOutside) == null || d.call(n, s), s.defaultPrevented || (r.current = !0, s.detail.originalEvent.type === "pointerdown" && (i.current = !0));
          const l = s.target;
          ((h = t.triggerRef.current) == null ? void 0 : h.contains(l)) && s.preventDefault(), s.detail.originalEvent.type === "focusin" && i.current && s.preventDefault();
        }
      }
    );
  }
), tq = M.forwardRef(
  (n, e) => {
    const {
      __scopePopover: t,
      trapFocus: r,
      onOpenAutoFocus: i,
      onCloseAutoFocus: s,
      disableOutsidePointerEvents: l,
      onEscapeKeyDown: c,
      onPointerDownOutside: d,
      onFocusOutside: h,
      onInteractOutside: g,
      ...y
    } = n, v = Rh(Fy, t), w = Ow(t);
    return lj(), /* @__PURE__ */ m.jsx(
      y_,
      {
        asChild: !0,
        loop: !0,
        trapped: r,
        onMountAutoFocus: i,
        onUnmountAutoFocus: s,
        children: /* @__PURE__ */ m.jsx(
          Tw,
          {
            asChild: !0,
            disableOutsidePointerEvents: l,
            onInteractOutside: g,
            onEscapeKeyDown: c,
            onPointerDownOutside: d,
            onFocusOutside: h,
            onDismiss: () => v.onOpenChange(!1),
            children: /* @__PURE__ */ m.jsx(
              lV,
              {
                "data-state": rq(v.open),
                role: "dialog",
                id: v.contentId,
                ...w,
                ...y,
                ref: e,
                style: {
                  ...y.style,
                  "--radix-popover-content-transform-origin": "var(--radix-popper-transform-origin)",
                  "--radix-popover-content-available-width": "var(--radix-popper-available-width)",
                  "--radix-popover-content-available-height": "var(--radix-popper-available-height)",
                  "--radix-popover-trigger-width": "var(--radix-popper-anchor-width)",
                  "--radix-popover-trigger-height": "var(--radix-popper-anchor-height)"
                }
              }
            )
          }
        )
      }
    );
  }
), nq = "PopoverClose", fbe = M.forwardRef(
  (n, e) => {
    const { __scopePopover: t, ...r } = n, i = Rh(nq, t);
    return /* @__PURE__ */ m.jsx(
      Wn.button,
      {
        type: "button",
        ...r,
        ref: e,
        onClick: bt(n.onClick, () => i.onOpenChange(!1))
      }
    );
  }
);
fbe.displayName = nq;
var hbe = "PopoverArrow", pbe = M.forwardRef(
  (n, e) => {
    const { __scopePopover: t, ...r } = n, i = Ow(t);
    return /* @__PURE__ */ m.jsx(cV, { ...i, ...r, ref: e });
  }
);
pbe.displayName = hbe;
function rq(n) {
  return n ? "open" : "closed";
}
var dL = YG, fL = QG, hL = JG, pL = eq;
function gL({ id: n, children: e, onOpenChange: t, open: r }) {
  const [i, s] = Xd(n, t);
  return /* @__PURE__ */ m.jsx(
    dL,
    {
      onOpenChange: s,
      open: r || i,
      children: /* @__PURE__ */ m.jsx("div", { className: "tlui-popover", children: e })
    }
  );
}
function mL({ children: n }) {
  return /* @__PURE__ */ m.jsx(fL, { asChild: !0, dir: "ltr", children: n });
}
function yL({
  side: n,
  children: e,
  align: t = "center",
  sideOffset: r = 8,
  alignOffset: i = 0,
  disableEscapeKeyDown: s = !1
}) {
  const l = io();
  return /* @__PURE__ */ m.jsx(hL, { container: l, children: /* @__PURE__ */ m.jsx(
    pL,
    {
      className: "tlui-popover__content",
      side: n,
      sideOffset: r,
      align: t,
      alignOffset: i,
      dir: "ltr",
      onEscapeKeyDown: (c) => s && c.preventDefault(),
      children: e
    }
  ) });
}
function gbe(n) {
  return n.getSelectedShapeIds().map((r) => n.getShape(r)).filter((r) => {
    if (!r) return !1;
    if (n.isShapeOfType(r, "arrow")) {
      const i = wa(n, r);
      if (i.start || i.end) return !1;
    }
    return !0;
  });
}
const iq = () => {
  const n = be();
  return Pe("threeStackableItems", () => gbe(n).length > 2, [n]);
}, Zd = () => {
  const n = be();
  return Pe("isInSelectState", () => n.isIn("select"), [n]);
}, oq = () => {
  const n = be();
  return Pe(
    "allow group",
    () => {
      const e = n.getSelectedShapes();
      if (e.length < 2) return !1;
      for (const t of e)
        if (n.isShapeOfType(t, "arrow")) {
          const r = wa(n, t);
          if (r.start && !e.some((i) => i.id === r.start.toId) || r.end && !e.some((i) => i.id === r.end.toId))
            return !1;
        }
      return !0;
    },
    [n]
  );
}, sq = () => {
  const n = be();
  return Pe(
    "allowUngroup",
    () => n.getSelectedShapeIds().some((e) => {
      var t;
      return ((t = n.getShape(e)) == null ? void 0 : t.type) === "group";
    }),
    [n]
  );
}, mbe = typeof window < "u" && "navigator" in window && !!navigator.clipboard && !!navigator.clipboard.read;
function aq(n, e) {
  const t = be();
  return Pe(
    "selectedShapes",
    () => t.getSelectedShapes().length >= n,
    [t, n, e]
  );
}
function Ys(n, e) {
  const t = be();
  return Pe(
    "selectedShapes",
    () => {
      const r = t.getSelectedShapes().filter((i) => !t.isShapeOrAncestorLocked(i)).length;
      return n === void 0 ? r : r >= n;
    },
    [t]
  );
}
function ybe() {
  const n = be();
  return Pe(
    "showAutoSizeToggle",
    () => {
      const e = n.getSelectedShapes();
      return e.length === 1 && n.isShapeOfType(e[0], "text") && e[0].props.autoSize === !1;
    },
    [n]
  );
}
function lq() {
  const n = be();
  return Pe(
    "hasLinkShapeSelected",
    () => {
      const e = n.getOnlySelectedShape();
      return !!(e && e.type !== "embed" && "url" in e.props && !e.isLocked);
    },
    [n]
  );
}
function vbe() {
  const n = be();
  return Pe(
    "onlyFlippableShape",
    () => {
      const e = n.getOnlySelectedShape();
      return e && (n.isShapeOfType(e, "group") || n.isShapeOfType(e, "image") || n.isShapeOfType(e, "arrow") || n.isShapeOfType(e, "line") || n.isShapeOfType(e, "draw"));
    },
    [n]
  );
}
function cq() {
  const n = be();
  return Pe("useCanRedo", () => n.getCanRedo(), [n]);
}
function uq() {
  const n = be();
  return Pe("useCanUndo", () => n.getCanUndo(), [n]);
}
function Sbe() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(xbe, {}),
    /* @__PURE__ */ m.jsx(wbe, {}),
    /* @__PURE__ */ m.jsx(bbe, {}),
    /* @__PURE__ */ m.jsx(Cbe, {}),
    /* @__PURE__ */ m.jsx(Ebe, {}),
    /* @__PURE__ */ m.jsx(Tbe, {}),
    /* @__PURE__ */ m.jsx(Ibe, {}),
    /* @__PURE__ */ m.jsx(kbe, {})
  ] });
}
function xbe() {
  const n = Ys(2), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-left", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-horizontal", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-right", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "stretch-horizontal", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-top", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-vertical", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "align-bottom", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "stretch-vertical", disabled: !t })
  ] });
}
function wbe() {
  const n = Ys(3), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "distribute-horizontal", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "distribute-vertical", disabled: !t })
  ] });
}
function bbe() {
  const n = iq(), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "stack-horizontal", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "stack-vertical", disabled: !t })
  ] });
}
function Cbe() {
  const n = Ys(1), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "send-to-back", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "send-backward", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-forward", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-to-front", disabled: !t })
  ] });
}
function Ebe() {
  return qs() < yi.TABLET_SM ? /* @__PURE__ */ m.jsx(_be, {}) : /* @__PURE__ */ m.jsx(Pbe, {});
}
function _be() {
  const n = be(), e = Pe("zoom is 1", () => n.getZoomLevel() === 1, [n]);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-to-100", disabled: e });
}
function Pbe() {
  const n = Ys(1), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "rotate-ccw", disabled: !t });
}
function Tbe() {
  const n = Ys(1), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "rotate-cw", disabled: !t });
}
function Ibe() {
  const n = lq(), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "edit-link", disabled: !t });
}
function kbe() {
  const n = oq(), e = sq();
  return n ? /* @__PURE__ */ m.jsx(P$, {}) : e ? /* @__PURE__ */ m.jsx(Rbe, {}) : /* @__PURE__ */ m.jsx(P$, {});
}
function P$() {
  const n = Ys(2), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "group", disabled: !t });
}
function Rbe() {
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "ungroup" });
}
const Mbe = M.memo(function({
  children: e
}) {
  const t = Ln(), r = qs(), i = ol(), s = M.useRef(null);
  Th(s);
  const l = be(), c = Pe(
    "should display quick actions when in readonly",
    () => l.isInAny("hand", "zoom"),
    [l]
  ), d = e ?? /* @__PURE__ */ m.jsx(Sbe, {});
  if (!(i && !c))
    return /* @__PURE__ */ m.jsxs(gL, { id: "actions-menu", children: [
      /* @__PURE__ */ m.jsx(mL, { children: /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          "data-testid": "actions-menu.button",
          title: t("actions-menu.title"),
          children: /* @__PURE__ */ m.jsx(In, { icon: "dots-vertical", small: !0 })
        }
      ) }),
      /* @__PURE__ */ m.jsx(
        yL,
        {
          side: r >= yi.TABLET ? "bottom" : "top",
          sideOffset: 6,
          children: /* @__PURE__ */ m.jsx(
            "div",
            {
              ref: s,
              className: "tlui-actions-menu tlui-buttons__grid",
              "data-testid": "actions-menu.content",
              children: /* @__PURE__ */ m.jsx(Ll, { type: "icons", sourceId: "actions-menu", children: d })
            }
          )
        }
      )
    ] });
});
function dq() {
  return ybe() ? /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-auto-size" }) : null;
}
function fq() {
  return lq() ? /* @__PURE__ */ m.jsx(Fe, { actionId: "edit-link" }) : null;
}
function Abe() {
  return Ys(1) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "duplicate" }) : null;
}
function hq() {
  const n = be();
  return Pe(
    "should display flatten option",
    () => {
      if (n.getSelectedShapeIds().length === 0) return !1;
      const r = n.getOnlySelectedShape();
      return !(r && n.isShapeOfType(r, "image"));
    },
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "flatten-to-image" }) : null;
}
function pq() {
  return oq() ? /* @__PURE__ */ m.jsx(Fe, { actionId: "group" }) : null;
}
function gq() {
  return sq() ? /* @__PURE__ */ m.jsx(Fe, { actionId: "ungroup" }) : null;
}
function mq() {
  const n = be();
  return Pe(
    "allow unframe",
    () => {
      const t = n.getSelectedShapes();
      return t.length === 0 ? !1 : t.every((r) => n.isShapeOfType(r, "frame"));
    },
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "remove-frame" }) : null;
}
function yq() {
  const n = be();
  return Pe(
    "allow fit frame to content",
    () => {
      const t = n.getOnlySelectedShape();
      return t ? n.isShapeOfType(t, "frame") && n.getSortedChildIdsForParent(t).length > 0 : !1;
    },
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "fit-frame-to-content" }) : null;
}
function vq() {
  const n = be();
  return Pe("selected shapes", () => n.getSelectedShapes().length > 0, [
    n
  ]) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-lock" }) : null;
}
function vL() {
  const n = be(), e = Pe(
    "isTransparentBg",
    () => !n.getInstanceState().exportBackground,
    [n]
  );
  return /* @__PURE__ */ m.jsx(
    Mc,
    {
      actionId: "toggle-transparent",
      checked: e,
      toggle: !0
    }
  );
}
function Dbe() {
  const n = be(), e = Pe("any shapes", () => n.getCurrentPageShapeIds().size > 0, [
    n
  ]);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "unlock-all", disabled: !e });
}
function Sq() {
  const n = be(), e = Pe("zoomed to 100", () => n.getZoomLevel() === 1, [n]);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-to-100", noClose: !0, disabled: e });
}
function xq() {
  const n = be(), e = Pe("has shapes", () => n.getCurrentPageShapeIds().size > 0, [n]);
  return /* @__PURE__ */ m.jsx(
    Fe,
    {
      actionId: "zoom-to-fit",
      disabled: !e,
      "data-testid": "minimap.zoom-menu.zoom-to-fit",
      noClose: !0
    }
  );
}
function wq() {
  const n = be(), e = Pe("has shapes", () => n.getSelectedShapeIds().length > 0, [
    n
  ]);
  return /* @__PURE__ */ m.jsx(
    Fe,
    {
      actionId: "zoom-to-selection",
      disabled: !e,
      "data-testid": "minimap.zoom-menu.zoom-to-selection",
      noClose: !0
    }
  );
}
function bq() {
  return /* @__PURE__ */ m.jsxs(gn, { id: "clipboard", children: [
    /* @__PURE__ */ m.jsx(jbe, {}),
    /* @__PURE__ */ m.jsx(Lbe, {}),
    /* @__PURE__ */ m.jsx(Nbe, {}),
    /* @__PURE__ */ m.jsx(Abe, {}),
    /* @__PURE__ */ m.jsx(Fbe, {})
  ] });
}
function Obe() {
  var t;
  const n = be(), e = Pe(
    "atLeastOneShapeOnPage",
    () => n.getCurrentPageShapeIds().size > 0,
    [n]
  );
  return /* @__PURE__ */ m.jsxs(
    Ia,
    {
      id: "copy-as",
      label: "context-menu.copy-as",
      size: "small",
      disabled: !e,
      children: [
        /* @__PURE__ */ m.jsxs(gn, { id: "copy-as-group", children: [
          /* @__PURE__ */ m.jsx(Fe, { actionId: "copy-as-svg" }),
          !!((t = window.navigator.clipboard) != null && t.write) && /* @__PURE__ */ m.jsx(Fe, { actionId: "copy-as-png" }),
          /* @__PURE__ */ m.jsx(Fe, { actionId: "copy-as-json" })
        ] }),
        /* @__PURE__ */ m.jsx(gn, { id: "copy-as-bg", children: /* @__PURE__ */ m.jsx(vL, {}) })
      ]
    }
  );
}
function jbe() {
  const n = Ys(1);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "cut", disabled: !n });
}
function Lbe() {
  const n = aq(1);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "copy", disabled: !n });
}
function Nbe() {
  const n = mbe;
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "paste", disabled: !n });
}
function Cq() {
  const n = be();
  return Pe(
    "atLeastOneShapeOnPage",
    () => n.getCurrentPageShapeIds().size > 0,
    [n]
  ) ? /* @__PURE__ */ m.jsxs(gn, { id: "conversions", children: [
    /* @__PURE__ */ m.jsx(Obe, {}),
    /* @__PURE__ */ m.jsxs(Ia, { id: "export-as", label: "context-menu.export-as", size: "small", children: [
      /* @__PURE__ */ m.jsxs(gn, { id: "export-as-group", children: [
        /* @__PURE__ */ m.jsx(Fe, { actionId: "export-as-svg" }),
        /* @__PURE__ */ m.jsx(Fe, { actionId: "export-as-png" }),
        /* @__PURE__ */ m.jsx(Fe, { actionId: "export-as-json" })
      ] }),
      /* @__PURE__ */ m.jsx(gn, { id: "export-as-bg", children: /* @__PURE__ */ m.jsx(vL, {}) })
    ] })
  ] }) : null;
}
function Eq() {
  const n = be(), e = Pe(
    "atLeastOneShapeOnPage",
    () => n.getCurrentPageShapeIds().size > 0,
    [n]
  );
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "select-all", disabled: !e });
}
function Fbe() {
  const n = Ys(1);
  return /* @__PURE__ */ m.jsx(Fe, { actionId: "delete", disabled: !n });
}
function zbe() {
  const n = ol();
  return !aq(1) || n ? null : /* @__PURE__ */ m.jsxs(Ia, { id: "edit", label: "context-menu.edit", size: "small", children: [
    /* @__PURE__ */ m.jsx(pq, {}),
    /* @__PURE__ */ m.jsx(gq, {}),
    /* @__PURE__ */ m.jsx(hq, {}),
    /* @__PURE__ */ m.jsx(fq, {}),
    /* @__PURE__ */ m.jsx(yq, {}),
    /* @__PURE__ */ m.jsx(mq, {}),
    /* @__PURE__ */ m.jsx(Pq, {}),
    /* @__PURE__ */ m.jsx(_q, {}),
    /* @__PURE__ */ m.jsx(dq, {}),
    /* @__PURE__ */ m.jsx(vq, {})
  ] });
}
function Ube() {
  const n = Ys(2), e = vbe();
  return ol() || !(n || e) ? null : /* @__PURE__ */ m.jsxs(Ia, { id: "arrange", label: "context-menu.arrange", size: "small", children: [
    n && /* @__PURE__ */ m.jsxs(gn, { id: "align", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-left" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-right" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-top" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-bottom" })
    ] }),
    /* @__PURE__ */ m.jsx($be, {}),
    n && /* @__PURE__ */ m.jsxs(gn, { id: "stretch", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "stretch-horizontal" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "stretch-vertical" })
    ] }),
    (n || e) && /* @__PURE__ */ m.jsxs(gn, { id: "flip", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "flip-vertical" })
    ] }),
    /* @__PURE__ */ m.jsx(Bbe, {})
  ] });
}
function $be() {
  return Ys(3) ? /* @__PURE__ */ m.jsxs(gn, { id: "distribute", children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "distribute-horizontal" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "distribute-vertical" })
  ] }) : null;
}
function Bbe() {
  const n = Ys(2), e = iq();
  return n ? /* @__PURE__ */ m.jsxs(gn, { id: "order", children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "pack" }),
    e && /* @__PURE__ */ m.jsx(Fe, { actionId: "stack-horizontal" }),
    e && /* @__PURE__ */ m.jsx(Fe, { actionId: "stack-vertical" })
  ] }) : null;
}
function Hbe() {
  const n = ol(), e = Ys(1);
  return n || !e ? null : /* @__PURE__ */ m.jsx(Ia, { id: "reorder", label: "context-menu.reorder", size: "small", children: /* @__PURE__ */ m.jsxs(gn, { id: "reorder", children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-to-front" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-forward" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "send-backward" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "send-to-back" })
  ] }) });
}
function Vbe() {
  const n = be(), e = Pe("pages", () => n.getPages(), [n]), t = Pe("current page id", () => n.getCurrentPageId(), [n]), { addToast: r } = Yd(), i = Vo(), s = ol();
  return !Ys(1) || s ? null : /* @__PURE__ */ m.jsxs(Ia, { id: "move-to-page", label: "context-menu.move-to-page", size: "small", children: [
    /* @__PURE__ */ m.jsx(gn, { id: "pages", children: e.map((c) => /* @__PURE__ */ m.jsx(
      Lo,
      {
        id: c.id,
        disabled: t === c.id,
        label: c.name.length > 30 ? `${c.name.slice(0, 30)}…` : c.name,
        onSelect: () => {
          n.markHistoryStoppingPoint("move_shapes_to_page"), n.moveShapesToPage(n.getSelectedShapeIds(), c.id);
          const d = n.getPage(c.id);
          d && r({
            title: "Changed Page",
            description: `Moved to ${d.name}.`,
            actions: [
              {
                label: "Go Back",
                type: "primary",
                onClick: () => {
                  n.markHistoryStoppingPoint("change-page"), n.setCurrentPage(t);
                }
              }
            ]
          }), i("move-to-page", { source: "context-menu" });
        }
      },
      c.id
    )) }),
    /* @__PURE__ */ m.jsx(gn, { id: "new-page", children: /* @__PURE__ */ m.jsx(Fe, { actionId: "move-to-new-page" }) })
  ] });
}
function _q() {
  const n = be();
  return Pe(
    "oneEmbedSelected",
    () => {
      const t = n.getOnlySelectedShape();
      return t ? !!(n.isShapeOfType(t, "embed") && t.props.url && !n.isShapeOrAncestorLocked(t)) : !1;
    },
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "convert-to-bookmark" }) : null;
}
function Pq() {
  const n = be(), e = Bj();
  return Pe(
    "oneEmbeddableBookmarkSelected",
    () => {
      const r = n.getOnlySelectedShape();
      return r ? !!(n.isShapeOfType(r, "bookmark") && r.props.url && e(r.props.url) && !n.isShapeOrAncestorLocked(r)) : !1;
    },
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "convert-to-embed" }) : null;
}
function Kbe() {
  const n = be(), e = Pe("isSnapMode", () => n.user.getIsSnapMode(), [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-snap-mode", checked: e });
}
function Wbe() {
  const n = be(), e = Pe("isToolLock", () => n.getInstanceState().isToolLocked, [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-tool-lock", checked: e });
}
function Gbe() {
  const n = be(), e = Pe("isGridMode", () => n.getInstanceState().isGridMode, [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-grid", checked: e });
}
function qbe() {
  const n = be(), e = Pe("isWrapMode", () => n.user.getIsWrapMode(), [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-wrap-mode", checked: e });
}
function Ybe() {
  const n = be(), e = Pe("isFocusMode", () => n.getInstanceState().isFocusMode, [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-focus-mode", checked: e });
}
function Xbe() {
  const n = be(), e = Pe("edgeScrollSpeed", () => n.user.getEdgeScrollSpeed(), [
    n
  ]);
  return /* @__PURE__ */ m.jsx(
    Mc,
    {
      actionId: "toggle-edge-scrolling",
      checked: e === 1
    }
  );
}
function Zbe() {
  const n = be(), e = Pe("animationSpeed", () => n.user.getAnimationSpeed(), [n]);
  return /* @__PURE__ */ m.jsx(
    Mc,
    {
      actionId: "toggle-reduce-motion",
      checked: e === 0
    }
  );
}
function Qbe() {
  const n = be(), e = Pe("isDebugMode", () => n.getInstanceState().isDebugMode, [n]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-debug-mode", checked: e });
}
function Jbe() {
  const n = be(), e = Pe(
    "dynamic resize",
    () => n.user.getIsDynamicResizeMode(),
    [n]
  );
  return /* @__PURE__ */ m.jsx(
    Mc,
    {
      actionId: "toggle-dynamic-size-mode",
      checked: e
    }
  );
}
function e0e() {
  const n = be(), e = Pe("paste at cursor", () => n.user.getIsPasteAtCursorMode(), [
    n
  ]);
  return /* @__PURE__ */ m.jsx(Mc, { actionId: "toggle-paste-at-cursor", checked: e });
}
function t0e() {
  const n = be();
  return Pe(
    "show cursor chat",
    () => n.getCurrentToolId() === "select" && !n.getInstanceState().isCoarsePointer,
    [n]
  ) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "open-cursor-chat" }) : null;
}
function n0e() {
  const n = be(), e = A_(), t = Pe(
    "isSelectToolActive",
    () => n.getCurrentToolId() === "select",
    [n]
  ), r = Pe("isSinglePageMode", () => n.options.maxPages <= 1, [
    n
  ]);
  return t ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    e && /* @__PURE__ */ m.jsx(t0e, {}),
    /* @__PURE__ */ m.jsxs(gn, { id: "modify", children: [
      /* @__PURE__ */ m.jsx(zbe, {}),
      /* @__PURE__ */ m.jsx(Ube, {}),
      /* @__PURE__ */ m.jsx(Hbe, {}),
      !r && /* @__PURE__ */ m.jsx(Vbe, {})
    ] }),
    /* @__PURE__ */ m.jsx(bq, {}),
    /* @__PURE__ */ m.jsx(Cq, {}),
    /* @__PURE__ */ m.jsx(gn, { id: "select-all", children: /* @__PURE__ */ m.jsx(Eq, {}) })
  ] }) : null;
}
const r0e = M.memo(function({
  children: e,
  disabled: t = !1
}) {
  const r = be(), { Canvas: i } = Br(), s = M.useCallback(
    (g) => {
      if (g) {
        if (r.getInstanceState().isCoarsePointer) {
          const y = r.getSelectedShapes(), {
            inputs: { currentPagePoint: v }
          } = r, w = r.getShapesAtPoint(v);
          if (
            // if there are no selected shapes
            !r.getSelectedShapes().length || // OR if none of the shapes at the point include the selected shape
            !w.some((C) => y.includes(C))
          ) {
            const C = w.filter((E) => r.isShapeOrAncestorLocked(E));
            C.length && r.select(...C.map((E) => E.id));
          }
        }
      } else {
        const y = r.getOnlySelectedShape();
        y && r.isShapeOrAncestorLocked(y) && r.setSelectedShapes([]);
      }
    },
    [r]
  ), l = io(), [c, d] = Xd("context menu", s), h = e ?? /* @__PURE__ */ m.jsx(n0e, {});
  return /* @__PURE__ */ m.jsxs($ge, { dir: "ltr", onOpenChange: d, modal: !1, children: [
    /* @__PURE__ */ m.jsx(Bge, { onContextMenu: void 0, dir: "ltr", disabled: t, children: i ? /* @__PURE__ */ m.jsx(i, {}) : null }),
    c && /* @__PURE__ */ m.jsx(Hge, { container: l, children: /* @__PURE__ */ m.jsx(
      Vge,
      {
        className: "tlui-menu scrollable",
        "data-testid": "context-menu",
        alignOffset: -4,
        collisionPadding: 4,
        onContextMenu: wn,
        children: /* @__PURE__ */ m.jsx(Ll, { type: "context-menu", sourceId: "context-menu", children: h })
      }
    ) })
  ] });
}), i0e = 2e3, o0e = 5e3, s0e = Ho(function() {
  const e = be(), { isChatting: t, chatMessage: r } = e.getInstanceState(), i = M.useRef(-1), [s, l] = M.useState("");
  return M.useEffect(() => {
    if (!t && r || t) {
      const d = t ? o0e : i0e;
      i.current = e.timers.setTimeout(() => {
        e.updateInstanceState({ chatMessage: "", isChatting: !1 }), l(""), e.focus();
      }, d);
    }
    return () => {
      clearTimeout(i.current);
    };
  }, [e, r, t]), t ? /* @__PURE__ */ m.jsx(l0e, { value: s, setValue: l, chatMessage: r }) : r.trim() ? /* @__PURE__ */ m.jsx(a0e, { chatMessage: r }) : null;
});
function Tq(n) {
  const e = be();
  M.useLayoutEffect(() => {
    var l;
    if (!n.current) return;
    const { x: r, y: i } = e.inputs.currentScreenPoint;
    (l = n.current) == null || l.style.setProperty("transform", `translate(${r}px, ${i}px)`);
    function s(c) {
      var g;
      const { minX: d, minY: h } = e.getViewportScreenBounds();
      (g = n.current) == null || g.style.setProperty(
        "transform",
        `translate(${c.clientX - d}px, ${c.clientY - h}px)`
      );
    }
    return window.addEventListener("pointermove", s), () => {
      window.removeEventListener("pointermove", s);
    };
  }, [n, e]);
}
const a0e = ({ chatMessage: n }) => {
  const e = be(), t = M.useRef(null);
  return Tq(t), /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: t,
      className: "tl-cursor-chat tl-cursor-chat__bubble",
      style: { backgroundColor: e.user.getColor() },
      children: n
    }
  );
}, l0e = Ho(function({
  chatMessage: e,
  value: t,
  setValue: r
}) {
  const i = be(), s = Ln(), l = M.useRef(null), c = e || s("cursor-chat.type-to-chat");
  Tq(l), M.useLayoutEffect(() => {
    const v = l.current;
    if (!v) return;
    const w = i.textMeasure.measureText(t || c, {
      fontFamily: "var(--font-body)",
      fontSize: 12,
      fontWeight: "500",
      fontStyle: "normal",
      maxWidth: null,
      lineHeight: 1,
      padding: "6px"
    });
    v.style.setProperty("width", w.w + "px");
  }, [i, t, c]), M.useLayoutEffect(() => {
    const v = i.timers.requestAnimationFrame(() => {
      var w;
      (w = l.current) == null || w.focus();
    });
    return () => {
      cancelAnimationFrame(v);
    };
  }, [i]);
  const d = M.useCallback(() => {
    i.updateInstanceState({ isChatting: !1 }), i.focus();
  }, [i]), h = M.useCallback(
    (v) => {
      const { value: w } = v.target;
      r(w.slice(0, 64)), i.updateInstanceState({ chatMessage: w });
    },
    [i, r]
  ), g = M.useCallback(
    (v) => {
      const w = l.current;
      if (!w) return;
      const { value: C } = w;
      switch (v.key) {
        case "Enter": {
          if (wn(v), v.stopPropagation(), !C) {
            d();
            return;
          }
          r("");
          break;
        }
        case "Escape": {
          wn(v), v.stopPropagation(), d();
          break;
        }
      }
    },
    [d, r]
  ), y = M.useCallback((v) => {
    v.stopPropagation();
  }, []);
  return /* @__PURE__ */ m.jsx(
    "input",
    {
      ref: l,
      className: "tl-cursor-chat",
      style: { backgroundColor: i.user.getColor() },
      onBlur: d,
      onChange: h,
      onKeyDown: g,
      onPaste: y,
      value: t,
      placeholder: c,
      spellCheck: !1
    }
  );
});
function $D({ checked: n }) {
  return /* @__PURE__ */ m.jsx(ku, { icon: n ? "check" : "none", className: "tlui-button__icon", small: !0 });
}
function c0e() {
  const n = be(), { addToast: e } = Yd(), { addDialog: t } = Dw(), [r, i] = Bt.useState(!1);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(gn, { id: "items", children: [
      /* @__PURE__ */ m.jsx(
        Lo,
        {
          id: "add-toast",
          onSelect: () => {
            e({
              id: or(),
              title: "Something good happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "success"
              // icon?: string
              // title?: string
              // description?: string
              // actions?: TLUiToastAction[]
            }), e({
              id: or(),
              title: "Something happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "info",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
              // icon?: string
              // title?: string
              // description?: string
              // actions?: TLUiToastAction[]
            }), e({
              id: or(),
              title: "Something maybe bad happened",
              description: "Hey, attend to this thing over here. It might be important!",
              keepOpen: !0,
              severity: "warning",
              actions: [
                {
                  label: "Primary",
                  type: "primary",
                  onClick: () => {
                  }
                },
                {
                  label: "Normal",
                  type: "normal",
                  onClick: () => {
                  }
                },
                {
                  label: "Danger",
                  type: "danger",
                  onClick: () => {
                  }
                }
              ]
            }), e({
              id: or(),
              title: "Something bad happened",
              severity: "error",
              keepOpen: !0
            });
          },
          label: "Show toast"
        }
      ),
      /* @__PURE__ */ m.jsx(
        Lo,
        {
          id: "show-dialog",
          label: "Show dialog",
          onSelect: () => {
            t({
              component: ({ onClose: s }) => /* @__PURE__ */ m.jsx(
                f0e,
                {
                  displayDontShowAgain: !0,
                  onCancel: () => s(),
                  onContinue: () => s()
                }
              ),
              onClose: () => {
              }
            });
          }
        }
      ),
      /* @__PURE__ */ m.jsx(
        Lo,
        {
          id: "create-shapes",
          label: "Create 100 shapes",
          onSelect: () => h0e(n, 100)
        }
      ),
      /* @__PURE__ */ m.jsx(
        Lo,
        {
          id: "count-nodes",
          label: "Count shapes / nodes",
          onSelect: () => {
            var c;
            const s = n.getSelectedShapes(), l = s.length === 0 ? n.getRenderingShapes() : s;
            window.alert(
              `Shapes ${l.length}, DOM nodes:${(c = document.querySelector(".tl-shapes").querySelectorAll("*")) == null ? void 0 : c.length}`
            );
          }
        }
      ),
      (() => {
        if (r) throw Error("oh no!");
        return null;
      })(),
      /* @__PURE__ */ m.jsx(Lo, { id: "throw-error", onSelect: () => i(!0), label: "Throw error" }),
      /* @__PURE__ */ m.jsx(Lo, { id: "hard-reset", onSelect: yB, label: "Hard reset" })
    ] }),
    /* @__PURE__ */ m.jsxs(gn, { id: "flags", children: [
      /* @__PURE__ */ m.jsx(u0e, {}),
      /* @__PURE__ */ m.jsx(d0e, {})
    ] })
  ] });
}
function u0e() {
  const n = Object.values(Ei);
  return n.length ? /* @__PURE__ */ m.jsx(Ia, { id: "debug flags", label: "Debug Flags", children: /* @__PURE__ */ m.jsx(gn, { id: "debug flags", children: n.map((e) => /* @__PURE__ */ m.jsx(Iq, { flag: e }, e.name)) }) }) : null;
}
function d0e() {
  const n = Object.values(use);
  return n.length ? /* @__PURE__ */ m.jsx(Ia, { id: "feature flags", label: "Feature Flags", children: /* @__PURE__ */ m.jsx(gn, { id: "feature flags", children: n.map((e) => /* @__PURE__ */ m.jsx(Iq, { flag: e }, e.name)) }) }) : null;
}
function f0e({
  title: n = "title",
  body: e = "hello hello hello",
  cancel: t = "Cancel",
  confirm: r = "Continue",
  displayDontShowAgain: i = !1,
  onCancel: s,
  onContinue: l
}) {
  const [c, d] = Bt.useState(!1);
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(I_, { children: [
      /* @__PURE__ */ m.jsx(k_, { children: n }),
      /* @__PURE__ */ m.jsx(R_, {})
    ] }),
    /* @__PURE__ */ m.jsx(nw, { style: { maxWidth: 350 }, children: e }),
    /* @__PURE__ */ m.jsxs(Uj, { className: "tlui-dialog__footer__actions", children: [
      i && /* @__PURE__ */ m.jsxs(
        Ot,
        {
          type: "normal",
          onClick: () => d(!c),
          style: { marginRight: "auto" },
          children: [
            /* @__PURE__ */ m.jsx($D, { checked: c }),
            /* @__PURE__ */ m.jsx(_i, { children: "Don’t show again" })
          ]
        }
      ),
      /* @__PURE__ */ m.jsx(Ot, { type: "normal", onClick: s, children: /* @__PURE__ */ m.jsx(_i, { children: t }) }),
      /* @__PURE__ */ m.jsx(Ot, { type: "primary", onClick: async () => l(), children: /* @__PURE__ */ m.jsx(_i, { children: r }) })
    ] })
  ] });
}
const Iq = Ho(function({
  flag: e,
  onChange: t
}) {
  const r = e.get();
  return /* @__PURE__ */ m.jsx(
    L_,
    {
      id: e.name,
      title: e.name,
      label: e.name.replace(/([a-z0-9])([A-Z])/g, (i) => `${i[0]} ${i[1].toLowerCase()}`).replace(/^[a-z]/, (i) => i.toUpperCase()),
      checked: r,
      onSelect: () => {
        e.set(!r), t == null || t(!r);
      }
    }
  );
});
let T$ = 0;
function h0e(n, e) {
  const t = Array(e), r = Math.floor(Math.sqrt(e));
  for (let i = 0; i < e; i++)
    T$++, t[i] = {
      id: Sr("box" + T$),
      type: "geo",
      x: i % r * 132,
      y: Math.floor(i / r) * 132
    };
  n.run(() => {
    n.createShapes(t).setSelectedShapes(t.map((i) => i.id));
  });
}
function p0e({ children: n }) {
  const e = n ?? /* @__PURE__ */ m.jsx(c0e, {});
  return /* @__PURE__ */ m.jsxs(og, { id: "debug", children: [
    /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(Ot, { type: "icon", title: "Debug menu", children: /* @__PURE__ */ m.jsx(In, { icon: "dots-horizontal" }) }) }),
    /* @__PURE__ */ m.jsx(ag, { side: "top", align: "end", alignOffset: 0, children: /* @__PURE__ */ m.jsx(Ll, { type: "menu", sourceId: "debug-panel", children: e }) })
  ] });
}
const g0e = M.memo(function() {
  const { DebugMenu: e } = Mh(), t = M.useRef(null);
  return Th(t), /* @__PURE__ */ m.jsxs("div", { ref: t, className: "tlui-debug-panel", children: [
    /* @__PURE__ */ m.jsx(y0e, {}),
    /* @__PURE__ */ m.jsx(v0e, {}),
    e && /* @__PURE__ */ m.jsx(e, {})
  ] });
});
function m0e(n = !0) {
  const [e, t] = M.useState(0), r = be();
  M.useEffect(() => {
    if (!n) return;
    const i = () => t((s) => s + 1);
    return r.on("tick", i), () => {
      r.off("tick", i);
    };
  }, [r, n]);
}
const y0e = Ho(function() {
  m0e();
  const e = be(), t = e.getPath(), r = e.getHoveredShape(), i = e.getOnlySelectedShape(), s = t === "select.idle" || !t.includes("select.") ? r : i, l = s && t.includes("select.") ? ` / ${s.type || ""}${"geo" in s.props ? " / " + s.props.geo : ""} / [${R.ToInt(e.getPointInShapeSpace(s, e.inputs.currentPagePoint))}]` : "", c = t.startsWith("select.") && !t.includes(".idle") ? ` / [${R.ToInt(e.inputs.originPagePoint)}] → [${R.ToInt(
    e.inputs.currentPagePoint
  )}] = ${R.Dist(e.inputs.originPagePoint, e.inputs.currentPagePoint).toFixed(0)}` : "";
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-debug-panel__current-state", children: `${t}${l}${c}` });
});
function v0e() {
  const n = be(), e = Pe("show_fps", () => Ei.showFps.get(), [Ei]), t = M.useRef(null);
  return M.useEffect(() => {
    if (!e) return;
    const r = 250;
    let i = 0, s = -1, l = performance.now(), c = 0, d = 0, h = !1;
    function g() {
      if (d++, c = performance.now() - l, c > r) {
        const y = Math.round(
          d * (r / c) * (1e3 / r)
        );
        y > i && (i = y);
        const v = i * 0.75;
        (y < v && !h || y >= v && h) && (h = !h), t.current.innerHTML = `FPS ${y.toString()}`, t.current.className = "tlui-debug-panel__fps" + (h ? " tlui-debug-panel__fps__slow" : ""), c -= r, d = 0, l = performance.now();
      }
      s = n.timers.requestAnimationFrame(g);
    }
    return g(), () => {
      cancelAnimationFrame(s);
    };
  }, [e, n]), e ? /* @__PURE__ */ m.jsx("div", { ref: t }) : null;
}
const S0e = M.memo(function() {
  const e = qs(), t = M.useRef(null);
  Th(t);
  const { MainMenu: r, QuickActions: i, ActionsMenu: s, PageMenu: l } = Mh(), c = be(), d = Pe("isSinglePageMode", () => c.options.maxPages <= 1, [
    c
  ]), h = c.options.actionShortcutsLocation === "menu" ? !0 : c.options.actionShortcutsLocation === "toolbar" ? !1 : e >= yi.TABLET;
  return !r && !l && !h ? null : /* @__PURE__ */ m.jsx("div", { ref: t, className: "tlui-menu-zone", children: /* @__PURE__ */ m.jsxs("div", { className: "tlui-buttons__horizontal", children: [
    r && /* @__PURE__ */ m.jsx(r, {}),
    l && !d && /* @__PURE__ */ m.jsx(l, {}),
    h ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      i && /* @__PURE__ */ m.jsx(i, {}),
      s && /* @__PURE__ */ m.jsx(s, {})
    ] }) : null
  ] }) });
});
function x0e() {
  const n = be(), e = gg(), [t, r] = M.useState(!1), i = M.useRef(!1);
  return dh(
    "toggle showback to content",
    () => {
      const s = i.current, l = n.getCurrentPageShapeIds();
      let c = !1;
      l.size && (c = l.size === n.getCulledShapes().size), s !== c && (r(c), i.current = c);
    },
    [n]
  ), t ? /* @__PURE__ */ m.jsx(
    Fe,
    {
      actionId: "back-to-content",
      onSelect: () => {
        e["back-to-content"].onSelect("helper-buttons"), r(!1);
      }
    }
  ) : null;
}
function w0e() {
  const n = be();
  return Pe("is pen mode", () => n.getInstanceState().isPenMode, [n]) ? /* @__PURE__ */ m.jsx(Fe, { actionId: "exit-pen-mode" }) : null;
}
function b0e() {
  const n = be(), e = gg();
  return Pe(
    "is following user",
    () => !!n.getInstanceState().followingUserId,
    [n]
  ) ? /* @__PURE__ */ m.jsx(Lo, { ...e["stop-following"] }) : null;
}
function C0e() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(w0e, {}),
    /* @__PURE__ */ m.jsx(x0e, {}),
    /* @__PURE__ */ m.jsx(b0e, {})
  ] });
}
function E0e({ children: n }) {
  const e = n ?? /* @__PURE__ */ m.jsx(C0e, {});
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-helper-buttons", children: /* @__PURE__ */ m.jsx(Ll, { type: "helper-buttons", sourceId: "helper-buttons", children: e }) });
}
function _0e() {
  const n = A_();
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(gn, { label: "shortcuts-dialog.tools", id: "tools", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-tool-lock" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "insert-media" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "select" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "draw" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "eraser" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "hand" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "rectangle" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "ellipse" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "arrow" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "line" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "text" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "frame" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "note" }),
      /* @__PURE__ */ m.jsx(ma, { toolId: "laser" }),
      /* @__PURE__ */ m.jsx(
        Lo,
        {
          id: "pointer-down",
          label: "tool.pointer-down",
          kbd: ",",
          onSelect: () => {
          }
        }
      )
    ] }),
    /* @__PURE__ */ m.jsxs(gn, { label: "shortcuts-dialog.preferences", id: "preferences", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-dark-mode" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-focus-mode" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "toggle-grid" })
    ] }),
    /* @__PURE__ */ m.jsxs(gn, { label: "shortcuts-dialog.edit", id: "edit", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "undo" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "redo" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "cut" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "copy" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "paste" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "select-all" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "delete" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "duplicate" })
    ] }),
    /* @__PURE__ */ m.jsxs(gn, { label: "shortcuts-dialog.view", id: "view", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-in" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-out" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-to-100" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-to-fit" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-to-selection" })
    ] }),
    /* @__PURE__ */ m.jsxs(gn, { label: "shortcuts-dialog.transform", id: "transform", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-to-front" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "bring-forward" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "send-backward" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "send-to-back" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "group" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "ungroup" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "flip-horizontal" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "flip-vertical" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-top" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-vertical" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-bottom" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-left" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-center-horizontal" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "align-right" })
    ] }),
    n && /* @__PURE__ */ m.jsx(gn, { label: "shortcuts-dialog.collaboration", id: "collaboration", children: /* @__PURE__ */ m.jsx(Fe, { actionId: "open-cursor-chat" }) })
  ] });
}
const P0e = M.memo(function({
  children: e
}) {
  const t = Ln(), r = qs(), i = e ?? /* @__PURE__ */ m.jsx(_0e, {});
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(I_, { className: "tlui-shortcuts-dialog__header", children: [
      /* @__PURE__ */ m.jsx(k_, { children: t("shortcuts-dialog.title") }),
      /* @__PURE__ */ m.jsx(R_, {})
    ] }),
    /* @__PURE__ */ m.jsx(
      nw,
      {
        className: It("tlui-shortcuts-dialog__body", {
          "tlui-shortcuts-dialog__body__mobile": r <= yi.MOBILE_XS,
          "tlui-shortcuts-dialog__body__tablet": r <= yi.TABLET
        }),
        children: /* @__PURE__ */ m.jsx(Ll, { type: "keyboard-shortcuts", sourceId: "kbd", children: i })
      }
    ),
    /* @__PURE__ */ m.jsx("div", { className: "tlui-dialog__scrim" })
  ] });
});
function kq() {
  const n = _h(), e = Vo(), t = Pe("locale", () => n == null ? void 0 : n.user.getLocale(), [n]);
  return n ? /* @__PURE__ */ m.jsx(Ia, { id: "help menu language", label: "menu.language", children: /* @__PURE__ */ m.jsx(gn, { id: "languages", children: qx.map(({ locale: r, label: i }) => /* @__PURE__ */ m.jsx(
    L_,
    {
      id: `language-${r}`,
      title: r,
      label: i,
      checked: r === t,
      readonlyOk: !0,
      onSelect: () => {
        n.user.updateUserPreferences({ locale: r }), e("change-language", { source: "menu", locale: r });
      }
    },
    r
  )) }) }) : null;
}
function T0e() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(kq, {}),
    /* @__PURE__ */ m.jsx(Rq, {})
  ] });
}
function Rq() {
  const { KeyboardShortcutsDialog: n } = Mh(), { addDialog: e } = Dw(), t = M.useCallback(() => {
    n && e({ component: n });
  }, [e, n]);
  return n ? /* @__PURE__ */ m.jsx(
    Lo,
    {
      id: "keyboard-shortcuts-button",
      label: "help-menu.keyboard-shortcuts",
      readonlyOk: !0,
      onSelect: t
    }
  ) : null;
}
function I0e() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(gn, { id: "basic", children: [
      /* @__PURE__ */ m.jsx(R0e, {}),
      /* @__PURE__ */ m.jsx(O0e, {}),
      /* @__PURE__ */ m.jsx(k0e, {}),
      /* @__PURE__ */ m.jsx(j0e, {})
    ] }),
    /* @__PURE__ */ m.jsx(L0e, {})
  ] });
}
function k0e() {
  return /* @__PURE__ */ m.jsxs(Ia, { id: "export-all-as", label: "context-menu.export-all-as", size: "small", children: [
    /* @__PURE__ */ m.jsxs(gn, { id: "export-all-as-group", children: [
      /* @__PURE__ */ m.jsx(Fe, { actionId: "export-all-as-svg" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "export-all-as-png" }),
      /* @__PURE__ */ m.jsx(Fe, { actionId: "export-all-as-json" })
    ] }),
    /* @__PURE__ */ m.jsx(gn, { id: "export-all-as-bg", children: /* @__PURE__ */ m.jsx(vL, {}) })
  ] });
}
function R0e() {
  const n = be(), e = Pe(
    "isSelectToolActive",
    () => n.getCurrentToolId() === "select",
    [n]
  );
  return /* @__PURE__ */ m.jsxs(Ia, { id: "edit", label: "menu.edit", disabled: !e, children: [
    /* @__PURE__ */ m.jsx(D0e, {}),
    /* @__PURE__ */ m.jsx(bq, {}),
    /* @__PURE__ */ m.jsx(Cq, {}),
    /* @__PURE__ */ m.jsx(M0e, {}),
    /* @__PURE__ */ m.jsx(A0e, {}),
    /* @__PURE__ */ m.jsx(gn, { id: "select-all", children: /* @__PURE__ */ m.jsx(Eq, {}) })
  ] });
}
function M0e() {
  return /* @__PURE__ */ m.jsxs(gn, { id: "misc", children: [
    /* @__PURE__ */ m.jsx(pq, {}),
    /* @__PURE__ */ m.jsx(gq, {}),
    /* @__PURE__ */ m.jsx(fq, {}),
    /* @__PURE__ */ m.jsx(dq, {}),
    /* @__PURE__ */ m.jsx(mq, {}),
    /* @__PURE__ */ m.jsx(yq, {}),
    /* @__PURE__ */ m.jsx(Pq, {}),
    /* @__PURE__ */ m.jsx(_q, {}),
    /* @__PURE__ */ m.jsx(hq, {})
  ] });
}
function A0e() {
  return /* @__PURE__ */ m.jsxs(gn, { id: "lock", children: [
    /* @__PURE__ */ m.jsx(vq, {}),
    /* @__PURE__ */ m.jsx(Dbe, {})
  ] });
}
function D0e() {
  const n = uq(), e = cq();
  return /* @__PURE__ */ m.jsxs(gn, { id: "undo-redo", children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "undo", disabled: !n }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "redo", disabled: !e })
  ] });
}
function O0e() {
  return /* @__PURE__ */ m.jsx(Ia, { id: "view", label: "menu.view", children: /* @__PURE__ */ m.jsxs(gn, { id: "view-actions", children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-in" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-out" }),
    /* @__PURE__ */ m.jsx(Sq, {}),
    /* @__PURE__ */ m.jsx(xq, {}),
    /* @__PURE__ */ m.jsx(wq, {})
  ] }) });
}
function j0e() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "insert-embed" }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "insert-media" })
  ] });
}
function L0e() {
  return /* @__PURE__ */ m.jsxs(gn, { id: "preferences", children: [
    /* @__PURE__ */ m.jsxs(Ia, { id: "preferences", label: "menu.preferences", children: [
      /* @__PURE__ */ m.jsxs(gn, { id: "preferences-actions", children: [
        /* @__PURE__ */ m.jsx(Kbe, {}),
        /* @__PURE__ */ m.jsx(Wbe, {}),
        /* @__PURE__ */ m.jsx(Gbe, {}),
        /* @__PURE__ */ m.jsx(qbe, {}),
        /* @__PURE__ */ m.jsx(Ybe, {}),
        /* @__PURE__ */ m.jsx(Xbe, {}),
        /* @__PURE__ */ m.jsx(Zbe, {}),
        /* @__PURE__ */ m.jsx(Jbe, {}),
        /* @__PURE__ */ m.jsx(e0e, {}),
        /* @__PURE__ */ m.jsx(Qbe, {})
      ] }),
      /* @__PURE__ */ m.jsx(gn, { id: "color-scheme", children: /* @__PURE__ */ m.jsx(Fve, {}) })
    ] }),
    /* @__PURE__ */ m.jsx(kq, {}),
    /* @__PURE__ */ m.jsx(Rq, {})
  ] });
}
const N0e = M.memo(function({ children: e }) {
  const t = io(), [r, i] = Xd("main menu"), s = Ln(), l = e ?? /* @__PURE__ */ m.jsx(I0e, {});
  return /* @__PURE__ */ m.jsxs(Aj, { dir: "ltr", open: r, onOpenChange: i, modal: !1, children: [
    /* @__PURE__ */ m.jsx(Dj, { asChild: !0, dir: "ltr", children: /* @__PURE__ */ m.jsx(Ot, { type: "icon", "data-testid": "main-menu.button", title: s("menu.title"), children: /* @__PURE__ */ m.jsx(In, { icon: "menu", small: !0 }) }) }),
    /* @__PURE__ */ m.jsx(T_, { container: t, children: /* @__PURE__ */ m.jsx(
      Oj,
      {
        className: "tlui-menu",
        side: "bottom",
        align: "start",
        collisionPadding: 4,
        alignOffset: 0,
        sideOffset: 6,
        children: /* @__PURE__ */ m.jsx(Ll, { type: "menu", sourceId: "main-menu", children: l })
      }
    ) })
  ] });
}), aA = {};
function px(n) {
  if (aA[n])
    return aA[n];
  const t = document.createElement("canvas").getContext("2d");
  t.fillStyle = n, t.fillRect(0, 0, 1, 1);
  const [r, i, s, l] = t.getImageData(0, 0, 1, 1).data, c = new Float32Array([r / 255, i / 255, s / 255, l / 255]);
  return aA[n] = c, c;
}
const YC = 10, Mq = (
  // num triangles in corners
  // num triangles in outer rects
  4 * 6 * YC + // num triangles in center rect
  12 + 4 * 12
);
function gy(n, {
  center: e,
  radius: t,
  numArcSegments: r = 20,
  startAngle: i = 0,
  endAngle: s = hr,
  offset: l = 0
}) {
  const c = (s - i) / r;
  let d = l;
  for (let h = i; h < s; h += c)
    n[d++] = e.x, n[d++] = e.y, n[d++] = e.x + Math.cos(h) * t, n[d++] = e.y + Math.sin(h) * t, n[d++] = e.x + Math.cos(h + c) * t, n[d++] = e.y + Math.sin(h + c) * t;
  return n;
}
function my(n, e, t, r, i, s) {
  n[e++] = t, n[e++] = r, n[e++] = t, n[e++] = r + s, n[e++] = t + i, n[e++] = r, n[e++] = t + i, n[e++] = r, n[e++] = t, n[e++] = r + s, n[e++] = t + i, n[e++] = r + s;
}
function F0e(n, e, t) {
  const r = YC;
  t = Math.min(t, Math.min(e.w, e.h) / 2);
  const i = Xe.ExpandBy(e, -t);
  if (i.w <= 0 || i.h <= 0)
    return gy(n, { center: e.center, radius: t, numArcSegments: YC * 4 }), YC * 4 * 6;
  let s = 0;
  return my(n, s, i.minX, i.minY, i.w, i.h), s += 12, my(n, s, i.minX, e.minY, i.w, t), s += 12, my(n, s, i.maxX, i.minY, t, i.h), s += 12, my(n, s, i.minX, i.maxY, i.w, t), s += 12, my(n, s, e.minX, i.minY, t, i.h), s += 12, gy(n, {
    numArcSegments: r,
    offset: s,
    center: i.point,
    radius: t,
    startAngle: Xn,
    endAngle: Xn * 1.5
  }), s += r * 6, gy(n, {
    numArcSegments: r,
    offset: s,
    center: R.Add(i.point, new R(i.w, 0)),
    radius: t,
    startAngle: Xn * 1.5,
    endAngle: hr
  }), s += r * 6, gy(n, {
    numArcSegments: r,
    offset: s,
    center: R.Add(i.point, i.size),
    radius: t,
    startAngle: 0,
    endAngle: Or
  }), s += r * 6, gy(n, {
    numArcSegments: r,
    offset: s,
    center: R.Add(i.point, new R(0, i.h)),
    radius: t,
    startAngle: Or,
    endAngle: Xn
  }), Mq;
}
function z0e(n) {
  if (!n) throw new Error("Canvas element not found");
  const e = n.getContext("webgl2", {
    premultipliedAlpha: !1
  });
  if (!e) throw new Error("Failed to get webgl2 context");
  const t = `#version 300 es
  precision mediump float;
  
  in vec2 shapeVertexPosition;

	uniform vec4 canvasPageBounds;

	// taken (with thanks) from
	// https://webglfundamentals.org/webgl/lessons/webgl-2d-matrices.html
  void main() {
		// convert the position from pixels to 0.0 to 1.0
		vec2 zeroToOne = (shapeVertexPosition - canvasPageBounds.xy) / canvasPageBounds.zw;
	
		// convert from 0->1 to 0->2
		vec2 zeroToTwo = zeroToOne * 2.0;
	
		// convert from 0->2 to -1->+1 (clipspace)
		vec2 clipSpace = zeroToTwo - 1.0;
	
		gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);
  }`, r = e.createShader(e.VERTEX_SHADER);
  if (!r)
    throw new Error("Failed to create vertex shader");
  if (e.shaderSource(r, t), e.compileShader(r), !e.getShaderParameter(r, e.COMPILE_STATUS))
    throw new Error("Failed to compile vertex shader");
  const i = `#version 300 es
  precision mediump float;
  
	uniform vec4 fillColor;
  out vec4 outputColor;

  void main() {
	outputColor = fillColor;
  }`, s = e.createShader(e.FRAGMENT_SHADER);
  if (!s)
    throw new Error("Failed to create fragment shader");
  if (e.shaderSource(s, i), e.compileShader(s), !e.getShaderParameter(s, e.COMPILE_STATUS))
    throw new Error("Failed to compile fragment shader");
  const l = e.createProgram();
  if (!l)
    throw new Error("Failed to create program");
  if (e.attachShader(l, r), e.attachShader(l, s), e.linkProgram(l), !e.getProgramParameter(l, e.LINK_STATUS))
    throw new Error("Failed to link program");
  e.useProgram(l);
  const c = e.getAttribLocation(
    l,
    "shapeVertexPosition"
  );
  if (c < 0)
    throw new Error("Failed to get shapeVertexPosition attribute location");
  e.enableVertexAttribArray(c);
  const d = e.getUniformLocation(l, "canvasPageBounds"), h = e.getUniformLocation(l, "fillColor");
  if (!e.createBuffer()) throw new Error("Failed to create buffer");
  if (!e.createBuffer()) throw new Error("Failed to create buffer");
  return {
    context: e,
    selectedShapes: pC(e, 1024),
    unselectedShapes: pC(e, 4096),
    viewport: pC(e, Mq),
    collaborators: pC(e, 1024),
    prepareTriangles(v, w) {
      e.bindBuffer(e.ARRAY_BUFFER, v.buffer), e.bufferData(e.ARRAY_BUFFER, v.vertices, e.STATIC_DRAW, 0, w), e.enableVertexAttribArray(c), e.vertexAttribPointer(
        c,
        2,
        e.FLOAT,
        !1,
        0,
        0
      );
    },
    drawTrianglesTransparently(v) {
      e.enable(e.BLEND), e.blendFunc(e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA), e.drawArrays(e.TRIANGLES, 0, v / 2), e.disable(e.BLEND);
    },
    drawTriangles(v) {
      e.drawArrays(e.TRIANGLES, 0, v / 2);
    },
    setFillColor(v) {
      e.uniform4fv(h, v);
    },
    setCanvasPageBounds(v) {
      e.uniform4fv(d, v);
    }
  };
}
function pC(n, e) {
  const t = n.createBuffer();
  if (!t) throw new Error("Failed to create buffer");
  return { buffer: t, vertices: new Float32Array(e) };
}
function I$(n, e, t) {
  let r = n.vertices.length;
  for (; r < e + t.length; )
    r *= 2;
  if (r != n.vertices.length) {
    const i = new Float32Array(r);
    i.set(n.vertices), n.vertices = i;
  }
  n.vertices.set(t, e);
}
var U0e = Object.create, Aq = Object.defineProperty, $0e = Object.getOwnPropertyDescriptor, B0e = (n, e) => (e = Symbol[n]) ? e : Symbol.for("Symbol." + n), Dq = (n) => {
  throw TypeError(n);
}, Oq = (n, e, t) => e in n ? Aq(n, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : n[e] = t, H0e = (n) => [, , , U0e(null)], jq = ["class", "method", "getter", "setter", "accessor", "field", "value", "get", "set"], Lq = (n) => n !== void 0 && typeof n != "function" ? Dq("Function expected") : n, V0e = (n, e, t, r, i) => ({ kind: jq[n], name: e, metadata: r, addInitializer: (s) => t._ ? Dq("Already initialized") : i.push(Lq(s || null)) }), K0e = (n, e) => Oq(e, B0e("metadata"), n[3]), W0e = (n, e, t, r) => {
  for (var i = 0, s = n[e >> 1], l = s && s.length; i < l; i++) s[i].call(t);
  return r;
}, Nu = (n, e, t, r, i, s) => {
  for (var l, c, d, h, g = e & 7, y = !1, v = !1, w = 2, C = jq[g + 5], E = n[w] || (n[w] = []), P = (i = i.prototype, $0e(i, t)), I = r.length - 1; I >= 0; I--)
    d = V0e(g, t, c = {}, n[3], E), d.static = y, d.private = v, h = d.access = { has: (k) => t in k }, h.get = (k) => k[t], l = (0, r[I])(P[C], d), c._ = 1, Lq(l) && (P[C] = l);
  return P && Aq(i, t, P), i;
}, kd = (n, e, t) => Oq(n, typeof e != "symbol" ? e + "" : e, t), Nq, Fq, zq, Uq, $q, Bq, Hq, Vq, Kq, Wq, sl;
Wq = [Ca], Kq = [Le], Vq = [Le], Hq = [Le], Bq = [Le], $q = [Le], Uq = [Le], zq = [Le], Fq = [Le], Nq = [Ca];
class zl {
  constructor(e, t, r) {
    this.editor = e, this.elem = t, this.container = r, W0e(sl, 5, this), kd(this, "disposables", []), kd(this, "gl"), kd(this, "shapeGeometryCache"), kd(this, "colors"), kd(this, "id", or()), kd(this, "canvasBoundingClientRect", mi("canvasBoundingClientRect", new Xe())), kd(this, "originPagePoint", new R()), kd(this, "originPageCenter", new R()), kd(this, "isInViewport", !1), this.gl = z0e(t), this.shapeGeometryCache = e.store.createComputedCache("webgl-geometry", (i) => {
      const s = e.getShapeMaskedPageBounds(i.id);
      if (!s) return null;
      const l = new Float32Array(12);
      return my(l, 0, s.x, s.y, s.w, s.h), l;
    }), this.colors = this._getColors(), this.disposables.push(this._listenForCanvasResize(), wc("minimap render", this.render));
  }
  close() {
    return this.disposables.forEach((e) => e());
  }
  _getColors() {
    const e = getComputedStyle(this.editor.getContainer());
    return {
      shapeFill: px(e.getPropertyValue("--color-text-3").trim()),
      selectFill: px(e.getPropertyValue("--color-selected").trim()),
      viewportFill: px(e.getPropertyValue("--color-muted-1").trim()),
      background: px(e.getPropertyValue("--color-low").trim())
    };
  }
  // this should be called after dark/light mode changes have propagated to the dom
  updateColors() {
    this.colors = this._getColors();
  }
  getDpr() {
    return this.editor.getInstanceState().devicePixelRatio;
  }
  getContentPageBounds() {
    const e = this.editor.getViewportPageBounds(), t = this.editor.getCurrentPageBounds();
    return t ? Xe.Expand(t, e) : e;
  }
  getContentScreenBounds() {
    const e = this.getContentPageBounds(), t = this.editor.pageToScreen(e.point), r = this.editor.pageToScreen(
      new R(e.maxX, e.maxY)
    );
    return new Xe(t.x, t.y, r.x - t.x, r.y - t.y);
  }
  _getCanvasBoundingRect() {
    const { x: e, y: t, width: r, height: i } = this.elem.getBoundingClientRect();
    return new Xe(e, t, r, i);
  }
  getCanvasScreenBounds() {
    return this.canvasBoundingClientRect.get();
  }
  _listenForCanvasResize() {
    const e = new ResizeObserver(() => {
      const t = this._getCanvasBoundingRect();
      this.canvasBoundingClientRect.set(t);
    });
    return e.observe(this.elem), e.observe(this.container), () => e.disconnect();
  }
  getCanvasSize() {
    const e = this.canvasBoundingClientRect.get(), t = this.getDpr();
    return new R(e.width * t, e.height * t);
  }
  getCanvasClientPosition() {
    return this.canvasBoundingClientRect.get().point;
  }
  getCanvasPageBounds() {
    const e = this.getCanvasScreenBounds(), t = this.getContentPageBounds(), r = e.width / e.height;
    let i = t.width, s = i / r;
    s < t.height && (s = t.height, i = s * r);
    const l = new Xe(0, 0, i, s);
    return l.center = t.center, l;
  }
  getZoom() {
    return this.getCanvasPageBounds().width / this.getCanvasScreenBounds().width;
  }
  getCanvasPageBoundsArray() {
    const { x: e, y: t, w: r, h: i } = this.getCanvasPageBounds();
    return new Float32Array([e, t, r, i]);
  }
  getMinimapPagePoint(e, t) {
    const r = this.getCanvasPageBounds(), i = this.getCanvasScreenBounds();
    let s = e - i.x, l = t - i.y;
    return s *= r.width / i.width, l *= r.height / i.height, s += r.minX, l += r.minY, new R(s, l, 1);
  }
  minimapScreenPointToPagePoint(e, t, r = !1, i = !1) {
    const { editor: s } = this, l = s.getViewportPageBounds();
    let { x: c, y: d } = this.getMinimapPagePoint(e, t);
    if (i) {
      const h = this.editor.getCurrentPageBounds() ?? new Xe(), g = h.minX - l.width / 2, y = h.maxX + l.width / 2, v = h.minY - l.height / 2, w = h.maxY + l.height / 2, C = Math.max(0, g + l.width - c), E = Math.max(0, -(y - l.width - c)), P = Math.max(0, v + l.height - d), I = Math.max(0, -(w - l.height - d));
      c += (C - E) / 2, d += (P - I) / 2, c = Do(c, g, y), d = Do(d, v, w);
    }
    if (r) {
      const { originPagePoint: h } = this, g = Math.abs(c - h.x), y = Math.abs(d - h.y);
      g > y ? d = h.y : c = h.x;
    }
    return new R(c, d);
  }
  render() {
    const e = this.gl.context, t = this.getCanvasSize();
    this.gl.setCanvasPageBounds(this.getCanvasPageBoundsArray()), this.elem.width = t.x, this.elem.height = t.y, e.viewport(0, 0, t.x, t.y), e.clearColor(
      this.colors.background[0],
      this.colors.background[1],
      this.colors.background[2],
      1
    ), e.clear(e.COLOR_BUFFER_BIT);
    const r = new Set(this.editor.getSelectedShapeIds()), i = this.colors;
    let s = 0, l = 0;
    const c = this.editor.getCurrentPageShapeIdsSorted();
    for (let d = 0, h = c.length; d < h; d++) {
      const g = c[d], y = this.shapeGeometryCache.get(g);
      if (!y) continue;
      const v = y.length;
      r.has(g) ? (I$(this.gl.selectedShapes, s, y), s += v) : (I$(this.gl.unselectedShapes, l, y), l += v);
    }
    this.drawShapes(this.gl.unselectedShapes, l, i.shapeFill), this.drawShapes(this.gl.selectedShapes, s, i.selectFill), this.drawViewport(), this.drawCollaborators();
  }
  drawShapes(e, t, r) {
    this.gl.prepareTriangles(e, t), this.gl.setFillColor(r), this.gl.drawTriangles(t);
  }
  drawViewport() {
    const e = this.editor.getViewportPageBounds(), t = F0e(this.gl.viewport.vertices, e, 4 * this.getZoom());
    this.gl.prepareTriangles(this.gl.viewport, t), this.gl.setFillColor(this.colors.viewportFill), this.gl.drawTrianglesTransparently(t), Er.isSafari && (this.gl.drawTrianglesTransparently(t), this.gl.drawTrianglesTransparently(t), this.gl.drawTrianglesTransparently(t));
  }
  drawCollaborators() {
    const e = this.editor.getCollaboratorsOnCurrentPage();
    if (!e.length) return;
    const t = 20, r = t * 6, i = r * e.length;
    this.gl.collaborators.vertices.length < i && (this.gl.collaborators.vertices = new Float32Array(i));
    const s = this.gl.collaborators.vertices;
    let l = 0;
    const c = this.getZoom();
    for (const { cursor: d } of e)
      d && (gy(s, {
        center: R.From(d),
        radius: 3 * c,
        offset: l,
        numArcSegments: t
      }), l += r);
    this.gl.prepareTriangles(this.gl.collaborators, i), l = 0;
    for (const { color: d } of e)
      this.gl.setFillColor(px(d)), this.gl.context.drawArrays(this.gl.context.TRIANGLES, l / 2, r / 2), l += r;
  }
}
sl = H0e();
Nu(sl, 1, "close", Wq, zl);
Nu(sl, 1, "getDpr", Kq, zl);
Nu(sl, 1, "getContentPageBounds", Vq, zl);
Nu(sl, 1, "getContentScreenBounds", Hq, zl);
Nu(sl, 1, "getCanvasSize", Bq, zl);
Nu(sl, 1, "getCanvasClientPosition", $q, zl);
Nu(sl, 1, "getCanvasPageBounds", Uq, zl);
Nu(sl, 1, "getZoom", zq, zl);
Nu(sl, 1, "getCanvasPageBoundsArray", Fq, zl);
Nu(sl, 1, "render", Nq, zl);
K0e(sl, zl);
function G0e() {
  const n = be(), e = io(), t = M.useRef(null), r = M.useRef(!1), i = M.useRef();
  M.useEffect(() => {
    try {
      const g = new zl(n, t.current, e);
      return i.current = g, i.current.close;
    } catch (g) {
      n.annotateError(g, {
        origin: "minimap",
        willCrashApp: !1
      }), n.timers.setTimeout(() => {
        throw g;
      });
    }
  }, [n, e]);
  const s = M.useCallback(
    (g) => {
      if (!n.getCurrentPageShapeIds().size || !i.current) return;
      const y = i.current.minimapScreenPointToPagePoint(
        g.clientX,
        g.clientY,
        !1,
        !1
      ), v = i.current.minimapScreenPointToPagePoint(
        g.clientX,
        g.clientY,
        !1,
        !0
      );
      i.current.originPagePoint.setTo(v), i.current.originPageCenter.setTo(n.getViewportPageBounds().center), n.centerOnPoint(y, { animation: { duration: n.options.animationMediumMs } });
    },
    [n]
  ), l = M.useCallback(
    (g) => {
      if (!i.current) return;
      const y = g.currentTarget;
      if (yw(y, g), !n.getCurrentPageShapeIds().size) return;
      r.current = !0, i.current.isInViewport = !1;
      const v = i.current.minimapScreenPointToPagePoint(
        g.clientX,
        g.clientY,
        !1,
        !1
      ), w = n.getViewportPageBounds(), C = i.current.getContentPageBounds();
      if (new Xe(
        C.x - w.width / 2,
        C.y - w.height / 2,
        C.width + w.width,
        C.height + w.height
      ).containsPoint(v) && !w.containsPoint(v)) {
        i.current.isInViewport = w.containsPoint(v);
        const I = R.Sub(w.center, w.point), k = R.Add(v, I);
        i.current.originPagePoint.setTo(k), i.current.originPageCenter.setTo(v), n.centerOnPoint(v, { animation: { duration: n.options.animationMediumMs } });
      } else {
        const I = i.current.minimapScreenPointToPagePoint(
          g.clientX,
          g.clientY,
          !1,
          !0
        );
        i.current.isInViewport = w.containsPoint(I), i.current.originPagePoint.setTo(I), i.current.originPageCenter.setTo(w.center);
      }
      function P(I) {
        y && vw(y, I), r.current = !1, document.body.removeEventListener("pointerup", P);
      }
      document.body.addEventListener("pointerup", P);
    },
    [n]
  ), c = M.useCallback(
    (g) => {
      if (!i.current) return;
      const y = i.current.minimapScreenPointToPagePoint(
        g.clientX,
        g.clientY,
        g.shiftKey,
        !0
      );
      if (r.current) {
        if (i.current.isInViewport) {
          const E = i.current.originPagePoint.clone().sub(i.current.originPageCenter);
          n.centerOnPoint(R.Sub(y, E));
          return;
        }
        n.centerOnPoint(y);
      }
      const v = i.current.getMinimapPagePoint(g.clientX, g.clientY), w = n.pageToScreen(v), C = {
        type: "pointer",
        target: "canvas",
        name: "pointer_move",
        ...Xa(g),
        point: w,
        isPen: n.getInstanceState().isPenMode
      };
      n.dispatch(C);
    },
    [n]
  ), d = M.useCallback(
    (g) => {
      const y = sB(g);
      n.dispatch({
        type: "wheel",
        name: "wheel",
        delta: y,
        point: new R(g.clientX, g.clientY),
        shiftKey: g.shiftKey,
        altKey: g.altKey,
        ctrlKey: g.metaKey || g.ctrlKey,
        metaKey: g.metaKey,
        accelKey: ms(g)
      });
    },
    [n]
  ), h = Pw();
  return M.useEffect(() => {
    n.timers.setTimeout(() => {
      var g, y;
      (g = i.current) == null || g.updateColors(), (y = i.current) == null || y.render();
    });
  }, [h, n]), /* @__PURE__ */ m.jsx("div", { className: "tlui-minimap", children: /* @__PURE__ */ m.jsx(
    "canvas",
    {
      role: "img",
      "aria-label": "minimap",
      ref: t,
      className: "tlui-minimap__canvas",
      onDoubleClick: s,
      onPointerMove: c,
      onPointerDown: l,
      onWheelCapture: d
    }
  ) });
}
function q0e(n, e) {
  const [t, r] = Bt.useState(e);
  Bt.useLayoutEffect(() => {
    const s = eO(n);
    if (s)
      try {
        r(JSON.parse(s));
      } catch {
        console.error(`Could not restore value ${n} from local storage.`);
      }
  }, [n]);
  const i = Bt.useCallback(
    (s) => {
      r((l) => {
        const c = typeof s == "function" ? s(l) : s;
        return tO(n, JSON.stringify(c)), c;
      });
    },
    [n]
  );
  return [t, i];
}
const Y0e = M.memo(function() {
  const e = gg(), t = Ln(), r = qs(), i = M.useRef(null);
  Th(i);
  const [s, l] = q0e("minimap", !0), c = M.useCallback(() => {
    l((g) => !g);
  }, [l]), { ZoomMenu: d, Minimap: h } = Mh();
  return r < yi.MOBILE ? null : /* @__PURE__ */ m.jsxs("div", { ref: i, className: "tlui-navigation-panel", children: [
    /* @__PURE__ */ m.jsx("div", { className: "tlui-buttons__horizontal", children: d && r < yi.TABLET ? /* @__PURE__ */ m.jsx(d, {}) : s ? /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      d && /* @__PURE__ */ m.jsx(d, {}),
      h && /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: t("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: c,
          children: /* @__PURE__ */ m.jsx(In, { icon: s ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          "data-testid": "minimap.zoom-out",
          title: `${t(rw(e["zoom-out"].label))} ${bD(e["zoom-out"].kbd)}`,
          onClick: () => e["zoom-out"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ m.jsx(In, { icon: "minus" })
        }
      ),
      d && /* @__PURE__ */ m.jsx(d, {}),
      /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          "data-testid": "minimap.zoom-in",
          title: `${t(rw(e["zoom-in"].label))} ${bD(e["zoom-in"].kbd)}`,
          onClick: () => e["zoom-in"].onSelect("navigation-zone"),
          children: /* @__PURE__ */ m.jsx(In, { icon: "plus" })
        }
      ),
      h && /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          "data-testid": "minimap.toggle-button",
          title: t("navigation-zone.toggle-minimap"),
          className: "tlui-navigation-panel__toggle",
          onClick: c,
          children: /* @__PURE__ */ m.jsx(In, { icon: s ? "chevrons-ne" : "chevrons-sw" })
        }
      )
    ] }) }),
    h && r >= yi.TABLET && !s && /* @__PURE__ */ m.jsx(h, {})
  ] });
}), X0e = function({
  name: e,
  id: t,
  isCurrentPage: r,
  onCancel: i
}) {
  const s = be(), l = Vo(), c = M.useRef(null), d = M.useRef(null), h = M.useCallback(() => {
    d.current = s.markHistoryStoppingPoint("rename page");
  }, [s]), g = M.useCallback(
    (v) => {
      s.renamePage(t, v || "New Page"), l("rename-page", { source: "page-menu" });
    },
    [s, t, l]
  ), y = M.useCallback(() => {
    d.current && s.bailToMark(d.current), i();
  }, [s, i]);
  return /* @__PURE__ */ m.jsx(
    M_,
    {
      className: "tlui-page-menu__item__input",
      ref: (v) => c.current = v,
      defaultValue: e,
      onValueChange: g,
      onCancel: y,
      onFocus: h,
      shouldManuallyMaintainScrollPositionWhenFocused: !0,
      autoFocus: r,
      autoSelect: !0
    }
  );
}, BD = (n, e, t, r, i) => {
  let s;
  const l = n.getPages(), c = t > r ? l[r - 1] : l[r], d = t > r ? l[r] : l[r + 1];
  c && !d ? s = vu(c.index) : !c && d ? s = dne(l[0].index) : s = Hx(c.index, d.index), s !== l[t].index && (n.markHistoryStoppingPoint("moving page"), n.updatePage({
    id: e,
    index: s
  }), i("move-page", { source: "page-menu" }));
}, k$ = Ho(function({
  index: e,
  listSize: t,
  item: r,
  onRename: i
}) {
  const s = be(), l = Ln(), c = s.getPages(), d = Vo(), h = M.useCallback(() => {
    s.markHistoryStoppingPoint("creating page");
    const w = rl.createId();
    s.duplicatePage(r.id, w), d("duplicate-page", { source: "page-menu" });
  }, [s, r, d]), g = M.useCallback(() => {
    BD(s, r.id, e, e - 1, d);
  }, [s, r, e, d]), y = M.useCallback(() => {
    BD(s, r.id, e, e + 1, d);
  }, [s, r, e, d]), v = M.useCallback(() => {
    s.markHistoryStoppingPoint("deleting page"), s.deletePage(r.id), d("delete-page", { source: "page-menu" });
  }, [s, r, d]);
  return /* @__PURE__ */ m.jsxs(og, { id: `page item submenu ${e}`, children: [
    /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(Ot, { type: "icon", title: l("page-menu.submenu.title"), children: /* @__PURE__ */ m.jsx(In, { icon: "dots-vertical", small: !0 }) }) }),
    /* @__PURE__ */ m.jsx(ag, { alignOffset: 0, side: "right", sideOffset: -4, children: /* @__PURE__ */ m.jsxs(Ll, { type: "menu", sourceId: "page-menu", children: [
      /* @__PURE__ */ m.jsxs(gn, { id: "modify", children: [
        i && /* @__PURE__ */ m.jsx(Lo, { id: "rename", label: "page-menu.submenu.rename", onSelect: i }),
        /* @__PURE__ */ m.jsx(
          Lo,
          {
            id: "duplicate",
            label: "page-menu.submenu.duplicate-page",
            onSelect: h,
            disabled: c.length >= s.options.maxPages
          }
        ),
        e > 0 && /* @__PURE__ */ m.jsx(
          Lo,
          {
            id: "move-up",
            onSelect: g,
            label: "page-menu.submenu.move-up"
          }
        ),
        e < t - 1 && /* @__PURE__ */ m.jsx(
          Lo,
          {
            id: "move-down",
            label: "page-menu.submenu.move-down",
            onSelect: y
          }
        )
      ] }),
      t > 1 && /* @__PURE__ */ m.jsx(gn, { id: "delete", children: /* @__PURE__ */ m.jsx(Lo, { id: "delete", onSelect: v, label: "page-menu.submenu.delete" }) })
    ] }) })
  ] });
}), Z0e = M.memo(function() {
  const e = be(), t = Vo(), r = Ln(), i = qs(), s = M.useCallback(() => I(!1), []), [l, c] = Xd("page-menu", s), d = 36, h = M.useRef(null), g = Pe("pages", () => e.getPages(), [e]), y = Pe("currentPage", () => e.getCurrentPage(), [e]), v = Pe("currentPageId", () => e.getCurrentPageId(), [e]), w = ol(), C = Pe(
    "maxPageCountReached",
    () => e.getPages().length >= e.options.maxPages,
    [e]
  ), E = Pe(
    "isCoarsePointer",
    () => e.getInstanceState().isCoarsePointer,
    [e]
  ), [P, I] = M.useState(!1), k = M.useCallback(() => {
    w || I((W) => !W);
  }, [w]), L = M.useRef({
    isPointing: !1,
    status: "idle",
    pointing: null,
    startY: 0,
    startIndex: 0,
    dragIndex: 0
  }), [O, z] = M.useState(
    Object.fromEntries(
      g.map((W, Y) => [W.id, { y: Y * d, offsetY: 0, isSelected: !1 }])
    )
  );
  M.useLayoutEffect(() => {
    z(
      Object.fromEntries(
        g.map((W, Y) => [W.id, { y: Y * d, offsetY: 0, isSelected: !1 }])
      )
    );
  }, [d, g]), M.useEffect(() => {
    l && e.timers.requestAnimationFrame(() => {
      const W = document.querySelector(
        `[data-testid="page-menu-item-${v}"]`
      );
      if (W) {
        const Y = h.current;
        if (!Y) return;
        const oe = W.offsetTop, le = Y.scrollTop;
        oe < le && Y.scrollTo({ top: oe });
        const ce = oe + d, Q = Y.scrollTop + Y.offsetHeight;
        ce > Q && Y.scrollTo({ top: ce - Y.offsetHeight });
      }
    });
  }, [d, v, l, e]);
  const F = M.useCallback(
    (W) => {
      const { clientY: Y, currentTarget: oe } = W, {
        dataset: { id: le, index: ce }
      } = oe;
      if (!le || !ce) return;
      const Q = L.current;
      yw(W.currentTarget, W), Q.status = "pointing", Q.pointing = { id: le, index: +ce };
      const ke = O[le].y;
      Q.startY = Y, Q.startIndex = Math.max(0, Math.min(Math.round(ke / d), g.length - 1));
    },
    [d, g.length, O]
  ), H = M.useCallback(
    (W) => {
      const Y = L.current;
      if (Y.status === "pointing") {
        const { clientY: oe } = W, le = oe - Y.startY;
        Math.abs(le) > 5 && (Y.status = "dragging");
      }
      if (Y.status === "dragging") {
        const { clientY: oe } = W, le = oe - Y.startY, ce = O[Y.pointing.id], { startIndex: Q, pointing: he } = Y, ke = ce.y + le, te = Math.max(0, Math.min(Math.round(ke / d), g.length - 1)), me = { ...O };
        if (me[he.id] = {
          y: ce.y,
          offsetY: le,
          isSelected: !0
        }, te !== Y.dragIndex) {
          Y.dragIndex = te;
          for (let Oe = 0; Oe < g.length; Oe++) {
            const Ze = g[Oe];
            if (Ze.id === Y.pointing.id)
              continue;
            let { y: De } = me[Ze.id];
            te === Q ? De = Oe * d : te < Q ? te <= Oe && Oe < Q ? De = (Oe + 1) * d : De = Oe * d : te > Q && (te >= Oe && Oe > Q ? De = (Oe - 1) * d : De = Oe * d), De !== me[Ze.id].y && (me[Ze.id] = { y: De, offsetY: 0, isSelected: !0 });
          }
        }
        z(me);
      }
    },
    [d, g, O]
  ), V = M.useCallback(
    (W) => {
      const Y = L.current;
      if (Y.status === "dragging") {
        const { id: oe, index: le } = Y.pointing;
        BD(e, oe, le, Y.dragIndex, t);
      }
      vw(W.currentTarget, W), Y.status = "idle";
    },
    [e, t]
  ), re = M.useCallback(
    (W) => {
      const Y = L.current;
      W.key === "Escape" && (Y.status === "dragging" && z(
        Object.fromEntries(
          g.map((oe, le) => [
            oe.id,
            { y: le * d, offsetY: 0, isSelected: !1 }
          ])
        )
      ), Y.status = "idle");
    },
    [d, g]
  ), q = M.useCallback(() => {
    w || (e.run(() => {
      e.markHistoryStoppingPoint("creating page");
      const W = rl.createId();
      e.createPage({ name: r("page-menu.new-page-initial-name"), id: W }), e.setCurrentPage(W), I(!0);
    }), t("new-page", { source: "page-menu" }));
  }, [e, r, w, t]), J = M.useCallback(
    (W) => {
      e.setCurrentPage(W), t("change-page", { source: "page-menu" });
    },
    [e, t]
  ), ie = M.useCallback(
    (W, Y) => {
      e.renamePage(W, Y), t("rename-page", { source: "page-menu" });
    },
    [e, t]
  );
  return /* @__PURE__ */ m.jsxs(gL, { id: "pages", onOpenChange: c, open: l, children: [
    /* @__PURE__ */ m.jsx(mL, { "data-testid": "main.page-menu", children: /* @__PURE__ */ m.jsxs(
      Ot,
      {
        type: "menu",
        title: y.name,
        "data-testid": "page-menu.button",
        className: "tlui-page-menu__trigger",
        children: [
          /* @__PURE__ */ m.jsx("div", { className: "tlui-page-menu__name", children: y.name }),
          /* @__PURE__ */ m.jsx(In, { icon: "chevron-down", small: !0 })
        ]
      }
    ) }),
    /* @__PURE__ */ m.jsx(
      yL,
      {
        side: "bottom",
        align: "start",
        sideOffset: 6,
        disableEscapeKeyDown: P,
        children: /* @__PURE__ */ m.jsxs("div", { className: "tlui-page-menu__wrapper", children: [
          /* @__PURE__ */ m.jsxs("div", { className: "tlui-page-menu__header", children: [
            /* @__PURE__ */ m.jsx("div", { className: "tlui-page-menu__header__title", children: r("page-menu.title") }),
            !w && /* @__PURE__ */ m.jsxs("div", { className: "tlui-buttons__horizontal", children: [
              /* @__PURE__ */ m.jsx(
                Ot,
                {
                  type: "icon",
                  "data-testid": "page-menu.edit",
                  title: r(P ? "page-menu.edit-done" : "page-menu.edit-start"),
                  onClick: k,
                  children: /* @__PURE__ */ m.jsx(In, { icon: P ? "check" : "edit" })
                }
              ),
              /* @__PURE__ */ m.jsx(
                Ot,
                {
                  type: "icon",
                  "data-testid": "page-menu.create",
                  title: r(
                    C ? "page-menu.max-page-count-reached" : "page-menu.create-new-page"
                  ),
                  disabled: C,
                  onClick: q,
                  children: /* @__PURE__ */ m.jsx(In, { icon: "plus" })
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ m.jsx(
            "div",
            {
              "data-testid": "page-menu.list",
              className: "tlui-page-menu__list tlui-menu__group",
              style: { height: d * g.length + 4 },
              ref: h,
              children: g.map((W, Y) => {
                const oe = O[W.id] ?? {
                  position: Y * 40,
                  offsetY: 0
                };
                return P ? /* @__PURE__ */ m.jsxs(
                  "div",
                  {
                    "data-testid": "page-menu.item",
                    className: "tlui-page_menu__item__sortable",
                    style: {
                      zIndex: W.id === y.id ? 888 : Y,
                      transform: `translate(0px, ${oe.y + oe.offsetY}px)`
                    },
                    children: [
                      /* @__PURE__ */ m.jsx(
                        Ot,
                        {
                          type: "icon",
                          tabIndex: -1,
                          className: "tlui-page_menu__item__sortable__handle",
                          onPointerDown: F,
                          onPointerUp: V,
                          onPointerMove: H,
                          onKeyDown: re,
                          "data-id": W.id,
                          "data-index": Y,
                          children: /* @__PURE__ */ m.jsx(In, { icon: "drag-handle-dots" })
                        }
                      ),
                      i < yi.TABLET_SM && E ? (
                        // sigh, this is a workaround for iOS Safari
                        // because the device and the radix popover seem
                        // to be fighting over scroll position. Nothing
                        // else seems to work!
                        /* @__PURE__ */ m.jsxs(Ot, {
                          type: "normal",
                          className: "tlui-page-menu__item__button",
                          onClick: () => {
                            const le = window.prompt("Rename page", W.name);
                            le && le !== W.name && ie(W.id, le);
                          },
                          onDoubleClick: k,
                          children: [
                            /* @__PURE__ */ m.jsx($D, { checked: W.id === y.id }),
                            /* @__PURE__ */ m.jsx(_i, { children: W.name })
                          ]
                        })
                      ) : /* @__PURE__ */ m.jsx(
                        "div",
                        {
                          className: "tlui-page_menu__item__sortable__title",
                          style: { height: d },
                          children: /* @__PURE__ */ m.jsx(
                            X0e,
                            {
                              id: W.id,
                              name: W.name,
                              isCurrentPage: W.id === y.id,
                              onCancel: () => {
                                I(!1), e.menus.clearOpenMenus();
                              }
                            }
                          )
                        }
                      ),
                      !w && /* @__PURE__ */ m.jsx("div", { className: "tlui-page_menu__item__submenu", "data-isediting": P, children: /* @__PURE__ */ m.jsx(k$, { index: Y, item: W, listSize: g.length }) })
                    ]
                  },
                  W.id + "_editing"
                ) : /* @__PURE__ */ m.jsxs("div", { "data-testid": "page-menu.item", className: "tlui-page-menu__item", children: [
                  /* @__PURE__ */ m.jsxs(
                    Ot,
                    {
                      type: "normal",
                      className: "tlui-page-menu__item__button",
                      onClick: () => J(W.id),
                      onDoubleClick: k,
                      title: r("page-menu.go-to-page"),
                      children: [
                        /* @__PURE__ */ m.jsx($D, { checked: W.id === y.id }),
                        /* @__PURE__ */ m.jsx(_i, { children: W.name })
                      ]
                    }
                  ),
                  !w && /* @__PURE__ */ m.jsx("div", { className: "tlui-page_menu__item__submenu", children: /* @__PURE__ */ m.jsx(
                    k$,
                    {
                      index: Y,
                      item: W,
                      listSize: g.length,
                      onRename: () => {
                        if (Er.isIos) {
                          const le = window.prompt("Rename page", W.name);
                          le && le !== W.name && ie(W.id, le);
                        } else
                          I(!0), v !== W.id && J(W.id);
                      }
                    }
                  ) })
                ] }, W.id);
              })
            }
          )
        ] })
      }
    )
  ] });
});
function Q0e() {
  const n = be(), e = ol(), t = Pe(
    "should display quick actions",
    () => n.isInAny("select", "hand", "zoom"),
    [n]
  );
  if (!(e && !t))
    return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(e1e, {}),
      /* @__PURE__ */ m.jsx(J0e, {})
    ] });
}
function J0e() {
  const n = Ys(1), e = Zd(), t = n && e;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "delete", disabled: !t }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "duplicate", disabled: !t })
  ] });
}
function e1e() {
  const n = uq(), e = cq();
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "undo", disabled: !n }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "redo", disabled: !e })
  ] });
}
const t1e = M.memo(function({
  children: e
}) {
  const t = e ?? /* @__PURE__ */ m.jsx(Q0e, {});
  return /* @__PURE__ */ m.jsx(Ll, { type: "small-icons", sourceId: "quick-actions", children: t });
});
function n1e({ userId: n }) {
  const e = JE(n);
  return e ? /* @__PURE__ */ m.jsx(
    "div",
    {
      className: "tlui-people-menu__avatar",
      style: {
        backgroundColor: e.color
      },
      children: e.userName === "New User" ? "" : e.userName[0] ?? ""
    },
    n
  ) : null;
}
const r1e = Ho(function({ userId: e }) {
  const t = be(), r = Ln(), i = Vo(), s = JE(e), l = M.useCallback(() => {
    t.getInstanceState().followingUserId === e ? (t.stopFollowingUser(), i("stop-following", { source: "people-menu" })) : (t.startFollowingUser(e), i("start-following", { source: "people-menu" }));
  }, [t, e, i]), c = (s == null ? void 0 : s.followingUserId) === t.user.getId(), d = t.getInstanceState().followingUserId === e;
  return s ? /* @__PURE__ */ m.jsxs("div", { className: "tlui-people-menu__item tlui-buttons__horizontal", children: [
    /* @__PURE__ */ m.jsxs(
      Ot,
      {
        type: "menu",
        className: "tlui-people-menu__item__button",
        onClick: () => t.zoomToUser(e),
        onDoubleClick: l,
        children: [
          /* @__PURE__ */ m.jsx(ku, { icon: "color", color: s.color }),
          /* @__PURE__ */ m.jsx("div", { className: "tlui-people-menu__name", children: s.userName ?? "New User" })
        ]
      }
    ),
    /* @__PURE__ */ m.jsx(
      Ot,
      {
        type: "icon",
        className: "tlui-people-menu__item__follow",
        title: r(c ? "people-menu.leading" : d ? "people-menu.following" : "people-menu.follow"),
        onClick: l,
        disabled: c,
        "data-active": d || c,
        children: /* @__PURE__ */ m.jsx(
          In,
          {
            icon: c ? "leading" : d ? "following" : "follow"
          }
        )
      }
    )
  ] }) : null;
});
function i1e({ count: n }) {
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-people-menu__more", children: "+" + Math.abs(n) });
}
const o1e = Ho(function() {
  const e = be(), t = io(), r = Ln(), i = Vo(), s = M.useRef(!1), [l, c] = M.useState(!1), d = M.useCallback((E) => {
    c(E);
  }, []), h = e.user.getColor(), g = M.useCallback(
    (E) => {
      e.user.updateUserPreferences({ color: E }), i("set-color", { source: "people-menu" });
    },
    [e, i]
  ), {
    handleButtonClick: y,
    handleButtonPointerDown: v,
    handleButtonPointerEnter: w,
    handleButtonPointerUp: C
  } = Bt.useMemo(() => {
    const E = () => {
      s.current = !1, window.removeEventListener("pointerup", E);
    };
    return {
      handleButtonClick: (O) => {
        const { id: z } = O.currentTarget.dataset;
        z && h !== z && g(z);
      },
      handleButtonPointerDown: (O) => {
        const { id: z } = O.currentTarget.dataset;
        z && (g(z), s.current = !0, window.addEventListener("pointerup", E));
      },
      handleButtonPointerEnter: (O) => {
        if (!s.current) return;
        const { id: z } = O.currentTarget.dataset;
        z && g(z);
      },
      handleButtonPointerUp: (O) => {
        const { id: z } = O.currentTarget.dataset;
        z && g(z);
      }
    };
  }, [h, g]);
  return /* @__PURE__ */ m.jsxs(dL, { onOpenChange: d, open: l, children: [
    /* @__PURE__ */ m.jsx(fL, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ m.jsx(
      Ot,
      {
        type: "icon",
        className: "tlui-people-menu__user__color",
        style: { color: e.user.getColor() },
        title: r("people-menu.change-color"),
        children: /* @__PURE__ */ m.jsx(In, { icon: "color" })
      }
    ) }),
    /* @__PURE__ */ m.jsx(hL, { container: t, children: /* @__PURE__ */ m.jsx(
      pL,
      {
        dir: "ltr",
        className: "tlui-menu tlui-people-menu__user__color-picker",
        align: "start",
        side: "left",
        sideOffset: 8,
        children: /* @__PURE__ */ m.jsx("div", { className: "tlui-buttons__grid", children: YA.map((E) => /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            "data-id": E,
            "data-testid": E,
            "aria-label": E,
            "data-state": h === E ? "hinted" : void 0,
            title: E,
            className: "tlui-button-grid__button",
            style: { color: E },
            onPointerEnter: w,
            onPointerDown: v,
            onPointerUp: C,
            onClick: y,
            children: /* @__PURE__ */ m.jsx(In, { icon: "color" })
          },
          E
        )) })
      }
    ) })
  ] });
});
function s1e() {
  const n = be(), e = Vo(), t = Pe("userName", () => n.user.getName(), []), r = Ln(), i = M.useRef(t), s = M.useRef(t), [l, c] = M.useState(!1), d = M.useCallback(() => {
    c((v) => !v);
  }, []), h = M.useCallback(
    (v) => {
      s.current = v, n.user.updateUserPreferences({ name: v });
    },
    [n]
  ), g = M.useCallback(() => {
    i.current !== s.current && (e("change-user-name", { source: "people-menu" }), i.current = s.current);
  }, [e]), y = M.useCallback(() => {
    c(!1), n.user.updateUserPreferences({ name: i.current }), n.menus.clearOpenMenus();
  }, [n]);
  return /* @__PURE__ */ m.jsxs("div", { className: "tlui-people-menu__user", children: [
    /* @__PURE__ */ m.jsx(o1e, {}),
    l ? /* @__PURE__ */ m.jsx(
      M_,
      {
        className: "tlui-people-menu__user__input",
        defaultValue: t,
        onValueChange: h,
        onComplete: d,
        onCancel: y,
        onBlur: g,
        shouldManuallyMaintainScrollPositionWhenFocused: !0,
        autoFocus: !0,
        autoSelect: !0
      }
    ) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
      /* @__PURE__ */ m.jsx(
        "div",
        {
          className: "tlui-people-menu__user__name",
          onDoubleClick: () => {
            l || c(!0);
          },
          children: t
        }
      ),
      t === "New User" ? /* @__PURE__ */ m.jsx("div", { className: "tlui-people-menu__user__label", children: r("people-menu.user") }) : null
    ] }),
    /* @__PURE__ */ m.jsx(
      Ot,
      {
        type: "icon",
        className: "tlui-people-menu__user__edit",
        "data-testid": "people-menu.change-name",
        title: r("people-menu.change-name"),
        onClick: d,
        children: /* @__PURE__ */ m.jsx(In, { icon: l ? "check" : "edit" })
      }
    )
  ] });
}
function a1e({ displayUserWhenAlone: n, children: e }) {
  const t = Ln(), r = io(), i = be(), s = cB(), l = Pe("user", () => i.user.getColor(), [i]), c = Pe("user", () => i.user.getName(), [i]), [d, h] = Xd("people menu");
  return /* @__PURE__ */ m.jsxs(dL, { onOpenChange: h, open: d, children: [
    /* @__PURE__ */ m.jsx(fL, { dir: "ltr", asChild: !0, children: /* @__PURE__ */ m.jsxs("button", { className: "tlui-people-menu__avatars-button", title: t("people-menu.title"), children: [
      s.length > 5 && /* @__PURE__ */ m.jsx(i1e, { count: s.length - 5 }),
      /* @__PURE__ */ m.jsxs("div", { className: "tlui-people-menu__avatars", children: [
        s.slice(-5).map((g) => /* @__PURE__ */ m.jsx(n1e, { userId: g }, g)),
        (n || s.length > 0) && /* @__PURE__ */ m.jsx(
          "div",
          {
            className: "tlui-people-menu__avatar",
            style: {
              backgroundColor: l
            },
            children: c === "New User" ? "" : c[0] ?? ""
          }
        )
      ] })
    ] }) }),
    /* @__PURE__ */ m.jsx(hL, { container: r, children: /* @__PURE__ */ m.jsx(
      pL,
      {
        dir: "ltr",
        className: "tlui-menu",
        side: "bottom",
        sideOffset: 2,
        collisionPadding: 4,
        onEscapeKeyDown: wn,
        children: /* @__PURE__ */ m.jsxs("div", { className: "tlui-people-menu__wrapper", children: [
          /* @__PURE__ */ m.jsx("div", { className: "tlui-people-menu__section", children: /* @__PURE__ */ m.jsx(s1e, {}) }),
          s.length > 0 && /* @__PURE__ */ m.jsx("div", { className: "tlui-people-menu__section", children: s.map((g) => /* @__PURE__ */ m.jsx(r1e, { userId: g }, g + "_presence")) }),
          e
        ] })
      }
    ) })
  ] });
}
function l1e() {
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-share-zone", draggable: !1, children: /* @__PURE__ */ m.jsx(a1e, { displayUserWhenAlone: !0 }) });
}
const c1e = Object.freeze([
  nl,
  Jp,
  eg,
  Pu
]);
function Gq(n = c1e) {
  const e = be();
  return Pe(
    "getRelevantStyles",
    () => {
      var s;
      const t = new tD(e.getSharedStyles()), r = !!((s = e.root.getCurrent()) != null && s.shapeType), i = e.isIn("select") && e.getSelectedShapeIds().length > 0;
      if (t.size === 0 && e.isIn("select") && e.getSelectedShapeIds().length === 0)
        for (const l of n)
          t.applyValue(l, e.getStyleForNextShape(l));
      return r || i || t.size > 0 ? t : null;
    },
    [e]
  );
}
const Al = {
  color: [
    { value: "black", icon: "color" },
    { value: "grey", icon: "color" },
    { value: "light-violet", icon: "color" },
    { value: "violet", icon: "color" },
    { value: "blue", icon: "color" },
    { value: "light-blue", icon: "color" },
    { value: "yellow", icon: "color" },
    { value: "orange", icon: "color" },
    { value: "green", icon: "color" },
    { value: "light-green", icon: "color" },
    { value: "light-red", icon: "color" },
    { value: "red", icon: "color" }
  ],
  fill: [
    { value: "none", icon: "fill-none" },
    { value: "semi", icon: "fill-semi" },
    { value: "solid", icon: "fill-solid" },
    { value: "pattern", icon: "fill-pattern" }
    // { value: 'fill', icon: 'fill-fill' },
  ],
  dash: [
    { value: "draw", icon: "dash-draw" },
    { value: "dashed", icon: "dash-dashed" },
    { value: "dotted", icon: "dash-dotted" },
    { value: "solid", icon: "dash-solid" }
  ],
  size: [
    { value: "s", icon: "size-small" },
    { value: "m", icon: "size-medium" },
    { value: "l", icon: "size-large" },
    { value: "xl", icon: "size-extra-large" }
  ],
  font: [
    { value: "draw", icon: "font-draw" },
    { value: "sans", icon: "font-sans" },
    { value: "serif", icon: "font-serif" },
    { value: "mono", icon: "font-mono" }
  ],
  textAlign: [
    { value: "start", icon: "text-align-left" },
    { value: "middle", icon: "text-align-center" },
    { value: "end", icon: "text-align-right" }
  ],
  horizontalAlign: [
    { value: "start", icon: "horizontal-align-start" },
    { value: "middle", icon: "horizontal-align-middle" },
    { value: "end", icon: "horizontal-align-end" }
  ],
  verticalAlign: [
    { value: "start", icon: "vertical-align-start" },
    { value: "middle", icon: "vertical-align-middle" },
    { value: "end", icon: "vertical-align-end" }
  ],
  geo: [
    { value: "rectangle", icon: "geo-rectangle" },
    { value: "ellipse", icon: "geo-ellipse" },
    { value: "triangle", icon: "geo-triangle" },
    { value: "diamond", icon: "geo-diamond" },
    { value: "star", icon: "geo-star" },
    { value: "pentagon", icon: "geo-pentagon" },
    { value: "hexagon", icon: "geo-hexagon" },
    { value: "octagon", icon: "geo-octagon" },
    { value: "rhombus", icon: "geo-rhombus" },
    { value: "rhombus-2", icon: "geo-rhombus-2" },
    { value: "oval", icon: "geo-oval" },
    { value: "trapezoid", icon: "geo-trapezoid" },
    { value: "arrow-left", icon: "geo-arrow-left" },
    { value: "arrow-up", icon: "geo-arrow-up" },
    { value: "arrow-down", icon: "geo-arrow-down" },
    { value: "arrow-right", icon: "geo-arrow-right" },
    { value: "cloud", icon: "geo-cloud" },
    { value: "x-box", icon: "geo-x-box" },
    { value: "check-box", icon: "geo-check-box" },
    { value: "heart", icon: "geo-heart" }
  ],
  arrowheadStart: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  arrowheadEnd: [
    { value: "none", icon: "arrowhead-none" },
    { value: "arrow", icon: "arrowhead-arrow" },
    { value: "triangle", icon: "arrowhead-triangle" },
    { value: "square", icon: "arrowhead-square" },
    { value: "dot", icon: "arrowhead-dot" },
    { value: "diamond", icon: "arrowhead-diamond" },
    { value: "inverted", icon: "arrowhead-triangle-inverted" },
    { value: "bar", icon: "arrowhead-bar" }
  ],
  spline: [
    { value: "line", icon: "spline-line" },
    { value: "cubic", icon: "spline-cubic" }
  ]
}, Wp = M.memo(function(e) {
  const {
    uiType: t,
    items: r,
    title: i,
    style: s,
    value: l,
    // columns = clamp(items.length, 2, 4),
    onValueChange: c,
    onHistoryMark: d,
    theme: h
  } = e, g = Ln(), y = M.useRef(!1), v = M.useRef(null), {
    handleButtonClick: w,
    handleButtonPointerDown: C,
    handleButtonPointerEnter: E,
    handleButtonPointerUp: P
  } = M.useMemo(() => {
    const I = () => {
      y.current = !1, window.removeEventListener("pointerup", I);
      const F = v.current;
      F && ["TEXTAREA", "INPUT"].includes(F.nodeName) && F.focus(), v.current = null;
    };
    return {
      handleButtonClick: (F) => {
        const { id: H } = F.currentTarget.dataset;
        l.type === "shared" && l.value === H || (d == null || d("point picker item"), c(s, H));
      },
      handleButtonPointerDown: (F) => {
        const { id: H } = F.currentTarget.dataset;
        d == null || d("point picker item"), c(s, H), y.current = !0, v.current = document.activeElement, window.addEventListener("pointerup", I);
      },
      handleButtonPointerEnter: (F) => {
        if (!y.current) return;
        const { id: H } = F.currentTarget.dataset;
        c(s, H);
      },
      handleButtonPointerUp: (F) => {
        const { id: H } = F.currentTarget.dataset;
        l.type === "shared" && l.value === H || c(s, H);
      }
    };
  }, [l, d, c, s]);
  return /* @__PURE__ */ m.jsx("div", { "data-testid": `style.${t}`, className: It("tlui-buttons__grid"), children: r.map((I) => /* @__PURE__ */ m.jsx(
    Ot,
    {
      type: "icon",
      "data-id": I.value,
      "data-testid": `style.${t}.${I.value}`,
      "aria-label": I.value,
      "data-state": l.type === "shared" && l.value === I.value ? "hinted" : void 0,
      title: i + " — " + g(`${t}-style.${I.value}`),
      className: It("tlui-button-grid__button"),
      style: s === nl ? { color: h[I.value].solid } : void 0,
      onPointerEnter: E,
      onPointerDown: C,
      onPointerUp: P,
      onClick: w,
      children: /* @__PURE__ */ m.jsx(In, { icon: I.icon })
    },
    I.value
  )) });
});
function qq(n, [e, t]) {
  return Math.min(t, Math.max(e, n));
}
function u1e(n) {
  const e = M.useRef({ value: n, previous: n });
  return M.useMemo(() => (e.current.value !== n && (e.current.previous = e.current.value, e.current.value = n), e.current.previous), [n]);
}
var Yq = ["PageUp", "PageDown"], Xq = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"], Zq = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
}, Jy = "Slider", [HD, d1e, f1e] = m_(Jy), [Qq, LEe] = ju(Jy, [
  f1e
]), [h1e, W_] = Qq(Jy), Jq = M.forwardRef(
  (n, e) => {
    const {
      name: t,
      min: r = 0,
      max: i = 100,
      step: s = 1,
      orientation: l = "horizontal",
      disabled: c = !1,
      minStepsBetweenThumbs: d = 0,
      defaultValue: h = [r],
      value: g,
      onValueChange: y = () => {
      },
      onValueCommit: v = () => {
      },
      inverted: w = !1,
      form: C,
      ...E
    } = n, P = M.useRef(/* @__PURE__ */ new Set()), I = M.useRef(0), L = l === "horizontal" ? p1e : g1e, [O = [], z] = Ih({
      prop: g,
      defaultProp: h,
      onChange: (J) => {
        var W;
        (W = [...P.current][I.current]) == null || W.focus(), y(J);
      }
    }), F = M.useRef(O);
    function H(J) {
      const ie = x1e(O, J);
      q(J, ie);
    }
    function V(J) {
      q(J, I.current);
    }
    function re() {
      const J = F.current[I.current];
      O[I.current] !== J && v(O);
    }
    function q(J, ie, { commit: W } = { commit: !1 }) {
      const Y = E1e(s), oe = _1e(Math.round((J - r) / s) * s + r, Y), le = qq(oe, [r, i]);
      z((ce = []) => {
        const Q = v1e(ce, le, ie);
        if (C1e(Q, d * s)) {
          I.current = Q.indexOf(le);
          const he = String(Q) !== String(ce);
          return he && W && v(Q), he ? Q : ce;
        } else
          return ce;
      });
    }
    return /* @__PURE__ */ m.jsx(
      h1e,
      {
        scope: n.__scopeSlider,
        name: t,
        disabled: c,
        min: r,
        max: i,
        valueIndexToChangeRef: I,
        thumbs: P.current,
        values: O,
        orientation: l,
        form: C,
        children: /* @__PURE__ */ m.jsx(HD.Provider, { scope: n.__scopeSlider, children: /* @__PURE__ */ m.jsx(HD.Slot, { scope: n.__scopeSlider, children: /* @__PURE__ */ m.jsx(
          L,
          {
            "aria-disabled": c,
            "data-disabled": c ? "" : void 0,
            ...E,
            ref: e,
            onPointerDown: bt(E.onPointerDown, () => {
              c || (F.current = O);
            }),
            min: r,
            max: i,
            inverted: w,
            onSlideStart: c ? void 0 : H,
            onSlideMove: c ? void 0 : V,
            onSlideEnd: c ? void 0 : re,
            onHomeKeyDown: () => !c && q(r, 0, { commit: !0 }),
            onEndKeyDown: () => !c && q(i, O.length - 1, { commit: !0 }),
            onStepKeyDown: ({ event: J, direction: ie }) => {
              if (!c) {
                const oe = Yq.includes(J.key) || J.shiftKey && Xq.includes(J.key) ? 10 : 1, le = I.current, ce = O[le], Q = s * oe * ie;
                q(ce + Q, le, { commit: !0 });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Jq.displayName = Jy;
var [eY, tY] = Qq(Jy, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
}), p1e = M.forwardRef(
  (n, e) => {
    const {
      min: t,
      max: r,
      dir: i,
      inverted: s,
      onSlideStart: l,
      onSlideMove: c,
      onSlideEnd: d,
      onStepKeyDown: h,
      ...g
    } = n, [y, v] = M.useState(null), w = jr(e, (L) => v(L)), C = M.useRef(void 0), E = aj(i), P = E === "ltr", I = P && !s || !P && s;
    function k(L) {
      const O = C.current || y.getBoundingClientRect(), z = [0, O.width], H = SL(z, I ? [t, r] : [r, t]);
      return C.current = O, H(L - O.left);
    }
    return /* @__PURE__ */ m.jsx(
      eY,
      {
        scope: n.__scopeSlider,
        startEdge: I ? "left" : "right",
        endEdge: I ? "right" : "left",
        direction: I ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ m.jsx(
          nY,
          {
            dir: E,
            "data-orientation": "horizontal",
            ...g,
            ref: w,
            style: {
              ...g.style,
              "--radix-slider-thumb-transform": "translateX(-50%)"
            },
            onSlideStart: (L) => {
              const O = k(L.clientX);
              l == null || l(O);
            },
            onSlideMove: (L) => {
              const O = k(L.clientX);
              c == null || c(O);
            },
            onSlideEnd: () => {
              C.current = void 0, d == null || d();
            },
            onStepKeyDown: (L) => {
              const z = Zq[I ? "from-left" : "from-right"].includes(L.key);
              h == null || h({ event: L, direction: z ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), g1e = M.forwardRef(
  (n, e) => {
    const {
      min: t,
      max: r,
      inverted: i,
      onSlideStart: s,
      onSlideMove: l,
      onSlideEnd: c,
      onStepKeyDown: d,
      ...h
    } = n, g = M.useRef(null), y = jr(e, g), v = M.useRef(void 0), w = !i;
    function C(E) {
      const P = v.current || g.current.getBoundingClientRect(), I = [0, P.height], L = SL(I, w ? [r, t] : [t, r]);
      return v.current = P, L(E - P.top);
    }
    return /* @__PURE__ */ m.jsx(
      eY,
      {
        scope: n.__scopeSlider,
        startEdge: w ? "bottom" : "top",
        endEdge: w ? "top" : "bottom",
        size: "height",
        direction: w ? 1 : -1,
        children: /* @__PURE__ */ m.jsx(
          nY,
          {
            "data-orientation": "vertical",
            ...h,
            ref: y,
            style: {
              ...h.style,
              "--radix-slider-thumb-transform": "translateY(50%)"
            },
            onSlideStart: (E) => {
              const P = C(E.clientY);
              s == null || s(P);
            },
            onSlideMove: (E) => {
              const P = C(E.clientY);
              l == null || l(P);
            },
            onSlideEnd: () => {
              v.current = void 0, c == null || c();
            },
            onStepKeyDown: (E) => {
              const I = Zq[w ? "from-bottom" : "from-top"].includes(E.key);
              d == null || d({ event: E, direction: I ? -1 : 1 });
            }
          }
        )
      }
    );
  }
), nY = M.forwardRef(
  (n, e) => {
    const {
      __scopeSlider: t,
      onSlideStart: r,
      onSlideMove: i,
      onSlideEnd: s,
      onHomeKeyDown: l,
      onEndKeyDown: c,
      onStepKeyDown: d,
      ...h
    } = n, g = W_(Jy, t);
    return /* @__PURE__ */ m.jsx(
      Wn.span,
      {
        ...h,
        ref: e,
        onKeyDown: bt(n.onKeyDown, (y) => {
          y.key === "Home" ? (l(y), y.preventDefault()) : y.key === "End" ? (c(y), y.preventDefault()) : Yq.concat(Xq).includes(y.key) && (d(y), y.preventDefault());
        }),
        onPointerDown: bt(n.onPointerDown, (y) => {
          const v = y.target;
          v.setPointerCapture(y.pointerId), y.preventDefault(), g.thumbs.has(v) ? v.focus() : r(y);
        }),
        onPointerMove: bt(n.onPointerMove, (y) => {
          y.target.hasPointerCapture(y.pointerId) && i(y);
        }),
        onPointerUp: bt(n.onPointerUp, (y) => {
          const v = y.target;
          v.hasPointerCapture(y.pointerId) && (v.releasePointerCapture(y.pointerId), s(y));
        })
      }
    );
  }
), rY = "SliderTrack", iY = M.forwardRef(
  (n, e) => {
    const { __scopeSlider: t, ...r } = n, i = W_(rY, t);
    return /* @__PURE__ */ m.jsx(
      Wn.span,
      {
        "data-disabled": i.disabled ? "" : void 0,
        "data-orientation": i.orientation,
        ...r,
        ref: e
      }
    );
  }
);
iY.displayName = rY;
var VD = "SliderRange", oY = M.forwardRef(
  (n, e) => {
    const { __scopeSlider: t, ...r } = n, i = W_(VD, t), s = tY(VD, t), l = M.useRef(null), c = jr(e, l), d = i.values.length, h = i.values.map(
      (v) => aY(v, i.min, i.max)
    ), g = d > 1 ? Math.min(...h) : 0, y = 100 - Math.max(...h);
    return /* @__PURE__ */ m.jsx(
      Wn.span,
      {
        "data-orientation": i.orientation,
        "data-disabled": i.disabled ? "" : void 0,
        ...r,
        ref: c,
        style: {
          ...n.style,
          [s.startEdge]: g + "%",
          [s.endEdge]: y + "%"
        }
      }
    );
  }
);
oY.displayName = VD;
var KD = "SliderThumb", sY = M.forwardRef(
  (n, e) => {
    const t = d1e(n.__scopeSlider), [r, i] = M.useState(null), s = jr(e, (c) => i(c)), l = M.useMemo(
      () => r ? t().findIndex((c) => c.ref.current === r) : -1,
      [t, r]
    );
    return /* @__PURE__ */ m.jsx(m1e, { ...n, ref: s, index: l });
  }
), m1e = M.forwardRef(
  (n, e) => {
    const { __scopeSlider: t, index: r, name: i, ...s } = n, l = W_(KD, t), c = tY(KD, t), [d, h] = M.useState(null), g = jr(e, (k) => h(k)), y = d ? l.form || !!d.closest("form") : !0, v = QH(d), w = l.values[r], C = w === void 0 ? 0 : aY(w, l.min, l.max), E = S1e(r, l.values.length), P = v == null ? void 0 : v[c.size], I = P ? w1e(P, C, c.direction) : 0;
    return M.useEffect(() => {
      if (d)
        return l.thumbs.add(d), () => {
          l.thumbs.delete(d);
        };
    }, [d, l.thumbs]), /* @__PURE__ */ m.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [c.startEdge]: `calc(${C}% + ${I}px)`
        },
        children: [
          /* @__PURE__ */ m.jsx(HD.ItemSlot, { scope: n.__scopeSlider, children: /* @__PURE__ */ m.jsx(
            Wn.span,
            {
              role: "slider",
              "aria-label": n["aria-label"] || E,
              "aria-valuemin": l.min,
              "aria-valuenow": w,
              "aria-valuemax": l.max,
              "aria-orientation": l.orientation,
              "data-orientation": l.orientation,
              "data-disabled": l.disabled ? "" : void 0,
              tabIndex: l.disabled ? void 0 : 0,
              ...s,
              ref: g,
              style: w === void 0 ? { display: "none" } : n.style,
              onFocus: bt(n.onFocus, () => {
                l.valueIndexToChangeRef.current = r;
              })
            }
          ) }),
          y && /* @__PURE__ */ m.jsx(
            y1e,
            {
              name: i ?? (l.name ? l.name + (l.values.length > 1 ? "[]" : "") : void 0),
              form: l.form,
              value: w
            },
            r
          )
        ]
      }
    );
  }
);
sY.displayName = KD;
var y1e = (n) => {
  const { value: e, ...t } = n, r = M.useRef(null), i = u1e(e);
  return M.useEffect(() => {
    const s = r.current, l = window.HTMLInputElement.prototype, d = Object.getOwnPropertyDescriptor(l, "value").set;
    if (i !== e && d) {
      const h = new Event("input", { bubbles: !0 });
      d.call(s, e), s.dispatchEvent(h);
    }
  }, [i, e]), /* @__PURE__ */ m.jsx("input", { style: { display: "none" }, ...t, ref: r, defaultValue: e });
};
function v1e(n = [], e, t) {
  const r = [...n];
  return r[t] = e, r.sort((i, s) => i - s);
}
function aY(n, e, t) {
  const s = 100 / (t - e) * (n - e);
  return qq(s, [0, 100]);
}
function S1e(n, e) {
  return e > 2 ? `Value ${n + 1} of ${e}` : e === 2 ? ["Minimum", "Maximum"][n] : void 0;
}
function x1e(n, e) {
  if (n.length === 1) return 0;
  const t = n.map((i) => Math.abs(i - e)), r = Math.min(...t);
  return t.indexOf(r);
}
function w1e(n, e, t) {
  const r = n / 2, s = SL([0, 50], [0, r]);
  return (r - s(e) * t) * t;
}
function b1e(n) {
  return n.slice(0, -1).map((e, t) => n[t + 1] - e);
}
function C1e(n, e) {
  if (e > 0) {
    const t = b1e(n);
    return Math.min(...t) >= e;
  }
  return !0;
}
function SL(n, e) {
  return (t) => {
    if (n[0] === n[1] || e[0] === e[1]) return e[0];
    const r = (e[1] - e[0]) / (n[1] - n[0]);
    return e[0] + r * (t - n[0]);
  };
}
function E1e(n) {
  return (String(n).split(".")[1] || "").length;
}
function _1e(n, e) {
  const t = Math.pow(10, e);
  return Math.round(n * t) / t;
}
var P1e = Jq, T1e = iY, I1e = oY, k1e = sY;
const R1e = M.memo(function({
  onHistoryMark: e,
  title: t,
  steps: r,
  value: i,
  label: s,
  onValueChange: l,
  ["data-testid"]: c
}) {
  const d = Ln(), h = M.useCallback(
    (v) => {
      l(v[0]);
    },
    [l]
  ), g = M.useCallback(() => {
    e("click slider");
  }, [e]), y = M.useCallback(() => {
    i && l(i);
  }, [i, l]);
  return /* @__PURE__ */ m.jsx("div", { className: "tlui-slider__container", children: /* @__PURE__ */ m.jsxs(
    P1e,
    {
      "data-testid": c,
      className: "tlui-slider",
      "area-label": "Opacity",
      dir: "ltr",
      min: 0,
      max: r,
      step: 1,
      value: i ? [i] : void 0,
      onPointerDown: g,
      onValueChange: h,
      onPointerUp: y,
      title: t + " — " + d(s),
      children: [
        /* @__PURE__ */ m.jsx(T1e, { className: "tlui-slider__track", dir: "ltr", children: i !== null && /* @__PURE__ */ m.jsx(I1e, { className: "tlui-slider__range", dir: "ltr" }) }),
        i !== null && /* @__PURE__ */ m.jsx(k1e, { className: "tlui-slider__thumb", dir: "ltr" })
      ]
    }
  ) });
});
function M1e({
  label: n,
  uiTypeA: e,
  uiTypeB: t,
  labelA: r,
  labelB: i,
  itemsA: s,
  itemsB: l,
  styleA: c,
  styleB: d,
  valueA: h,
  valueB: g,
  onValueChange: y
}) {
  const v = Ln(), w = M.useMemo(
    () => {
      var E;
      return ((E = s.find((P) => h.type === "shared" && h.value === P.value)) == null ? void 0 : E.icon) ?? "mixed";
    },
    [s, h]
  ), C = M.useMemo(
    () => {
      var E;
      return ((E = l.find((P) => g.type === "shared" && g.value === P.value)) == null ? void 0 : E.icon) ?? "mixed";
    },
    [l, g]
  );
  return h === void 0 && g === void 0 ? null : /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__double-select-picker", children: [
    /* @__PURE__ */ m.jsx("div", { title: v(n), className: "tlui-style-panel__double-select-picker-label", children: v(n) }),
    /* @__PURE__ */ m.jsxs("div", { className: "tlui-buttons__horizontal", children: [
      /* @__PURE__ */ m.jsxs(og, { id: `style panel ${e} A`, children: [
        /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            "data-testid": `style.${e}`,
            title: v(r) + " — " + (h === null || h.type === "mixed" ? v("style-panel.mixed") : v(`${e}-style.${h.value}`)),
            children: /* @__PURE__ */ m.jsx(In, { icon: w, small: !0, invertIcon: !0 })
          }
        ) }),
        /* @__PURE__ */ m.jsx(ag, { side: "left", align: "center", sideOffset: 80, alignOffset: 0, children: /* @__PURE__ */ m.jsx("div", { className: "tlui-buttons__grid", children: s.map((E, P) => /* @__PURE__ */ m.jsx(iw, { "data-testid": `style.${e}.${E.value}`, children: /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            onClick: () => y(c, E.value),
            title: `${v(r)} — ${v(`${e}-style.${E.value}`)}`,
            children: /* @__PURE__ */ m.jsx(In, { icon: E.icon, invertIcon: !0 })
          },
          E.value
        ) }, P)) }) })
      ] }),
      /* @__PURE__ */ m.jsxs(og, { id: `style panel ${t}`, children: [
        /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            "data-testid": `style.${t}`,
            title: v(i) + " — " + (g === null || g.type === "mixed" ? v("style-panel.mixed") : v(`${t}-style.${g.value}`)),
            children: /* @__PURE__ */ m.jsx(In, { icon: C, small: !0 })
          }
        ) }),
        /* @__PURE__ */ m.jsx(ag, { side: "left", align: "center", sideOffset: 116, alignOffset: 0, children: /* @__PURE__ */ m.jsx("div", { className: "tlui-buttons__grid", children: l.map((E) => /* @__PURE__ */ m.jsx(iw, { children: /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            title: `${v(i)} — ${v(`${t}-style.${E.value}`)}`,
            "data-testid": `style.${t}.${E.value}`,
            onClick: () => y(d, E.value),
            children: /* @__PURE__ */ m.jsx(In, { icon: E.icon })
          }
        ) }, E.value)) }) })
      ] })
    ] })
  ] });
}
const A1e = M.memo(
  M1e
);
function D1e({
  id: n,
  label: e,
  uiType: t,
  stylePanelType: r,
  style: i,
  items: s,
  type: l,
  value: c,
  onValueChange: d
}) {
  const h = Ln(), g = be(), y = M.useMemo(
    () => {
      var E;
      return (E = s.find((P) => c.type === "shared" && P.value === c.value)) == null ? void 0 : E.icon;
    },
    [s, c]
  ), v = h(`style-panel.${r}`), w = c.type === "mixed" ? h("style-panel.mixed") : v + " — " + h(`${t}-style.${c.value}`), C = e ? h(e) : "";
  return /* @__PURE__ */ m.jsxs(og, { id: `style panel ${n}`, children: [
    /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsxs(Ot, { type: l, "data-testid": `style.${t}`, title: w, children: [
      C && /* @__PURE__ */ m.jsx(_i, { children: C }),
      /* @__PURE__ */ m.jsx(In, { icon: y ?? "mixed" })
    ] }) }),
    /* @__PURE__ */ m.jsx(ag, { side: "left", align: "center", alignOffset: 0, children: /* @__PURE__ */ m.jsx("div", { className: "tlui-buttons__grid", children: s.map((E) => /* @__PURE__ */ m.jsx(iw, { children: /* @__PURE__ */ m.jsx(
      Ot,
      {
        type: "icon",
        "data-testid": `style.${t}.${E.value}`,
        title: v + " — " + h(`${t}-style.${E.value}`),
        onClick: () => {
          g.markHistoryStoppingPoint("select style dropdown item"), d(i, E.value);
        },
        children: /* @__PURE__ */ m.jsx(In, { icon: E.icon })
      }
    ) }, E.value)) }) })
  ] });
}
const xL = M.memo(D1e);
function O1e({ styles: n }) {
  const e = Pw();
  if (!n) return null;
  const t = n.get(Sc), r = n.get(fE), i = n.get(dE), s = n.get(gE), l = n.get(_u), c = t === void 0, d = r === void 0 && i === void 0, h = s === void 0, g = l === void 0, y = Wd({ isDarkMode: e });
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(j1e, { theme: y, styles: n }),
    !g && /* @__PURE__ */ m.jsx(L1e, { theme: y, styles: n }),
    !(c && d && h) && /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      /* @__PURE__ */ m.jsx(N1e, { styles: n }),
      /* @__PURE__ */ m.jsx(z1e, { styles: n }),
      /* @__PURE__ */ m.jsx(F1e, { styles: n })
    ] })
  ] });
}
function jw() {
  const n = be(), e = Vo();
  return Bt.useMemo(
    () => function(r, i) {
      n.run(() => {
        n.isIn("select") && n.setStyleForSelectedShapes(r, i), n.setStyleForNextShapes(r, i), n.updateInstanceState({ isChangingStyle: !0 });
      }), e("set-style", { source: "style-panel", id: r.id, value: i });
    },
    [n, e]
  );
}
function j1e({ styles: n, theme: e }) {
  const t = Ln(), r = be(), i = M.useCallback((y) => r.markHistoryStoppingPoint(y), [r]), s = jw(), l = n.get(nl), c = n.get(eg), d = n.get(Jp), h = n.get(Pu), g = c !== void 0 || d !== void 0 || h !== void 0;
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        tabIndex: -1,
        className: "tlui-style-panel__section__common",
        "aria-label": "style panel styles",
        "data-testid": "style.panel",
        children: [
          l === void 0 ? null : /* @__PURE__ */ m.jsx(
            Wp,
            {
              title: t("style-panel.color"),
              uiType: "color",
              style: nl,
              items: Al.color,
              value: l,
              onValueChange: s,
              theme: e,
              onHistoryMark: i
            }
          ),
          /* @__PURE__ */ m.jsx(U1e, {})
        ]
      }
    ),
    g && /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel styles", children: [
      c === void 0 ? null : /* @__PURE__ */ m.jsx(
        Wp,
        {
          title: t("style-panel.fill"),
          uiType: "fill",
          style: eg,
          items: Al.fill,
          value: c,
          onValueChange: s,
          theme: e,
          onHistoryMark: i
        }
      ),
      d === void 0 ? null : /* @__PURE__ */ m.jsx(
        Wp,
        {
          title: t("style-panel.dash"),
          uiType: "dash",
          style: Jp,
          items: Al.dash,
          value: d,
          onValueChange: s,
          theme: e,
          onHistoryMark: i
        }
      ),
      h === void 0 ? null : /* @__PURE__ */ m.jsx(
        Wp,
        {
          title: t("style-panel.size"),
          uiType: "size",
          style: Pu,
          items: Al.size,
          value: h,
          onValueChange: (y, v) => {
            s(y, v);
            const w = r.getSelectedShapeIds();
            w.length > 0 && Dr(r, w);
          },
          theme: e,
          onHistoryMark: i
        }
      )
    ] })
  ] });
}
function L1e({ theme: n, styles: e }) {
  const t = Ln(), r = jw(), i = be(), s = M.useCallback((g) => i.markHistoryStoppingPoint(g), [i]), l = e.get(_u), c = e.get(BA), d = e.get(hE), h = e.get(pE);
  return l === void 0 && d === void 0 ? null : /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__section", "aria-label": "style panel text", children: [
    l === void 0 ? null : /* @__PURE__ */ m.jsx(
      Wp,
      {
        title: t("style-panel.font"),
        uiType: "font",
        style: _u,
        items: Al.font,
        value: l,
        onValueChange: r,
        theme: n,
        onHistoryMark: s
      }
    ),
    c === void 0 ? null : /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ m.jsx(
        Wp,
        {
          title: t("style-panel.align"),
          uiType: "align",
          style: BA,
          items: Al.textAlign,
          value: c,
          onValueChange: r,
          theme: n,
          onHistoryMark: s
        }
      ),
      /* @__PURE__ */ m.jsx("div", { className: "tlui-style-panel__row__extra-button", children: /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          title: t("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ m.jsx(In, { icon: "vertical-align-middle" })
        }
      ) })
    ] }),
    d === void 0 ? null : /* @__PURE__ */ m.jsxs("div", { className: "tlui-style-panel__row", children: [
      /* @__PURE__ */ m.jsx(
        Wp,
        {
          title: t("style-panel.label-align"),
          uiType: "align",
          style: hE,
          items: Al.horizontalAlign,
          value: d,
          onValueChange: r,
          theme: n,
          onHistoryMark: s
        }
      ),
      /* @__PURE__ */ m.jsx("div", { className: "tlui-style-panel__row__extra-button", children: h === void 0 ? /* @__PURE__ */ m.jsx(
        Ot,
        {
          type: "icon",
          title: t("style-panel.vertical-align"),
          "data-testid": "vertical-align",
          disabled: !0,
          children: /* @__PURE__ */ m.jsx(In, { icon: "vertical-align-middle" })
        }
      ) : /* @__PURE__ */ m.jsx(
        xL,
        {
          type: "icon",
          id: "geo-vertical-alignment",
          uiType: "verticalAlign",
          stylePanelType: "vertical-align",
          style: pE,
          items: Al.verticalAlign,
          value: h,
          onValueChange: r
        }
      ) })
    ] })
  ] });
}
function N1e({ styles: n }) {
  const e = jw(), t = n.get(Sc);
  return t === void 0 ? null : /* @__PURE__ */ m.jsx(
    xL,
    {
      id: "geo",
      type: "menu",
      label: "style-panel.geo",
      uiType: "geo",
      stylePanelType: "geo",
      style: Sc,
      items: Al.geo,
      value: t,
      onValueChange: e
    }
  );
}
function F1e({ styles: n }) {
  const e = jw(), t = n.get(gE);
  return t === void 0 ? null : /* @__PURE__ */ m.jsx(
    xL,
    {
      id: "spline",
      type: "menu",
      label: "style-panel.spline",
      uiType: "spline",
      stylePanelType: "spline",
      style: gE,
      items: Al.spline,
      value: t,
      onValueChange: e
    }
  );
}
function z1e({ styles: n }) {
  const e = jw(), t = n.get(fE), r = n.get(dE);
  return !t || !r ? null : /* @__PURE__ */ m.jsx(
    A1e,
    {
      label: "style-panel.arrowheads",
      uiTypeA: "arrowheadStart",
      styleA: dE,
      itemsA: Al.arrowheadStart,
      valueA: r,
      uiTypeB: "arrowheadEnd",
      styleB: fE,
      itemsB: Al.arrowheadEnd,
      valueB: t,
      onValueChange: e,
      labelA: "style-panel.arrowhead-start",
      labelB: "style-panel.arrowhead-end"
    }
  );
}
const gx = [0.1, 0.25, 0.5, 0.75, 1];
function U1e() {
  const n = be(), e = M.useCallback((c) => n.markHistoryStoppingPoint(c), [n]), t = Pe("opacity", () => n.getSharedOpacity(), [n]), r = Vo(), i = Ln(), s = Bt.useCallback(
    (c) => {
      const d = gx[c];
      n.run(() => {
        n.isIn("select") && n.setOpacityForSelectedShapes(d), n.setOpacityForNextShapes(d), n.updateInstanceState({ isChangingStyle: !0 });
      }), r("set-style", { source: "style-panel", id: "opacity", value: c });
    },
    [n, r]
  );
  if (t === void 0) return null;
  const l = t.type === "mixed" ? -1 : gx.indexOf(
    jte(
      gx,
      (c) => Math.abs(c - t.value)
    )
  );
  return /* @__PURE__ */ m.jsx(
    R1e,
    {
      "data-testid": "style.opacity",
      value: l >= 0 ? l : gx.length - 1,
      label: t.type === "mixed" ? "style-panel.mixed" : `opacity-style.${t.value}`,
      onValueChange: s,
      steps: gx.length - 1,
      title: i("style-panel.opacity"),
      onHistoryMark: e
    }
  );
}
const $1e = M.memo(function({
  isMobile: e,
  children: t
}) {
  const r = be(), i = M.useRef(null);
  Th(i);
  const s = Gq(), l = M.useCallback(() => {
    e || r.updateInstanceState({ isChangingStyle: !1 });
  }, [r, e]), c = t ?? /* @__PURE__ */ m.jsx(O1e, { styles: s });
  return /* @__PURE__ */ m.jsx(
    "div",
    {
      ref: i,
      className: It("tlui-style-panel", { "tlui-style-panel__wrapper": !e }),
      "data-ismobile": e,
      onPointerLeave: l,
      children: c
    }
  );
});
function B1e() {
  const n = be(), e = Ln(), t = Gq(), r = t == null ? void 0 : t.get(nl), i = Wd({ isDarkMode: n.user.getIsDarkMode() }), s = ((r == null ? void 0 : r.type) === "shared" ? i[r.value] : i.black).solid, l = Pe(
    "disable style panel",
    () => n.isInAny("hand", "zoom", "eraser", "laser"),
    [n]
  ), c = M.useCallback(
    (h) => {
      h || n.updateInstanceState({ isChangingStyle: !1 });
    },
    [n]
  ), { StylePanel: d } = Mh();
  return d ? /* @__PURE__ */ m.jsxs(gL, { id: "mobile style menu", onOpenChange: c, children: [
    /* @__PURE__ */ m.jsx(mL, { children: /* @__PURE__ */ m.jsx(
      Ot,
      {
        type: "tool",
        "data-testid": "mobile-styles.button",
        style: {
          color: l ? "var(--color-muted-1)" : s
        },
        title: e("style-panel.title"),
        disabled: l,
        children: /* @__PURE__ */ m.jsx(
          In,
          {
            icon: l ? "blob" : (r == null ? void 0 : r.type) === "mixed" ? "mixed" : "blob"
          }
        )
      }
    ) }),
    /* @__PURE__ */ m.jsx(yL, { side: "top", align: "end", children: d && /* @__PURE__ */ m.jsx(d, { isMobile: !0 }) })
  ] }) : null;
}
function H1e() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(K1e, {}),
    /* @__PURE__ */ m.jsx(W1e, {}),
    /* @__PURE__ */ m.jsx(G1e, {}),
    /* @__PURE__ */ m.jsx(q1e, {}),
    /* @__PURE__ */ m.jsx(Y1e, {}),
    /* @__PURE__ */ m.jsx(X1e, {}),
    /* @__PURE__ */ m.jsx(Z1e, {}),
    /* @__PURE__ */ m.jsx(Q1e, {}),
    /* @__PURE__ */ m.jsx(J1e, {}),
    /* @__PURE__ */ m.jsx(eCe, {}),
    /* @__PURE__ */ m.jsx(nCe, {}),
    /* @__PURE__ */ m.jsx(tCe, {}),
    /* @__PURE__ */ m.jsx(oCe, {}),
    /* @__PURE__ */ m.jsx(lCe, {}),
    /* @__PURE__ */ m.jsx(rCe, {}),
    /* @__PURE__ */ m.jsx(aCe, {}),
    /* @__PURE__ */ m.jsx(sCe, {}),
    /* @__PURE__ */ m.jsx(iCe, {}),
    /* @__PURE__ */ m.jsx(cCe, {}),
    /* @__PURE__ */ m.jsx(uCe, {}),
    /* @__PURE__ */ m.jsx(dCe, {}),
    /* @__PURE__ */ m.jsx(fCe, {}),
    /* @__PURE__ */ m.jsx(hCe, {}),
    /* @__PURE__ */ m.jsx(pCe, {}),
    /* @__PURE__ */ m.jsx(gCe, {}),
    /* @__PURE__ */ m.jsx(mCe, {}),
    /* @__PURE__ */ m.jsx(vCe, {}),
    /* @__PURE__ */ m.jsx(yCe, {})
  ] });
}
function V1e(n) {
  var r;
  const e = be(), t = (r = n.meta) == null ? void 0 : r.geo;
  return Pe(
    "is tool selected",
    () => {
      const i = e.getCurrentToolId(), s = e.getSharedStyles().getAsKnownValue(Sc);
      return t ? i === "geo" && s === t : i === n.id;
    },
    [e, n.id, t]
  );
}
function _r({ tool: n }) {
  const e = Yj(), t = V1e(e[n]);
  return /* @__PURE__ */ m.jsx(ma, { toolId: n, isSelected: t });
}
function K1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "select" });
}
function W1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "hand" });
}
function G1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "draw" });
}
function q1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "eraser" });
}
function Y1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "arrow" });
}
function X1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "text" });
}
function Z1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "note" });
}
function Q1e() {
  return /* @__PURE__ */ m.jsx(ma, { toolId: "asset" });
}
function J1e() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "rectangle" });
}
function eCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "ellipse" });
}
function tCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "diamond" });
}
function nCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "triangle" });
}
function rCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "rhombus" });
}
function iCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "heart" });
}
function oCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "hexagon" });
}
function sCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "cloud" });
}
function aCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "star" });
}
function lCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "oval" });
}
function cCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "x-box" });
}
function uCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "check-box" });
}
function dCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "arrow-left" });
}
function fCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "arrow-up" });
}
function hCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "arrow-down" });
}
function pCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "arrow-right" });
}
function gCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "line" });
}
function mCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "highlight" });
}
function yCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "frame" });
}
function vCe() {
  return /* @__PURE__ */ m.jsx(_r, { tool: "laser" });
}
const lA = typeof navigator < "u" ? navigator.userAgent.toLowerCase().indexOf("firefox") > 0 : !1;
function cA(n, e, t, r) {
  n.addEventListener ? n.addEventListener(e, t, r) : n.attachEvent && n.attachEvent("on".concat(e), t);
}
function mx(n, e, t, r) {
  n.removeEventListener ? n.removeEventListener(e, t, r) : n.detachEvent && n.detachEvent("on".concat(e), t);
}
function lY(n, e) {
  const t = e.slice(0, e.length - 1);
  for (let r = 0; r < t.length; r++) t[r] = n[t[r].toLowerCase()];
  return t;
}
function cY(n) {
  typeof n != "string" && (n = ""), n = n.replace(/\s/g, "");
  const e = n.split(",");
  let t = e.lastIndexOf("");
  for (; t >= 0; )
    e[t - 1] += ",", e.splice(t, 1), t = e.lastIndexOf("");
  return e;
}
function SCe(n, e) {
  const t = n.length >= e.length ? n : e, r = n.length >= e.length ? e : n;
  let i = !0;
  for (let s = 0; s < t.length; s++)
    r.indexOf(t[s]) === -1 && (i = !1);
  return i;
}
const ow = {
  backspace: 8,
  "⌫": 8,
  tab: 9,
  clear: 12,
  enter: 13,
  "↩": 13,
  return: 13,
  esc: 27,
  escape: 27,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  del: 46,
  delete: 46,
  ins: 45,
  insert: 45,
  home: 36,
  end: 35,
  pageup: 33,
  pagedown: 34,
  capslock: 20,
  num_0: 96,
  num_1: 97,
  num_2: 98,
  num_3: 99,
  num_4: 100,
  num_5: 101,
  num_6: 102,
  num_7: 103,
  num_8: 104,
  num_9: 105,
  num_multiply: 106,
  num_add: 107,
  num_enter: 108,
  num_subtract: 109,
  num_decimal: 110,
  num_divide: 111,
  "⇪": 20,
  ",": 188,
  ".": 190,
  "/": 191,
  "`": 192,
  "-": lA ? 173 : 189,
  "=": lA ? 61 : 187,
  ";": lA ? 59 : 186,
  "'": 222,
  "[": 219,
  "]": 221,
  "\\": 220
}, Mu = {
  // shiftKey
  "⇧": 16,
  shift: 16,
  // altKey
  "⌥": 18,
  alt: 18,
  option: 18,
  // ctrlKey
  "⌃": 17,
  ctrl: 17,
  control: 17,
  // metaKey
  "⌘": 91,
  cmd: 91,
  command: 91
}, XC = {
  16: "shiftKey",
  18: "altKey",
  17: "ctrlKey",
  91: "metaKey",
  shiftKey: 16,
  ctrlKey: 17,
  altKey: 18,
  metaKey: 91
}, Oo = {
  16: !1,
  18: !1,
  17: !1,
  91: !1
}, oi = {};
for (let n = 1; n < 20; n++)
  ow["f".concat(n)] = 111 + n;
let Yr = [], zx = null, uY = "all";
const Ad = /* @__PURE__ */ new Map(), Lw = (n) => ow[n.toLowerCase()] || Mu[n.toLowerCase()] || n.toUpperCase().charCodeAt(0), xCe = (n) => Object.keys(ow).find((e) => ow[e] === n), wCe = (n) => Object.keys(Mu).find((e) => Mu[e] === n);
function dY(n) {
  uY = n || "all";
}
function sw() {
  return uY || "all";
}
function bCe() {
  return Yr.slice(0);
}
function CCe() {
  return Yr.map((n) => xCe(n) || wCe(n) || String.fromCharCode(n));
}
function ECe() {
  const n = [];
  return Object.keys(oi).forEach((e) => {
    oi[e].forEach((t) => {
      let {
        key: r,
        scope: i,
        mods: s,
        shortcut: l
      } = t;
      n.push({
        scope: i,
        shortcut: l,
        mods: s,
        keys: r.split("+").map((c) => Lw(c))
      });
    });
  }), n;
}
function _Ce(n) {
  const e = n.target || n.srcElement, {
    tagName: t
  } = e;
  let r = !0;
  const i = t === "INPUT" && !["checkbox", "radio", "range", "button", "file", "reset", "submit", "color"].includes(e.type);
  return (e.isContentEditable || (i || t === "TEXTAREA" || t === "SELECT") && !e.readOnly) && (r = !1), r;
}
function PCe(n) {
  return typeof n == "string" && (n = Lw(n)), Yr.indexOf(n) !== -1;
}
function TCe(n, e) {
  let t, r;
  n || (n = sw());
  for (const i in oi)
    if (Object.prototype.hasOwnProperty.call(oi, i))
      for (t = oi[i], r = 0; r < t.length; )
        t[r].scope === n ? t.splice(r, 1).forEach((l) => {
          let {
            element: c
          } = l;
          return wL(c);
        }) : r++;
  sw() === n && dY(e || "all");
}
function ICe(n) {
  let e = n.keyCode || n.which || n.charCode;
  const t = Yr.indexOf(e);
  if (t >= 0 && Yr.splice(t, 1), n.key && n.key.toLowerCase() === "meta" && Yr.splice(0, Yr.length), (e === 93 || e === 224) && (e = 91), e in Oo) {
    Oo[e] = !1;
    for (const r in Mu) Mu[r] === e && (Ea[r] = !1);
  }
}
function fY(n) {
  if (typeof n > "u")
    Object.keys(oi).forEach((i) => {
      Array.isArray(oi[i]) && oi[i].forEach((s) => gC(s)), delete oi[i];
    }), wL(null);
  else if (Array.isArray(n))
    n.forEach((i) => {
      i.key && gC(i);
    });
  else if (typeof n == "object")
    n.key && gC(n);
  else if (typeof n == "string") {
    for (var e = arguments.length, t = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
      t[r - 1] = arguments[r];
    let [i, s] = t;
    typeof i == "function" && (s = i, i = ""), gC({
      key: n,
      scope: i,
      method: s,
      splitKey: "+"
    });
  }
}
const gC = (n) => {
  let {
    key: e,
    scope: t,
    method: r,
    splitKey: i = "+"
  } = n;
  cY(e).forEach((l) => {
    const c = l.split(i), d = c.length, h = c[d - 1], g = h === "*" ? "*" : Lw(h);
    if (!oi[g]) return;
    t || (t = sw());
    const y = d > 1 ? lY(Mu, c) : [], v = [];
    oi[g] = oi[g].filter((w) => {
      const E = (r ? w.method === r : !0) && w.scope === t && SCe(w.mods, y);
      return E && v.push(w.element), !E;
    }), v.forEach((w) => wL(w));
  });
};
function R$(n, e, t, r) {
  if (e.element !== r)
    return;
  let i;
  if (e.scope === t || e.scope === "all") {
    i = e.mods.length > 0;
    for (const s in Oo)
      Object.prototype.hasOwnProperty.call(Oo, s) && (!Oo[s] && e.mods.indexOf(+s) > -1 || Oo[s] && e.mods.indexOf(+s) === -1) && (i = !1);
    (e.mods.length === 0 && !Oo[16] && !Oo[18] && !Oo[17] && !Oo[91] || i || e.shortcut === "*") && (e.keys = [], e.keys = e.keys.concat(Yr), e.method(n, e) === !1 && (n.preventDefault ? n.preventDefault() : n.returnValue = !1, n.stopPropagation && n.stopPropagation(), n.cancelBubble && (n.cancelBubble = !0)));
  }
}
function M$(n, e) {
  const t = oi["*"];
  let r = n.keyCode || n.which || n.charCode;
  if (!Ea.filter.call(this, n)) return;
  if ((r === 93 || r === 224) && (r = 91), Yr.indexOf(r) === -1 && r !== 229 && Yr.push(r), ["metaKey", "ctrlKey", "altKey", "shiftKey"].forEach((c) => {
    const d = XC[c];
    n[c] && Yr.indexOf(d) === -1 ? Yr.push(d) : !n[c] && Yr.indexOf(d) > -1 ? Yr.splice(Yr.indexOf(d), 1) : c === "metaKey" && n[c] && (Yr = Yr.filter((h) => h in XC || h === r));
  }), r in Oo) {
    Oo[r] = !0;
    for (const c in Mu)
      Mu[c] === r && (Ea[c] = !0);
    if (!t) return;
  }
  for (const c in Oo)
    Object.prototype.hasOwnProperty.call(Oo, c) && (Oo[c] = n[XC[c]]);
  n.getModifierState && !(n.altKey && !n.ctrlKey) && n.getModifierState("AltGraph") && (Yr.indexOf(17) === -1 && Yr.push(17), Yr.indexOf(18) === -1 && Yr.push(18), Oo[17] = !0, Oo[18] = !0);
  const i = sw();
  if (t)
    for (let c = 0; c < t.length; c++)
      t[c].scope === i && (n.type === "keydown" && t[c].keydown || n.type === "keyup" && t[c].keyup) && R$(n, t[c], i, e);
  if (!(r in oi)) return;
  const s = oi[r], l = s.length;
  for (let c = 0; c < l; c++)
    if ((n.type === "keydown" && s[c].keydown || n.type === "keyup" && s[c].keyup) && s[c].key) {
      const d = s[c], {
        splitKey: h
      } = d, g = d.key.split(h), y = [];
      for (let v = 0; v < g.length; v++)
        y.push(Lw(g[v]));
      y.sort().join("") === Yr.sort().join("") && R$(n, d, i, e);
    }
}
function Ea(n, e, t) {
  Yr = [];
  const r = cY(n);
  let i = [], s = "all", l = document, c = 0, d = !1, h = !0, g = "+", y = !1, v = !1;
  for (t === void 0 && typeof e == "function" && (t = e), Object.prototype.toString.call(e) === "[object Object]" && (e.scope && (s = e.scope), e.element && (l = e.element), e.keyup && (d = e.keyup), e.keydown !== void 0 && (h = e.keydown), e.capture !== void 0 && (y = e.capture), typeof e.splitKey == "string" && (g = e.splitKey), e.single === !0 && (v = !0)), typeof e == "string" && (s = e), v && fY(n, s); c < r.length; c++)
    n = r[c].split(g), i = [], n.length > 1 && (i = lY(Mu, n)), n = n[n.length - 1], n = n === "*" ? "*" : Lw(n), n in oi || (oi[n] = []), oi[n].push({
      keyup: d,
      keydown: h,
      scope: s,
      mods: i,
      shortcut: r[c],
      method: t,
      key: r[c],
      splitKey: g,
      element: l
    });
  if (typeof l < "u" && window) {
    if (!Ad.has(l)) {
      const w = function() {
        let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        return M$(E, l);
      }, C = function() {
        let E = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.event;
        M$(E, l), ICe(E);
      };
      Ad.set(l, {
        keydownListener: w,
        keyupListenr: C,
        capture: y
      }), cA(l, "keydown", w, y), cA(l, "keyup", C, y);
    }
    if (!zx) {
      const w = () => {
        Yr = [];
      };
      zx = {
        listener: w,
        capture: y
      }, cA(window, "focus", w, y);
    }
  }
}
function kCe(n) {
  let e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "all";
  Object.keys(oi).forEach((t) => {
    oi[t].filter((i) => i.scope === e && i.shortcut === n).forEach((i) => {
      i && i.method && i.method();
    });
  });
}
function wL(n) {
  const e = Object.values(oi).flat();
  if (e.findIndex((r) => {
    let {
      element: i
    } = r;
    return i === n;
  }) < 0) {
    const {
      keydownListener: r,
      keyupListenr: i,
      capture: s
    } = Ad.get(n) || {};
    r && i && (mx(n, "keyup", i, s), mx(n, "keydown", r, s), Ad.delete(n));
  }
  if ((e.length <= 0 || Ad.size <= 0) && (Object.keys(Ad).forEach((i) => {
    const {
      keydownListener: s,
      keyupListenr: l,
      capture: c
    } = Ad.get(i) || {};
    s && l && (mx(i, "keyup", l, c), mx(i, "keydown", s, c), Ad.delete(i));
  }), Ad.clear(), Object.keys(oi).forEach((i) => delete oi[i]), zx)) {
    const {
      listener: i,
      capture: s
    } = zx;
    mx(window, "focus", i, s), zx = null;
  }
}
const uA = {
  getPressedKeyString: CCe,
  setScope: dY,
  getScope: sw,
  deleteScope: TCe,
  getPressedKeyCodes: bCe,
  getAllKeyCodes: ECe,
  isPressed: PCe,
  filter: _Ce,
  trigger: kCe,
  unbind: fY,
  keyMap: ow,
  modifier: Mu,
  modifierMap: XC
};
for (const n in uA)
  Object.prototype.hasOwnProperty.call(uA, n) && (Ea[n] = uA[n]);
if (typeof window < "u") {
  const n = window.hotkeys;
  Ea.noConflict = (e) => (e && window.hotkeys === Ea && (window.hotkeys = n), Ea), window.hotkeys = Ea;
}
const A$ = [
  // we set these in useNativeClipboardEvents instead
  "copy",
  "cut",
  "paste",
  // There's also an upload asset action, so we don't want to set the kbd twice
  "asset"
];
function RCe() {
  const n = be(), e = ol(), t = gg(), r = Yj(), i = Pe("is focused", () => n.getInstanceState().isFocused, [n]);
  M.useEffect(() => {
    if (!i) return;
    const s = new Array(), l = (d, h) => {
      Ea(d, { element: document.body }, h), s.push(() => {
        Ea.unbind(d, h);
      });
    }, c = (d, h) => {
      Ea(d, { element: document.body, keyup: !0, keydown: !1 }, h), s.push(() => {
        Ea.unbind(d, h);
      });
    };
    for (const d of Object.values(t))
      d.kbd && (e && !d.readonlyOk || A$.includes(d.id) || l(D$(d.kbd), (h) => {
        kx(n) || (wn(h), d.onSelect("kbd"));
      }));
    for (const d of Object.values(r))
      !d.kbd || !d.readonlyOk && n.getIsReadonly() || A$.includes(d.id) || l(D$(d.kbd), (h) => {
        kx(n) || (wn(h), d.onSelect("kbd"));
      });
    return l(",", (d) => {
      if (kx(n) || n.inputs.keys.has("Comma")) return;
      wn(d), n.focus(), n.inputs.keys.add("Comma");
      const { x: h, y: g, z: y } = n.inputs.currentPagePoint, v = n.pageToScreen({ x: h, y: g }), w = {
        type: "pointer",
        name: "pointer_down",
        point: { x: v.x, y: v.y, z: y },
        shiftKey: d.shiftKey,
        altKey: d.altKey,
        ctrlKey: d.metaKey || d.ctrlKey,
        metaKey: d.metaKey,
        accelKey: ms(d),
        pointerId: 0,
        button: 0,
        isPen: n.getInstanceState().isPenMode,
        target: "canvas"
      };
      n.dispatch(w);
    }), c(",", (d) => {
      if (kx(n) || !n.inputs.keys.has("Comma")) return;
      n.inputs.keys.delete("Comma");
      const { x: h, y: g, z: y } = n.inputs.currentScreenPoint, v = {
        type: "pointer",
        name: "pointer_up",
        point: { x: h, y: g, z: y },
        shiftKey: d.shiftKey,
        altKey: d.altKey,
        ctrlKey: d.metaKey || d.ctrlKey,
        metaKey: d.metaKey,
        accelKey: ms(d),
        pointerId: 0,
        button: 0,
        isPen: n.getInstanceState().isPenMode,
        target: "canvas"
      };
      n.dispatch(v);
    }), () => {
      s.forEach((d) => d());
    };
  }, [t, r, e, n, i]);
}
function D$(n) {
  return MCe(n).map((e) => {
    let t = "";
    const r = e.split("");
    return r.length === 1 ? t = r[0] : r[0] === "!" ? t = `shift+${r[1]}` : r[0] === "?" ? r.length === 3 && r[1] === "!" ? t = `alt+shift+${r[2]}` : t = `alt+${r[1]}` : r[0] === "$" ? r[1] === "!" ? t = `cmd+shift+${r[2]},ctrl+shift+${r[2]}` : r[1] === "?" ? t = `cmd+⌥+${r[2]},ctrl+alt+${r[2]}` : t = `cmd+${r[1]},ctrl+${r[1]}` : t = e, t;
  }).join(",");
}
function MCe(n) {
  typeof n != "string" && (n = ""), n = n.replace(/\s/g, "");
  const e = n.split(",");
  let t = e.lastIndexOf("");
  for (; t >= 0; )
    e[t - 1] += ",", e.splice(t, 1), t = e.lastIndexOf("");
  return e;
}
function kx(n) {
  return n.menus.hasAnyOpenMenus() || n.getEditingShapeId() !== null || n.getCrashingError();
}
const ACe = M.createContext(!1);
function DCe({ children: n }) {
  const e = be(), t = Vy(), r = qs(), i = Ln(), s = Math.min(8, 5 + r), [l, c] = M.useState(0), d = M.useRef(null), [h, g] = M.useState(null), y = M.useMemo(() => {
    const w = h ? `:not([data-value="${h}"])` : "";
    return `
			#${t}_main > *:nth-child(n + ${s + (h ? 1 : 2)})${w} {
				display: none;
			}
			#${t}_more > *:nth-child(-n + ${s}) {
				display: none;
			}
        `;
  }, [h, t, s]), v = s_(() => {
    if (!d.current) return;
    const w = Array.from(d.current.children);
    c(w.length), w.findIndex(
      (P) => P.getAttribute("data-value") === h
    ) <= s && g(null);
    const E = Array.from(d.current.children).findIndex(
      (P) => P.getAttribute("aria-checked") === "true"
    );
    E !== -1 && E >= s && g(w[E].getAttribute("data-value"));
  });
  return M.useLayoutEffect(() => {
    v();
  }), M.useLayoutEffect(() => {
    if (!d.current) return;
    const w = new MutationObserver(v);
    return w.observe(d.current, {
      childList: !0,
      subtree: !0,
      attributeFilter: ["data-value", "aria-checked"]
    }), () => {
      w.disconnect();
    };
  }, [v]), M.useEffect(() => {
    const w = [
      ["1", 0],
      ["2", 1],
      ["3", 2],
      ["4", 3],
      ["5", 4],
      ["6", 5],
      ["7", 6],
      ["8", 7],
      ["9", 8],
      ["0", 9]
    ];
    for (const [C, E] of w)
      Ea(C, (P) => {
        var L;
        if (kx(e)) return;
        wn(P);
        const k = Array.from(((L = d.current) == null ? void 0 : L.children) ?? []).filter(
          (O) => !(O instanceof HTMLElement) || O.tagName.toLowerCase() !== "button" ? !1 : !!(O.offsetWidth || O.offsetHeight)
        )[E];
        k && k.click();
      });
    return () => {
      Ea.unbind("1,2,3,4,5,6,7,8,9,0");
    };
  }, [e]), /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx("style", { children: y }),
    /* @__PURE__ */ m.jsxs(
      "div",
      {
        className: It("tlui-toolbar__tools", {
          "tlui-toolbar__tools__mobile": r < yi.TABLET_SM
        }),
        role: "radiogroup",
        children: [
          /* @__PURE__ */ m.jsx("div", { id: `${t}_main`, ref: d, className: "tlui-toolbar__tools__list", children: /* @__PURE__ */ m.jsx(Ll, { type: "toolbar", sourceId: "toolbar", children: n }) }),
          l > s + 1 && /* @__PURE__ */ m.jsx(ACe.Provider, { value: !0, children: /* @__PURE__ */ m.jsxs(og, { id: "toolbar overflow", modal: !1, children: [
            /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(
              Ot,
              {
                title: i("tool-panel.more"),
                type: "tool",
                className: "tlui-toolbar__overflow",
                "data-testid": "tools.more-button",
                children: /* @__PURE__ */ m.jsx(In, { icon: "chevron-up" })
              }
            ) }),
            /* @__PURE__ */ m.jsx(ag, { side: "top", align: "center", children: /* @__PURE__ */ m.jsx(
              "div",
              {
                className: "tlui-buttons__grid",
                "data-testid": "tools.more-content",
                id: `${t}_more`,
                children: /* @__PURE__ */ m.jsx(Ll, { type: "toolbar-overflow", sourceId: "toolbar", children: n })
              }
            ) })
          ] }) })
        ]
      }
    )
  ] });
}
function OCe({ activeToolId: n }) {
  const e = be(), t = qs(), r = Ln(), i = Pe("is tool locked", () => e.getInstanceState().isToolLocked, [
    e
  ]), s = Pe("current tool", () => e.getCurrentTool(), [e]);
  return !n || !s.isLockable ? null : /* @__PURE__ */ m.jsx(
    Ot,
    {
      type: "normal",
      title: r("action.toggle-tool-lock"),
      "data-testid": "tool-lock",
      className: It("tlui-toolbar__lock-button", {
        "tlui-toolbar__lock-button__mobile": t < yi.TABLET_SM
      }),
      onClick: () => e.updateInstanceState({ isToolLocked: !i }),
      children: /* @__PURE__ */ m.jsx(In, { icon: i ? "lock" : "unlock", small: !0 })
    }
  );
}
const jCe = M.memo(function({ children: e }) {
  const t = be(), r = qs(), i = ol(), s = Pe("current tool id", () => t.getCurrentToolId(), [t]), l = M.useRef(null);
  Th(l);
  const { ActionsMenu: c, QuickActions: d } = Mh(), h = t.options.actionShortcutsLocation === "menu" ? !1 : t.options.actionShortcutsLocation === "toolbar" ? !0 : r < yi.TABLET;
  return /* @__PURE__ */ m.jsx("div", { ref: l, className: "tlui-toolbar", children: /* @__PURE__ */ m.jsxs("div", { className: "tlui-toolbar__inner", children: [
    /* @__PURE__ */ m.jsxs("div", { className: "tlui-toolbar__left", children: [
      !i && /* @__PURE__ */ m.jsxs("div", { className: "tlui-toolbar__extras", children: [
        h && /* @__PURE__ */ m.jsxs("div", { className: "tlui-toolbar__extras__controls tlui-buttons__horizontal", children: [
          d && /* @__PURE__ */ m.jsx(d, {}),
          c && /* @__PURE__ */ m.jsx(c, {})
        ] }),
        /* @__PURE__ */ m.jsx(OCe, { activeToolId: s })
      ] }),
      /* @__PURE__ */ m.jsx(DCe, { children: e ?? /* @__PURE__ */ m.jsx(H1e, {}) })
    ] }),
    r < yi.TABLET_SM && !i && /* @__PURE__ */ m.jsx("div", { className: "tlui-toolbar__tools", children: /* @__PURE__ */ m.jsx(B1e, {}) })
  ] }) });
});
function LCe() {
  const n = Ln();
  return /* @__PURE__ */ m.jsxs("div", { className: It("tlui-offline-indicator"), children: [
    n("status.offline"),
    /* @__PURE__ */ m.jsx(ku, { "aria-label": "offline", icon: "status-offline", small: !0 })
  ] });
}
function NCe({
  maxWidth: n = 420,
  ignoreRightWidth: e = 0,
  stylePanelWidth: t = 148,
  marginBetweenZones: r = 12,
  squeezeAmount: i = 52,
  children: s
}) {
  const l = M.useRef(null), c = qs(), d = M.useCallback(() => {
    const h = l.current;
    if (!h) return;
    const g = h.parentElement.parentElement, y = g.querySelector(".tlui-layout__top__left"), v = g.querySelector(".tlui-layout__top__right"), w = g.offsetWidth, C = y.offsetWidth, E = v.offsetWidth, P = h.offsetWidth - e;
    let I = (w - P) / 2;
    w % 2 !== 0 && (I -= 0.5);
    const k = C + r, L = h.offsetLeft, O = Math.min(
      w - E - C - 2 * r,
      n
    ), z = Math.max(I, k) - L;
    v.offsetWidth > t && c <= 6 ? h.style.setProperty("max-width", O - i + "px") : h.style.setProperty("max-width", O + "px"), h.style.setProperty("transform", `translate(${z}px, 0px)`);
  }, [c, e, r, n, i, t]);
  return M.useLayoutEffect(() => {
    const h = l.current;
    if (!h) return;
    const g = h.parentElement.parentElement, y = g.querySelector(".tlui-layout__top__left"), v = g.querySelector(".tlui-layout__top__right"), w = new ResizeObserver(d);
    return w.observe(y), w.observe(v), w.observe(g), w.observe(h), d(), () => {
      w.disconnect();
    };
  }, [d]), M.useLayoutEffect(() => {
    d();
  }), /* @__PURE__ */ m.jsx("div", { ref: l, className: "tlui-top-panel__container", children: s });
}
function FCe() {
  const n = Xme() === "offline";
  return /* @__PURE__ */ m.jsx(NCe, { children: n && /* @__PURE__ */ m.jsx(LCe, {}) });
}
function zCe() {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-in", noClose: !0 }),
    /* @__PURE__ */ m.jsx(Fe, { actionId: "zoom-out", noClose: !0 }),
    /* @__PURE__ */ m.jsx(Sq, {}),
    /* @__PURE__ */ m.jsx(xq, {}),
    /* @__PURE__ */ m.jsx(wq, {})
  ] });
}
const UCe = M.memo(function({ children: e }) {
  const t = io(), [r, i] = Xd("zoom menu"), s = e ?? /* @__PURE__ */ m.jsx(zCe, {});
  return /* @__PURE__ */ m.jsxs(Aj, { dir: "ltr", open: r, onOpenChange: i, modal: !1, children: [
    /* @__PURE__ */ m.jsx(Dj, { asChild: !0, dir: "ltr", children: /* @__PURE__ */ m.jsx($Ce, {}) }),
    /* @__PURE__ */ m.jsx(T_, { container: t, children: /* @__PURE__ */ m.jsx(
      Oj,
      {
        className: "tlui-menu",
        side: "top",
        align: "start",
        alignOffset: 0,
        sideOffset: 8,
        collisionPadding: 4,
        children: /* @__PURE__ */ m.jsx(Ll, { type: "menu", sourceId: "zoom-menu", children: s })
      }
    ) })
  ] });
}), $Ce = M.forwardRef(
  function(e, t) {
    const r = be(), i = qs(), s = Pe("zoom", () => r.getZoomLevel(), [r]), l = Ln(), c = M.useCallback(() => {
      r.resetZoom(r.getViewportScreenCenter(), {
        animation: { duration: r.options.animationMediumMs }
      });
    }, [r]);
    return /* @__PURE__ */ m.jsx(
      Ot,
      {
        ref: t,
        ...e,
        type: "icon",
        title: `${l("navigation-zone.zoom")}`,
        "data-testid": "minimap.zoom-menu-button",
        className: i < yi.TABLET_SM ? "tlui-zoom-menu__button" : "tlui-zoom-menu__button__pct",
        onDoubleClick: c,
        children: i < yi.MOBILE ? null : /* @__PURE__ */ m.jsxs("span", { style: { flexGrow: 0, textAlign: "center" }, children: [
          Math.floor(s * 100),
          "%"
        ] })
      }
    );
  }
), hY = M.createContext(null);
function BCe({
  overrides: n = {},
  children: e
}) {
  const t = fg(n), r = A_();
  return /* @__PURE__ */ m.jsx(
    hY.Provider,
    {
      value: M.useMemo(
        () => ({
          ContextMenu: r0e,
          ActionsMenu: Mbe,
          HelpMenu: null,
          ZoomMenu: UCe,
          MainMenu: N0e,
          Minimap: G0e,
          StylePanel: $1e,
          PageMenu: Z0e,
          NavigationPanel: Y0e,
          Toolbar: jCe,
          KeyboardShortcutsDialog: P0e,
          QuickActions: t1e,
          HelperButtons: E0e,
          DebugPanel: g0e,
          DebugMenu: p0e,
          MenuPanel: S0e,
          SharePanel: r ? l1e : null,
          CursorChatBubble: r ? s0e : null,
          TopPanel: r ? FCe : null,
          ...t
        }),
        [t, r]
      ),
      children: e
    }
  );
}
function Mh() {
  const n = M.useContext(hY);
  if (!n)
    throw new Error("useTldrawUiComponents must be used within a TldrawUiComponentsProvider");
  return n;
}
const HCe = Ho(function({
  overrides: e,
  components: t,
  assetUrls: r,
  onUiEvent: i,
  forceMobile: s,
  mediaMimeTypes: l,
  children: c
}) {
  const d = _h();
  return /* @__PURE__ */ m.jsx(CW.Provider, { value: l, children: /* @__PURE__ */ m.jsx(bme, { assetUrls: obe(r), children: /* @__PURE__ */ m.jsx(
    Pme,
    {
      overrides: Pve(e),
      locale: (d == null ? void 0 : d.user.getLocale()) ?? Tl.locale,
      children: /* @__PURE__ */ m.jsx(pfe, { onEvent: i, children: /* @__PURE__ */ m.jsx(wye, { children: /* @__PURE__ */ m.jsx(Qme, { context: d == null ? void 0 : d.contextId, children: /* @__PURE__ */ m.jsx(Zme, { forceMobile: s, children: /* @__PURE__ */ m.jsx(BCe, { overrides: t, children: d ? (
        // the internal providers are only valid when an editor is present
        /* @__PURE__ */ m.jsx(VCe, { overrides: e, children: c })
      ) : c }) }) }) }) })
    }
  ) }) });
});
function VCe({
  overrides: n,
  children: e
}) {
  const t = Tve(n);
  return /* @__PURE__ */ m.jsx(kve, { overrides: t.actions, children: /* @__PURE__ */ m.jsx(Kve, { overrides: t.tools, children: e }) });
}
function KCe() {
  const n = be(), { addToast: e } = Yd();
  M.useEffect(() => {
    function t({ name: r, count: i }) {
      e({
        title: "Maximum Shapes Reached",
        description: `You've reached the maximum number of shapes allowed on ${r} (${i}). Please delete some shapes or move to a different page to continue.`,
        severity: "warning"
      });
    }
    return n.addListener("max-shapes", t), () => {
      n.removeListener("max-shapes", t);
    };
  }, [n, e]);
}
const WCe = Bt.memo(function({
  renderDebugMenuItems: e,
  children: t,
  hideUi: r,
  components: i,
  ...s
}) {
  return /* @__PURE__ */ m.jsx(HCe, { ...s, components: i, children: /* @__PURE__ */ m.jsx(GCe, { hideUi: r, renderDebugMenuItems: e, children: t }) });
}), GCe = Bt.memo(function({
  children: e,
  hideUi: t,
  ...r
}) {
  return /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
    e,
    t ? null : /* @__PURE__ */ m.jsx(qCe, { ...r })
  ] });
}), qCe = Bt.memo(function() {
  const e = be(), t = Ln(), r = qs(), i = ol(), s = Pe("focus", () => e.getInstanceState().isFocusMode, [e]), l = Pe("debug", () => e.getInstanceState().isDebugMode, [e]), {
    SharePanel: c,
    TopPanel: d,
    MenuPanel: h,
    StylePanel: g,
    Toolbar: y,
    HelpMenu: v,
    NavigationPanel: w,
    HelperButtons: C,
    DebugPanel: E,
    CursorChatBubble: P
  } = Mh();
  RCe(), Qye(), KCe();
  const { "toggle-focus-mode": I } = gg();
  return /* @__PURE__ */ m.jsxs(
    "div",
    {
      className: It("tlui-layout", {
        "tlui-layout__mobile": r < yi.TABLET_SM
      }),
      "data-breakpoint": r,
      children: [
        s ? /* @__PURE__ */ m.jsx("div", { className: "tlui-layout__top", children: /* @__PURE__ */ m.jsx(
          Ot,
          {
            type: "icon",
            className: "tlui-focus-button",
            title: t("focus-mode.toggle-focus-mode"),
            onClick: () => I.onSelect("menu"),
            children: /* @__PURE__ */ m.jsx(In, { icon: "dot" })
          }
        ) }) : /* @__PURE__ */ m.jsxs(m.Fragment, { children: [
          /* @__PURE__ */ m.jsxs("div", { className: "tlui-layout__top", children: [
            /* @__PURE__ */ m.jsxs("div", { className: "tlui-layout__top__left", children: [
              h && /* @__PURE__ */ m.jsx(h, {}),
              C && /* @__PURE__ */ m.jsx(C, {})
            ] }),
            /* @__PURE__ */ m.jsx("div", { className: "tlui-layout__top__center", children: d && /* @__PURE__ */ m.jsx(d, {}) }),
            /* @__PURE__ */ m.jsxs("div", { className: "tlui-layout__top__right", children: [
              c && /* @__PURE__ */ m.jsx(c, {}),
              g && r >= yi.TABLET_SM && !i && /* @__PURE__ */ m.jsx(g, {})
            ] })
          ] }),
          /* @__PURE__ */ m.jsxs("div", { className: "tlui-layout__bottom", children: [
            /* @__PURE__ */ m.jsxs("div", { className: "tlui-layout__bottom__main", children: [
              w && /* @__PURE__ */ m.jsx(w, {}),
              y && /* @__PURE__ */ m.jsx(y, {}),
              v && /* @__PURE__ */ m.jsx(v, {})
            ] }),
            l && E && /* @__PURE__ */ m.jsx(E, {})
          ] })
        ] }),
        /* @__PURE__ */ m.jsx(Vve, {}),
        /* @__PURE__ */ m.jsx(Uve, {}),
        /* @__PURE__ */ m.jsx(nbe, {}),
        P && /* @__PURE__ */ m.jsx(P, {})
      ]
    }
  );
});
async function YCe(n, e) {
  const {
    url: t,
    style: r = "normal",
    weight: i = "500",
    display: s,
    featureSettings: l,
    stretch: c,
    unicodeRange: d,
    variant: h,
    format: g
  } = e, y = {
    style: r,
    weight: i,
    display: s,
    featureSettings: l,
    stretch: c,
    unicodeRange: d,
    // @ts-expect-error why is this here
    variant: h
  }, v = new FontFace(n, `url(${t})`, y);
  return await v.load(), document.fonts.add(v), v.$$_url = t, v.$$_fontface = `
@font-face {
	font-family: ${v.family};
	font-stretch: ${v.stretch};
	font-weight: ${v.weight};
	font-style: ${v.style};
	src: url("${t}") format("${g}")
}`, v;
}
const mC = (n, e) => {
  const [t, r] = M.useState(
    2
    /* WAITING */
  );
  return M.useEffect(() => {
    let i = !1;
    return r(
      2
      /* WAITING */
    ), YCe(n, e).then(() => {
      i || r(
        0
        /* SUCCESS */
      );
    }).catch((s) => {
      i || (console.error(s), r(
        1
        /* FAILED */
      ));
    }), () => {
      i = !0;
    };
  }, [n, e]), t;
};
function XCe(n) {
  return {
    draw: {
      url: n.fonts.draw,
      format: n.fonts.draw.split(".").pop()
    },
    serif: {
      url: n.fonts.serif,
      format: n.fonts.serif.split(".").pop()
    },
    sansSerif: {
      url: n.fonts.sansSerif,
      format: n.fonts.sansSerif.split(".").pop()
    },
    monospace: {
      url: n.fonts.monospace,
      format: n.fonts.monospace.split(".").pop()
    }
  };
}
function pY(n) {
  const e = M.useMemo(() => XCe(n), [n]), t = [
    mC("tldraw_draw", e.draw),
    mC("tldraw_serif", e.serif),
    mC("tldraw_sans", e.sansSerif),
    mC("tldraw_mono", e.monospace)
  ];
  return {
    // If any of the results have errored, then preloading has failed
    error: t.some(
      (r) => r === 1
      /* FAILED */
    ),
    // If any of the results are waiting, then we're not done yet
    done: !t.some(
      (r) => r === 2
      /* WAITING */
    )
  };
}
function ZCe(n) {
  const {
    children: e,
    maxImageDimension: t,
    maxAssetSize: r,
    acceptedImageMimeTypes: i,
    acceptedVideoMimeTypes: s,
    onMount: l,
    components: c = {},
    shapeUtils: d = [],
    bindingUtils: h = [],
    tools: g = [],
    embeds: y,
    ...v
  } = n, w = fg(c), C = M.useMemo(
    () => ({
      Scribble: HU,
      ShapeIndicators: nSe,
      CollaboratorScribble: HU,
      SelectionForeground: Jve,
      SelectionBackground: Zve,
      Handles: Wve,
      ...w
    }),
    [w]
  ), E = sh(d), P = M.useMemo(
    () => [...cG, ...E],
    [E]
  ), I = sh(h), k = M.useMemo(
    () => [...MW, ...I],
    [I]
  ), L = sh(g), O = M.useMemo(
    () => [...tbe, ...$Se, ...L],
    [L]
  ), z = sh(
    i ?? NE
  ), F = sh(
    s ?? YD
  ), H = M.useMemo(
    () => [...z, ...F],
    [z, F]
  ), V = GG(v.assetUrls), { done: re, error: q } = pY(V);
  return q ? /* @__PURE__ */ m.jsx(AH, { children: "Could not load assets. Please refresh the page." }) : re ? (P.find((ie) => ie.type === "embed") && y && OE.setEmbedDefinitions(y), /* @__PURE__ */ m.jsx(
    Qde,
    {
      initialState: "select",
      ...v,
      components: C,
      shapeUtils: P,
      bindingUtils: k,
      tools: O,
      children: /* @__PURE__ */ m.jsxs(WCe, { ...v, components: C, mediaMimeTypes: H, children: [
        /* @__PURE__ */ m.jsx(
          QCe,
          {
            maxImageDimension: t,
            maxAssetSize: r,
            acceptedImageMimeTypes: z,
            acceptedVideoMimeTypes: F,
            onMount: l
          }
        ),
        e
      ] })
    }
  )) : /* @__PURE__ */ m.jsx(rj, { children: /* @__PURE__ */ m.jsx(UO, {}) });
}
function QCe({
  maxImageDimension: n = 5e3,
  maxAssetSize: e = 10 * 1024 * 1024,
  // 10mb
  acceptedImageMimeTypes: t = NE,
  acceptedVideoMimeTypes: r = YD,
  onMount: i
}) {
  const s = be(), l = Yd(), c = Ln();
  DH(() => {
    const g = [];
    return g.push(Ewe(s)), SSe(
      s,
      {
        maxImageDimension: n,
        maxAssetSize: e,
        acceptedImageMimeTypes: t,
        acceptedVideoMimeTypes: r
      },
      {
        toasts: l,
        msg: c
      }
    ), g.push(s.store.props.onMount(s)), g.push(i == null ? void 0 : i(s)), () => {
      g.forEach((y) => y == null ? void 0 : y());
    };
  });
  const { Canvas: d } = Br(), { ContextMenu: h } = Mh();
  return h ? /* @__PURE__ */ m.jsx(h, {}) : d ? /* @__PURE__ */ m.jsx(d, {}) : null;
}
M.memo(function(e) {
  const [t, r] = M.useState(null), [i, s] = M.useState(null), l = sh(e.shapeUtils ?? []), c = M.useMemo(() => [...cG, ...l], [l]), d = sh(e.bindingUtils ?? []), h = M.useMemo(
    () => [...MW, ...d],
    [d]
  ), g = ofe({ snapshot: e.snapshot, shapeUtils: c }), y = GG(e.assetUrls), { done: v, error: w } = pY(y), {
    pageId: C,
    bounds: E,
    scale: P,
    pixelRatio: I,
    background: k,
    padding: L,
    darkMode: O,
    preserveAspectRatio: z,
    format: F = "svg",
    licenseKey: H
  } = e;
  return M.useLayoutEffect(() => {
    if (!i || !g || !v) return;
    let V = !1;
    const re = document.createElement("div");
    i.appendChild(re), i.classList.add("tl-container", "tl-theme__light");
    const q = new at({
      store: g,
      shapeUtils: c,
      bindingUtils: h,
      tools: [],
      getContainer: () => re,
      licenseKey: H
    });
    C && q.setCurrentPage(C);
    const J = q.getCurrentPageShapeIds();
    async function ie() {
      const W = await q.getSvgString([...J], {
        bounds: E,
        scale: P,
        background: k,
        padding: L,
        darkMode: O,
        preserveAspectRatio: z
      });
      if (W && !V) {
        if (F === "svg") {
          if (!V) {
            const Y = new Blob([W.svg], { type: "image/svg+xml" }), oe = URL.createObjectURL(Y);
            r(oe);
          }
        } else if (F === "png") {
          const Y = await xW(q, W.svg, {
            type: F,
            width: W.width,
            height: W.height,
            pixelRatio: I
          });
          if (Y && !V) {
            const oe = URL.createObjectURL(Y);
            r(oe);
          }
        }
      }
      q.dispose();
    }
    return ie(), () => {
      V = !0;
    };
  }, [
    F,
    i,
    g,
    c,
    h,
    C,
    E,
    P,
    k,
    L,
    O,
    z,
    v,
    w,
    H,
    I
  ]), w ? /* @__PURE__ */ m.jsx(AH, { children: "Could not load assets." }) : v ? /* @__PURE__ */ m.jsx("div", { ref: s, style: { position: "relative", width: "100%", height: "100%" }, children: t && /* @__PURE__ */ m.jsx(
    "img",
    {
      src: t,
      referrerPolicy: "strict-origin-when-cross-origin",
      style: { width: "100%", height: "100%" }
    }
  ) }) : /* @__PURE__ */ m.jsx(rj, { children: /* @__PURE__ */ m.jsx(UO, {}) });
});
M.memo(function({ children: e }) {
  const t = Ln(), r = qs(), i = M.useRef(null);
  Th(i);
  const s = e ?? /* @__PURE__ */ m.jsx(T0e, {});
  return r < yi.MOBILE ? null : /* @__PURE__ */ m.jsx("div", { ref: i, className: "tlui-help-menu", children: /* @__PURE__ */ m.jsxs(og, { id: "help menu", children: [
    /* @__PURE__ */ m.jsx(sg, { children: /* @__PURE__ */ m.jsx(Ot, { type: "help", title: t("help-menu.title"), "data-testid": "help-menu.button", children: /* @__PURE__ */ m.jsx(In, { icon: "question-mark", small: !0 }) }) }),
    /* @__PURE__ */ m.jsx(ag, { side: "top", align: "end", alignOffset: 0, sideOffset: 8, children: /* @__PURE__ */ m.jsx(Ll, { type: "menu", sourceId: "help-menu", children: s }) })
  ] }) });
});
const JCe = kn({
  schemaVersion: xs(1),
  storeVersion: vC,
  recordVersions: cE(
    sn,
    kn({
      version: vC,
      subTypeVersions: cE(sn, vC).optional(),
      subTypeKey: sn.optional()
    })
  )
}), eEe = kn({
  schemaVersion: xs(2),
  sequences: cE(sn, vC)
});
kn({
  tldrawFileFormatVersion: bre,
  schema: Cre("schemaVersion", {
    1: JCe,
    2: eEe
  }),
  records: No(
    kn({
      id: sn,
      typeName: sn
    }).allowUnknownProperties()
  )
});
Au(
  "tldraw",
  "3.7.0",
  "esm"
);
const hy = "multiplayer.client";
function tEe(n) {
  const [e, t] = nj(null), {
    uri: r,
    roomId: i = "default",
    assets: s,
    onMount: l,
    trackAnalyticsEvent: c,
    userInfo: d,
    getUserPresence: h,
    ...g
  } = n, y = sfe(g), v = fg(d), w = xce(h ?? nie), C = uw(
    "userAtom",
    v
  );
  return M.useEffect(() => {
    C.set(v);
  }, [v, C]), M.useEffect(() => {
    const E = or(), P = Le(
      "userPreferences",
      () => {
        const V = C.get(), re = (Nne(V) ? V.get() : V) ?? BO();
        return {
          id: re.id,
          color: re.color ?? Tl.color,
          name: re.name ?? Tl.name
        };
      }
    ), I = new cre(async () => {
      const V = typeof r == "string" ? r : await r(), re = new URL(V);
      if (re.searchParams.has("sessionId"))
        throw new Error(
          'useSync. "sessionId" is a reserved query param name. Please use a different name'
        );
      if (re.searchParams.has("storeId"))
        throw new Error(
          'useSync. "storeId" is a reserved query param name. Please use a different name'
        );
      return re.searchParams.set("sessionId", Xx), re.searchParams.set("storeId", E), re.toString();
    });
    let k = !1;
    const L = Le(
      "collaboration status",
      () => I.connectionStatus === "error" ? "offline" : I.connectionStatus
    ), O = mi("sync mode", "readwrite"), z = Zx({
      id: E,
      schema: y,
      assets: s,
      onMount: l,
      collaboration: {
        status: L,
        mode: O
      }
    }), F = Le("instancePresence", () => {
      const V = w(z, P.get());
      return V ? UA.create({
        ...V,
        id: UA.createId(z.id)
      }) : null;
    }), H = new lre({
      store: z,
      socket: I,
      didCancel: () => k,
      onLoad(V) {
        c == null || c(hy, { name: "load", roomId: i }), t({ readyClient: V });
      },
      onSyncError(V) {
        switch (console.error("sync error", V), V) {
          case bx.NOT_FOUND:
            c == null || c(hy, { name: "room-not-found", roomId: i });
            break;
          case bx.FORBIDDEN:
            c == null || c(hy, { name: "forbidden", roomId: i });
            break;
          case bx.NOT_AUTHENTICATED:
            c == null || c(hy, { name: "not-authenticated", roomId: i });
            break;
          case bx.RATE_LIMITED:
            c == null || c(hy, { name: "rate-limited", roomId: i });
            break;
          default:
            c == null || c(hy, { name: "sync-error:" + V, roomId: i });
            break;
        }
        t({ error: new mre(V) }), I.close();
      },
      onAfterConnect(V, { isReadonly: re }) {
        Dl(() => {
          O.set(re ? "readonly" : "readwrite"), z.ensureStoreIsUsable();
        });
      },
      presence: F
    });
    return () => {
      k = !0, H.close(), I.close(), t(null);
    };
  }, [s, l, C, i, y, t, c, r, w]), Pe(
    "remote synced store",
    () => {
      if (!e) return { status: "loading" };
      if (e.error) return { status: "error", error: e.error };
      if (!e.readyClient) return { status: "loading" };
      const E = e.readyClient.socket.connectionStatus;
      return {
        status: "synced-remote",
        connectionStatus: E === "error" ? "offline" : E,
        store: e.readyClient.store
      };
    },
    [e]
  );
}
var nEe = {};
function gY(n) {
  try {
    return n();
  } catch {
    return;
  }
}
gY(() => "https://demo.tldraw.xyz");
gY(() => nEe.TLDRAW_IMAGE_URL);
Au(
  "@tldraw/sync",
  "3.7.0",
  "esm"
);
const rEe = ({ debug: n, roomId: e, serverUri: t, queryParams: r, multiplayerAssetsFunc: i, getUser: s, onMount: l, ...c }) => {
  const d = s == null ? void 0 : s(), h = `${t ?? "http://localhost:5858"}/connect/${e ?? "10"}`, g = M.useMemo(() => i == null ? void 0 : i(), [i]), y = tEe({
    uri: h,
    assets: g
  });
  return n && (console.log("Debugging is on"), console.log("multiplayerAssets", g), console.log("multiplayerAssetsFunc", i)), g ? Bt.createElement(
    Bt.Fragment,
    null,
    n && Bt.createElement(
      "div",
      null,
      Bt.createElement("div", null, "Debug mode on."),
      Bt.createElement(
        "div",
        null,
        "connected to ",
        h
      ),
      Bt.createElement(
        "div",
        null,
        "Room ",
        e
      )
    ),
    Bt.createElement(
      "div",
      { style: {
        width: "100%",
        height: "100%"
      } },
      Bt.createElement(ZCe, { store: y, user: d, ...c })
    )
  ) : Bt.createElement(
    Bt.Fragment,
    null,
    n && Bt.createElement(
      "div",
      null,
      Bt.createElement("div", null, "Debug mode on."),
      Bt.createElement(
        "div",
        null,
        "connected to ",
        h
      ),
      Bt.createElement(
        "div",
        null,
        "Room ",
        e
      )
    ),
    "We require multiplayer assets"
  );
}, iEe = Pte(rEe, {
  props: {
    debug: "boolean",
    roomId: "string",
    serverUri: "string",
    queryParams: "json",
    multiplayerAssetsFunc: "function",
    autoFocus: "boolean",
    forceMobile: "boolean",
    hideUi: "boolean",
    inferDarkMode: "boolean",
    onMount: "function",
    defaultName: "string",
    initialState: "string",
    licenseKey: "string",
    maxAssetSize: "number",
    maxImageDimension: "number",
    sessionId: "string",
    getUser: "function"
  }
});
customElements.define("tldraw-sync-web-component", iEe);
export {
  rEe as TldrawSync
};
